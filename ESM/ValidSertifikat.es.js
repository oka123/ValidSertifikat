const minifiedHtml = `<div id="app-container" class="dark bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 antialiased font-['Poppins'] m-0 p-0"><div id="app" class="flex h-screen w-full flex-col overflow-hidden"><header class="w-screen flex h-16 shrink-0 items-center justify-between borders-b border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 px-2 md:px-4 z-50"><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 32 32"><g fill="none"><path fill="url(#SVGT7uX3cDG)" d="M5.25 4A3.25 3.25 0 0 0 2 7.25V20h.525c.092.933.441 1.79.975 2.5V25h23.25A3.25 3.25 0 0 0 30 21.75V7.25A3.25 3.25 0 0 0 26.75 4z"/><path fill="url(#SVGzm6hyd4I)" fill-opacity="0.9" d="M8 11a1 1 0 0 1 1-1h14a1 1 0 1 1 0 2H9a1 1 0 0 1-1-1m9 6a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2z"/><path fill="url(#SVGvQsnyeMK)" d="M12 21.862A6.97 6.97 0 0 1 7.5 23.5A6.97 6.97 0 0 1 3 21.862V29a1 1 0 0 0 1.528.849l2.972-1.85l2.972 1.85a1 1 0 0 0 1.528-.85z"/><path fill="url(#SVG6fUzRbkW)" d="M13 19.5a5.5 5.5 0 1 1-11 0a5.5 5.5 0 0 1 11 0"/><defs><radialGradient id="SVGvQsnyeMK" cx="0" cy="0" r="1" gradientTransform="matrix(0 11.421 -17.6871 0 7.5 22)" gradientUnits="userSpaceOnUse"><stop stop-color="#163697"/><stop offset="1" stop-color="#29c3ff"/></radialGradient><radialGradient id="SVG6fUzRbkW" cx="0" cy="0" r="1" gradientTransform="rotate(56.615 11.86 -32.457)scale(61.3992 52.5856)" gradientUnits="userSpaceOnUse"><stop offset=".772" stop-color="#ffcd0f"/><stop offset=".991" stop-color="#e67505"/></radialGradient><linearGradient id="SVGT7uX3cDG" x1="3" x2="16.766" y1="7.938" y2="27.007" gradientUnits="userSpaceOnUse"><stop stop-color="#0fafff"/><stop offset="1" stop-color="#2764e7"/></linearGradient><linearGradient id="SVGzm6hyd4I" x1="31.2" x2="20.404" y1="30.7" y2="1.771" gradientUnits="userSpaceOnUse"><stop stop-color="#9deaff"/><stop offset="1" stop-color="#fff"/></linearGradient></defs></g></svg> <a href="./" title="ValidSertifikat" onclick="return false;" class="flex flex-col"><h1 class="inline text-wrap text-[10px] md:text-lg font-semibold">ValidSertifikat</h1><p class="inline text-[9px] md:text-xs">Â© 2025 Oka & Team</p></a></div><div class="flex items-center gap-1 md:gap-4"><div class="flex items-center borders-r border-slate-200 dark:border-slate-700 pr-2 gap-1 md:gap-2"><button id="undo-btn" class="p-2 rounded-md text-slate-400 disabled:text-slate-300 dark:disabled:text-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 disabled:cursor-not-allowed" disabled="disabled" title="Undo (Ctrl+Z)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 512 512"><path fill="currentColor" d="M256 64c-56.8 0-107.9 24.7-143.1 64H160c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32V32C0 14.3 14.3 0 32 0s32 14.3 32 32v54.7C110.9 33.6 179.5 0 256 0c141.4 0 256 114.6 256 256S397.4 512 256 512c-87 0-163.9-43.4-210.1-109.7c-10.1-14.5-6.6-34.4 7.9-44.6s34.4-6.6 44.6 7.9c34.8 49.8 92.4 82.3 157.6 82.3c106 0 192-86 192-192S362 64 256 64"/></svg></button> <button id="redo-btn" class="p-2 rounded-md text-slate-400 disabled:text-slate-300 dark:disabled:text-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 disabled:cursor-not-allowed" disabled="disabled" title="Redo (Ctrl+Y)"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 512 512"><path fill="currentColor" d="M436.7 74.7L448 85.4V32c0-17.7 14.3-32 32-32s32 14.3 32 32v128c0 17.7-14.3 32-32 32H352c-17.7 0-32-14.3-32-32s14.3-32 32-32h47.9l-7.6-7.2l-.6-.6c-75-75-196.5-75-271.5 0s-75 196.5 0 271.5s196.5 75 271.5 0q12.3-12.3 21.9-26.1c10.1-14.5 30.1-18 44.6-7.9s18 30.1 7.9 44.6c-8.5 12.2-18.2 23.8-29.1 34.7c-100 100-262.1 100-362 0S-25 175 75 75c99.9-99.9 261.7-100 361.7-.3"/></svg></button></div><button id="theme-toggle" type="button" class="text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none rounded-lg text-sm p-2.5"><svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg> <svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.707.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg></button><div class="relative inline-block text-left"><button id="download-zip-btn" type="button" class="flex items-center gap-2 rounded-md bg-indigo-600 px-3 py-2 text-sm font-medium text-white shadow-sm transition-colors hover:bg-indigo-700 disabled:cursor-not-allowed disabled:opacity-50" aria-expanded="false" aria-haspopup="true"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg> <span class="hidden sm:inline">Download Semua</span></button><div id="download-format" class="absolute right-0 top-full w-auto z-10 origin-top-right rounded-md bg-white dark:bg-slate-800 shadow-lg ring-1 ring-black dark:ring-slate-700 ring-opacity-5 focus:outline-none hidden" role="menu" aria-orientation="vertical" aria-labelledby="download-zip-btn" tabindex="-1"><div class="py-1 w-fit" role="none"><button class="download-format text-gray-700 dark:text-slate-300 block px-4 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-slate-700 whitespace-nowrap" role="menuitem" data-format="jpeg">Format JPG</button> <button class="download-format text-gray-700 dark:text-slate-300 block px-4 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-slate-700 whitespace-nowrap" role="menuitem" data-format="pdf">Format PDF</button> <button class="download-format text-gray-700 dark:text-slate-300 block px-4 py-2 text-left text-sm hover:bg-gray-100 dark:hover:bg-slate-700 whitespace-nowrap" role="menuitem" data-format="png">Format PNG</button></div></div></div><button id="sidebar-toggle" class="md:hidden p-2 rounded-md border-slate-300 dark:border-slate-600"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-5 w-5"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></button></div></header><div class="flex flex-1 overflow-hidden"><aside id="sidebar" class="hidden absolute md:relative md:flex w-66 flex-col borders-r border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-800 h-full z-20 transform -translate-x-full md:translate-x-0 transition-transform duration-300 ease-in-out"><div class="flex h-14 items-center justify-between borders-b border-slate-200 dark:border-slate-700 px-4"><h2 class="font-semibold">Tools Panel</h2></div><div class="flex-1 overflow-y-auto p-4 space-y-4"><div class="space-y-2"><h3 class="font-medium text-sm">Ukuran Kanvas</h3><div class="flex items-center gap-2"><label for="canvas-width" class="text-sm"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M22 12H2m20 0l-4 4m4-4l-4-4M2 12l4 4m-4-4l4-4"/></svg></label> <input type="number" id="canvas-width" value="1920" class="h-8 w-16 lg:w-20 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"> <label for="canvas-height" class="text-sm"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 22V2m0 20l-4-4m4 4l4-4M12 2L8 6m4-4l4 4"/></svg></label> <input type="number" id="canvas-height" value="1080" class="h-8 w-16 lg:w-20 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"></div></div><div class="space-y-2"><h3 class="font-medium text-sm">Desain Template (Background)</h3><label class="flex w-full cursor-pointer items-center justify-center gap-2 rounded-md border-2 border-dashed border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700/50 p-4 text-sm text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><g fill="none"><path d="M22 4v16H2V4z"/><path d="M18 4h-4v5.5L16 8l2 1.5z"/><path stroke="currentColor" stroke-linecap="square" stroke-width="2" d="M6 12h4m-4 4h12M14 4h4v5.5L16 8l-2 1.5z"/><path stroke="currentColor" stroke-linecap="square" stroke-width="2" d="M22 4v16H2V4z"/></g></svg> <span>Upload Desain Sertifikat</span> <input type="file" id="bg-uploader" class="hidden" accept="image/*"></label></div><div class="space-y-2"><h3 class="font-medium text-sm">Elemen</h3><div class="grid grid-cols-2 gap-2"><button id="add-text" class="flex flex-col items-center gap-1 rounded-md borders border-slate-300 dark:border-slate-600 p-2 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 7V4h-6v16h3a1 1 0 1 1 0 2H8a1 1 0 1 1 0-2h3V4H5v3a1 1 0 0 1-2 0V3a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v4a1 1 0 1 1-2 0"/></svg> <span class="text-xs">Teks</span></button> <button id="add-rect" class="flex flex-col items-center gap-1 rounded-md borders border-slate-300 dark:border-slate-600 p-2 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/></svg> <span class="text-xs">Kotak</span></button> <label class="flex flex-col items-center gap-1 rounded-md borders border-slate-300 dark:border-slate-600 p-2 hover:bg-slate-100 dark:hover:bg-slate-700 cursor-pointer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512"><path fill="currentColor" d="M448 80c8.8 0 16 7.2 16 16v319.8l-5-6.5l-136-176c-4.5-5.9-11.6-9.3-19-9.3s-14.4 3.4-19 9.3l-83 107.4l-30.5-42.7c-4.5-6.3-11.7-10-19.5-10s-15 3.7-19.5 10.1l-80 112l-4.5 6.2V96c0-8.8 7.2-16 16-16zM64 32C28.7 32 0 60.7 0 96v320c0 35.3 28.7 64 64 64h384c35.3 0 64-28.7 64-64V96c0-35.3-28.7-64-64-64zm80 192a48 48 0 1 0 0-96a48 48 0 1 0 0 96"/></svg> <span class="text-xs">Gambar</span> <input type="file" id="image-uploader" class="hidden" accept="image/*"></label> <button id="add-qrcode" class="flex flex-col items-center gap-1 rounded-md borders border-slate-300 dark:border-slate-600 p-2 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512"><rect width="80" height="80" x="336" y="336" fill="currentColor" rx="8" ry="8"/><rect width="64" height="64" x="272" y="272" fill="currentColor" rx="8" ry="8"/><rect width="64" height="64" x="416" y="416" fill="currentColor" rx="8" ry="8"/><rect width="48" height="48" x="432" y="272" fill="currentColor" rx="8" ry="8"/><rect width="48" height="48" x="272" y="432" fill="currentColor" rx="8" ry="8"/><rect width="80" height="80" x="336" y="96" fill="currentColor" rx="8" ry="8"/><rect width="176" height="176" x="288" y="48" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" rx="16" ry="16"/><rect width="80" height="80" x="96" y="96" fill="currentColor" rx="8" ry="8"/><rect width="176" height="176" x="48" y="48" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" rx="16" ry="16"/><rect width="80" height="80" x="96" y="336" fill="currentColor" rx="8" ry="8"/><rect width="176" height="176" x="48" y="288" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" rx="16" ry="16"/></svg> <span class="text-xs">QR Code</span></button></div></div><div class="space-y-2"><h3 class="font-medium text-sm">Data Peserta</h3><label class="flex w-full cursor-pointer items-center justify-center gap-2 rounded-md border-2 border-dashed border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700/50 p-4 text-sm text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M12 18v-6"/><path d="m15 15-3-3-3 3"/></svg> <span>Upload Excel/CSV</span> <input type="file" id="data-uploader" class="hidden" accept=".xlsx, .xls, .csv"></label><div id="data-mapping-container" class="space-y-2 hidden"><p class="text-xs font-medium text-slate-600 dark:text-slate-400">Hubungkan Data ke Elemen:</p><div id="data-mapping-ui" class="space-y-2 text-sm"><p class="text-xs text-slate-500 dark:text-slate-400">Pilih elemen di kanvas untuk dihubungkan dengan kolom data.</p></div></div></div><div class="space-y-2"><h3 class="font-medium text-sm">Custom Font</h3><label class="flex w-full cursor-pointer items-center justify-center gap-2 rounded-md border-2 border-dashed border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700/50 p-4 text-sm text-slate-500 dark:text-slate-400 hover:bg-slate-100 dark:hover:bg-slate-700"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/><path d="M14 2v6h6"/><path d="M10.4 12.6c.2-.4.5-.8.9-1s.8-.4 1.3-.5c.5-.1 1-.1 1.4.1s.8.4 1.1.8c.3.4.5.8.5 1.3s-.1 1-.4 1.4c-.3.4-.7.7-1.1.9s-.9.3-1.4.3c-.5 0-1-.1-1.4-.3s-.8-.4-1.1-.7c-.3-.3-.5-.7-.6-1.1H8.9c.1.9.4 1.7.9 2.3s1.2 1 2 1.3c.8.3 1.6.4 2.5.2s1.7-.6 2.4-1.2c.7-.6 1.1-1.4 1.3-2.3s.1-1.8-.4-2.7c-.5-.8-1.2-1.5-2-1.9s-1.7-.7-2.6-.5c-1 .1-1.9.5-2.6 1.1s-1.3 1.4-1.6 2.3H13v-1Z"/></svg> <span>Upload Font (.ttf, .otf)</span> <input type="file" id="font-uploader" class="hidden" accept=".ttf, .otf, .woff, .woff2"></label></div></div></aside><main id="main-canvas" class="flex-1 flex items-center justify-center bg-dots overflow-scroll relative p-4 md:p-8"><div id="contextual-toolbar" class="w-full absolute top-0 left-0 z-10 hidden items-center justify-center"><div class="w-fit flex flex-row items-center justify-center gap-2 rounded-lg bg-white dark:bg-slate-800 borders border-slate-200 dark:border-slate-700 p-2 shadow-lg flex-wrap"><div id="text-options" class="hidden items-center justify-center gap-1 flex-wrap p-1"><select id="font-family-select" class="h-8 rounded-md border border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"></select> <input type="number" id="font-size-input" class="h-8 w-16 rounded-md border border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm" value="40"> <input type="color" id="font-color-picker" class="h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 p-1 cursor-pointer bg-white dark:bg-slate-700" title="Warna Teks"> <button id="font-bold-btn" class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 font-bold" title="Bold">B</button> <button id="font-italic-btn" class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 italic" title="Italic">I</button></div><div id="general-options" class="hidden items-center justify-center gap-1 flex-wrap p-1"><input type="color" id="fill-color-picker" class="h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 p-1 cursor-pointer bg-white dark:bg-slate-700" title="Warna Isi"> <button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700" data-action="copy" title="Copy (Ctrl+C)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M5.503 4.627L5.5 6.75v10.504a3.25 3.25 0 0 0 3.25 3.25h8.616a2.25 2.25 0 0 1-2.122 1.5H8.75A4.75 4.75 0 0 1 4 17.254V6.75c0-.98.627-1.815 1.503-2.123M17.75 2A2.25 2.25 0 0 1 20 4.25v13a2.25 2.25 0 0 1-2.25 2.25h-9a2.25 2.25 0 0 1-2.25-2.25v-13A2.25 2.25 0 0 1 8.75 2zm0 1.5h-9a.75.75 0 0 0-.75.75v13c0 .414.336.75.75.75h9a.75.75 0 0 0 .75-.75v-13a.75.75 0 0 0-.75-.75"/></svg></button> <button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700 disabled:opacity-50" data-action="paste" title="Paste (Ctrl+V)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M12.753 2c1.158 0 2.111.875 2.234 2h1.763a2.25 2.25 0 0 1 2.245 2.096L19 6.25a.75.75 0 0 1-.647.742L18.249 7a.75.75 0 0 1-.742-.647L17.5 6.25a.75.75 0 0 0-.648-.743L16.75 5.5h-2.132a2.24 2.24 0 0 1-1.865.993H9.247a2.24 2.24 0 0 1-1.865-.992L5.25 5.5a.75.75 0 0 0-.743.648L4.5 6.25v13.505c0 .38.282.693.648.743l.102.007h3a.75.75 0 0 1 .743.647l.007.102a.75.75 0 0 1-.75.75h-3a2.25 2.25 0 0 1-2.245-2.095L3 19.755V6.25a2.25 2.25 0 0 1 2.096-2.245L5.25 4h1.763a2.247 2.247 0 0 1 2.234-2zm5.997 6a2.25 2.25 0 0 1 2.245 2.096l.005.154v9.5a2.25 2.25 0 0 1-2.096 2.245L18.75 22h-6.5a2.25 2.25 0 0 1-2.245-2.096L10 19.75v-9.5a2.25 2.25 0 0 1 2.096-2.245L12.25 8zm0 1.5h-6.5a.75.75 0 0 0-.743.648l-.007.102v9.5c0 .38.282.694.648.743l.102.007h6.5a.75.75 0 0 0 .743-.648l.007-.102v-9.5a.75.75 0 0 0-.648-.743zm-5.997-6H9.247a.747.747 0 0 0 0 1.493h3.506a.747.747 0 1 0 0-1.493"/></svg></button> <button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700" data-action="duplicate" title="Duplicate (Ctrl+D)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512"><rect width="336" height="336" x="128" y="128" fill="none" stroke="currentColor" stroke-linejoin="round" stroke-width="32" rx="57" ry="57"/><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="m383.5 128l.5-24a56.16 56.16 0 0 0-56-56H112a64.19 64.19 0 0 0-64 64v216a56.16 56.16 0 0 0 56 56h24m168-168v160m80-80H216"/></svg></button><div class="relative group flex justify-center items-center" data-submenu-container><button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700" title="Layer"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M20.026 12.192a2 2 0 0 1-.577.598l-6.05 4.084a2.5 2.5 0 0 1-2.798 0l-6.05-4.084a2 2 0 0 1-.779-2.29l6.841 4.56a2.5 2.5 0 0 0 2.613.098l.16-.098l6.841-4.56a2 2 0 0 1-.201 1.692m.201 1.558a1.996 1.996 0 0 1-.778 2.29l-6.05 4.084a2.5 2.5 0 0 1-2.798 0l-6.05-4.084a2 2 0 0 1-.779-2.29l6.841 4.56a2.5 2.5 0 0 0 2.613.098l.16-.098zm-6.84-10.325l6.365 4.243a1 1 0 0 1 0 1.664l-6.365 4.244a2.5 2.5 0 0 1-2.774 0L4.248 9.332a1 1 0 0 1 0-1.664l6.365-4.243a2.5 2.5 0 0 1 2.774 0M11.56 4.606l-.116.067L5.705 8.5l5.74 3.828a1 1 0 0 0 .994.066l.116-.066L18.294 8.5l-5.74-3.827a1 1 0 0 0-.993-.067"/></svg></button><div class="group-hover:flex hidden flex-row items-center justify-center absolute top-full bg-white dark:bg-slate-800 rounded-md shadow-lg border border-slate-200 dark:border-slate-700 p-1 z-10"><button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="bring-to-front" title="Bring to front"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path d="m16.978 8l2.31 1.06C21.095 9.892 22 10.308 22 11s-.904 1.109-2.713 1.94l-4.893 2.247c-1.18.542-1.77.813-2.394.813s-1.214-.271-2.394-.813l-4.893-2.248C2.904 12.11 2 11.693 2 11s.904-1.109 2.713-1.94L7.022 8M12 2.5V10m3-5c-.59-.607-2.16-3-3-3S9.59 4.393 9 5"/><path d="M20.233 15.5C21.41 16.062 22 16.44 22 17c0 .693-.904 1.109-2.713 1.94l-4.893 2.247c-1.18.542-1.77.813-2.394.813s-1.214-.27-2.394-.813L4.713 18.94C2.904 18.11 2 17.694 2 17c0-.56.59-.938 1.767-1.5"/></g></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="bring-forward" title="Bring forward"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m15.89 11.5l3.397 1.56C21.096 13.892 22 14.308 22 15s-.904 1.109-2.713 1.94l-4.893 2.247c-1.18.542-1.77.813-2.394.813s-1.214-.271-2.394-.813l-4.893-2.248C2.904 16.11 2 15.693 2 15s.904-1.109 2.713-1.94L8.11 11.5m3.89-7V15m3-8c-.59-.607-2.16-3-3-3S9.59 6.393 9 7"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="send-backward" title="Send backward"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m15.89 12.5l3.397-1.56C21.096 10.108 22 9.692 22 9s-.904-1.109-2.713-1.94l-4.893-2.247C13.214 4.271 12.624 4 12 4s-1.214.271-2.394.813L4.713 7.061C2.904 7.89 2 8.307 2 9s.904 1.109 2.713 1.94L8.11 12.5m3.89 7V9m3 8c-.59.607-2.16 3-3 3s-2.41-2.393-3-3"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="send-to-back" title="Send to back"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 21.5V7m3 12c-.59.607-2.16 3-3 3s-2.41-2.393-3-3m11.233-7.5C21.41 12.062 22 12.44 22 13c0 .693-.904 1.109-2.713 1.94L15.89 16.5m-12.123-5C2.59 12.062 2 12.44 2 13c0 .693.904 1.109 2.713 1.94L8.11 16.5m0-6L4.713 8.94C2.904 8.108 2 7.692 2 7s.904-1.109 2.713-1.94l4.893-2.247C10.786 2.271 11.376 2 12 2s1.214.271 2.394.813l4.893 2.248C21.096 5.89 22 6.307 22 7s-.904 1.109-2.713 1.94L15.89 10.5"/></svg></button></div></div><div class="relative group flex justify-center items-center" data-submenu-container><button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 dark:border-slate-600 hover:bg-slate-100 dark:hover:bg-slate-700" title="Align"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M22 2v2H2V2h20M2 10h11V6H2v4m13 0h7V6h-7v4m-2 12h11v-4H2v4M2 16h7v-4H2v4m9 0h11v-4H11v4Z"/></svg></button><div class="group-hover:block hidden flex-col items-center justify-center absolute top-full bg-white dark:bg-slate-800 rounded-md shadow-lg border border-slate-200 dark:border-slate-700 p-1 z-10"><div class="flex flex-row items-center justify-center"><button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-left" title="Align Left"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M3 2.75a.75.75 0 0 1 1.5 0v18.5a.75.75 0 0 1-1.5 0zM8.25 4A2.25 2.25 0 0 0 6 6.25v2.5A2.25 2.25 0 0 0 8.25 11h10.5A2.25 2.25 0 0 0 21 8.75v-2.5A2.25 2.25 0 0 0 18.75 4zM7.5 6.25a.75.75 0 0 1 .75-.75h10.5a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-.75.75H8.25a.75.75 0 0 1-.75-.75zM8.25 13A2.25 2.25 0 0 0 6 15.25v2.5A2.25 2.25 0 0 0 8.25 20h7a2.25 2.25 0 0 0 2.25-2.25v-2.5A2.25 2.25 0 0 0 15.25 13zm-.75 2.25a.75.75 0 0 1 .75-.75h7a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-.75.75h-7a.75.75 0 0 1-.75-.75z"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-center" title="Align Center"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M11.25 21.25V20h-2.5a2.25 2.25 0 0 1-2.25-2.25v-2.5A2.25 2.25 0 0 1 8.75 13h2.5v-2h-4.5A2.25 2.25 0 0 1 4.5 8.75v-2.5A2.25 2.25 0 0 1 6.75 4h4.5V2.75a.75.75 0 0 1 1.5 0V4h4.5a2.25 2.25 0 0 1 2.25 2.25v2.5A2.25 2.25 0 0 1 17.25 11h-4.5v2h2.5a2.25 2.25 0 0 1 2.25 2.25v2.5A2.25 2.25 0 0 1 15.25 20h-2.5v1.25a.75.75 0 0 1-1.5 0m4-2.75a.75.75 0 0 0 .75-.75v-2.5a.75.75 0 0 0-.75-.75h-6.5a.75.75 0 0 0-.75.75v2.5c0 .414.336.75.75.75zm2-9a.75.75 0 0 0 .75-.75v-2.5a.75.75 0 0 0-.75-.75H6.75a.75.75 0 0 0-.75.75v2.5c0 .414.336.75.75.75z"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-right" title="Align Right"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M21 2.75a.75.75 0 0 0-1.5 0v18.5a.75.75 0 0 0 1.5 0zM15.75 4A2.25 2.25 0 0 1 18 6.25v2.5A2.25 2.25 0 0 1 15.75 11H5.25A2.25 2.25 0 0 1 3 8.75v-2.5A2.25 2.25 0 0 1 5.25 4zm.75 2.25a.75.75 0 0 0-.75-.75H5.25a.75.75 0 0 0-.75.75v2.5c0 .414.336.75.75.75h10.5a.75.75 0 0 0 .75-.75zM15.75 13A2.25 2.25 0 0 1 18 15.25v2.5A2.25 2.25 0 0 1 15.75 20h-7a2.25 2.25 0 0 1-2.25-2.25v-2.5A2.25 2.25 0 0 1 8.75 13zm.75 2.25a.75.75 0 0 0-.75-.75h-7a.75.75 0 0 0-.75.75v2.5c0 .414.336.75.75.75h7a.75.75 0 0 0 .75-.75z"/></svg></button></div><div class="flex flex-row items-center justify-center"><button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-top" title="Align Top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M2.75 3a.75.75 0 0 0 0 1.5h18.5a.75.75 0 0 0 0-1.5zM4 8.25A2.25 2.25 0 0 1 6.25 6h2.5A2.25 2.25 0 0 1 11 8.25v10.5A2.25 2.25 0 0 1 8.75 21h-2.5A2.25 2.25 0 0 1 4 18.75zm2.25-.75a.75.75 0 0 0-.75.75v10.5c0 .414.336.75.75.75h2.5a.75.75 0 0 0 .75-.75V8.25a.75.75 0 0 0-.75-.75zm6.75.75A2.25 2.25 0 0 1 15.25 6h2.5A2.25 2.25 0 0 1 20 8.25v7a2.25 2.25 0 0 1-2.25 2.25h-2.5A2.25 2.25 0 0 1 13 15.25zm2.25-.75a.75.75 0 0 0-.75.75v7c0 .414.336.75.75.75h2.5a.75.75 0 0 0 .75-.75v-7a.75.75 0 0 0-.75-.75z"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-middle" title="Align Middle"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3.75 12h-3m13.5 0h-4.5m13.5 0h-3M9.75 3.25v17.5s0 1-1 1h-4s-1 0-1-1V3.25s0-1 1-1h4s1 0 1 1m10.5 3v11.5s0 1-1 1h-4s-1 0-1-1V6.25s0-1 1-1h4s1 0 1 1"/></svg></button> <button class="w-full text-left px-3 py-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700" data-action="align-bottom" title="Align Bottom"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M2.75 21a.75.75 0 0 1 0-1.5h18.5a.75.75 0 0 1 0 1.5zM4 15.75A2.25 2.25 0 0 0 6.25 18h2.5A2.25 2.25 0 0 0 11 15.75V5.25A2.25 2.25 0 0 0 8.75 3h-2.5A2.25 2.25 0 0 0 4 5.25zm2.25.75a.75.75 0 0 1-.75-.75V5.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 .75.75v10.5a.75.75 0 0 1-.75.75zm6.75-.75A2.25 2.25 0 0 0 15.25 18h2.5A2.25 2.25 0 0 0 20 15.75v-7a2.25 2.25 0 0 0-2.25-2.25h-2.5A2.25 2.25 0 0 0 13 8.75zm2.25.75a.75.75 0 0 1-.75-.75v-7a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 .75.75v7a.75.75 0 0 1-.75.75z"/></svg></button></div></div></div><div class="h-6 w-px bg-slate-200 dark:bg-slate-600 mx-1"></div><button class="flex items-center justify-center h-8 w-8 rounded-md border border-slate-300 text-red-500 dark:border-slate-600 hover:bg-red-50 dark:hover:bg-red-500/10" data-action="delete" title="Delete"><svg class="w-5 h-5" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-width="2" d="M3 6h18m-2 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg></button></div></div></div><div id="canvas-container" class="bg-white dark:bg-slate-950 shadow-lg"><canvas id="certificate-canvas"></canvas></div></main><div id="zoom-controls" class="absolute bottom-4 right-4 z-10 flex items-center gap-1 rounded-lg bg-white dark:bg-slate-800 borders border-slate-200 dark:border-slate-700 p-2 shadow-lg"><button id="zoom-out-btn" class="h-8 w-8 rounded-md borders border-slate-300 dark:border-slate-600 p-1 hover:bg-slate-100 dark:hover:bg-slate-700 cursor-zoom-out">-</button> <button id="fit-to-screen-btn" class="h-8 rounded-md borders border-slate-300 dark:border-slate-600 px-3 text-sm hover:bg-slate-100 dark:hover:bg-slate-700 cursor-nwse-resize"><span id="zoom-level-text">100%</span></button> <button id="zoom-in-btn" class="h-8 w-8 rounded-md borders border-slate-300 dark:border-slate-600 p-1 hover:bg-slate-100 dark:hover:bg-slate-700 cursor-zoom-in">+</button></div></div></div><div id="loading-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 items-center justify-center"><div class="bg-white dark:bg-slate-800 rounded-lg p-8 flex flex-col items-center gap-4"><svg class="animate-spin h-10 w-10 text-indigo-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><p id="loading-text" class="font-medium">Memproses...</p></div></div><div id="qrcode-modal" class="hidden fixed inset-0 z-50 bg-gray-800 bg-opacity-75 items-center justify-center p-4"><div class="bg-white dark:bg-slate-800 rounded-lg shadow-2xl w-full max-h-[90vh] flex flex-col"><div class="p-4 borders-b border-slate-200 dark:border-slate-700 flex justify-between items-center shrink-0"><h2 class="text-lg font-semibold">Pengaturan Kustomisasi QR Code</h2><button id="close-qrcode-modal" class="text-slate-500 dark:text-slate-400 hover:text-slate-800 dark:hover:text-white text-2xl">&times;</button></div><div class="p-6 overflow-y-auto grid grid-cols-1 lg:grid-cols-2 gap-x-10 gap-y-8"><div class="space-y-4 lg:col-span-2"><h3 class="text-base font-semibold borders-b border-slate-200 dark:border-slate-700 pb-2">Sumber Data</h3><p class="text-sm text-slate-500 dark:text-slate-400">Pilih kolom yang akan digabung dan dienkripsi menjadi QR Code. Urutan penting.</p><div id="qrcode-columns-container" class="space-y-2"></div><button id="add-qrcode-column" class="text-sm text-indigo-600 hover:underline">+ Tambah Kolom</button><div class="space-y-1"><label for="validation-url" class="text-sm font-medium">URL Validasi (sebelum kode)</label> <input type="text" id="validation-url" placeholder="https://domain.com/cek/?kode=" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"></div></div><div class="space-y-4"><h3 class="text-base font-semibold borders-b border-slate-200 dark:border-slate-700 pb-2">Titik (Dots)</h3><div><label for="qr-dots-type" class="block text-sm font-medium">Gaya Titik</label> <select id="qr-dots-type" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"><option value="rounded">Rounded</option><option value="dots">Dots</option><option value="classy">Classy</option><option value="classy-rounded">Classy Rounded</option><option value="square">Square</option><option value="extra-rounded" selected="selected">Extra Rounded</option></select></div><div><label class="block text-sm font-medium">Tipe Warna Titik</label><div class="flex gap-4 mt-1 text-sm"><label class="flex items-center gap-2"><input type="radio" name="dots-color-type" value="single" checked="checked" class="text-indigo-600 focus:ring-indigo-500"> Single</label> <label class="flex items-center gap-2"><input type="radio" name="dots-color-type" value="gradient" class="text-indigo-600 focus:ring-indigo-500"> Gradient</label></div></div><div class="dots-single-color-fields"><label for="qr-dots-color" class="block text-sm font-medium">Warna</label> <input type="color" id="qr-dots-color" value="#000000" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"></div><div class="dots-gradient-fields space-y-2 hidden"><label class="block text-sm font-medium">Warna Gradien</label><div class="flex gap-2"><input type="color" id="qr-dots-gradient-color1" value="#000000" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"> <input type="color" id="qr-dots-gradient-color2" value="#999999" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"></div><label for="qr-dots-gradient-rotation" class="block text-sm font-medium">Rotasi Gradien</label> <input type="range" id="qr-dots-gradient-rotation" value="0" min="0" max="360" class="w-full"></div></div><div class="space-y-4"><h3 class="text-base font-semibold borders-b border-slate-200 dark:border-slate-700 pb-2">Sudut (Corners)</h3><div><label for="qr-corners-square-type" class="block text-sm font-medium">Gaya Kotak Sudut</label> <select id="qr-corners-square-type" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"><option value="extra-rounded" selected="selected">Extra Rounded</option><option value="dot">Dot</option><option value="square">Square</option></select></div><div><label for="qr-corners-square-color" class="block text-sm font-medium">Warna Kotak Sudut</label> <input type="color" id="qr-corners-square-color" value="#000000" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"></div><div><label for="qr-corners-dot-type" class="block text-sm font-medium">Gaya Titik Sudut</label> <select id="qr-corners-dot-type" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"><option value="dot">Dot</option><option value="square">Square</option></select></div><div><label for="qr-corners-dot-color" class="block text-sm font-medium">Warna Titik Sudut</label> <input type="color" id="qr-corners-dot-color" value="#000000" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"></div></div><div class="space-y-4"><h3 class="text-base font-semibold borders-b border-slate-200 dark:border-slate-700 pb-2">Latar & Logo</h3><div><label for="qr-bg-color" class="block text-sm font-medium">Warna Latar</label> <input type="color" id="qr-bg-color" value="#ffffff" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 p-1 bg-white dark:bg-slate-700"></div><div class="flex items-center gap-4"><label for="logoUploader" class="text-sm p-2 borders border-slate-300 dark:border-slate-600 rounded-md cursor-pointer hover:bg-slate-100 dark:hover:bg-slate-700">Pilih Logo...</label> <input type="file" id="logoUploader" class="hidden" accept="image/png, image/jpeg, image/svg+xml"><div id="logo-preview-container" class="flex items-center gap-2"><img id="logo-preview" src="" class="h-10 w-10 object-contain hidden bg-gray-100 dark:bg-slate-700 rounded"> <button id="remove-logo" class="hidden text-red-500 hover:text-red-700 font-bold text-xl">&times;</button></div></div><div><label for="qr-image-margin" class="block text-sm font-medium">Margin Logo</label> <input type="number" id="qr-image-margin" value="1" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"></div></div><div class="space-y-4"><h3 class="text-base font-semibold borders-b border-slate-200 dark:border-slate-700 pb-2">Opsi Teknis</h3><div><label for="qr-error-correction-level" class="block text-sm font-medium">Level Koreksi Error</label> <select id="qr-error-correction-level" class="w-full h-9 rounded-md borders border-slate-300 dark:border-slate-600 bg-slate-50 dark:bg-slate-700 px-2 text-sm"><option value="L">Low</option><option value="M">Medium</option><option value="Q">Quartile</option><option value="H" selected="selected">High</option></select></div></div></div><div class="p-4 borders-t border-slate-200 dark:border-slate-700 flex justify-end shrink-0"><button id="save-qrcode-btn" class="rounded-md bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700">Simpan & Tambah ke Kanvas</button></div></div></div><div id="context-menu" class="hidden absolute z-50"><div class="hidden md:flex flex-col w-64 bg-slate-800 text-slate-200 rounded-md shadow-lg text-sm p-1"><div class="flex flex-col" data-menu-section="clipboard"><button data-action="copy"><span>Copy</span><span class="shortcut">Ctrl+C</span></button> <button data-action="paste"><span>Paste</span><span class="shortcut">Ctrl+V</span></button> <button data-action="duplicate"><span>Duplicate</span><span class="shortcut">Ctrl+D</span></button> <button data-action="delete"><span>Delete</span><span class="shortcut">Delete</span></button></div><div class="separator"></div><div class="flex flex-col" data-menu-section="layer"><div class="submenu-container group"><button><span>Layer</span><span class="shortcut text-xl leading-none">âº</span></button><div class="submenu group-hover:block m-0"><button data-action="bring-forward"><span>Bring forward</span></button> <button data-action="bring-to-front"><span>Bring to front</span></button> <button data-action="send-backward"><span>Send backward</span></button> <button data-action="send-to-back"><span>Send to back</span></button></div></div></div><div class="separator"></div><div class="flex flex-col" data-menu-section="align"><div class="submenu-container group"><button><span>Align to page</span><span class="shortcut text-xl leading-none">âº</span></button><div class="submenu group-hover:block m-0"><button data-action="align-left"><span>Left</span></button> <button data-action="align-center"><span>Center</span></button> <button data-action="align-right"><span>Right</span></button><div class="separator"></div><button data-action="align-top"><span>Top</span></button> <button data-action="align-middle"><span>Middle</span></button> <button data-action="align-bottom"><span>Bottom</span></button></div></div></div></div><div class="flex md:hidden bg-slate-800 rounded-md shadow-lg p-1 gap-1"><button data-action="copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 21H8V7h11m-2-2H8a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2m-3-4H4a2 2 0 0 0-2 2v14h2V3h12V1Z"/></svg></button> <button data-action="paste" title="Paste"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 2h-4.18C14.4.84 13.3 0 12 0S9.6.84 9.18 2H5a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2m-7 0c.55 0 1 .45 1 1s-.45 1-1 1s-1-.45-1-1s.45-1 1-1m7 18H5V4h2v3h10V4h2v16Z"/></svg></button> <button data-action="duplicate" title="Duplicate"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M11 17H4a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h12v2H4v12h7v-2l4 3l-4 3v-2M20 5a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H9a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h11m0 2H9v12h11V7Z"/></svg></button> <button data-action="delete" title="Delete"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M19 4h-3.5l-1-1h-5l-1 1H5v2h14M6 19a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7H6v12Z"/></svg></button></div></div></div>`;
const minifiedCss = `/*! tailwindcss v4.1.14 | MIT License | https://tailwindcss.com */
@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-duration:initial;--tw-ease:initial;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-50:oklch(97.1% .013 17.38);--color-red-500:oklch(63.7% .237 25.331);--color-red-700:oklch(50.5% .213 27.518);--color-indigo-500:oklch(58.5% .233 277.117);--color-indigo-600:oklch(51.1% .262 276.966);--color-indigo-700:oklch(45.7% .24 277.023);--color-slate-50:oklch(98.4% .003 247.858);--color-slate-100:oklch(96.8% .007 247.896);--color-slate-200:oklch(92.9% .013 255.508);--color-slate-300:oklch(86.9% .022 252.894);--color-slate-400:oklch(70.4% .04 256.788);--color-slate-500:oklch(55.4% .046 257.417);--color-slate-600:oklch(44.6% .043 257.281);--color-slate-700:oklch(37.2% .044 257.287);--color-slate-800:oklch(27.9% .041 260.031);--color-slate-900:oklch(20.8% .042 265.755);--color-slate-950:oklch(12.9% .042 264.695);--color-gray-100:oklch(96.7% .003 264.542);--color-gray-400:oklch(70.7% .022 261.325);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-700:oklch(37.3% .034 259.733);--color-gray-800:oklch(27.8% .033 256.848);--color-black:#000;--color-white:#fff;--spacing:.25rem;--container-xl:36rem;--container-5xl:64rem;--container-7xl:80rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height:calc(1.5/1);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-md:.375rem;--radius-lg:.5rem;--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab, red, red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}button{cursor:pointer}}@layer components;@layer utilities{.collapse{visibility:collapse}.invisible{visibility:hidden}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.sticky{position:sticky}.inset-0{inset:calc(var(--spacing)*0)}.top-0{top:calc(var(--spacing)*0)}.top-4{top:calc(var(--spacing)*4)}.top-full{top:100%}.right-0{right:calc(var(--spacing)*0)}.right-4{right:calc(var(--spacing)*4)}.bottom-4{bottom:calc(var(--spacing)*4)}.left-0{left:calc(var(--spacing)*0)}.left-1{left:calc(var(--spacing)*1)}.left-1\\/2{left:50%}.z-10{z-index:10}.z-20{z-index:20}.z-40{z-index:40}.z-50{z-index:50}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-0{margin:calc(var(--spacing)*0)}.m-1{margin:calc(var(--spacing)*1)}.mx-1{margin-inline:calc(var(--spacing)*1)}.mt-1{margin-top:calc(var(--spacing)*1)}.mt-2{margin-top:calc(var(--spacing)*2)}.mb-1{margin-bottom:calc(var(--spacing)*1)}.block{display:block}.contents{display:contents}.flex{display:flex}.flow-root{display:flow-root}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.inline-grid{display:inline-grid}.inline-table{display:inline-table}.list-item{display:list-item}.table{display:table}.table\\!{display:table!important}.table-caption{display:table-caption}.table-cell{display:table-cell}.table-column{display:table-column}.table-column-group{display:table-column-group}.table-footer-group{display:table-footer-group}.table-header-group{display:table-header-group}.table-row{display:table-row}.table-row-group{display:table-row-group}.h-4{height:calc(var(--spacing)*4)}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-14{height:calc(var(--spacing)*14)}.h-16{height:calc(var(--spacing)*16)}.h-full{height:100%}.h-screen{height:100vh}.max-h-\\[90vh\\]{max-height:90vh}.w-4{width:calc(var(--spacing)*4)}.w-5{width:calc(var(--spacing)*5)}.w-8{width:calc(var(--spacing)*8)}.w-10{width:calc(var(--spacing)*10)}.w-11{width:calc(var(--spacing)*11)}.w-11\\/12{width:91.6667%}.w-16{width:calc(var(--spacing)*16)}.w-64{width:calc(var(--spacing)*64)}.w-66{width:calc(var(--spacing)*66)}.w-72{width:calc(var(--spacing)*72)}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.w-px{width:1px}.w-screen{width:100vw}.max-w-5xl{max-width:var(--container-5xl)}.flex-1{flex:1}.shrink-0{flex-shrink:0}.border-collapse{border-collapse:collapse}.origin-top-right{transform-origin:100% 0}.-translate-x-1{--tw-translate-x:calc(var(--spacing)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-1\\/2{--tw-translate-x:calc(calc(1/2*100%)*-1);translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-x-full{--tw-translate-x:-100%;translate:var(--tw-translate-x)var(--tw-translate-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.transform\\!{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)!important}.animate-spin{animation:var(--animate-spin)}.cursor-nwse-resize{cursor:nwse-resize}.cursor-pointer{cursor:pointer}.cursor-zoom-in{cursor:zoom-in}.cursor-zoom-out{cursor:zoom-out}.resize{resize:both}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.gap-1{gap:calc(var(--spacing)*1)}.gap-2{gap:calc(var(--spacing)*2)}.gap-4{gap:calc(var(--spacing)*4)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-4>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*4)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*4)*calc(1 - var(--tw-space-y-reverse)))}.gap-x-10{column-gap:calc(var(--spacing)*10)}.gap-y-8{row-gap:calc(var(--spacing)*8)}.overflow-hidden{overflow:hidden}.overflow-scroll{overflow:scroll}.overflow-y-auto{overflow-y:auto}.scroll-smooth{scroll-behavior:smooth}.rounded{border-radius:.25rem}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-r{border-right-style:var(--tw-border-style);border-right-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-slate-200{border-color:var(--color-slate-200)}.border-slate-300{border-color:var(--color-slate-300)}.bg-black{background-color:var(--color-black)}.bg-gray-100{background-color:var(--color-gray-100)}.bg-gray-800{background-color:var(--color-gray-800)}.bg-indigo-600{background-color:var(--color-indigo-600)}.bg-slate-50{background-color:var(--color-slate-50)}.bg-slate-100{background-color:var(--color-slate-100)}.bg-slate-200{background-color:var(--color-slate-200)}.bg-slate-800{background-color:var(--color-slate-800)}.bg-white{background-color:var(--color-white)}.object-contain{object-fit:contain}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-2\\.5{padding:calc(var(--spacing)*2.5)}.p-4{padding:calc(var(--spacing)*4)}.p-6{padding:calc(var(--spacing)*6)}.p-8{padding:calc(var(--spacing)*8)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.pr-2{padding-right:calc(var(--spacing)*2)}.pb-2{padding-bottom:calc(var(--spacing)*2)}.text-left{text-align:left}.align-bottom{vertical-align:bottom}.align-middle{vertical-align:middle}.align-top{vertical-align:top}.font-\\[\\'Poppins\\'\\]{font-family:Poppins}.font-\\[\\\\\\'Poppins\\\\\\'\\]{font-family:"'Poppins'"}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[9px\\]{font-size:9px}.text-\\[10px\\]{font-size:10px}.leading-none{--tw-leading:1;line-height:1}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.text-wrap{text-wrap:wrap}.break-all{word-break:break-all}.whitespace-nowrap{white-space:nowrap}.text-gray-500{color:var(--color-gray-500)}.text-gray-700{color:var(--color-gray-700)}.text-indigo-600{color:var(--color-indigo-600)}.text-red-500{color:var(--color-red-500)}.text-slate-200{color:var(--color-slate-200)}.text-slate-400{color:var(--color-slate-400)}.text-slate-500{color:var(--color-slate-500)}.text-slate-600{color:var(--color-slate-600)}.text-slate-800{color:var(--color-slate-800)}.text-white{color:var(--color-white)}.capitalize{text-transform:capitalize}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.italic{font-style:italic}.line-through{text-decoration-line:line-through}.overline{text-decoration-line:overline}.overline\\!{text-decoration-line:overline!important}.underline{text-decoration-line:underline}.underline\\!{text-decoration-line:underline!important}.antialiased{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.opacity-25{opacity:.25}.opacity-75{opacity:.75}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-2xl{--tw-shadow:0 25px 50px -12px var(--tw-shadow-color,#00000040);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-1{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-black{--tw-ring-color:var(--color-black)}.\\!outline{outline-style:var(--tw-outline-style)!important;outline-width:1px!important}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.invert{--tw-invert:invert(100%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter\\!{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)!important}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-300{--tw-duration:.3s;transition-duration:.3s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}@media (hover:hover){.group-hover\\:block:is(:where(.group):hover *){display:block}.group-hover\\:flex:is(:where(.group):hover *){display:flex}}.before\\:transform:before{content:var(--tw-content);transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}@media (hover:hover){.hover\\:bg-gray-100:hover{background-color:var(--color-gray-100)}.hover\\:bg-indigo-700:hover{background-color:var(--color-indigo-700)}.hover\\:bg-red-50:hover{background-color:var(--color-red-50)}.hover\\:bg-slate-100:hover{background-color:var(--color-slate-100)}.hover\\:text-red-700:hover{color:var(--color-red-700)}.hover\\:text-slate-800:hover{color:var(--color-slate-800)}.hover\\:underline:hover{text-decoration-line:underline}}.focus\\:ring-indigo-500:focus{--tw-ring-color:var(--color-indigo-500)}.focus\\:outline-none:focus{--tw-outline-style:none;outline-style:none}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:text-slate-300:disabled{color:var(--color-slate-300)}.disabled\\:opacity-50:disabled{opacity:.5}@media (min-width:40rem){.sm\\:block{display:block}.sm\\:inline{display:inline}}@media (min-width:48rem){.md\\:relative{position:relative}.md\\:flex{display:flex}.md\\:hidden{display:none}.md\\:inline{display:inline}.md\\:w-auto{width:auto}.md\\:translate-x-0{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.md\\:gap-2{gap:calc(var(--spacing)*2)}.md\\:gap-4{gap:calc(var(--spacing)*4)}.md\\:gap-5{gap:calc(var(--spacing)*5)}.md\\:p-8{padding:calc(var(--spacing)*8)}.md\\:px-4{padding-inline:calc(var(--spacing)*4)}.md\\:text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.md\\:text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}}@media (min-width:64rem){.lg\\:col-span-2{grid-column:span 2/span 2}.lg\\:w-20{width:calc(var(--spacing)*20)}.lg\\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}}.dark\\:border-slate-600:where(.dark,.dark *){border-color:var(--color-slate-600)}.dark\\:border-slate-700:where(.dark,.dark *){border-color:var(--color-slate-700)}.dark\\:bg-slate-600:where(.dark,.dark *){background-color:var(--color-slate-600)}.dark\\:bg-slate-700:where(.dark,.dark *){background-color:var(--color-slate-700)}.dark\\:bg-slate-700\\/50:where(.dark,.dark *){background-color:#31415880}@supports (color:color-mix(in lab, red, red)){.dark\\:bg-slate-700\\/50:where(.dark,.dark *){background-color:color-mix(in oklab,var(--color-slate-700)50%,transparent)}}.dark\\:bg-slate-800:where(.dark,.dark *){background-color:var(--color-slate-800)}.dark\\:bg-slate-900:where(.dark,.dark *){background-color:var(--color-slate-900)}.dark\\:bg-slate-950:where(.dark,.dark *){background-color:var(--color-slate-950)}.dark\\:text-gray-400:where(.dark,.dark *){color:var(--color-gray-400)}.dark\\:text-slate-200:where(.dark,.dark *){color:var(--color-slate-200)}.dark\\:text-slate-300:where(.dark,.dark *){color:var(--color-slate-300)}.dark\\:text-slate-400:where(.dark,.dark *){color:var(--color-slate-400)}.dark\\:ring-slate-700:where(.dark,.dark *){--tw-ring-color:var(--color-slate-700)}@media (hover:hover){.dark\\:hover\\:bg-gray-700:where(.dark,.dark *):hover{background-color:var(--color-gray-700)}.dark\\:hover\\:bg-red-500\\/10:where(.dark,.dark *):hover{background-color:#fb2c361a}@supports (color:color-mix(in lab, red, red)){.dark\\:hover\\:bg-red-500\\/10:where(.dark,.dark *):hover{background-color:color-mix(in oklab,var(--color-red-500)10%,transparent)}}.dark\\:hover\\:bg-slate-700:where(.dark,.dark *):hover{background-color:var(--color-slate-700)}.dark\\:hover\\:text-white:where(.dark,.dark *):hover{color:var(--color-white)}}.dark\\:disabled\\:text-slate-600:where(.dark,.dark *):disabled{color:var(--color-slate-600)}}:host{width:100%;height:100%;display:block}.bg-dots{background-image:radial-gradient(#a1a1aa 1px,#0000 0);background-size:20px 20px}.dark .bg-dots{background-image:radial-gradient(#475569 1px,#0000 0)}::-webkit-scrollbar{width:8px;height:8px}::-webkit-scrollbar-track{background-color:#f1f5f9}::-webkit-scrollbar-thumb{background-color:#94a3b8;border-radius:4px}@media (hover:hover){::-webkit-scrollbar-thumb:hover:hover{background-color:#64748b}}.dark ::-webkit-scrollbar-track{background:#1e293b}.dark ::-webkit-scrollbar-thumb{background:#475569}.dark ::-webkit-scrollbar-thumb:hover{background:#64748b}.borders{border-width:1px}.borders-r{border-right-width:1px}.borders-b{border-bottom-width:1px}.borders-l{border-left-width:1px}.borders-t{border-top-width:1px}#context-menu{--menu-bg:#1e293b;--menu-text:#cbd5e1;--menu-hover-bg:#334155;--menu-separator:#475569;--menu-shortcut-text:#94a3b8}#context-menu button{width:100%;color:var(--menu-text);text-align:left;cursor:pointer;white-space:nowrap;background-color:#0000;border:none;border-radius:4px;justify-content:space-between;align-items:center;padding:8px 12px;display:flex}#context-menu button:hover{background-color:var(--menu-hover-bg)}#context-menu button:disabled{color:#475569;cursor:not-allowed;background-color:#0000}#context-menu .shortcut{color:var(--menu-shortcut-text);margin-left:16px;font-size:12px}#context-menu .separator{background-color:var(--menu-separator);height:1px;margin:4px 0}#context-menu .submenu-container{position:relative}#context-menu .submenu{background-color:var(--menu-bg);border-radius:6px;min-width:150px;padding:4px;display:none;position:absolute;top:-5px;left:100%;box-shadow:0 4px 6px #0000001a}#context-menu .submenu-container:hover .submenu{display:block}#context-menu .submenu-container.submenu-open-left .submenu{left:auto;right:100%}#context-menu .submenu-container.submenu-open-right .submenu{left:100%;right:auto}#context-menu .md\\:hidden button{color:var(--menu-text);padding:10px}#context-menu .md\\:hidden button svg{width:24px;height:24px}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-space-y-reverse{syntax:"*";inherits:false;initial-value:0}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}@keyframes spin{to{transform:rotate(360deg)}}`;
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString$2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction$1 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isEmptyObject = (val) => {
  if (!isObject$1(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e2) {
    return false;
  }
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn.call(null, obj[i2], i2, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction$1(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content2) => {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$1(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray$1(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$1(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
const utils$2 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$2.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors$1 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors$1[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors$1);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$2.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  const msg = error && error.message ? error.message : "Error";
  const errCode = code == null && error ? error.code : code;
  AxiosError$1.call(axiosError, msg, errCode, config, request, response);
  if (error && axiosError.cause == null) {
    Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
  }
  axiosError.name = error && error.name || "Error";
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
}
function removeBrackets(key) {
  return utils$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$2.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
  if (!utils$2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$2.isDate(value)) {
      return value.toISOString();
    }
    if (utils$2.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils$2.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, "[]")) && (arr = utils$2.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$2.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$2.forEach(value, function each(el, key) {
      const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$2.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode$1;
  if (utils$2.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$2.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$1,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), {
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$2.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}
function parsePropPath(name) {
  return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils$2.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$2.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$2.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index2);
    if (result && utils$2.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
    const obj = {};
    utils$2.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder2) {
  if (utils$2.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$2.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$2.isObject(data);
    if (isObjectPayload && utils$2.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$2.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$2.isArrayBuffer(data) || utils$2.isBuffer(data) || utils$2.isStream(data) || utils$2.isFile(data) || utils$2.isBlob(data) || utils$2.isReadableStream(data)) {
      return data;
    }
    if (utils$2.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$2.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$2.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$2.isResponse(data) || utils$2.isReadableStream(data)) {
      return data;
    }
    if (data && utils$2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data, this.parseReviver);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const ignoreDuplicateOf = utils$2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$2.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$2.isString(value)) return;
  if (utils$2.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$2.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$2.isObject(header) && utils$2.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$2.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$2.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$2.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$2.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i2 = keys2.length;
    let deleted = false;
    while (i2--) {
      const key = keys2[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$2.forEach(this, (value, header) => {
      const key = utils$2.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$2.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$2.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$2.forEach(fns, function transform2(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$2.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$2.asap(() => fn(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$2.isString(path2) && cookie.push("path=" + path2);
      utils$2.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge.call({ caseless }, target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$2.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$2.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$2.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$2.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils$2.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils$2.isFunction(data.getHeaders)) {
      const formHeaders = data.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$2.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$2.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const { isFunction } = utils$2;
const globalFetchAPI = (({ Request, Response }) => ({
  Request,
  Response
}))(utils$2.global);
const {
  ReadableStream: ReadableStream$1,
  TextEncoder: TextEncoder$1
} = utils$2.global;
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e2) {
    return false;
  }
};
const factory = (env) => {
  env = utils$2.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request, Response } = env;
  const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction(Request);
  const isResponseSupported = isFunction(Response);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
  const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request(platform.origin, {
      body: new ReadableStream$1(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$2.isReadableStream(new Response("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils$2.isBlob(body)) {
      return body.size;
    }
    if (utils$2.isSpecCompliantForm(body)) {
      const _request = new Request(platform.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils$2.isArrayBufferView(body) || utils$2.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils$2.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils$2.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils$2.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url,
      method,
      data,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
        let _request = new Request(url, {
          method: "POST",
          body: data,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils$2.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils$2.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils$2.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils$2.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders$1.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError$1.from(err, err && err.code, config, request);
    }
  };
};
const seedCache = /* @__PURE__ */ new Map();
const getFetch = (config) => {
  let env = config ? config.env : {};
  const { fetch: fetch2, Request, Response } = env;
  const seeds = [
    Request,
    Response,
    fetch2
  ];
  let len = seeds.length, i2 = len, seed, target, map = seedCache;
  while (i2--) {
    seed = seeds[i2];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
getFetch();
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: {
    get: getFetch
  }
};
utils$2.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2, config) => {
    adapters2 = utils$2.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter && (utils$2.isFunction(adapter) || (adapter = adapter.get(config)))) {
        break;
      }
      rejectedReasons[id || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults.adapter, config);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION$1 = "1.12.2";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$2.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$2.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$2.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$2.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (Object.prototype.hasOwnProperty.call(n2, "__esModule")) return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      var isInstance = false;
      try {
        isInstance = this instanceof a3;
      } catch {
      }
      if (isInstance) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var qrCodeStyling$1 = { exports: {} };
var qrCodeStyling = qrCodeStyling$1.exports;
var hasRequiredQrCodeStyling;
function requireQrCodeStyling() {
  if (hasRequiredQrCodeStyling) return qrCodeStyling$1.exports;
  hasRequiredQrCodeStyling = 1;
  (function(module, exports) {
    !(function(t3, e2) {
      module.exports = e2();
    })(qrCodeStyling, (() => (() => {
      var t3 = { 873: (t4, e3) => {
        var i3, r3, n2 = (function() {
          var t5 = function(t6, e5) {
            var i5 = t6, r5 = s2[e5], n4 = null, o3 = 0, h3 = null, p3 = [], v3 = {}, m2 = function(t7, e6) {
              n4 = (function(t8) {
                for (var e7 = new Array(t8), i6 = 0; i6 < t8; i6 += 1) {
                  e7[i6] = new Array(t8);
                  for (var r6 = 0; r6 < t8; r6 += 1) e7[i6][r6] = null;
                }
                return e7;
              })(o3 = 4 * i5 + 17), b2(0, 0), b2(o3 - 7, 0), b2(0, o3 - 7), x2(), y2(), C2(t7, e6), i5 >= 7 && S2(t7), null == h3 && (h3 = M2(i5, r5, p3)), A2(h3, e6);
            }, b2 = function(t7, e6) {
              for (var i6 = -1; i6 <= 7; i6 += 1) if (!(t7 + i6 <= -1 || o3 <= t7 + i6)) for (var r6 = -1; r6 <= 7; r6 += 1) e6 + r6 <= -1 || o3 <= e6 + r6 || (n4[t7 + i6][e6 + r6] = 0 <= i6 && i6 <= 6 && (0 == r6 || 6 == r6) || 0 <= r6 && r6 <= 6 && (0 == i6 || 6 == i6) || 2 <= i6 && i6 <= 4 && 2 <= r6 && r6 <= 4);
            }, y2 = function() {
              for (var t7 = 8; t7 < o3 - 8; t7 += 1) null == n4[t7][6] && (n4[t7][6] = t7 % 2 == 0);
              for (var e6 = 8; e6 < o3 - 8; e6 += 1) null == n4[6][e6] && (n4[6][e6] = e6 % 2 == 0);
            }, x2 = function() {
              for (var t7 = a2.getPatternPosition(i5), e6 = 0; e6 < t7.length; e6 += 1) for (var r6 = 0; r6 < t7.length; r6 += 1) {
                var o4 = t7[e6], s3 = t7[r6];
                if (null == n4[o4][s3]) for (var h4 = -2; h4 <= 2; h4 += 1) for (var d3 = -2; d3 <= 2; d3 += 1) n4[o4 + h4][s3 + d3] = -2 == h4 || 2 == h4 || -2 == d3 || 2 == d3 || 0 == h4 && 0 == d3;
              }
            }, S2 = function(t7) {
              for (var e6 = a2.getBCHTypeNumber(i5), r6 = 0; r6 < 18; r6 += 1) {
                var s3 = !t7 && 1 == (e6 >> r6 & 1);
                n4[Math.floor(r6 / 3)][r6 % 3 + o3 - 8 - 3] = s3;
              }
              for (r6 = 0; r6 < 18; r6 += 1) s3 = !t7 && 1 == (e6 >> r6 & 1), n4[r6 % 3 + o3 - 8 - 3][Math.floor(r6 / 3)] = s3;
            }, C2 = function(t7, e6) {
              for (var i6 = r5 << 3 | e6, s3 = a2.getBCHTypeInfo(i6), h4 = 0; h4 < 15; h4 += 1) {
                var d3 = !t7 && 1 == (s3 >> h4 & 1);
                h4 < 6 ? n4[h4][8] = d3 : h4 < 8 ? n4[h4 + 1][8] = d3 : n4[o3 - 15 + h4][8] = d3;
              }
              for (h4 = 0; h4 < 15; h4 += 1) d3 = !t7 && 1 == (s3 >> h4 & 1), h4 < 8 ? n4[8][o3 - h4 - 1] = d3 : h4 < 9 ? n4[8][15 - h4 - 1 + 1] = d3 : n4[8][15 - h4 - 1] = d3;
              n4[o3 - 8][8] = !t7;
            }, A2 = function(t7, e6) {
              for (var i6 = -1, r6 = o3 - 1, s3 = 7, h4 = 0, d3 = a2.getMaskFunction(e6), u3 = o3 - 1; u3 > 0; u3 -= 2) for (6 == u3 && (u3 -= 1); ; ) {
                for (var c3 = 0; c3 < 2; c3 += 1) if (null == n4[r6][u3 - c3]) {
                  var l3 = false;
                  h4 < t7.length && (l3 = 1 == (t7[h4] >>> s3 & 1)), d3(r6, u3 - c3) && (l3 = !l3), n4[r6][u3 - c3] = l3, -1 == (s3 -= 1) && (h4 += 1, s3 = 7);
                }
                if ((r6 += i6) < 0 || o3 <= r6) {
                  r6 -= i6, i6 = -i6;
                  break;
                }
              }
            }, M2 = function(t7, e6, i6) {
              for (var r6 = u2.getRSBlocks(t7, e6), n5 = c2(), o4 = 0; o4 < i6.length; o4 += 1) {
                var s3 = i6[o4];
                n5.put(s3.getMode(), 4), n5.put(s3.getLength(), a2.getLengthInBits(s3.getMode(), t7)), s3.write(n5);
              }
              var h4 = 0;
              for (o4 = 0; o4 < r6.length; o4 += 1) h4 += r6[o4].dataCount;
              if (n5.getLengthInBits() > 8 * h4) throw "code length overflow. (" + n5.getLengthInBits() + ">" + 8 * h4 + ")";
              for (n5.getLengthInBits() + 4 <= 8 * h4 && n5.put(0, 4); n5.getLengthInBits() % 8 != 0; ) n5.putBit(false);
              for (; !(n5.getLengthInBits() >= 8 * h4 || (n5.put(236, 8), n5.getLengthInBits() >= 8 * h4)); ) n5.put(17, 8);
              return (function(t8, e7) {
                for (var i7 = 0, r7 = 0, n6 = 0, o5 = new Array(e7.length), s4 = new Array(e7.length), h5 = 0; h5 < e7.length; h5 += 1) {
                  var u3 = e7[h5].dataCount, c3 = e7[h5].totalCount - u3;
                  r7 = Math.max(r7, u3), n6 = Math.max(n6, c3), o5[h5] = new Array(u3);
                  for (var l3 = 0; l3 < o5[h5].length; l3 += 1) o5[h5][l3] = 255 & t8.getBuffer()[l3 + i7];
                  i7 += u3;
                  var g3 = a2.getErrorCorrectPolynomial(c3), f3 = d2(o5[h5], g3.getLength() - 1).mod(g3);
                  for (s4[h5] = new Array(g3.getLength() - 1), l3 = 0; l3 < s4[h5].length; l3 += 1) {
                    var w3 = l3 + f3.getLength() - s4[h5].length;
                    s4[h5][l3] = w3 >= 0 ? f3.getAt(w3) : 0;
                  }
                }
                var p4 = 0;
                for (l3 = 0; l3 < e7.length; l3 += 1) p4 += e7[l3].totalCount;
                var v4 = new Array(p4), _3 = 0;
                for (l3 = 0; l3 < r7; l3 += 1) for (h5 = 0; h5 < e7.length; h5 += 1) l3 < o5[h5].length && (v4[_3] = o5[h5][l3], _3 += 1);
                for (l3 = 0; l3 < n6; l3 += 1) for (h5 = 0; h5 < e7.length; h5 += 1) l3 < s4[h5].length && (v4[_3] = s4[h5][l3], _3 += 1);
                return v4;
              })(n5, r6);
            };
            v3.addData = function(t7, e6) {
              var i6 = null;
              switch (e6 = e6 || "Byte") {
                case "Numeric":
                  i6 = l2(t7);
                  break;
                case "Alphanumeric":
                  i6 = g2(t7);
                  break;
                case "Byte":
                  i6 = f2(t7);
                  break;
                case "Kanji":
                  i6 = w2(t7);
                  break;
                default:
                  throw "mode:" + e6;
              }
              p3.push(i6), h3 = null;
            }, v3.isDark = function(t7, e6) {
              if (t7 < 0 || o3 <= t7 || e6 < 0 || o3 <= e6) throw t7 + "," + e6;
              return n4[t7][e6];
            }, v3.getModuleCount = function() {
              return o3;
            }, v3.make = function() {
              if (i5 < 1) {
                for (var t7 = 1; t7 < 40; t7++) {
                  for (var e6 = u2.getRSBlocks(t7, r5), n5 = c2(), o4 = 0; o4 < p3.length; o4++) {
                    var s3 = p3[o4];
                    n5.put(s3.getMode(), 4), n5.put(s3.getLength(), a2.getLengthInBits(s3.getMode(), t7)), s3.write(n5);
                  }
                  var h4 = 0;
                  for (o4 = 0; o4 < e6.length; o4++) h4 += e6[o4].dataCount;
                  if (n5.getLengthInBits() <= 8 * h4) break;
                }
                i5 = t7;
              }
              m2(false, (function() {
                for (var t8 = 0, e7 = 0, i6 = 0; i6 < 8; i6 += 1) {
                  m2(true, i6);
                  var r6 = a2.getLostPoint(v3);
                  (0 == i6 || t8 > r6) && (t8 = r6, e7 = i6);
                }
                return e7;
              })());
            }, v3.createTableTag = function(t7, e6) {
              t7 = t7 || 2;
              var i6 = "";
              i6 += '<table style="', i6 += " border-width: 0px; border-style: none;", i6 += " border-collapse: collapse;", i6 += " padding: 0px; margin: " + (e6 = void 0 === e6 ? 4 * t7 : e6) + "px;", i6 += '">', i6 += "<tbody>";
              for (var r6 = 0; r6 < v3.getModuleCount(); r6 += 1) {
                i6 += "<tr>";
                for (var n5 = 0; n5 < v3.getModuleCount(); n5 += 1) i6 += '<td style="', i6 += " border-width: 0px; border-style: none;", i6 += " border-collapse: collapse;", i6 += " padding: 0px; margin: 0px;", i6 += " width: " + t7 + "px;", i6 += " height: " + t7 + "px;", i6 += " background-color: ", i6 += v3.isDark(r6, n5) ? "#000000" : "#ffffff", i6 += ";", i6 += '"/>';
                i6 += "</tr>";
              }
              return (i6 += "</tbody>") + "</table>";
            }, v3.createSvgTag = function(t7, e6, i6, r6) {
              var n5 = {};
              "object" == typeof arguments[0] && (t7 = (n5 = arguments[0]).cellSize, e6 = n5.margin, i6 = n5.alt, r6 = n5.title), t7 = t7 || 2, e6 = void 0 === e6 ? 4 * t7 : e6, (i6 = "string" == typeof i6 ? { text: i6 } : i6 || {}).text = i6.text || null, i6.id = i6.text ? i6.id || "qrcode-description" : null, (r6 = "string" == typeof r6 ? { text: r6 } : r6 || {}).text = r6.text || null, r6.id = r6.text ? r6.id || "qrcode-title" : null;
              var o4, s3, a3, h4, d3 = v3.getModuleCount() * t7 + 2 * e6, u3 = "";
              for (h4 = "l" + t7 + ",0 0," + t7 + " -" + t7 + ",0 0,-" + t7 + "z ", u3 += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', u3 += n5.scalable ? "" : ' width="' + d3 + 'px" height="' + d3 + 'px"', u3 += ' viewBox="0 0 ' + d3 + " " + d3 + '" ', u3 += ' preserveAspectRatio="xMinYMin meet"', u3 += r6.text || i6.text ? ' role="img" aria-labelledby="' + $2([r6.id, i6.id].join(" ").trim()) + '"' : "", u3 += ">", u3 += r6.text ? '<title id="' + $2(r6.id) + '">' + $2(r6.text) + "</title>" : "", u3 += i6.text ? '<description id="' + $2(i6.id) + '">' + $2(i6.text) + "</description>" : "", u3 += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', u3 += '<path d="', s3 = 0; s3 < v3.getModuleCount(); s3 += 1) for (a3 = s3 * t7 + e6, o4 = 0; o4 < v3.getModuleCount(); o4 += 1) v3.isDark(s3, o4) && (u3 += "M" + (o4 * t7 + e6) + "," + a3 + h4);
              return (u3 += '" stroke="transparent" fill="black"/>') + "</svg>";
            }, v3.createDataURL = function(t7, e6) {
              t7 = t7 || 2, e6 = void 0 === e6 ? 4 * t7 : e6;
              var i6 = v3.getModuleCount() * t7 + 2 * e6, r6 = e6, n5 = i6 - e6;
              return _2(i6, i6, (function(e7, i7) {
                if (r6 <= e7 && e7 < n5 && r6 <= i7 && i7 < n5) {
                  var o4 = Math.floor((e7 - r6) / t7), s3 = Math.floor((i7 - r6) / t7);
                  return v3.isDark(s3, o4) ? 0 : 1;
                }
                return 1;
              }));
            }, v3.createImgTag = function(t7, e6, i6) {
              t7 = t7 || 2, e6 = void 0 === e6 ? 4 * t7 : e6;
              var r6 = v3.getModuleCount() * t7 + 2 * e6, n5 = "";
              return n5 += "<img", n5 += ' src="', n5 += v3.createDataURL(t7, e6), n5 += '"', n5 += ' width="', n5 += r6, n5 += '"', n5 += ' height="', n5 += r6, n5 += '"', i6 && (n5 += ' alt="', n5 += $2(i6), n5 += '"'), n5 + "/>";
            };
            var $2 = function(t7) {
              for (var e6 = "", i6 = 0; i6 < t7.length; i6 += 1) {
                var r6 = t7.charAt(i6);
                switch (r6) {
                  case "<":
                    e6 += "&lt;";
                    break;
                  case ">":
                    e6 += "&gt;";
                    break;
                  case "&":
                    e6 += "&amp;";
                    break;
                  case '"':
                    e6 += "&quot;";
                    break;
                  default:
                    e6 += r6;
                }
              }
              return e6;
            };
            return v3.createASCII = function(t7, e6) {
              if ((t7 = t7 || 1) < 2) return (function(t8) {
                t8 = void 0 === t8 ? 2 : t8;
                var e7, i7, r7, n6, o5, s4 = 1 * v3.getModuleCount() + 2 * t8, a4 = t8, h5 = s4 - t8, d4 = { "ââ": "â", "â ": "â", " â": "â", "  ": " " }, u4 = { "ââ": "â", "â ": "â", " â": " ", "  ": " " }, c4 = "";
                for (e7 = 0; e7 < s4; e7 += 2) {
                  for (r7 = Math.floor((e7 - a4) / 1), n6 = Math.floor((e7 + 1 - a4) / 1), i7 = 0; i7 < s4; i7 += 1) o5 = "â", a4 <= i7 && i7 < h5 && a4 <= e7 && e7 < h5 && v3.isDark(r7, Math.floor((i7 - a4) / 1)) && (o5 = " "), a4 <= i7 && i7 < h5 && a4 <= e7 + 1 && e7 + 1 < h5 && v3.isDark(n6, Math.floor((i7 - a4) / 1)) ? o5 += " " : o5 += "â", c4 += t8 < 1 && e7 + 1 >= h5 ? u4[o5] : d4[o5];
                  c4 += "\n";
                }
                return s4 % 2 && t8 > 0 ? c4.substring(0, c4.length - s4 - 1) + Array(s4 + 1).join("â") : c4.substring(0, c4.length - 1);
              })(e6);
              t7 -= 1, e6 = void 0 === e6 ? 2 * t7 : e6;
              var i6, r6, n5, o4, s3 = v3.getModuleCount() * t7 + 2 * e6, a3 = e6, h4 = s3 - e6, d3 = Array(t7 + 1).join("ââ"), u3 = Array(t7 + 1).join("  "), c3 = "", l3 = "";
              for (i6 = 0; i6 < s3; i6 += 1) {
                for (n5 = Math.floor((i6 - a3) / t7), l3 = "", r6 = 0; r6 < s3; r6 += 1) o4 = 1, a3 <= r6 && r6 < h4 && a3 <= i6 && i6 < h4 && v3.isDark(n5, Math.floor((r6 - a3) / t7)) && (o4 = 0), l3 += o4 ? d3 : u3;
                for (n5 = 0; n5 < t7; n5 += 1) c3 += l3 + "\n";
              }
              return c3.substring(0, c3.length - 1);
            }, v3.renderTo2dContext = function(t7, e6) {
              e6 = e6 || 2;
              for (var i6 = v3.getModuleCount(), r6 = 0; r6 < i6; r6++) for (var n5 = 0; n5 < i6; n5++) t7.fillStyle = v3.isDark(r6, n5) ? "black" : "white", t7.fillRect(r6 * e6, n5 * e6, e6, e6);
            }, v3;
          };
          t5.stringToBytes = (t5.stringToBytesFuncs = { default: function(t6) {
            for (var e5 = [], i5 = 0; i5 < t6.length; i5 += 1) {
              var r5 = t6.charCodeAt(i5);
              e5.push(255 & r5);
            }
            return e5;
          } }).default, t5.createStringToBytes = function(t6, e5) {
            var i5 = (function() {
              for (var i6 = v2(t6), r6 = function() {
                var t7 = i6.read();
                if (-1 == t7) throw "eof";
                return t7;
              }, n4 = 0, o3 = {}; ; ) {
                var s3 = i6.read();
                if (-1 == s3) break;
                var a3 = r6(), h3 = r6() << 8 | r6();
                o3[String.fromCharCode(s3 << 8 | a3)] = h3, n4 += 1;
              }
              if (n4 != e5) throw n4 + " != " + e5;
              return o3;
            })(), r5 = "?".charCodeAt(0);
            return function(t7) {
              for (var e6 = [], n4 = 0; n4 < t7.length; n4 += 1) {
                var o3 = t7.charCodeAt(n4);
                if (o3 < 128) e6.push(o3);
                else {
                  var s3 = i5[t7.charAt(n4)];
                  "number" == typeof s3 ? (255 & s3) == s3 ? e6.push(s3) : (e6.push(s3 >>> 8), e6.push(255 & s3)) : e6.push(r5);
                }
              }
              return e6;
            };
          };
          var e4, i4, r4, n3, o2, s2 = { L: 1, M: 0, Q: 3, H: 2 }, a2 = (e4 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], i4 = 1335, r4 = 7973, o2 = function(t6) {
            for (var e5 = 0; 0 != t6; ) e5 += 1, t6 >>>= 1;
            return e5;
          }, (n3 = {}).getBCHTypeInfo = function(t6) {
            for (var e5 = t6 << 10; o2(e5) - o2(i4) >= 0; ) e5 ^= i4 << o2(e5) - o2(i4);
            return 21522 ^ (t6 << 10 | e5);
          }, n3.getBCHTypeNumber = function(t6) {
            for (var e5 = t6 << 12; o2(e5) - o2(r4) >= 0; ) e5 ^= r4 << o2(e5) - o2(r4);
            return t6 << 12 | e5;
          }, n3.getPatternPosition = function(t6) {
            return e4[t6 - 1];
          }, n3.getMaskFunction = function(t6) {
            switch (t6) {
              case 0:
                return function(t7, e5) {
                  return (t7 + e5) % 2 == 0;
                };
              case 1:
                return function(t7, e5) {
                  return t7 % 2 == 0;
                };
              case 2:
                return function(t7, e5) {
                  return e5 % 3 == 0;
                };
              case 3:
                return function(t7, e5) {
                  return (t7 + e5) % 3 == 0;
                };
              case 4:
                return function(t7, e5) {
                  return (Math.floor(t7 / 2) + Math.floor(e5 / 3)) % 2 == 0;
                };
              case 5:
                return function(t7, e5) {
                  return t7 * e5 % 2 + t7 * e5 % 3 == 0;
                };
              case 6:
                return function(t7, e5) {
                  return (t7 * e5 % 2 + t7 * e5 % 3) % 2 == 0;
                };
              case 7:
                return function(t7, e5) {
                  return (t7 * e5 % 3 + (t7 + e5) % 2) % 2 == 0;
                };
              default:
                throw "bad maskPattern:" + t6;
            }
          }, n3.getErrorCorrectPolynomial = function(t6) {
            for (var e5 = d2([1], 0), i5 = 0; i5 < t6; i5 += 1) e5 = e5.multiply(d2([1, h2.gexp(i5)], 0));
            return e5;
          }, n3.getLengthInBits = function(t6, e5) {
            if (1 <= e5 && e5 < 10) switch (t6) {
              case 1:
                return 10;
              case 2:
                return 9;
              case 4:
              case 8:
                return 8;
              default:
                throw "mode:" + t6;
            }
            else if (e5 < 27) switch (t6) {
              case 1:
                return 12;
              case 2:
                return 11;
              case 4:
                return 16;
              case 8:
                return 10;
              default:
                throw "mode:" + t6;
            }
            else {
              if (!(e5 < 41)) throw "type:" + e5;
              switch (t6) {
                case 1:
                  return 14;
                case 2:
                  return 13;
                case 4:
                  return 16;
                case 8:
                  return 12;
                default:
                  throw "mode:" + t6;
              }
            }
          }, n3.getLostPoint = function(t6) {
            for (var e5 = t6.getModuleCount(), i5 = 0, r5 = 0; r5 < e5; r5 += 1) for (var n4 = 0; n4 < e5; n4 += 1) {
              for (var o3 = 0, s3 = t6.isDark(r5, n4), a3 = -1; a3 <= 1; a3 += 1) if (!(r5 + a3 < 0 || e5 <= r5 + a3)) for (var h3 = -1; h3 <= 1; h3 += 1) n4 + h3 < 0 || e5 <= n4 + h3 || 0 == a3 && 0 == h3 || s3 == t6.isDark(r5 + a3, n4 + h3) && (o3 += 1);
              o3 > 5 && (i5 += 3 + o3 - 5);
            }
            for (r5 = 0; r5 < e5 - 1; r5 += 1) for (n4 = 0; n4 < e5 - 1; n4 += 1) {
              var d3 = 0;
              t6.isDark(r5, n4) && (d3 += 1), t6.isDark(r5 + 1, n4) && (d3 += 1), t6.isDark(r5, n4 + 1) && (d3 += 1), t6.isDark(r5 + 1, n4 + 1) && (d3 += 1), 0 != d3 && 4 != d3 || (i5 += 3);
            }
            for (r5 = 0; r5 < e5; r5 += 1) for (n4 = 0; n4 < e5 - 6; n4 += 1) t6.isDark(r5, n4) && !t6.isDark(r5, n4 + 1) && t6.isDark(r5, n4 + 2) && t6.isDark(r5, n4 + 3) && t6.isDark(r5, n4 + 4) && !t6.isDark(r5, n4 + 5) && t6.isDark(r5, n4 + 6) && (i5 += 40);
            for (n4 = 0; n4 < e5; n4 += 1) for (r5 = 0; r5 < e5 - 6; r5 += 1) t6.isDark(r5, n4) && !t6.isDark(r5 + 1, n4) && t6.isDark(r5 + 2, n4) && t6.isDark(r5 + 3, n4) && t6.isDark(r5 + 4, n4) && !t6.isDark(r5 + 5, n4) && t6.isDark(r5 + 6, n4) && (i5 += 40);
            var u3 = 0;
            for (n4 = 0; n4 < e5; n4 += 1) for (r5 = 0; r5 < e5; r5 += 1) t6.isDark(r5, n4) && (u3 += 1);
            return i5 + Math.abs(100 * u3 / e5 / e5 - 50) / 5 * 10;
          }, n3), h2 = (function() {
            for (var t6 = new Array(256), e5 = new Array(256), i5 = 0; i5 < 8; i5 += 1) t6[i5] = 1 << i5;
            for (i5 = 8; i5 < 256; i5 += 1) t6[i5] = t6[i5 - 4] ^ t6[i5 - 5] ^ t6[i5 - 6] ^ t6[i5 - 8];
            for (i5 = 0; i5 < 255; i5 += 1) e5[t6[i5]] = i5;
            return { glog: function(t7) {
              if (t7 < 1) throw "glog(" + t7 + ")";
              return e5[t7];
            }, gexp: function(e6) {
              for (; e6 < 0; ) e6 += 255;
              for (; e6 >= 256; ) e6 -= 255;
              return t6[e6];
            } };
          })();
          function d2(t6, e5) {
            if (void 0 === t6.length) throw t6.length + "/" + e5;
            var i5 = (function() {
              for (var i6 = 0; i6 < t6.length && 0 == t6[i6]; ) i6 += 1;
              for (var r6 = new Array(t6.length - i6 + e5), n4 = 0; n4 < t6.length - i6; n4 += 1) r6[n4] = t6[n4 + i6];
              return r6;
            })(), r5 = { getAt: function(t7) {
              return i5[t7];
            }, getLength: function() {
              return i5.length;
            }, multiply: function(t7) {
              for (var e6 = new Array(r5.getLength() + t7.getLength() - 1), i6 = 0; i6 < r5.getLength(); i6 += 1) for (var n4 = 0; n4 < t7.getLength(); n4 += 1) e6[i6 + n4] ^= h2.gexp(h2.glog(r5.getAt(i6)) + h2.glog(t7.getAt(n4)));
              return d2(e6, 0);
            }, mod: function(t7) {
              if (r5.getLength() - t7.getLength() < 0) return r5;
              for (var e6 = h2.glog(r5.getAt(0)) - h2.glog(t7.getAt(0)), i6 = new Array(r5.getLength()), n4 = 0; n4 < r5.getLength(); n4 += 1) i6[n4] = r5.getAt(n4);
              for (n4 = 0; n4 < t7.getLength(); n4 += 1) i6[n4] ^= h2.gexp(h2.glog(t7.getAt(n4)) + e6);
              return d2(i6, 0).mod(t7);
            } };
            return r5;
          }
          var u2 = /* @__PURE__ */ (function() {
            var t6 = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], e5 = function(t7, e6) {
              var i6 = {};
              return i6.totalCount = t7, i6.dataCount = e6, i6;
            }, i5 = { getRSBlocks: function(i6, r5) {
              var n4 = (function(e6, i7) {
                switch (i7) {
                  case s2.L:
                    return t6[4 * (e6 - 1) + 0];
                  case s2.M:
                    return t6[4 * (e6 - 1) + 1];
                  case s2.Q:
                    return t6[4 * (e6 - 1) + 2];
                  case s2.H:
                    return t6[4 * (e6 - 1) + 3];
                  default:
                    return;
                }
              })(i6, r5);
              if (void 0 === n4) throw "bad rs block @ typeNumber:" + i6 + "/errorCorrectionLevel:" + r5;
              for (var o3 = n4.length / 3, a3 = [], h3 = 0; h3 < o3; h3 += 1) for (var d3 = n4[3 * h3 + 0], u3 = n4[3 * h3 + 1], c3 = n4[3 * h3 + 2], l3 = 0; l3 < d3; l3 += 1) a3.push(e5(u3, c3));
              return a3;
            } };
            return i5;
          })(), c2 = function() {
            var t6 = [], e5 = 0, i5 = { getBuffer: function() {
              return t6;
            }, getAt: function(e6) {
              var i6 = Math.floor(e6 / 8);
              return 1 == (t6[i6] >>> 7 - e6 % 8 & 1);
            }, put: function(t7, e6) {
              for (var r5 = 0; r5 < e6; r5 += 1) i5.putBit(1 == (t7 >>> e6 - r5 - 1 & 1));
            }, getLengthInBits: function() {
              return e5;
            }, putBit: function(i6) {
              var r5 = Math.floor(e5 / 8);
              t6.length <= r5 && t6.push(0), i6 && (t6[r5] |= 128 >>> e5 % 8), e5 += 1;
            } };
            return i5;
          }, l2 = function(t6) {
            var e5 = t6, i5 = { getMode: function() {
              return 1;
            }, getLength: function(t7) {
              return e5.length;
            }, write: function(t7) {
              for (var i6 = e5, n5 = 0; n5 + 2 < i6.length; ) t7.put(r5(i6.substring(n5, n5 + 3)), 10), n5 += 3;
              n5 < i6.length && (i6.length - n5 == 1 ? t7.put(r5(i6.substring(n5, n5 + 1)), 4) : i6.length - n5 == 2 && t7.put(r5(i6.substring(n5, n5 + 2)), 7));
            } }, r5 = function(t7) {
              for (var e6 = 0, i6 = 0; i6 < t7.length; i6 += 1) e6 = 10 * e6 + n4(t7.charAt(i6));
              return e6;
            }, n4 = function(t7) {
              if ("0" <= t7 && t7 <= "9") return t7.charCodeAt(0) - "0".charCodeAt(0);
              throw "illegal char :" + t7;
            };
            return i5;
          }, g2 = function(t6) {
            var e5 = t6, i5 = { getMode: function() {
              return 2;
            }, getLength: function(t7) {
              return e5.length;
            }, write: function(t7) {
              for (var i6 = e5, n4 = 0; n4 + 1 < i6.length; ) t7.put(45 * r5(i6.charAt(n4)) + r5(i6.charAt(n4 + 1)), 11), n4 += 2;
              n4 < i6.length && t7.put(r5(i6.charAt(n4)), 6);
            } }, r5 = function(t7) {
              if ("0" <= t7 && t7 <= "9") return t7.charCodeAt(0) - "0".charCodeAt(0);
              if ("A" <= t7 && t7 <= "Z") return t7.charCodeAt(0) - "A".charCodeAt(0) + 10;
              switch (t7) {
                case " ":
                  return 36;
                case "$":
                  return 37;
                case "%":
                  return 38;
                case "*":
                  return 39;
                case "+":
                  return 40;
                case "-":
                  return 41;
                case ".":
                  return 42;
                case "/":
                  return 43;
                case ":":
                  return 44;
                default:
                  throw "illegal char :" + t7;
              }
            };
            return i5;
          }, f2 = function(e5) {
            var i5 = t5.stringToBytes(e5);
            return { getMode: function() {
              return 4;
            }, getLength: function(t6) {
              return i5.length;
            }, write: function(t6) {
              for (var e6 = 0; e6 < i5.length; e6 += 1) t6.put(i5[e6], 8);
            } };
          }, w2 = function(e5) {
            var i5 = t5.stringToBytesFuncs.SJIS;
            if (!i5) throw "sjis not supported.";
            !(function() {
              var t6 = i5("å");
              if (2 != t6.length || 38726 != (t6[0] << 8 | t6[1])) throw "sjis not supported.";
            })();
            var r5 = i5(e5), n4 = { getMode: function() {
              return 8;
            }, getLength: function(t6) {
              return ~~(r5.length / 2);
            }, write: function(t6) {
              for (var e6 = r5, i6 = 0; i6 + 1 < e6.length; ) {
                var n5 = (255 & e6[i6]) << 8 | 255 & e6[i6 + 1];
                if (33088 <= n5 && n5 <= 40956) n5 -= 33088;
                else {
                  if (!(57408 <= n5 && n5 <= 60351)) throw "illegal char at " + (i6 + 1) + "/" + n5;
                  n5 -= 49472;
                }
                n5 = 192 * (n5 >>> 8 & 255) + (255 & n5), t6.put(n5, 13), i6 += 2;
              }
              if (i6 < e6.length) throw "illegal char at " + (i6 + 1);
            } };
            return n4;
          }, p2 = function() {
            var t6 = [], e5 = { writeByte: function(e6) {
              t6.push(255 & e6);
            }, writeShort: function(t7) {
              e5.writeByte(t7), e5.writeByte(t7 >>> 8);
            }, writeBytes: function(t7, i5, r5) {
              i5 = i5 || 0, r5 = r5 || t7.length;
              for (var n4 = 0; n4 < r5; n4 += 1) e5.writeByte(t7[n4 + i5]);
            }, writeString: function(t7) {
              for (var i5 = 0; i5 < t7.length; i5 += 1) e5.writeByte(t7.charCodeAt(i5));
            }, toByteArray: function() {
              return t6;
            }, toString: function() {
              var e6 = "";
              e6 += "[";
              for (var i5 = 0; i5 < t6.length; i5 += 1) i5 > 0 && (e6 += ","), e6 += t6[i5];
              return e6 + "]";
            } };
            return e5;
          }, v2 = function(t6) {
            var e5 = t6, i5 = 0, r5 = 0, n4 = 0, o3 = { read: function() {
              for (; n4 < 8; ) {
                if (i5 >= e5.length) {
                  if (0 == n4) return -1;
                  throw "unexpected end of file./" + n4;
                }
                var t7 = e5.charAt(i5);
                if (i5 += 1, "=" == t7) return n4 = 0, -1;
                t7.match(/^\s$/) || (r5 = r5 << 6 | s3(t7.charCodeAt(0)), n4 += 6);
              }
              var o4 = r5 >>> n4 - 8 & 255;
              return n4 -= 8, o4;
            } }, s3 = function(t7) {
              if (65 <= t7 && t7 <= 90) return t7 - 65;
              if (97 <= t7 && t7 <= 122) return t7 - 97 + 26;
              if (48 <= t7 && t7 <= 57) return t7 - 48 + 52;
              if (43 == t7) return 62;
              if (47 == t7) return 63;
              throw "c:" + t7;
            };
            return o3;
          }, _2 = function(t6, e5, i5) {
            for (var r5 = (function(t7, e6) {
              var i6 = t7, r6 = e6, n5 = new Array(t7 * e6), o4 = { setPixel: function(t8, e7, r7) {
                n5[e7 * i6 + t8] = r7;
              }, write: function(t8) {
                t8.writeString("GIF87a"), t8.writeShort(i6), t8.writeShort(r6), t8.writeByte(128), t8.writeByte(0), t8.writeByte(0), t8.writeByte(0), t8.writeByte(0), t8.writeByte(0), t8.writeByte(255), t8.writeByte(255), t8.writeByte(255), t8.writeString(","), t8.writeShort(0), t8.writeShort(0), t8.writeShort(i6), t8.writeShort(r6), t8.writeByte(0);
                var e7 = s4(2);
                t8.writeByte(2);
                for (var n6 = 0; e7.length - n6 > 255; ) t8.writeByte(255), t8.writeBytes(e7, n6, 255), n6 += 255;
                t8.writeByte(e7.length - n6), t8.writeBytes(e7, n6, e7.length - n6), t8.writeByte(0), t8.writeString(";");
              } }, s4 = function(t8) {
                for (var e7 = 1 << t8, i7 = 1 + (1 << t8), r7 = t8 + 1, o5 = a4(), s5 = 0; s5 < e7; s5 += 1) o5.add(String.fromCharCode(s5));
                o5.add(String.fromCharCode(e7)), o5.add(String.fromCharCode(i7));
                var h4, d4, u3, c3 = p2(), l3 = (h4 = c3, d4 = 0, u3 = 0, { write: function(t9, e8) {
                  if (t9 >>> e8 != 0) throw "length over";
                  for (; d4 + e8 >= 8; ) h4.writeByte(255 & (t9 << d4 | u3)), e8 -= 8 - d4, t9 >>>= 8 - d4, u3 = 0, d4 = 0;
                  u3 |= t9 << d4, d4 += e8;
                }, flush: function() {
                  d4 > 0 && h4.writeByte(u3);
                } });
                l3.write(e7, r7);
                var g3 = 0, f3 = String.fromCharCode(n5[g3]);
                for (g3 += 1; g3 < n5.length; ) {
                  var w3 = String.fromCharCode(n5[g3]);
                  g3 += 1, o5.contains(f3 + w3) ? f3 += w3 : (l3.write(o5.indexOf(f3), r7), o5.size() < 4095 && (o5.size() == 1 << r7 && (r7 += 1), o5.add(f3 + w3)), f3 = w3);
                }
                return l3.write(o5.indexOf(f3), r7), l3.write(i7, r7), l3.flush(), c3.toByteArray();
              }, a4 = function() {
                var t8 = {}, e7 = 0, i7 = { add: function(r7) {
                  if (i7.contains(r7)) throw "dup key:" + r7;
                  t8[r7] = e7, e7 += 1;
                }, size: function() {
                  return e7;
                }, indexOf: function(e8) {
                  return t8[e8];
                }, contains: function(e8) {
                  return void 0 !== t8[e8];
                } };
                return i7;
              };
              return o4;
            })(t6, e5), n4 = 0; n4 < e5; n4 += 1) for (var o3 = 0; o3 < t6; o3 += 1) r5.setPixel(o3, n4, i5(o3, n4));
            var s3 = p2();
            r5.write(s3);
            for (var a3 = (function() {
              var t7 = 0, e6 = 0, i6 = 0, r6 = "", n5 = {}, o4 = function(t8) {
                r6 += String.fromCharCode(s4(63 & t8));
              }, s4 = function(t8) {
                if (t8 < 0) ;
                else {
                  if (t8 < 26) return 65 + t8;
                  if (t8 < 52) return t8 - 26 + 97;
                  if (t8 < 62) return t8 - 52 + 48;
                  if (62 == t8) return 43;
                  if (63 == t8) return 47;
                }
                throw "n:" + t8;
              };
              return n5.writeByte = function(r7) {
                for (t7 = t7 << 8 | 255 & r7, e6 += 8, i6 += 1; e6 >= 6; ) o4(t7 >>> e6 - 6), e6 -= 6;
              }, n5.flush = function() {
                if (e6 > 0 && (o4(t7 << 6 - e6), t7 = 0, e6 = 0), i6 % 3 != 0) for (var n6 = 3 - i6 % 3, s5 = 0; s5 < n6; s5 += 1) r6 += "=";
              }, n5.toString = function() {
                return r6;
              }, n5;
            })(), h3 = s3.toByteArray(), d3 = 0; d3 < h3.length; d3 += 1) a3.writeByte(h3[d3]);
            return a3.flush(), "data:image/gif;base64," + a3;
          };
          return t5;
        })();
        n2.stringToBytesFuncs["UTF-8"] = function(t5) {
          return (function(t6) {
            for (var e4 = [], i4 = 0; i4 < t6.length; i4++) {
              var r4 = t6.charCodeAt(i4);
              r4 < 128 ? e4.push(r4) : r4 < 2048 ? e4.push(192 | r4 >> 6, 128 | 63 & r4) : r4 < 55296 || r4 >= 57344 ? e4.push(224 | r4 >> 12, 128 | r4 >> 6 & 63, 128 | 63 & r4) : (i4++, r4 = 65536 + ((1023 & r4) << 10 | 1023 & t6.charCodeAt(i4)), e4.push(240 | r4 >> 18, 128 | r4 >> 12 & 63, 128 | r4 >> 6 & 63, 128 | 63 & r4));
            }
            return e4;
          })(t5);
        }, void 0 === (r3 = "function" == typeof (i3 = function() {
          return n2;
        }) ? i3.apply(e3, []) : i3) || (t4.exports = r3);
      } }, e2 = {};
      function i2(r3) {
        var n2 = e2[r3];
        if (void 0 !== n2) return n2.exports;
        var o2 = e2[r3] = { exports: {} };
        return t3[r3](o2, o2.exports, i2), o2.exports;
      }
      i2.n = (t4) => {
        var e3 = t4 && t4.__esModule ? () => t4.default : () => t4;
        return i2.d(e3, { a: e3 }), e3;
      }, i2.d = (t4, e3) => {
        for (var r3 in e3) i2.o(e3, r3) && !i2.o(t4, r3) && Object.defineProperty(t4, r3, { enumerable: true, get: e3[r3] });
      }, i2.o = (t4, e3) => Object.prototype.hasOwnProperty.call(t4, e3);
      var r2 = {};
      return (() => {
        i2.d(r2, { default: () => $2 });
        const t4 = (t5) => !!t5 && "object" == typeof t5 && !Array.isArray(t5);
        function e3(i3, ...r3) {
          if (!r3.length) return i3;
          const n3 = r3.shift();
          return void 0 !== n3 && t4(i3) && t4(n3) ? (i3 = Object.assign({}, i3), Object.keys(n3).forEach(((r4) => {
            const o3 = i3[r4], s3 = n3[r4];
            Array.isArray(o3) && Array.isArray(s3) ? i3[r4] = s3 : t4(o3) && t4(s3) ? i3[r4] = e3(Object.assign({}, o3), s3) : i3[r4] = s3;
          })), e3(i3, ...r3)) : i3;
        }
        function n2(t5, e4) {
          const i3 = document.createElement("a");
          i3.download = e4, i3.href = t5, document.body.appendChild(i3), i3.click(), document.body.removeChild(i3);
        }
        const o2 = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
        class s2 {
          constructor({ svg: t5, type: e4, window: i3 }) {
            this._svg = t5, this._type = e4, this._window = i3;
          }
          draw(t5, e4, i3, r3) {
            let n3;
            switch (this._type) {
              case "dots":
                n3 = this._drawDot;
                break;
              case "classy":
                n3 = this._drawClassy;
                break;
              case "classy-rounded":
                n3 = this._drawClassyRounded;
                break;
              case "rounded":
                n3 = this._drawRounded;
                break;
              case "extra-rounded":
                n3 = this._drawExtraRounded;
                break;
              default:
                n3 = this._drawSquare;
            }
            n3.call(this, { x: t5, y: e4, size: i3, getNeighbor: r3 });
          }
          _rotateFigure({ x: t5, y: e4, size: i3, rotation: r3 = 0, draw: n3 }) {
            var o3;
            const s3 = t5 + i3 / 2, a3 = e4 + i3 / 2;
            n3(), null === (o3 = this._element) || void 0 === o3 || o3.setAttribute("transform", `rotate(${180 * r3 / Math.PI},${s3},${a3})`);
          }
          _basicDot(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(i3 + e4 / 2)), this._element.setAttribute("cy", String(r3 + e4 / 2)), this._element.setAttribute("r", String(e4 / 2));
            } }));
          }
          _basicSquare(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(i3)), this._element.setAttribute("y", String(r3)), this._element.setAttribute("width", String(e4)), this._element.setAttribute("height", String(e4));
            } }));
          }
          _basicSideRounded(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${i3} ${r3}v ${e4}h ` + e4 / 2 + `a ${e4 / 2} ${e4 / 2}, 0, 0, 0, 0 ${-e4}`);
            } }));
          }
          _basicCornerRounded(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${i3} ${r3}v ${e4}h ${e4}v ` + -e4 / 2 + `a ${e4 / 2} ${e4 / 2}, 0, 0, 0, ${-e4 / 2} ${-e4 / 2}`);
            } }));
          }
          _basicCornerExtraRounded(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${i3} ${r3}v ${e4}h ${e4}a ${e4} ${e4}, 0, 0, 0, ${-e4} ${-e4}`);
            } }));
          }
          _basicCornersRounded(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${i3} ${r3}v ` + e4 / 2 + `a ${e4 / 2} ${e4 / 2}, 0, 0, 0, ${e4 / 2} ${e4 / 2}h ` + e4 / 2 + "v " + -e4 / 2 + `a ${e4 / 2} ${e4 / 2}, 0, 0, 0, ${-e4 / 2} ${-e4 / 2}`);
            } }));
          }
          _drawDot({ x: t5, y: e4, size: i3 }) {
            this._basicDot({ x: t5, y: e4, size: i3, rotation: 0 });
          }
          _drawSquare({ x: t5, y: e4, size: i3 }) {
            this._basicSquare({ x: t5, y: e4, size: i3, rotation: 0 });
          }
          _drawRounded({ x: t5, y: e4, size: i3, getNeighbor: r3 }) {
            const n3 = r3 ? +r3(-1, 0) : 0, o3 = r3 ? +r3(1, 0) : 0, s3 = r3 ? +r3(0, -1) : 0, a3 = r3 ? +r3(0, 1) : 0, h3 = n3 + o3 + s3 + a3;
            if (0 !== h3) if (h3 > 2 || n3 && o3 || s3 && a3) this._basicSquare({ x: t5, y: e4, size: i3, rotation: 0 });
            else {
              if (2 === h3) {
                let r4 = 0;
                return n3 && s3 ? r4 = Math.PI / 2 : s3 && o3 ? r4 = Math.PI : o3 && a3 && (r4 = -Math.PI / 2), void this._basicCornerRounded({ x: t5, y: e4, size: i3, rotation: r4 });
              }
              if (1 === h3) {
                let r4 = 0;
                return s3 ? r4 = Math.PI / 2 : o3 ? r4 = Math.PI : a3 && (r4 = -Math.PI / 2), void this._basicSideRounded({ x: t5, y: e4, size: i3, rotation: r4 });
              }
            }
            else this._basicDot({ x: t5, y: e4, size: i3, rotation: 0 });
          }
          _drawExtraRounded({ x: t5, y: e4, size: i3, getNeighbor: r3 }) {
            const n3 = r3 ? +r3(-1, 0) : 0, o3 = r3 ? +r3(1, 0) : 0, s3 = r3 ? +r3(0, -1) : 0, a3 = r3 ? +r3(0, 1) : 0, h3 = n3 + o3 + s3 + a3;
            if (0 !== h3) if (h3 > 2 || n3 && o3 || s3 && a3) this._basicSquare({ x: t5, y: e4, size: i3, rotation: 0 });
            else {
              if (2 === h3) {
                let r4 = 0;
                return n3 && s3 ? r4 = Math.PI / 2 : s3 && o3 ? r4 = Math.PI : o3 && a3 && (r4 = -Math.PI / 2), void this._basicCornerExtraRounded({ x: t5, y: e4, size: i3, rotation: r4 });
              }
              if (1 === h3) {
                let r4 = 0;
                return s3 ? r4 = Math.PI / 2 : o3 ? r4 = Math.PI : a3 && (r4 = -Math.PI / 2), void this._basicSideRounded({ x: t5, y: e4, size: i3, rotation: r4 });
              }
            }
            else this._basicDot({ x: t5, y: e4, size: i3, rotation: 0 });
          }
          _drawClassy({ x: t5, y: e4, size: i3, getNeighbor: r3 }) {
            const n3 = r3 ? +r3(-1, 0) : 0, o3 = r3 ? +r3(1, 0) : 0, s3 = r3 ? +r3(0, -1) : 0, a3 = r3 ? +r3(0, 1) : 0;
            0 !== n3 + o3 + s3 + a3 ? n3 || s3 ? o3 || a3 ? this._basicSquare({ x: t5, y: e4, size: i3, rotation: 0 }) : this._basicCornerRounded({ x: t5, y: e4, size: i3, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: t5, y: e4, size: i3, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: t5, y: e4, size: i3, rotation: Math.PI / 2 });
          }
          _drawClassyRounded({ x: t5, y: e4, size: i3, getNeighbor: r3 }) {
            const n3 = r3 ? +r3(-1, 0) : 0, o3 = r3 ? +r3(1, 0) : 0, s3 = r3 ? +r3(0, -1) : 0, a3 = r3 ? +r3(0, 1) : 0;
            0 !== n3 + o3 + s3 + a3 ? n3 || s3 ? o3 || a3 ? this._basicSquare({ x: t5, y: e4, size: i3, rotation: 0 }) : this._basicCornerExtraRounded({ x: t5, y: e4, size: i3, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: t5, y: e4, size: i3, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: t5, y: e4, size: i3, rotation: Math.PI / 2 });
          }
        }
        const a2 = { dot: "dot", square: "square", extraRounded: "extra-rounded" }, h2 = Object.values(a2);
        class d2 {
          constructor({ svg: t5, type: e4, window: i3 }) {
            this._svg = t5, this._type = e4, this._window = i3;
          }
          draw(t5, e4, i3, r3) {
            let n3;
            switch (this._type) {
              case a2.square:
                n3 = this._drawSquare;
                break;
              case a2.extraRounded:
                n3 = this._drawExtraRounded;
                break;
              default:
                n3 = this._drawDot;
            }
            n3.call(this, { x: t5, y: e4, size: i3, rotation: r3 });
          }
          _rotateFigure({ x: t5, y: e4, size: i3, rotation: r3 = 0, draw: n3 }) {
            var o3;
            const s3 = t5 + i3 / 2, a3 = e4 + i3 / 2;
            n3(), null === (o3 = this._element) || void 0 === o3 || o3.setAttribute("transform", `rotate(${180 * r3 / Math.PI},${s3},${a3})`);
          }
          _basicDot(t5) {
            const { size: e4, x: i3, y: r3 } = t5, n3 = e4 / 7;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${i3 + e4 / 2} ${r3}a ${e4 / 2} ${e4 / 2} 0 1 0 0.1 0zm 0 ${n3}a ${e4 / 2 - n3} ${e4 / 2 - n3} 0 1 1 -0.1 0Z`);
            } }));
          }
          _basicSquare(t5) {
            const { size: e4, x: i3, y: r3 } = t5, n3 = e4 / 7;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${i3} ${r3}v ${e4}h ${e4}v ` + -e4 + `zM ${i3 + n3} ${r3 + n3}h ` + (e4 - 2 * n3) + "v " + (e4 - 2 * n3) + "h " + (2 * n3 - e4) + "z");
            } }));
          }
          _basicExtraRounded(t5) {
            const { size: e4, x: i3, y: r3 } = t5, n3 = e4 / 7;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${i3} ${r3 + 2.5 * n3}v ` + 2 * n3 + `a ${2.5 * n3} ${2.5 * n3}, 0, 0, 0, ${2.5 * n3} ${2.5 * n3}h ` + 2 * n3 + `a ${2.5 * n3} ${2.5 * n3}, 0, 0, 0, ${2.5 * n3} ${2.5 * -n3}v ` + -2 * n3 + `a ${2.5 * n3} ${2.5 * n3}, 0, 0, 0, ${2.5 * -n3} ${2.5 * -n3}h ` + -2 * n3 + `a ${2.5 * n3} ${2.5 * n3}, 0, 0, 0, ${2.5 * -n3} ${2.5 * n3}M ${i3 + 2.5 * n3} ${r3 + n3}h ` + 2 * n3 + `a ${1.5 * n3} ${1.5 * n3}, 0, 0, 1, ${1.5 * n3} ${1.5 * n3}v ` + 2 * n3 + `a ${1.5 * n3} ${1.5 * n3}, 0, 0, 1, ${1.5 * -n3} ${1.5 * n3}h ` + -2 * n3 + `a ${1.5 * n3} ${1.5 * n3}, 0, 0, 1, ${1.5 * -n3} ${1.5 * -n3}v ` + -2 * n3 + `a ${1.5 * n3} ${1.5 * n3}, 0, 0, 1, ${1.5 * n3} ${1.5 * -n3}`);
            } }));
          }
          _drawDot({ x: t5, y: e4, size: i3, rotation: r3 }) {
            this._basicDot({ x: t5, y: e4, size: i3, rotation: r3 });
          }
          _drawSquare({ x: t5, y: e4, size: i3, rotation: r3 }) {
            this._basicSquare({ x: t5, y: e4, size: i3, rotation: r3 });
          }
          _drawExtraRounded({ x: t5, y: e4, size: i3, rotation: r3 }) {
            this._basicExtraRounded({ x: t5, y: e4, size: i3, rotation: r3 });
          }
        }
        const u2 = { dot: "dot", square: "square" }, c2 = Object.values(u2);
        class l2 {
          constructor({ svg: t5, type: e4, window: i3 }) {
            this._svg = t5, this._type = e4, this._window = i3;
          }
          draw(t5, e4, i3, r3) {
            let n3;
            n3 = this._type === u2.square ? this._drawSquare : this._drawDot, n3.call(this, { x: t5, y: e4, size: i3, rotation: r3 });
          }
          _rotateFigure({ x: t5, y: e4, size: i3, rotation: r3 = 0, draw: n3 }) {
            var o3;
            const s3 = t5 + i3 / 2, a3 = e4 + i3 / 2;
            n3(), null === (o3 = this._element) || void 0 === o3 || o3.setAttribute("transform", `rotate(${180 * r3 / Math.PI},${s3},${a3})`);
          }
          _basicDot(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(i3 + e4 / 2)), this._element.setAttribute("cy", String(r3 + e4 / 2)), this._element.setAttribute("r", String(e4 / 2));
            } }));
          }
          _basicSquare(t5) {
            const { size: e4, x: i3, y: r3 } = t5;
            this._rotateFigure(Object.assign(Object.assign({}, t5), { draw: () => {
              this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(i3)), this._element.setAttribute("y", String(r3)), this._element.setAttribute("width", String(e4)), this._element.setAttribute("height", String(e4));
            } }));
          }
          _drawDot({ x: t5, y: e4, size: i3, rotation: r3 }) {
            this._basicDot({ x: t5, y: e4, size: i3, rotation: r3 });
          }
          _drawSquare({ x: t5, y: e4, size: i3, rotation: r3 }) {
            this._basicSquare({ x: t5, y: e4, size: i3, rotation: r3 });
          }
        }
        const g2 = "circle", f2 = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], w2 = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
        class p2 {
          constructor(t5, e4) {
            this._roundSize = (t6) => this._options.dotsOptions.roundSize ? Math.floor(t6) : t6, this._window = e4, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(t5.width)), this._element.setAttribute("height", String(t5.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), t5.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${t5.width} ${t5.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = t5.image, this._instanceId = p2.instanceCount++, this._options = t5;
          }
          get width() {
            return this._options.width;
          }
          get height() {
            return this._options.height;
          }
          getElement() {
            return this._element;
          }
          async drawQR(t5) {
            const e4 = t5.getModuleCount(), i3 = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, r3 = this._options.shape === g2 ? i3 / Math.sqrt(2) : i3, n3 = this._roundSize(r3 / e4);
            let s3 = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
            if (this._qr = t5, this._options.image) {
              if (await this.loadImage(), !this._image) return;
              const { imageOptions: t6, qrOptions: i4 } = this._options, r4 = t6.imageSize * o2[i4.errorCorrectionLevel], a3 = Math.floor(r4 * e4 * e4);
              s3 = (function({ originalHeight: t7, originalWidth: e5, maxHiddenDots: i5, maxHiddenAxisDots: r5, dotSize: n4 }) {
                const o3 = { x: 0, y: 0 }, s4 = { x: 0, y: 0 };
                if (t7 <= 0 || e5 <= 0 || i5 <= 0 || n4 <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
                const a4 = t7 / e5;
                return o3.x = Math.floor(Math.sqrt(i5 / a4)), o3.x <= 0 && (o3.x = 1), r5 && r5 < o3.x && (o3.x = r5), o3.x % 2 == 0 && o3.x--, s4.x = o3.x * n4, o3.y = 1 + 2 * Math.ceil((o3.x * a4 - 1) / 2), s4.y = Math.round(s4.x * a4), (o3.y * o3.x > i5 || r5 && r5 < o3.y) && (r5 && r5 < o3.y ? (o3.y = r5, o3.y % 2 == 0 && o3.x--) : o3.y -= 2, s4.y = o3.y * n4, o3.x = 1 + 2 * Math.ceil((o3.y / a4 - 1) / 2), s4.x = Math.round(s4.y / a4)), { height: s4.y, width: s4.x, hideYDots: o3.y, hideXDots: o3.x };
              })({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: a3, maxHiddenAxisDots: e4 - 14, dotSize: n3 });
            }
            this.drawBackground(), this.drawDots(((t6, i4) => {
              var r4, n4, o3, a3, h3, d3;
              return !(this._options.imageOptions.hideBackgroundDots && t6 >= (e4 - s3.hideYDots) / 2 && t6 < (e4 + s3.hideYDots) / 2 && i4 >= (e4 - s3.hideXDots) / 2 && i4 < (e4 + s3.hideXDots) / 2 || (null === (r4 = f2[t6]) || void 0 === r4 ? void 0 : r4[i4]) || (null === (n4 = f2[t6 - e4 + 7]) || void 0 === n4 ? void 0 : n4[i4]) || (null === (o3 = f2[t6]) || void 0 === o3 ? void 0 : o3[i4 - e4 + 7]) || (null === (a3 = w2[t6]) || void 0 === a3 ? void 0 : a3[i4]) || (null === (h3 = w2[t6 - e4 + 7]) || void 0 === h3 ? void 0 : h3[i4]) || (null === (d3 = w2[t6]) || void 0 === d3 ? void 0 : d3[i4 - e4 + 7]));
            })), this.drawCorners(), this._options.image && await this.drawImage({ width: s3.width, height: s3.height, count: e4, dotSize: n3 });
          }
          drawBackground() {
            var t5, e4, i3;
            const r3 = this._element, n3 = this._options;
            if (r3) {
              const r4 = null === (t5 = n3.backgroundOptions) || void 0 === t5 ? void 0 : t5.gradient, o3 = null === (e4 = n3.backgroundOptions) || void 0 === e4 ? void 0 : e4.color;
              let s3 = n3.height, a3 = n3.width;
              if (r4 || o3) {
                const t6 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), (null === (i3 = n3.backgroundOptions) || void 0 === i3 ? void 0 : i3.round) && (s3 = a3 = Math.min(n3.width, n3.height), t6.setAttribute("rx", String(s3 / 2 * n3.backgroundOptions.round))), t6.setAttribute("x", String(this._roundSize((n3.width - a3) / 2))), t6.setAttribute("y", String(this._roundSize((n3.height - s3) / 2))), t6.setAttribute("width", String(a3)), t6.setAttribute("height", String(s3)), this._backgroundClipPath.appendChild(t6), this._createColor({ options: r4, color: o3, additionalRotation: 0, x: 0, y: 0, height: n3.height, width: n3.width, name: `background-color-${this._instanceId}` });
              }
            }
          }
          drawDots(t5) {
            var e4, i3;
            if (!this._qr) throw "QR code is not defined";
            const r3 = this._options, n3 = this._qr.getModuleCount();
            if (n3 > r3.width || n3 > r3.height) throw "The canvas is too small.";
            const o3 = Math.min(r3.width, r3.height) - 2 * r3.margin, a3 = r3.shape === g2 ? o3 / Math.sqrt(2) : o3, h3 = this._roundSize(a3 / n3), d3 = this._roundSize((r3.width - n3 * h3) / 2), u3 = this._roundSize((r3.height - n3 * h3) / 2), c3 = new s2({ svg: this._element, type: r3.dotsOptions.type, window: this._window });
            this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: null === (e4 = r3.dotsOptions) || void 0 === e4 ? void 0 : e4.gradient, color: r3.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: r3.height, width: r3.width, name: `dot-color-${this._instanceId}` });
            for (let e5 = 0; e5 < n3; e5++) for (let r4 = 0; r4 < n3; r4++) t5 && !t5(e5, r4) || (null === (i3 = this._qr) || void 0 === i3 ? void 0 : i3.isDark(e5, r4)) && (c3.draw(d3 + r4 * h3, u3 + e5 * h3, h3, ((i4, o4) => !(r4 + i4 < 0 || e5 + o4 < 0 || r4 + i4 >= n3 || e5 + o4 >= n3) && !(t5 && !t5(e5 + o4, r4 + i4)) && !!this._qr && this._qr.isDark(e5 + o4, r4 + i4))), c3._element && this._dotsClipPath && this._dotsClipPath.appendChild(c3._element));
            if (r3.shape === g2) {
              const t6 = this._roundSize((o3 / h3 - n3) / 2), e5 = n3 + 2 * t6, i4 = d3 - t6 * h3, r4 = u3 - t6 * h3, s3 = [], a4 = this._roundSize(e5 / 2);
              for (let i5 = 0; i5 < e5; i5++) {
                s3[i5] = [];
                for (let r5 = 0; r5 < e5; r5++) i5 >= t6 - 1 && i5 <= e5 - t6 && r5 >= t6 - 1 && r5 <= e5 - t6 || Math.sqrt((i5 - a4) * (i5 - a4) + (r5 - a4) * (r5 - a4)) > a4 ? s3[i5][r5] = 0 : s3[i5][r5] = this._qr.isDark(r5 - 2 * t6 < 0 ? r5 : r5 >= n3 ? r5 - 2 * t6 : r5 - t6, i5 - 2 * t6 < 0 ? i5 : i5 >= n3 ? i5 - 2 * t6 : i5 - t6) ? 1 : 0;
              }
              for (let t7 = 0; t7 < e5; t7++) for (let n4 = 0; n4 < e5; n4++) s3[t7][n4] && (c3.draw(i4 + n4 * h3, r4 + t7 * h3, h3, ((e6, i5) => {
                var r5;
                return !!(null === (r5 = s3[t7 + i5]) || void 0 === r5 ? void 0 : r5[n4 + e6]);
              })), c3._element && this._dotsClipPath && this._dotsClipPath.appendChild(c3._element));
            }
          }
          drawCorners() {
            if (!this._qr) throw "QR code is not defined";
            const t5 = this._element, e4 = this._options;
            if (!t5) throw "Element code is not defined";
            const i3 = this._qr.getModuleCount(), r3 = Math.min(e4.width, e4.height) - 2 * e4.margin, n3 = e4.shape === g2 ? r3 / Math.sqrt(2) : r3, o3 = this._roundSize(n3 / i3), a3 = 7 * o3, u3 = 3 * o3, p3 = this._roundSize((e4.width - i3 * o3) / 2), v3 = this._roundSize((e4.height - i3 * o3) / 2);
            [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach((([t6, r4, n4]) => {
              var g3, _3, m3, b3, y3, x3, S3, C3, A3, M3, $3, O2, D2, k2;
              const z2 = p3 + t6 * o3 * (i3 - 7), B3 = v3 + r4 * o3 * (i3 - 7);
              let P2 = this._dotsClipPath, I2 = this._dotsClipPath;
              if (((null === (g3 = e4.cornersSquareOptions) || void 0 === g3 ? void 0 : g3.gradient) || (null === (_3 = e4.cornersSquareOptions) || void 0 === _3 ? void 0 : _3.color)) && (P2 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), P2.setAttribute("id", `clip-path-corners-square-color-${t6}-${r4}-${this._instanceId}`), this._defs.appendChild(P2), this._cornersSquareClipPath = this._cornersDotClipPath = I2 = P2, this._createColor({ options: null === (m3 = e4.cornersSquareOptions) || void 0 === m3 ? void 0 : m3.gradient, color: null === (b3 = e4.cornersSquareOptions) || void 0 === b3 ? void 0 : b3.color, additionalRotation: n4, x: z2, y: B3, height: a3, width: a3, name: `corners-square-color-${t6}-${r4}-${this._instanceId}` })), (null === (y3 = e4.cornersSquareOptions) || void 0 === y3 ? void 0 : y3.type) && h2.includes(e4.cornersSquareOptions.type)) {
                const t7 = new d2({ svg: this._element, type: e4.cornersSquareOptions.type, window: this._window });
                t7.draw(z2, B3, a3, n4), t7._element && P2 && P2.appendChild(t7._element);
              } else {
                const t7 = new s2({ svg: this._element, type: (null === (x3 = e4.cornersSquareOptions) || void 0 === x3 ? void 0 : x3.type) || e4.dotsOptions.type, window: this._window });
                for (let e5 = 0; e5 < f2.length; e5++) for (let i4 = 0; i4 < f2[e5].length; i4++) (null === (S3 = f2[e5]) || void 0 === S3 ? void 0 : S3[i4]) && (t7.draw(z2 + i4 * o3, B3 + e5 * o3, o3, ((t8, r5) => {
                  var n5;
                  return !!(null === (n5 = f2[e5 + r5]) || void 0 === n5 ? void 0 : n5[i4 + t8]);
                })), t7._element && P2 && P2.appendChild(t7._element));
              }
              if (((null === (C3 = e4.cornersDotOptions) || void 0 === C3 ? void 0 : C3.gradient) || (null === (A3 = e4.cornersDotOptions) || void 0 === A3 ? void 0 : A3.color)) && (I2 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), I2.setAttribute("id", `clip-path-corners-dot-color-${t6}-${r4}-${this._instanceId}`), this._defs.appendChild(I2), this._cornersDotClipPath = I2, this._createColor({ options: null === (M3 = e4.cornersDotOptions) || void 0 === M3 ? void 0 : M3.gradient, color: null === ($3 = e4.cornersDotOptions) || void 0 === $3 ? void 0 : $3.color, additionalRotation: n4, x: z2 + 2 * o3, y: B3 + 2 * o3, height: u3, width: u3, name: `corners-dot-color-${t6}-${r4}-${this._instanceId}` })), (null === (O2 = e4.cornersDotOptions) || void 0 === O2 ? void 0 : O2.type) && c2.includes(e4.cornersDotOptions.type)) {
                const t7 = new l2({ svg: this._element, type: e4.cornersDotOptions.type, window: this._window });
                t7.draw(z2 + 2 * o3, B3 + 2 * o3, u3, n4), t7._element && I2 && I2.appendChild(t7._element);
              } else {
                const t7 = new s2({ svg: this._element, type: (null === (D2 = e4.cornersDotOptions) || void 0 === D2 ? void 0 : D2.type) || e4.dotsOptions.type, window: this._window });
                for (let e5 = 0; e5 < w2.length; e5++) for (let i4 = 0; i4 < w2[e5].length; i4++) (null === (k2 = w2[e5]) || void 0 === k2 ? void 0 : k2[i4]) && (t7.draw(z2 + i4 * o3, B3 + e5 * o3, o3, ((t8, r5) => {
                  var n5;
                  return !!(null === (n5 = w2[e5 + r5]) || void 0 === n5 ? void 0 : n5[i4 + t8]);
                })), t7._element && I2 && I2.appendChild(t7._element));
              }
            }));
          }
          loadImage() {
            return new Promise(((t5, e4) => {
              var i3;
              const r3 = this._options;
              if (!r3.image) return e4("Image is not defined");
              if (null === (i3 = r3.nodeCanvas) || void 0 === i3 ? void 0 : i3.loadImage) r3.nodeCanvas.loadImage(r3.image).then(((e5) => {
                var i4, n3;
                if (this._image = e5, this._options.imageOptions.saveAsBlob) {
                  const t6 = null === (i4 = r3.nodeCanvas) || void 0 === i4 ? void 0 : i4.createCanvas(this._image.width, this._image.height);
                  null === (n3 = null == t6 ? void 0 : t6.getContext("2d")) || void 0 === n3 || n3.drawImage(e5, 0, 0), this._imageUri = null == t6 ? void 0 : t6.toDataURL();
                }
                t5();
              })).catch(e4);
              else {
                const e5 = new this._window.Image();
                "string" == typeof r3.imageOptions.crossOrigin && (e5.crossOrigin = r3.imageOptions.crossOrigin), this._image = e5, e5.onload = async () => {
                  this._options.imageOptions.saveAsBlob && (this._imageUri = await (async function(t6, e6) {
                    return new Promise(((i4) => {
                      const r4 = new e6.XMLHttpRequest();
                      r4.onload = function() {
                        const t7 = new e6.FileReader();
                        t7.onloadend = function() {
                          i4(t7.result);
                        }, t7.readAsDataURL(r4.response);
                      }, r4.open("GET", t6), r4.responseType = "blob", r4.send();
                    }));
                  })(r3.image || "", this._window)), t5();
                }, e5.src = r3.image;
              }
            }));
          }
          async drawImage({ width: t5, height: e4, count: i3, dotSize: r3 }) {
            const n3 = this._options, o3 = this._roundSize((n3.width - i3 * r3) / 2), s3 = this._roundSize((n3.height - i3 * r3) / 2), a3 = o3 + this._roundSize(n3.imageOptions.margin + (i3 * r3 - t5) / 2), h3 = s3 + this._roundSize(n3.imageOptions.margin + (i3 * r3 - e4) / 2), d3 = t5 - 2 * n3.imageOptions.margin, u3 = e4 - 2 * n3.imageOptions.margin, c3 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
            c3.setAttribute("href", this._imageUri || ""), c3.setAttribute("xlink:href", this._imageUri || ""), c3.setAttribute("x", String(a3)), c3.setAttribute("y", String(h3)), c3.setAttribute("width", `${d3}px`), c3.setAttribute("height", `${u3}px`), this._element.appendChild(c3);
          }
          _createColor({ options: t5, color: e4, additionalRotation: i3, x: r3, y: n3, height: o3, width: s3, name: a3 }) {
            const h3 = s3 > o3 ? s3 : o3, d3 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
            if (d3.setAttribute("x", String(r3)), d3.setAttribute("y", String(n3)), d3.setAttribute("height", String(o3)), d3.setAttribute("width", String(s3)), d3.setAttribute("clip-path", `url('#clip-path-${a3}')`), t5) {
              let e5;
              if ("radial" === t5.type) e5 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), e5.setAttribute("id", a3), e5.setAttribute("gradientUnits", "userSpaceOnUse"), e5.setAttribute("fx", String(r3 + s3 / 2)), e5.setAttribute("fy", String(n3 + o3 / 2)), e5.setAttribute("cx", String(r3 + s3 / 2)), e5.setAttribute("cy", String(n3 + o3 / 2)), e5.setAttribute("r", String(h3 / 2));
              else {
                const h4 = ((t5.rotation || 0) + i3) % (2 * Math.PI), d4 = (h4 + 2 * Math.PI) % (2 * Math.PI);
                let u3 = r3 + s3 / 2, c3 = n3 + o3 / 2, l3 = r3 + s3 / 2, g3 = n3 + o3 / 2;
                d4 >= 0 && d4 <= 0.25 * Math.PI || d4 > 1.75 * Math.PI && d4 <= 2 * Math.PI ? (u3 -= s3 / 2, c3 -= o3 / 2 * Math.tan(h4), l3 += s3 / 2, g3 += o3 / 2 * Math.tan(h4)) : d4 > 0.25 * Math.PI && d4 <= 0.75 * Math.PI ? (c3 -= o3 / 2, u3 -= s3 / 2 / Math.tan(h4), g3 += o3 / 2, l3 += s3 / 2 / Math.tan(h4)) : d4 > 0.75 * Math.PI && d4 <= 1.25 * Math.PI ? (u3 += s3 / 2, c3 += o3 / 2 * Math.tan(h4), l3 -= s3 / 2, g3 -= o3 / 2 * Math.tan(h4)) : d4 > 1.25 * Math.PI && d4 <= 1.75 * Math.PI && (c3 += o3 / 2, u3 += s3 / 2 / Math.tan(h4), g3 -= o3 / 2, l3 -= s3 / 2 / Math.tan(h4)), e5 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), e5.setAttribute("id", a3), e5.setAttribute("gradientUnits", "userSpaceOnUse"), e5.setAttribute("x1", String(Math.round(u3))), e5.setAttribute("y1", String(Math.round(c3))), e5.setAttribute("x2", String(Math.round(l3))), e5.setAttribute("y2", String(Math.round(g3)));
              }
              t5.colorStops.forEach((({ offset: t6, color: i4 }) => {
                const r4 = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
                r4.setAttribute("offset", 100 * t6 + "%"), r4.setAttribute("stop-color", i4), e5.appendChild(r4);
              })), d3.setAttribute("fill", `url('#${a3}')`), this._defs.appendChild(e5);
            } else e4 && d3.setAttribute("fill", e4);
            this._element.appendChild(d3);
          }
        }
        p2.instanceCount = 0;
        const v2 = p2, _2 = "canvas", m2 = {};
        for (let t5 = 0; t5 <= 40; t5++) m2[t5] = t5;
        const b2 = { type: _2, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: m2[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: true, hideBackgroundDots: true, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: true }, backgroundOptions: { round: 0, color: "#fff" } };
        function y2(t5) {
          const e4 = Object.assign({}, t5);
          if (!e4.colorStops || !e4.colorStops.length) throw "Field 'colorStops' is required in gradient";
          return e4.rotation ? e4.rotation = Number(e4.rotation) : e4.rotation = 0, e4.colorStops = e4.colorStops.map(((t6) => Object.assign(Object.assign({}, t6), { offset: Number(t6.offset) }))), e4;
        }
        function x2(t5) {
          const e4 = Object.assign({}, t5);
          return e4.width = Number(e4.width), e4.height = Number(e4.height), e4.margin = Number(e4.margin), e4.imageOptions = Object.assign(Object.assign({}, e4.imageOptions), { hideBackgroundDots: Boolean(e4.imageOptions.hideBackgroundDots), imageSize: Number(e4.imageOptions.imageSize), margin: Number(e4.imageOptions.margin) }), e4.margin > Math.min(e4.width, e4.height) && (e4.margin = Math.min(e4.width, e4.height)), e4.dotsOptions = Object.assign({}, e4.dotsOptions), e4.dotsOptions.gradient && (e4.dotsOptions.gradient = y2(e4.dotsOptions.gradient)), e4.cornersSquareOptions && (e4.cornersSquareOptions = Object.assign({}, e4.cornersSquareOptions), e4.cornersSquareOptions.gradient && (e4.cornersSquareOptions.gradient = y2(e4.cornersSquareOptions.gradient))), e4.cornersDotOptions && (e4.cornersDotOptions = Object.assign({}, e4.cornersDotOptions), e4.cornersDotOptions.gradient && (e4.cornersDotOptions.gradient = y2(e4.cornersDotOptions.gradient))), e4.backgroundOptions && (e4.backgroundOptions = Object.assign({}, e4.backgroundOptions), e4.backgroundOptions.gradient && (e4.backgroundOptions.gradient = y2(e4.backgroundOptions.gradient))), e4;
        }
        var S2 = i2(873), C2 = i2.n(S2);
        function A2(t5) {
          if (!t5) throw new Error("Extension must be defined");
          "." === t5[0] && (t5 = t5.substring(1));
          const e4 = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[t5.toLowerCase()];
          if (!e4) throw new Error(`Extension "${t5}" is not supported`);
          return e4;
        }
        class M2 {
          constructor(t5) {
            (null == t5 ? void 0 : t5.jsdom) ? this._window = new t5.jsdom("", { resources: "usable" }).window : this._window = window, this._options = t5 ? x2(e3(b2, t5)) : b2, this.update();
          }
          static _clearContainer(t5) {
            t5 && (t5.innerHTML = "");
          }
          _setupSvg() {
            if (!this._qr) return;
            const t5 = new v2(this._options, this._window);
            this._svg = t5.getElement(), this._svgDrawingPromise = t5.drawQR(this._qr).then((() => {
              var e4;
              this._svg && (null === (e4 = this._extension) || void 0 === e4 || e4.call(this, t5.getElement(), this._options));
            }));
          }
          _setupCanvas() {
            var t5, e4;
            this._qr && ((null === (t5 = this._options.nodeCanvas) || void 0 === t5 ? void 0 : t5.createCanvas) ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = null === (e4 = this._svgDrawingPromise) || void 0 === e4 ? void 0 : e4.then((() => {
              var t6;
              if (!this._svg) return;
              const e5 = this._svg, i3 = new this._window.XMLSerializer().serializeToString(e5), r3 = btoa(i3), n3 = `data:${A2("svg")};base64,${r3}`;
              if (null === (t6 = this._options.nodeCanvas) || void 0 === t6 ? void 0 : t6.loadImage) return this._options.nodeCanvas.loadImage(n3).then(((t7) => {
                var e6, i4;
                t7.width = this._options.width, t7.height = this._options.height, null === (i4 = null === (e6 = this._nodeCanvas) || void 0 === e6 ? void 0 : e6.getContext("2d")) || void 0 === i4 || i4.drawImage(t7, 0, 0);
              }));
              {
                const t7 = new this._window.Image();
                return new Promise(((e6) => {
                  t7.onload = () => {
                    var i4, r4;
                    null === (r4 = null === (i4 = this._domCanvas) || void 0 === i4 ? void 0 : i4.getContext("2d")) || void 0 === r4 || r4.drawImage(t7, 0, 0), e6();
                  }, t7.src = n3;
                }));
              }
            })));
          }
          async _getElement(t5 = "png") {
            if (!this._qr) throw "QR code is empty";
            return "svg" === t5.toLowerCase() ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
          }
          update(t5) {
            M2._clearContainer(this._container), this._options = t5 ? x2(e3(this._options, t5)) : this._options, this._options.data && (this._qr = C2()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || (function(t6) {
              switch (true) {
                case /^[0-9]*$/.test(t6):
                  return "Numeric";
                case /^[0-9A-Z $%*+\-./:]*$/.test(t6):
                  return "Alphanumeric";
                default:
                  return "Byte";
              }
            })(this._options.data)), this._qr.make(), this._options.type === _2 ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
          }
          append(t5) {
            if (t5) {
              if ("function" != typeof t5.appendChild) throw "Container should be a single DOM node";
              this._options.type === _2 ? this._domCanvas && t5.appendChild(this._domCanvas) : this._svg && t5.appendChild(this._svg), this._container = t5;
            }
          }
          applyExtension(t5) {
            if (!t5) throw "Extension function should be defined.";
            this._extension = t5, this.update();
          }
          deleteExtension() {
            this._extension = void 0, this.update();
          }
          async getRawData(t5 = "png") {
            if (!this._qr) throw "QR code is empty";
            const e4 = await this._getElement(t5), i3 = A2(t5);
            if (!e4) return null;
            if ("svg" === t5.toLowerCase()) {
              const t6 = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(e4)}`;
              return "undefined" == typeof Blob || this._options.jsdom ? Buffer.from(t6) : new Blob([t6], { type: i3 });
            }
            return new Promise(((t6) => {
              const r3 = e4;
              if ("toBuffer" in r3) if ("image/png" === i3) t6(r3.toBuffer(i3));
              else if ("image/jpeg" === i3) t6(r3.toBuffer(i3));
              else {
                if ("application/pdf" !== i3) throw Error("Unsupported extension");
                t6(r3.toBuffer(i3));
              }
              else "toBlob" in r3 && r3.toBlob(t6, i3, 1);
            }));
          }
          async download(t5) {
            if (!this._qr) throw "QR code is empty";
            if ("undefined" == typeof Blob) throw "Cannot download in Node.js, call getRawData instead.";
            let e4 = "png", i3 = "qr";
            "string" == typeof t5 ? (e4 = t5, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t5 && null !== t5 && (t5.name && (i3 = t5.name), t5.extension && (e4 = t5.extension));
            const r3 = await this._getElement(e4);
            if (r3) if ("svg" === e4.toLowerCase()) {
              let t6 = new XMLSerializer().serializeToString(r3);
              t6 = '<?xml version="1.0" standalone="no"?>\r\n' + t6, n2(`data:${A2(e4)};charset=utf-8,${encodeURIComponent(t6)}`, `${i3}.svg`);
            } else n2(r3.toDataURL(A2(e4)), `${i3}.${e4}`);
          }
        }
        const $2 = M2;
      })(), r2.default;
    })()));
  })(qrCodeStyling$1);
  return qrCodeStyling$1.exports;
}
var qrCodeStylingExports = requireQrCodeStyling();
const QRCodeStyling = /* @__PURE__ */ getDefaultExportFromCjs(qrCodeStylingExports);
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var hasRequiredJszip_min;
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module, exports) {
    !(function(e2) {
      module.exports = e2();
    })(function() {
      return (function s2(a2, o2, h2) {
        function u2(r2, e3) {
          if (!o2[r2]) {
            if (!a2[r2]) {
              var t3 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e3 && t3) return t3(r2, true);
              if (l2) return l2(r2, true);
              var n2 = new Error("Cannot find module '" + r2 + "'");
              throw n2.code = "MODULE_NOT_FOUND", n2;
            }
            var i2 = o2[r2] = { exports: {} };
            a2[r2][0].call(i2.exports, function(e4) {
              var t4 = a2[r2][1][e4];
              return u2(t4 || e4);
            }, i2, i2.exports, s2, a2, o2, h2);
          }
          return o2[r2].exports;
        }
        for (var l2 = "function" == typeof commonjsRequire && commonjsRequire, e2 = 0; e2 < h2.length; e2++) u2(h2[e2]);
        return u2;
      })({ 1: [function(e2, t3, r2) {
        var d2 = e2("./utils"), c2 = e2("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e3) {
          for (var t4, r3, n2, i2, s2, a2, o2, h2 = [], u2 = 0, l2 = e3.length, f2 = l2, c3 = "string" !== d2.getTypeOf(e3); u2 < e3.length; ) f2 = l2 - u2, n2 = c3 ? (t4 = e3[u2++], r3 = u2 < l2 ? e3[u2++] : 0, u2 < l2 ? e3[u2++] : 0) : (t4 = e3.charCodeAt(u2++), r3 = u2 < l2 ? e3.charCodeAt(u2++) : 0, u2 < l2 ? e3.charCodeAt(u2++) : 0), i2 = t4 >> 2, s2 = (3 & t4) << 4 | r3 >> 4, a2 = 1 < f2 ? (15 & r3) << 2 | n2 >> 6 : 64, o2 = 2 < f2 ? 63 & n2 : 64, h2.push(p2.charAt(i2) + p2.charAt(s2) + p2.charAt(a2) + p2.charAt(o2));
          return h2.join("");
        }, r2.decode = function(e3) {
          var t4, r3, n2, i2, s2, a2, o2 = 0, h2 = 0, u2 = "data:";
          if (e3.substr(0, u2.length) === u2) throw new Error("Invalid base64 input, it looks like a data url.");
          var l2, f2 = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e3.charAt(e3.length - 1) === p2.charAt(64) && f2--, e3.charAt(e3.length - 2) === p2.charAt(64) && f2--, f2 % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l2 = c2.uint8array ? new Uint8Array(0 | f2) : new Array(0 | f2); o2 < e3.length; ) t4 = p2.indexOf(e3.charAt(o2++)) << 2 | (i2 = p2.indexOf(e3.charAt(o2++))) >> 4, r3 = (15 & i2) << 4 | (s2 = p2.indexOf(e3.charAt(o2++))) >> 2, n2 = (3 & s2) << 6 | (a2 = p2.indexOf(e3.charAt(o2++))), l2[h2++] = t4, 64 !== s2 && (l2[h2++] = r3), 64 !== a2 && (l2[h2++] = n2);
          return l2;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t3, r2) {
        var n2 = e2("./external"), i2 = e2("./stream/DataWorker"), s2 = e2("./stream/Crc32Probe"), a2 = e2("./stream/DataLengthProbe");
        function o2(e3, t4, r3, n3, i3) {
          this.compressedSize = e3, this.uncompressedSize = t4, this.crc32 = r3, this.compression = n3, this.compressedContent = i3;
        }
        o2.prototype = { getContentWorker: function() {
          var e3 = new i2(n2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a2("data_length")), t4 = this;
          return e3.on("end", function() {
            if (this.streamInfo.data_length !== t4.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e3;
        }, getCompressedWorker: function() {
          return new i2(n2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o2.createWorkerFrom = function(e3, t4, r3) {
          return e3.pipe(new s2()).pipe(new a2("uncompressedSize")).pipe(t4.compressWorker(r3)).pipe(new a2("compressedSize")).withStreamInfo("compression", t4);
        }, t3.exports = o2;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t3, r2) {
        var n2 = e2("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n2("STORE compression");
        }, uncompressWorker: function() {
          return new n2("STORE decompression");
        } }, r2.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t3, r2) {
        var n2 = e2("./utils");
        var o2 = (function() {
          for (var e3, t4 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n3 = 0; n3 < 8; n3++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t4[r3] = e3;
          }
          return t4;
        })();
        t3.exports = function(e3, t4) {
          return void 0 !== e3 && e3.length ? "string" !== n2.getTypeOf(e3) ? (function(e4, t5, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++) e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t5[a2])];
            return -1 ^ e4;
          })(0 | t4, e3, e3.length, 0) : (function(e4, t5, r3, n3) {
            var i2 = o2, s2 = n3 + r3;
            e4 ^= -1;
            for (var a2 = n3; a2 < s2; a2++) e4 = e4 >>> 8 ^ i2[255 & (e4 ^ t5.charCodeAt(a2))];
            return -1 ^ e4;
          })(0 | t4, e3, e3.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t3, r2) {
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e2, t3, r2) {
        var n2 = null;
        n2 = "undefined" != typeof Promise ? Promise : e2("lie"), t3.exports = { Promise: n2 };
      }, { lie: 37 }], 7: [function(e2, t3, r2) {
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i2 = e2("pako"), s2 = e2("./utils"), a2 = e2("./stream/GenericWorker"), o2 = n2 ? "uint8array" : "array";
        function h2(e3, t4) {
          a2.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t4, this.meta = {};
        }
        r2.magic = "\b\0", s2.inherits(h2, a2), h2.prototype.processChunk = function(e3) {
          this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s2.transformTo(o2, e3.data), false);
        }, h2.prototype.flush = function() {
          a2.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a2.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i2[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t4 = this;
          this._pako.onData = function(e3) {
            t4.push({ data: e3, meta: t4.meta });
          };
        }, r2.compressWorker = function(e3) {
          return new h2("Deflate", e3);
        }, r2.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t3, r2) {
        function A2(e3, t4) {
          var r3, n3 = "";
          for (r3 = 0; r3 < t4; r3++) n3 += String.fromCharCode(255 & e3), e3 >>>= 8;
          return n3;
        }
        function n2(e3, t4, r3, n3, i3, s3) {
          var a2, o2, h2 = e3.file, u2 = e3.compression, l2 = s3 !== O2.utf8encode, f2 = I2.transformTo("string", s3(h2.name)), c2 = I2.transformTo("string", O2.utf8encode(h2.name)), d2 = h2.comment, p2 = I2.transformTo("string", s3(d2)), m2 = I2.transformTo("string", O2.utf8encode(d2)), _2 = c2.length !== h2.name.length, g2 = m2.length !== d2.length, b2 = "", v2 = "", y2 = "", w2 = h2.dir, k2 = h2.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t4 && !r3 || (x2.crc32 = e3.crc32, x2.compressedSize = e3.compressedSize, x2.uncompressedSize = e3.uncompressedSize);
          var S2 = 0;
          t4 && (S2 |= 8), l2 || !_2 && !g2 || (S2 |= 2048);
          var z2 = 0, C2 = 0;
          w2 && (z2 |= 16), "UNIX" === i3 ? (C2 = 798, z2 |= (function(e4, t5) {
            var r4 = e4;
            return e4 || (r4 = t5 ? 16893 : 33204), (65535 & r4) << 16;
          })(h2.unixPermissions, w2)) : (C2 = 20, z2 |= (function(e4) {
            return 63 & (e4 || 0);
          })(h2.dosPermissions)), a2 = k2.getUTCHours(), a2 <<= 6, a2 |= k2.getUTCMinutes(), a2 <<= 5, a2 |= k2.getUTCSeconds() / 2, o2 = k2.getUTCFullYear() - 1980, o2 <<= 4, o2 |= k2.getUTCMonth() + 1, o2 <<= 5, o2 |= k2.getUTCDate(), _2 && (v2 = A2(1, 1) + A2(B3(f2), 4) + c2, b2 += "up" + A2(v2.length, 2) + v2), g2 && (y2 = A2(1, 1) + A2(B3(p2), 4) + m2, b2 += "uc" + A2(y2.length, 2) + y2);
          var E2 = "";
          return E2 += "\n\0", E2 += A2(S2, 2), E2 += u2.magic, E2 += A2(a2, 2), E2 += A2(o2, 2), E2 += A2(x2.crc32, 4), E2 += A2(x2.compressedSize, 4), E2 += A2(x2.uncompressedSize, 4), E2 += A2(f2.length, 2), E2 += A2(b2.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f2 + b2, dirRecord: R2.CENTRAL_FILE_HEADER + A2(C2, 2) + E2 + A2(p2.length, 2) + "\0\0\0\0" + A2(z2, 4) + A2(n3, 4) + f2 + b2 + p2 };
        }
        var I2 = e2("../utils"), i2 = e2("../stream/GenericWorker"), O2 = e2("../utf8"), B3 = e2("../crc32"), R2 = e2("../signature");
        function s2(e3, t4, r3, n3) {
          i2.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t4, this.zipPlatform = r3, this.encodeFileName = n3, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I2.inherits(s2, i2), s2.prototype.push = function(e3) {
          var t4 = e3.meta.percent || 0, r3 = this.entriesCount, n3 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i2.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r3 ? (t4 + 100 * (r3 - n3 - 1)) / r3 : 100 } }));
        }, s2.prototype.openedSource = function(e3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
          var t4 = this.streamFiles && !e3.file.dir;
          if (t4) {
            var r3 = n2(e3, t4, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r3.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s2.prototype.closedSource = function(e3) {
          this.accumulate = false;
          var t4 = this.streamFiles && !e3.file.dir, r3 = n2(e3, t4, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r3.dirRecord), t4) this.push({ data: (function(e4) {
            return R2.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
          })(e3), meta: { percent: 100 } });
          else for (this.push({ data: r3.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s2.prototype.flush = function() {
          for (var e3 = this.bytesWritten, t4 = 0; t4 < this.dirRecords.length; t4++) this.push({ data: this.dirRecords[t4], meta: { percent: 100 } });
          var r3 = this.bytesWritten - e3, n3 = (function(e4, t5, r4, n4, i3) {
            var s3 = I2.transformTo("string", i3(n4));
            return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t5, 4) + A2(r4, 4) + A2(s3.length, 2) + s3;
          })(this.dirRecords.length, r3, e3, this.zipComment, this.encodeFileName);
          this.push({ data: n3, meta: { percent: 100 } });
        }, s2.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s2.prototype.registerPrevious = function(e3) {
          this._sources.push(e3);
          var t4 = this;
          return e3.on("data", function(e4) {
            t4.processChunk(e4);
          }), e3.on("end", function() {
            t4.closedSource(t4.previous.streamInfo), t4._sources.length ? t4.prepareNextSource() : t4.end();
          }), e3.on("error", function(e4) {
            t4.error(e4);
          }), this;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s2.prototype.error = function(e3) {
          var t4 = this._sources;
          if (!i2.prototype.error.call(this, e3)) return false;
          for (var r3 = 0; r3 < t4.length; r3++) try {
            t4[r3].error(e3);
          } catch (e4) {
          }
          return true;
        }, s2.prototype.lock = function() {
          i2.prototype.lock.call(this);
          for (var e3 = this._sources, t4 = 0; t4 < e3.length; t4++) e3[t4].lock();
        }, t3.exports = s2;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t3, r2) {
        var u2 = e2("../compressions"), n2 = e2("./ZipFileWorker");
        r2.generateWorker = function(e3, a2, t4) {
          var o2 = new n2(a2.streamFiles, t4, a2.platform, a2.encodeFileName), h2 = 0;
          try {
            e3.forEach(function(e4, t5) {
              h2++;
              var r3 = (function(e5, t6) {
                var r4 = e5 || t6, n4 = u2[r4];
                if (!n4) throw new Error(r4 + " is not a valid compression method !");
                return n4;
              })(t5.options.compression, a2.compression), n3 = t5.options.compressionOptions || a2.compressionOptions || {}, i2 = t5.dir, s2 = t5.date;
              t5._compressWorker(r3, n3).withStreamInfo("file", { name: e4, dir: i2, date: s2, comment: t5.comment || "", unixPermissions: t5.unixPermissions, dosPermissions: t5.dosPermissions }).pipe(o2);
            }), o2.entriesCount = h2;
          } catch (e4) {
            o2.error(e4);
          }
          return o2;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t3, r2) {
        function n2() {
          if (!(this instanceof n2)) return new n2();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e3 = new n2();
            for (var t4 in this) "function" != typeof this[t4] && (e3[t4] = this[t4]);
            return e3;
          };
        }
        (n2.prototype = e2("./object")).loadAsync = e2("./load"), n2.support = e2("./support"), n2.defaults = e2("./defaults"), n2.version = "3.10.1", n2.loadAsync = function(e3, t4) {
          return new n2().loadAsync(e3, t4);
        }, n2.external = e2("./external"), t3.exports = n2;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t3, r2) {
        var u2 = e2("./utils"), i2 = e2("./external"), n2 = e2("./utf8"), s2 = e2("./zipEntries"), a2 = e2("./stream/Crc32Probe"), l2 = e2("./nodejsUtils");
        function f2(n3) {
          return new i2.Promise(function(e3, t4) {
            var r3 = n3.decompressed.getContentWorker().pipe(new a2());
            r3.on("error", function(e4) {
              t4(e4);
            }).on("end", function() {
              r3.streamInfo.crc32 !== n3.decompressed.crc32 ? t4(new Error("Corrupted zip : CRC32 mismatch")) : e3();
            }).resume();
          });
        }
        t3.exports = function(e3, o2) {
          var h2 = this;
          return o2 = u2.extend(o2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n2.utf8decode }), l2.isNode && l2.isStream(e3) ? i2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o2.optimizedBinaryString, o2.base64).then(function(e4) {
            var t4 = new s2(o2);
            return t4.load(e4), t4;
          }).then(function(e4) {
            var t4 = [i2.Promise.resolve(e4)], r3 = e4.files;
            if (o2.checkCRC32) for (var n3 = 0; n3 < r3.length; n3++) t4.push(f2(r3[n3]));
            return i2.Promise.all(t4);
          }).then(function(e4) {
            for (var t4 = e4.shift(), r3 = t4.files, n3 = 0; n3 < r3.length; n3++) {
              var i3 = r3[n3], s3 = i3.fileNameStr, a3 = u2.resolve(i3.fileNameStr);
              h2.file(a3, i3.decompressed, { binary: true, optimizedBinaryString: true, date: i3.date, dir: i3.dir, comment: i3.fileCommentStr.length ? i3.fileCommentStr : null, unixPermissions: i3.unixPermissions, dosPermissions: i3.dosPermissions, createFolders: o2.createFolders }), i3.dir || (h2.file(a3).unsafeOriginalName = s3);
            }
            return t4.zipComment.length && (h2.comment = t4.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t3, r2) {
        var n2 = e2("../utils"), i2 = e2("../stream/GenericWorker");
        function s2(e3, t4) {
          i2.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t4);
        }
        n2.inherits(s2, i2), s2.prototype._bindStream = function(e3) {
          var t4 = this;
          (this._stream = e3).pause(), e3.on("data", function(e4) {
            t4.push({ data: e4, meta: { percent: 0 } });
          }).on("error", function(e4) {
            t4.isPaused ? this.generatedError = e4 : t4.error(e4);
          }).on("end", function() {
            t4.isPaused ? t4._upstreamEnded = true : t4.end();
          });
        }, s2.prototype.pause = function() {
          return !!i2.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t3.exports = s2;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t3, r2) {
        var i2 = e2("readable-stream").Readable;
        function n2(e3, t4, r3) {
          i2.call(this, t4), this._helper = e3;
          var n3 = this;
          e3.on("data", function(e4, t5) {
            n3.push(e4) || n3._helper.pause(), r3 && r3(t5);
          }).on("error", function(e4) {
            n3.emit("error", e4);
          }).on("end", function() {
            n3.push(null);
          });
        }
        e2("../utils").inherits(n2, i2), n2.prototype._read = function() {
          this._helper.resume();
        }, t3.exports = n2;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t3, r2) {
        t3.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t4) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e3, t4);
          if ("number" == typeof e3) throw new Error('The "data" argument must not be a number');
          return new Buffer(e3, t4);
        }, allocBuffer: function(e3) {
          if (Buffer.alloc) return Buffer.alloc(e3);
          var t4 = new Buffer(e3);
          return t4.fill(0), t4;
        }, isBuffer: function(e3) {
          return Buffer.isBuffer(e3);
        }, isStream: function(e3) {
          return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
        } };
      }, {}], 15: [function(e2, t3, r2) {
        function s2(e3, t4, r3) {
          var n3, i3 = u2.getTypeOf(t4), s3 = u2.extend(r3 || {}, f2);
          s3.date = s3.date || /* @__PURE__ */ new Date(), null !== s3.compression && (s3.compression = s3.compression.toUpperCase()), "string" == typeof s3.unixPermissions && (s3.unixPermissions = parseInt(s3.unixPermissions, 8)), s3.unixPermissions && 16384 & s3.unixPermissions && (s3.dir = true), s3.dosPermissions && 16 & s3.dosPermissions && (s3.dir = true), s3.dir && (e3 = g2(e3)), s3.createFolders && (n3 = _2(e3)) && b2.call(this, n3, true);
          var a3 = "string" === i3 && false === s3.binary && false === s3.base64;
          r3 && void 0 !== r3.binary || (s3.binary = !a3), (t4 instanceof c2 && 0 === t4.uncompressedSize || s3.dir || !t4 || 0 === t4.length) && (s3.base64 = false, s3.binary = true, t4 = "", s3.compression = "STORE", i3 = "string");
          var o3 = null;
          o3 = t4 instanceof c2 || t4 instanceof l2 ? t4 : p2.isNode && p2.isStream(t4) ? new m2(e3, t4) : u2.prepareContent(e3, t4, s3.binary, s3.optimizedBinaryString, s3.base64);
          var h3 = new d2(e3, o3, s3);
          this.files[e3] = h3;
        }
        var i2 = e2("./utf8"), u2 = e2("./utils"), l2 = e2("./stream/GenericWorker"), a2 = e2("./stream/StreamHelper"), f2 = e2("./defaults"), c2 = e2("./compressedObject"), d2 = e2("./zipObject"), o2 = e2("./generate"), p2 = e2("./nodejsUtils"), m2 = e2("./nodejs/NodejsStreamInputAdapter"), _2 = function(e3) {
          "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
          var t4 = e3.lastIndexOf("/");
          return 0 < t4 ? e3.substring(0, t4) : "";
        }, g2 = function(e3) {
          return "/" !== e3.slice(-1) && (e3 += "/"), e3;
        }, b2 = function(e3, t4) {
          return t4 = void 0 !== t4 ? t4 : f2.createFolders, e3 = g2(e3), this.files[e3] || s2.call(this, e3, null, { dir: true, createFolders: t4 }), this.files[e3];
        };
        function h2(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }
        var n2 = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e3) {
          var t4, r3, n3;
          for (t4 in this.files) n3 = this.files[t4], (r3 = t4.slice(this.root.length, t4.length)) && t4.slice(0, this.root.length) === this.root && e3(r3, n3);
        }, filter: function(r3) {
          var n3 = [];
          return this.forEach(function(e3, t4) {
            r3(e3, t4) && n3.push(t4);
          }), n3;
        }, file: function(e3, t4, r3) {
          if (1 !== arguments.length) return e3 = this.root + e3, s2.call(this, e3, t4, r3), this;
          if (h2(e3)) {
            var n3 = e3;
            return this.filter(function(e4, t5) {
              return !t5.dir && n3.test(e4);
            });
          }
          var i3 = this.files[this.root + e3];
          return i3 && !i3.dir ? i3 : null;
        }, folder: function(r3) {
          if (!r3) return this;
          if (h2(r3)) return this.filter(function(e4, t5) {
            return t5.dir && r3.test(e4);
          });
          var e3 = this.root + r3, t4 = b2.call(this, e3), n3 = this.clone();
          return n3.root = t4.name, n3;
        }, remove: function(r3) {
          r3 = this.root + r3;
          var e3 = this.files[r3];
          if (e3 || ("/" !== r3.slice(-1) && (r3 += "/"), e3 = this.files[r3]), e3 && !e3.dir) delete this.files[r3];
          else for (var t4 = this.filter(function(e4, t5) {
            return t5.name.slice(0, r3.length) === r3;
          }), n3 = 0; n3 < t4.length; n3++) delete this.files[t4[n3].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e3) {
          var t4, r3 = {};
          try {
            if ((r3 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i2.utf8encode })).type = r3.type.toLowerCase(), r3.compression = r3.compression.toUpperCase(), "binarystring" === r3.type && (r3.type = "string"), !r3.type) throw new Error("No output type specified.");
            u2.checkSupport(r3.type), "darwin" !== r3.platform && "freebsd" !== r3.platform && "linux" !== r3.platform && "sunos" !== r3.platform || (r3.platform = "UNIX"), "win32" === r3.platform && (r3.platform = "DOS");
            var n3 = r3.comment || this.comment || "";
            t4 = o2.generateWorker(this, r3, n3);
          } catch (e4) {
            (t4 = new l2("error")).error(e4);
          }
          return new a2(t4, r3.type || "string", r3.mimeType);
        }, generateAsync: function(e3, t4) {
          return this.generateInternalStream(e3).accumulate(t4);
        }, generateNodeStream: function(e3, t4) {
          return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t4);
        } };
        t3.exports = n2;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t3, r2) {
        t3.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t3, r2) {
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
          for (var t4 = 0; t4 < this.data.length; t4++) e3[t4] = 255 & e3[t4];
        }
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data[this.zero + e3];
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          for (var t4 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.length - 4; 0 <= s2; --s2) if (this.data[s2] === t4 && this.data[s2 + 1] === r3 && this.data[s2 + 2] === n3 && this.data[s2 + 3] === i3) return s2 - this.zero;
          return -1;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          var t4 = e3.charCodeAt(0), r3 = e3.charCodeAt(1), n3 = e3.charCodeAt(2), i3 = e3.charCodeAt(3), s2 = this.readData(4);
          return t4 === s2[0] && r3 === s2[1] && n3 === s2[2] && i3 === s2[3];
        }, i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3) return [];
          var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t4;
        }, t3.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t3, r2) {
        var n2 = e2("../utils");
        function i2(e3) {
          this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
        }
        i2.prototype = { checkOffset: function(e3) {
          this.checkIndex(this.index + e3);
        }, checkIndex: function(e3) {
          if (this.length < this.zero + e3 || e3 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
        }, setIndex: function(e3) {
          this.checkIndex(e3), this.index = e3;
        }, skip: function(e3) {
          this.setIndex(this.index + e3);
        }, byteAt: function() {
        }, readInt: function(e3) {
          var t4, r3 = 0;
          for (this.checkOffset(e3), t4 = this.index + e3 - 1; t4 >= this.index; t4--) r3 = (r3 << 8) + this.byteAt(t4);
          return this.index += e3, r3;
        }, readString: function(e3) {
          return n2.transformTo("string", this.readData(e3));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e3 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
        } }, t3.exports = i2;
      }, { "../utils": 32 }], 19: [function(e2, t3, r2) {
        var n2 = e2("./Uint8ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t4;
        }, t3.exports = i2;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t3, r2) {
        var n2 = e2("./DataReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.byteAt = function(e3) {
          return this.data.charCodeAt(this.zero + e3);
        }, i2.prototype.lastIndexOfSignature = function(e3) {
          return this.data.lastIndexOf(e3) - this.zero;
        }, i2.prototype.readAndCheckSignature = function(e3) {
          return e3 === this.readData(4);
        }, i2.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t4 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t4;
        }, t3.exports = i2;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t3, r2) {
        var n2 = e2("./ArrayReader");
        function i2(e3) {
          n2.call(this, e3);
        }
        e2("../utils").inherits(i2, n2), i2.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3) return new Uint8Array(0);
          var t4 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t4;
        }, t3.exports = i2;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t3, r2) {
        var n2 = e2("../utils"), i2 = e2("../support"), s2 = e2("./ArrayReader"), a2 = e2("./StringReader"), o2 = e2("./NodeBufferReader"), h2 = e2("./Uint8ArrayReader");
        t3.exports = function(e3) {
          var t4 = n2.getTypeOf(e3);
          return n2.checkSupport(t4), "string" !== t4 || i2.uint8array ? "nodebuffer" === t4 ? new o2(e3) : i2.uint8array ? new h2(n2.transformTo("uint8array", e3)) : new s2(n2.transformTo("array", e3)) : new a2(e3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t3, r2) {
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t3, r2) {
        var n2 = e2("./GenericWorker"), i2 = e2("../utils");
        function s2(e3) {
          n2.call(this, "ConvertWorker to " + e3), this.destType = e3;
        }
        i2.inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.push({ data: i2.transformTo(this.destType, e3.data), meta: e3.meta });
        }, t3.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t3, r2) {
        var n2 = e2("./GenericWorker"), i2 = e2("../crc32");
        function s2() {
          n2.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e2("../utils").inherits(s2, n2), s2.prototype.processChunk = function(e3) {
          this.streamInfo.crc32 = i2(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
        }, t3.exports = s2;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t3, r2) {
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
        }
        n2.inherits(s2, i2), s2.prototype.processChunk = function(e3) {
          if (e3) {
            var t4 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t4 + e3.data.length;
          }
          i2.prototype.processChunk.call(this, e3);
        }, t3.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t3, r2) {
        var n2 = e2("../utils"), i2 = e2("./GenericWorker");
        function s2(e3) {
          i2.call(this, "DataWorker");
          var t4 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
            t4.dataIsReady = true, t4.data = e4, t4.max = e4 && e4.length || 0, t4.type = n2.getTypeOf(e4), t4.isPaused || t4._tickAndRepeat();
          }, function(e4) {
            t4.error(e4);
          });
        }
        n2.inherits(s2, i2), s2.prototype.cleanUp = function() {
          i2.prototype.cleanUp.call(this), this.data = null;
        }, s2.prototype.resume = function() {
          return !!i2.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n2.delay(this._tickAndRepeat, [], this)), true);
        }, s2.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n2.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s2.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e3 = null, t4 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e3 = this.data.substring(this.index, t4);
              break;
            case "uint8array":
              e3 = this.data.subarray(this.index, t4);
              break;
            case "array":
            case "nodebuffer":
              e3 = this.data.slice(this.index, t4);
          }
          return this.index = t4, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t3.exports = s2;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t3, r2) {
        function n2(e3) {
          this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n2.prototype = { push: function(e3) {
          this.emit("data", e3);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e3) {
            this.emit("error", e3);
          }
          return true;
        }, error: function(e3) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
        }, on: function(e3, t4) {
          return this._listeners[e3].push(t4), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e3, t4) {
          if (this._listeners[e3]) for (var r3 = 0; r3 < this._listeners[e3].length; r3++) this._listeners[e3][r3].call(this, t4);
        }, pipe: function(e3) {
          return e3.registerPrevious(this);
        }, registerPrevious: function(e3) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
          var t4 = this;
          return e3.on("data", function(e4) {
            t4.processChunk(e4);
          }), e3.on("end", function() {
            t4.end();
          }), e3.on("error", function(e4) {
            t4.error(e4);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e3 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
        }, flush: function() {
        }, processChunk: function(e3) {
          this.push(e3);
        }, withStreamInfo: function(e3, t4) {
          return this.extraStreamInfo[e3] = t4, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e3 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e3 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e3 : e3;
        } }, t3.exports = n2;
      }, {}], 29: [function(e2, t3, r2) {
        var h2 = e2("../utils"), i2 = e2("./ConvertWorker"), s2 = e2("./GenericWorker"), u2 = e2("../base64"), n2 = e2("../support"), a2 = e2("../external"), o2 = null;
        if (n2.nodestream) try {
          o2 = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e3) {
        }
        function l2(e3, o3) {
          return new a2.Promise(function(t4, r3) {
            var n3 = [], i3 = e3._internalType, s3 = e3._outputType, a3 = e3._mimeType;
            e3.on("data", function(e4, t5) {
              n3.push(e4), o3 && o3(t5);
            }).on("error", function(e4) {
              n3 = [], r3(e4);
            }).on("end", function() {
              try {
                var e4 = (function(e5, t5, r4) {
                  switch (e5) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t5), r4);
                    case "base64":
                      return u2.encode(t5);
                    default:
                      return h2.transformTo(e5, t5);
                  }
                })(s3, (function(e5, t5) {
                  var r4, n4 = 0, i4 = null, s4 = 0;
                  for (r4 = 0; r4 < t5.length; r4++) s4 += t5[r4].length;
                  switch (e5) {
                    case "string":
                      return t5.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t5);
                    case "uint8array":
                      for (i4 = new Uint8Array(s4), r4 = 0; r4 < t5.length; r4++) i4.set(t5[r4], n4), n4 += t5[r4].length;
                      return i4;
                    case "nodebuffer":
                      return Buffer.concat(t5);
                    default:
                      throw new Error("concat : unsupported type '" + e5 + "'");
                  }
                })(i3, n3), a3);
                t4(e4);
              } catch (e5) {
                r3(e5);
              }
              n3 = [];
            }).resume();
          });
        }
        function f2(e3, t4, r3) {
          var n3 = t4;
          switch (t4) {
            case "blob":
            case "arraybuffer":
              n3 = "uint8array";
              break;
            case "base64":
              n3 = "string";
          }
          try {
            this._internalType = n3, this._outputType = t4, this._mimeType = r3, h2.checkSupport(n3), this._worker = e3.pipe(new i2(n3)), e3.lock();
          } catch (e4) {
            this._worker = new s2("error"), this._worker.error(e4);
          }
        }
        f2.prototype = { accumulate: function(e3) {
          return l2(this, e3);
        }, on: function(e3, t4) {
          var r3 = this;
          return "data" === e3 ? this._worker.on(e3, function(e4) {
            t4.call(r3, e4.data, e4.meta);
          }) : this._worker.on(e3, function() {
            h2.delay(t4, arguments, r3);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e3) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o2(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
        } }, t3.exports = f2;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t3, r2) {
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r2.blob = false;
        else {
          var n2 = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n2], { type: "application/zip" }).size;
          } catch (e3) {
            try {
              var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i2.append(n2), r2.blob = 0 === i2.getBlob("application/zip").size;
            } catch (e4) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e2("readable-stream").Readable;
        } catch (e3) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t3, s2) {
        for (var o2 = e2("./utils"), h2 = e2("./support"), r2 = e2("./nodejsUtils"), n2 = e2("./stream/GenericWorker"), u2 = new Array(256), i2 = 0; i2 < 256; i2++) u2[i2] = 252 <= i2 ? 6 : 248 <= i2 ? 5 : 240 <= i2 ? 4 : 224 <= i2 ? 3 : 192 <= i2 ? 2 : 1;
        u2[254] = u2[254] = 1;
        function a2() {
          n2.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l2() {
          n2.call(this, "utf-8 encode");
        }
        s2.utf8encode = function(e3) {
          return h2.nodebuffer ? r2.newBufferFrom(e3, "utf-8") : (function(e4) {
            var t4, r3, n3, i3, s3, a3 = e4.length, o3 = 0;
            for (i3 = 0; i3 < a3; i3++) 55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o3 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
            for (t4 = h2.uint8array ? new Uint8Array(o3) : new Array(o3), i3 = s3 = 0; s3 < o3; i3++) 55296 == (64512 & (r3 = e4.charCodeAt(i3))) && i3 + 1 < a3 && 56320 == (64512 & (n3 = e4.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t4[s3++] = r3 : (r3 < 2048 ? t4[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t4[s3++] = 224 | r3 >>> 12 : (t4[s3++] = 240 | r3 >>> 18, t4[s3++] = 128 | r3 >>> 12 & 63), t4[s3++] = 128 | r3 >>> 6 & 63), t4[s3++] = 128 | 63 & r3);
            return t4;
          })(e3);
        }, s2.utf8decode = function(e3) {
          return h2.nodebuffer ? o2.transformTo("nodebuffer", e3).toString("utf-8") : (function(e4) {
            var t4, r3, n3, i3, s3 = e4.length, a3 = new Array(2 * s3);
            for (t4 = r3 = 0; t4 < s3; ) if ((n3 = e4[t4++]) < 128) a3[r3++] = n3;
            else if (4 < (i3 = u2[n3])) a3[r3++] = 65533, t4 += i3 - 1;
            else {
              for (n3 &= 2 === i3 ? 31 : 3 === i3 ? 15 : 7; 1 < i3 && t4 < s3; ) n3 = n3 << 6 | 63 & e4[t4++], i3--;
              1 < i3 ? a3[r3++] = 65533 : n3 < 65536 ? a3[r3++] = n3 : (n3 -= 65536, a3[r3++] = 55296 | n3 >> 10 & 1023, a3[r3++] = 56320 | 1023 & n3);
            }
            return a3.length !== r3 && (a3.subarray ? a3 = a3.subarray(0, r3) : a3.length = r3), o2.applyFromCharCode(a3);
          })(e3 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3));
        }, o2.inherits(a2, n2), a2.prototype.processChunk = function(e3) {
          var t4 = o2.transformTo(h2.uint8array ? "uint8array" : "array", e3.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r3 = t4;
              (t4 = new Uint8Array(r3.length + this.leftOver.length)).set(this.leftOver, 0), t4.set(r3, this.leftOver.length);
            } else t4 = this.leftOver.concat(t4);
            this.leftOver = null;
          }
          var n3 = (function(e4, t5) {
            var r4;
            for ((t5 = t5 || e4.length) > e4.length && (t5 = e4.length), r4 = t5 - 1; 0 <= r4 && 128 == (192 & e4[r4]); ) r4--;
            return r4 < 0 ? t5 : 0 === r4 ? t5 : r4 + u2[e4[r4]] > t5 ? r4 : t5;
          })(t4), i3 = t4;
          n3 !== t4.length && (h2.uint8array ? (i3 = t4.subarray(0, n3), this.leftOver = t4.subarray(n3, t4.length)) : (i3 = t4.slice(0, n3), this.leftOver = t4.slice(n3, t4.length))), this.push({ data: s2.utf8decode(i3), meta: e3.meta });
        }, a2.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s2.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s2.Utf8DecodeWorker = a2, o2.inherits(l2, n2), l2.prototype.processChunk = function(e3) {
          this.push({ data: s2.utf8encode(e3.data), meta: e3.meta });
        }, s2.Utf8EncodeWorker = l2;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t3, a2) {
        var o2 = e2("./support"), h2 = e2("./base64"), r2 = e2("./nodejsUtils"), u2 = e2("./external");
        function n2(e3) {
          return e3;
        }
        function l2(e3, t4) {
          for (var r3 = 0; r3 < e3.length; ++r3) t4[r3] = 255 & e3.charCodeAt(r3);
          return t4;
        }
        e2("setimmediate"), a2.newBlob = function(t4, r3) {
          a2.checkSupport("blob");
          try {
            return new Blob([t4], { type: r3 });
          } catch (e3) {
            try {
              var n3 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n3.append(t4), n3.getBlob(r3);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i2 = { stringifyByChunk: function(e3, t4, r3) {
          var n3 = [], i3 = 0, s3 = e3.length;
          if (s3 <= r3) return String.fromCharCode.apply(null, e3);
          for (; i3 < s3; ) "array" === t4 || "nodebuffer" === t4 ? n3.push(String.fromCharCode.apply(null, e3.slice(i3, Math.min(i3 + r3, s3)))) : n3.push(String.fromCharCode.apply(null, e3.subarray(i3, Math.min(i3 + r3, s3)))), i3 += r3;
          return n3.join("");
        }, stringifyByChar: function(e3) {
          for (var t4 = "", r3 = 0; r3 < e3.length; r3++) t4 += String.fromCharCode(e3[r3]);
          return t4;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o2.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e3) {
            return false;
          }
        })(), nodebuffer: (function() {
          try {
            return o2.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e3) {
            return false;
          }
        })() } };
        function s2(e3) {
          var t4 = 65536, r3 = a2.getTypeOf(e3), n3 = true;
          if ("uint8array" === r3 ? n3 = i2.applyCanBeUsed.uint8array : "nodebuffer" === r3 && (n3 = i2.applyCanBeUsed.nodebuffer), n3) for (; 1 < t4; ) try {
            return i2.stringifyByChunk(e3, r3, t4);
          } catch (e4) {
            t4 = Math.floor(t4 / 2);
          }
          return i2.stringifyByChar(e3);
        }
        function f2(e3, t4) {
          for (var r3 = 0; r3 < e3.length; r3++) t4[r3] = e3[r3];
          return t4;
        }
        a2.applyFromCharCode = s2;
        var c2 = {};
        c2.string = { string: n2, array: function(e3) {
          return l2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.string.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return l2(e3, new Uint8Array(e3.length));
        }, nodebuffer: function(e3) {
          return l2(e3, r2.allocBuffer(e3.length));
        } }, c2.array = { string: s2, array: n2, arraybuffer: function(e3) {
          return new Uint8Array(e3).buffer;
        }, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.arraybuffer = { string: function(e3) {
          return s2(new Uint8Array(e3));
        }, array: function(e3) {
          return f2(new Uint8Array(e3), new Array(e3.byteLength));
        }, arraybuffer: n2, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r2.newBufferFrom(new Uint8Array(e3));
        } }, c2.uint8array = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return e3.buffer;
        }, uint8array: n2, nodebuffer: function(e3) {
          return r2.newBufferFrom(e3);
        } }, c2.nodebuffer = { string: s2, array: function(e3) {
          return f2(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.nodebuffer.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return f2(e3, new Uint8Array(e3.length));
        }, nodebuffer: n2 }, a2.transformTo = function(e3, t4) {
          if (t4 = t4 || "", !e3) return t4;
          a2.checkSupport(e3);
          var r3 = a2.getTypeOf(t4);
          return c2[r3][e3](t4);
        }, a2.resolve = function(e3) {
          for (var t4 = e3.split("/"), r3 = [], n3 = 0; n3 < t4.length; n3++) {
            var i3 = t4[n3];
            "." === i3 || "" === i3 && 0 !== n3 && n3 !== t4.length - 1 || (".." === i3 ? r3.pop() : r3.push(i3));
          }
          return r3.join("/");
        }, a2.getTypeOf = function(e3) {
          return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o2.nodebuffer && r2.isBuffer(e3) ? "nodebuffer" : o2.uint8array && e3 instanceof Uint8Array ? "uint8array" : o2.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a2.checkSupport = function(e3) {
          if (!o2[e3.toLowerCase()]) throw new Error(e3 + " is not supported by this platform");
        }, a2.MAX_VALUE_16BITS = 65535, a2.MAX_VALUE_32BITS = -1, a2.pretty = function(e3) {
          var t4, r3, n3 = "";
          for (r3 = 0; r3 < (e3 || "").length; r3++) n3 += "\\x" + ((t4 = e3.charCodeAt(r3)) < 16 ? "0" : "") + t4.toString(16).toUpperCase();
          return n3;
        }, a2.delay = function(e3, t4, r3) {
          setImmediate(function() {
            e3.apply(r3 || null, t4 || []);
          });
        }, a2.inherits = function(e3, t4) {
          function r3() {
          }
          r3.prototype = t4.prototype, e3.prototype = new r3();
        }, a2.extend = function() {
          var e3, t4, r3 = {};
          for (e3 = 0; e3 < arguments.length; e3++) for (t4 in arguments[e3]) Object.prototype.hasOwnProperty.call(arguments[e3], t4) && void 0 === r3[t4] && (r3[t4] = arguments[e3][t4]);
          return r3;
        }, a2.prepareContent = function(r3, e3, n3, i3, s3) {
          return u2.Promise.resolve(e3).then(function(n4) {
            return o2.blob && (n4 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n4))) && "undefined" != typeof FileReader ? new u2.Promise(function(t4, r4) {
              var e4 = new FileReader();
              e4.onload = function(e5) {
                t4(e5.target.result);
              }, e4.onerror = function(e5) {
                r4(e5.target.error);
              }, e4.readAsArrayBuffer(n4);
            }) : n4;
          }).then(function(e4) {
            var t4 = a2.getTypeOf(e4);
            return t4 ? ("arraybuffer" === t4 ? e4 = a2.transformTo("uint8array", e4) : "string" === t4 && (s3 ? e4 = h2.decode(e4) : n3 && true !== i3 && (e4 = (function(e5) {
              return l2(e5, o2.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
            })(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r3 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t3, r2) {
        var n2 = e2("./reader/readerFor"), i2 = e2("./utils"), s2 = e2("./signature"), a2 = e2("./zipEntry"), o2 = e2("./support");
        function h2(e3) {
          this.files = [], this.loadOptions = e3;
        }
        h2.prototype = { checkSignature: function(e3) {
          if (!this.reader.readAndCheckSignature(e3)) {
            this.reader.index -= 4;
            var t4 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i2.pretty(t4) + ", expected " + i2.pretty(e3) + ")");
          }
        }, isSignature: function(e3, t4) {
          var r3 = this.reader.index;
          this.reader.setIndex(e3);
          var n3 = this.reader.readString(4) === t4;
          return this.reader.setIndex(r3), n3;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e3 = this.reader.readData(this.zipCommentLength), t4 = o2.uint8array ? "uint8array" : "array", r3 = i2.transformTo(t4, e3);
          this.zipComment = this.loadOptions.decodeFileName(r3);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e3, t4, r3, n3 = this.zip64EndOfCentralSize - 44; 0 < n3; ) e3 = this.reader.readInt(2), t4 = this.reader.readInt(4), r3 = this.reader.readData(t4), this.zip64ExtensibleData[e3] = { id: e3, length: t4, value: r3 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e3, t4;
          for (e3 = 0; e3 < this.files.length; e3++) t4 = this.files[e3], this.reader.setIndex(t4.localHeaderOffset), this.checkSignature(s2.LOCAL_FILE_HEADER), t4.readLocalPart(this.reader), t4.handleUTF8(), t4.processAttributes();
        }, readCentralDir: function() {
          var e3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s2.CENTRAL_FILE_HEADER); ) (e3 = new a2({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e3 = this.reader.lastIndexOfSignature(s2.CENTRAL_DIRECTORY_END);
          if (e3 < 0) throw !this.isSignature(0, s2.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e3);
          var t4 = e3;
          if (this.checkSignature(s2.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i2.MAX_VALUE_16BITS || this.centralDirRecords === i2.MAX_VALUE_16BITS || this.centralDirSize === i2.MAX_VALUE_32BITS || this.centralDirOffset === i2.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e3), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s2.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s2.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r3 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r3 += 20, r3 += 12 + this.zip64EndOfCentralSize);
          var n3 = t4 - r3;
          if (0 < n3) this.isSignature(t4, s2.CENTRAL_FILE_HEADER) || (this.reader.zero = n3);
          else if (n3 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n3) + " bytes.");
        }, prepareReader: function(e3) {
          this.reader = n2(e3);
        }, load: function(e3) {
          this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t3.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t3, r2) {
        var n2 = e2("./reader/readerFor"), s2 = e2("./utils"), i2 = e2("./compressedObject"), a2 = e2("./crc32"), o2 = e2("./utf8"), h2 = e2("./compressions"), u2 = e2("./support");
        function l2(e3, t4) {
          this.options = e3, this.loadOptions = t4;
        }
        l2.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e3) {
          var t4, r3;
          if (e3.skip(22), this.fileNameLength = e3.readInt(2), r3 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r3), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t4 = (function(e4) {
            for (var t5 in h2) if (Object.prototype.hasOwnProperty.call(h2, t5) && h2[t5].magic === e4) return h2[t5];
            return null;
          })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s2.pretty(this.compressionMethod) + " unknown (inner file : " + s2.transformTo("string", this.fileName) + ")");
          this.decompressed = new i2(this.compressedSize, this.uncompressedSize, this.crc32, t4, e3.readData(this.compressedSize));
        }, readCentralPart: function(e3) {
          this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
          var t4 = e3.readInt(2);
          if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e3.skip(t4), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e3 = n2(this.extraFields[1].value);
            this.uncompressedSize === s2.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s2.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s2.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s2.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
          }
        }, readExtraFields: function(e3) {
          var t4, r3, n3, i3 = e3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i3; ) t4 = e3.readInt(2), r3 = e3.readInt(2), n3 = e3.readData(r3), this.extraFields[t4] = { id: t4, length: r3, value: n3 };
          e3.setIndex(i3);
        }, handleUTF8: function() {
          var e3 = u2.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o2.utf8decode(this.fileName), this.fileCommentStr = o2.utf8decode(this.fileComment);
          else {
            var t4 = this.findExtraFieldUnicodePath();
            if (null !== t4) this.fileNameStr = t4;
            else {
              var r3 = s2.transformTo(e3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r3);
            }
            var n3 = this.findExtraFieldUnicodeComment();
            if (null !== n3) this.fileCommentStr = n3;
            else {
              var i3 = s2.transformTo(e3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i3);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e3 = this.extraFields[28789];
          if (e3) {
            var t4 = n2(e3.value);
            return 1 !== t4.readInt(1) ? null : a2(this.fileName) !== t4.readInt(4) ? null : o2.utf8decode(t4.readData(e3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e3 = this.extraFields[25461];
          if (e3) {
            var t4 = n2(e3.value);
            return 1 !== t4.readInt(1) ? null : a2(this.fileComment) !== t4.readInt(4) ? null : o2.utf8decode(t4.readData(e3.length - 5));
          }
          return null;
        } }, t3.exports = l2;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t3, r2) {
        function n2(e3, t4, r3) {
          this.name = e3, this.dir = r3.dir, this.date = r3.date, this.comment = r3.comment, this.unixPermissions = r3.unixPermissions, this.dosPermissions = r3.dosPermissions, this._data = t4, this._dataBinary = r3.binary, this.options = { compression: r3.compression, compressionOptions: r3.compressionOptions };
        }
        var s2 = e2("./stream/StreamHelper"), i2 = e2("./stream/DataWorker"), a2 = e2("./utf8"), o2 = e2("./compressedObject"), h2 = e2("./stream/GenericWorker");
        n2.prototype = { internalStream: function(e3) {
          var t4 = null, r3 = "string";
          try {
            if (!e3) throw new Error("No output type specified.");
            var n3 = "string" === (r3 = e3.toLowerCase()) || "text" === r3;
            "binarystring" !== r3 && "text" !== r3 || (r3 = "string"), t4 = this._decompressWorker();
            var i3 = !this._dataBinary;
            i3 && !n3 && (t4 = t4.pipe(new a2.Utf8EncodeWorker())), !i3 && n3 && (t4 = t4.pipe(new a2.Utf8DecodeWorker()));
          } catch (e4) {
            (t4 = new h2("error")).error(e4);
          }
          return new s2(t4, r3, "");
        }, async: function(e3, t4) {
          return this.internalStream(e3).accumulate(t4);
        }, nodeStream: function(e3, t4) {
          return this.internalStream(e3 || "nodebuffer").toNodejsStream(t4);
        }, _compressWorker: function(e3, t4) {
          if (this._data instanceof o2 && this._data.compression.magic === e3.magic) return this._data.getCompressedWorker();
          var r3 = this._decompressWorker();
          return this._dataBinary || (r3 = r3.pipe(new a2.Utf8EncodeWorker())), o2.createWorkerFrom(r3, e3, t4);
        }, _decompressWorker: function() {
          return this._data instanceof o2 ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i2(this._data);
        } };
        for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f2 = 0; f2 < u2.length; f2++) n2.prototype[u2[f2]] = l2;
        t3.exports = n2;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l2, t3) {
        (function(t4) {
          var r2, n2, e3 = t4.MutationObserver || t4.WebKitMutationObserver;
          if (e3) {
            var i2 = 0, s2 = new e3(u2), a2 = t4.document.createTextNode("");
            s2.observe(a2, { characterData: true }), r2 = function() {
              a2.data = i2 = ++i2 % 2;
            };
          } else if (t4.setImmediate || void 0 === t4.MessageChannel) r2 = "document" in t4 && "onreadystatechange" in t4.document.createElement("script") ? function() {
            var e4 = t4.document.createElement("script");
            e4.onreadystatechange = function() {
              u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t4.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u2, 0);
          };
          else {
            var o2 = new t4.MessageChannel();
            o2.port1.onmessage = u2, r2 = function() {
              o2.port2.postMessage(0);
            };
          }
          var h2 = [];
          function u2() {
            var e4, t5;
            n2 = true;
            for (var r3 = h2.length; r3; ) {
              for (t5 = h2, h2 = [], e4 = -1; ++e4 < r3; ) t5[e4]();
              r3 = h2.length;
            }
            n2 = false;
          }
          l2.exports = function(e4) {
            1 !== h2.push(e4) || n2 || r2();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t3, r2) {
        var i2 = e2("immediate");
        function u2() {
        }
        var l2 = {}, s2 = ["REJECTED"], a2 = ["FULFILLED"], n2 = ["PENDING"];
        function o2(e3) {
          if ("function" != typeof e3) throw new TypeError("resolver must be a function");
          this.state = n2, this.queue = [], this.outcome = void 0, e3 !== u2 && d2(this, e3);
        }
        function h2(e3, t4, r3) {
          this.promise = e3, "function" == typeof t4 && (this.onFulfilled = t4, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r3 && (this.onRejected = r3, this.callRejected = this.otherCallRejected);
        }
        function f2(t4, r3, n3) {
          i2(function() {
            var e3;
            try {
              e3 = r3(n3);
            } catch (e4) {
              return l2.reject(t4, e4);
            }
            e3 === t4 ? l2.reject(t4, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t4, e3);
          });
        }
        function c2(e3) {
          var t4 = e3 && e3.then;
          if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t4) return function() {
            t4.apply(e3, arguments);
          };
        }
        function d2(t4, e3) {
          var r3 = false;
          function n3(e4) {
            r3 || (r3 = true, l2.reject(t4, e4));
          }
          function i3(e4) {
            r3 || (r3 = true, l2.resolve(t4, e4));
          }
          var s3 = p2(function() {
            e3(i3, n3);
          });
          "error" === s3.status && n3(s3.value);
        }
        function p2(e3, t4) {
          var r3 = {};
          try {
            r3.value = e3(t4), r3.status = "success";
          } catch (e4) {
            r3.status = "error", r3.value = e4;
          }
          return r3;
        }
        (t3.exports = o2).prototype.finally = function(t4) {
          if ("function" != typeof t4) return this;
          var r3 = this.constructor;
          return this.then(function(e3) {
            return r3.resolve(t4()).then(function() {
              return e3;
            });
          }, function(e3) {
            return r3.resolve(t4()).then(function() {
              throw e3;
            });
          });
        }, o2.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, o2.prototype.then = function(e3, t4) {
          if ("function" != typeof e3 && this.state === a2 || "function" != typeof t4 && this.state === s2) return this;
          var r3 = new this.constructor(u2);
          this.state !== n2 ? f2(r3, this.state === a2 ? e3 : t4, this.outcome) : this.queue.push(new h2(r3, e3, t4));
          return r3;
        }, h2.prototype.callFulfilled = function(e3) {
          l2.resolve(this.promise, e3);
        }, h2.prototype.otherCallFulfilled = function(e3) {
          f2(this.promise, this.onFulfilled, e3);
        }, h2.prototype.callRejected = function(e3) {
          l2.reject(this.promise, e3);
        }, h2.prototype.otherCallRejected = function(e3) {
          f2(this.promise, this.onRejected, e3);
        }, l2.resolve = function(e3, t4) {
          var r3 = p2(c2, t4);
          if ("error" === r3.status) return l2.reject(e3, r3.value);
          var n3 = r3.value;
          if (n3) d2(e3, n3);
          else {
            e3.state = a2, e3.outcome = t4;
            for (var i3 = -1, s3 = e3.queue.length; ++i3 < s3; ) e3.queue[i3].callFulfilled(t4);
          }
          return e3;
        }, l2.reject = function(e3, t4) {
          e3.state = s2, e3.outcome = t4;
          for (var r3 = -1, n3 = e3.queue.length; ++r3 < n3; ) e3.queue[r3].callRejected(t4);
          return e3;
        }, o2.resolve = function(e3) {
          if (e3 instanceof this) return e3;
          return l2.resolve(new this(u2), e3);
        }, o2.reject = function(e3) {
          var t4 = new this(u2);
          return l2.reject(t4, e3);
        }, o2.all = function(e3) {
          var r3 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
          var n3 = e3.length, i3 = false;
          if (!n3) return this.resolve([]);
          var s3 = new Array(n3), a3 = 0, t4 = -1, o3 = new this(u2);
          for (; ++t4 < n3; ) h3(e3[t4], t4);
          return o3;
          function h3(e4, t5) {
            r3.resolve(e4).then(function(e5) {
              s3[t5] = e5, ++a3 !== n3 || i3 || (i3 = true, l2.resolve(o3, s3));
            }, function(e5) {
              i3 || (i3 = true, l2.reject(o3, e5));
            });
          }
        }, o2.race = function(e3) {
          var t4 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
          var r3 = e3.length, n3 = false;
          if (!r3) return this.resolve([]);
          var i3 = -1, s3 = new this(u2);
          for (; ++i3 < r3; ) a3 = e3[i3], t4.resolve(a3).then(function(e4) {
            n3 || (n3 = true, l2.resolve(s3, e4));
          }, function(e4) {
            n3 || (n3 = true, l2.reject(s3, e4));
          });
          var a3;
          return s3;
        };
      }, { immediate: 36 }], 38: [function(e2, t3, r2) {
        var n2 = {};
        (0, e2("./lib/utils/common").assign)(n2, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t3.exports = n2;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t3, r2) {
        var a2 = e2("./zlib/deflate"), o2 = e2("./utils/common"), h2 = e2("./utils/strings"), i2 = e2("./zlib/messages"), s2 = e2("./zlib/zstream"), u2 = Object.prototype.toString, l2 = 0, f2 = -1, c2 = 0, d2 = 8;
        function p2(e3) {
          if (!(this instanceof p2)) return new p2(e3);
          this.options = o2.assign({ level: f2, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
          var t4 = this.options;
          t4.raw && 0 < t4.windowBits ? t4.windowBits = -t4.windowBits : t4.gzip && 0 < t4.windowBits && t4.windowBits < 16 && (t4.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s2(), this.strm.avail_out = 0;
          var r3 = a2.deflateInit2(this.strm, t4.level, t4.method, t4.windowBits, t4.memLevel, t4.strategy);
          if (r3 !== l2) throw new Error(i2[r3]);
          if (t4.header && a2.deflateSetHeader(this.strm, t4.header), t4.dictionary) {
            var n3;
            if (n3 = "string" == typeof t4.dictionary ? h2.string2buf(t4.dictionary) : "[object ArrayBuffer]" === u2.call(t4.dictionary) ? new Uint8Array(t4.dictionary) : t4.dictionary, (r3 = a2.deflateSetDictionary(this.strm, n3)) !== l2) throw new Error(i2[r3]);
            this._dict_set = true;
          }
        }
        function n2(e3, t4) {
          var r3 = new p2(t4);
          if (r3.push(e3, true), r3.err) throw r3.msg || i2[r3.err];
          return r3.result;
        }
        p2.prototype.push = function(e3, t4) {
          var r3, n3, i3 = this.strm, s3 = this.options.chunkSize;
          if (this.ended) return false;
          n3 = t4 === ~~t4 ? t4 : true === t4 ? 4 : 0, "string" == typeof e3 ? i3.input = h2.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i3.input = new Uint8Array(e3) : i3.input = e3, i3.next_in = 0, i3.avail_in = i3.input.length;
          do {
            if (0 === i3.avail_out && (i3.output = new o2.Buf8(s3), i3.next_out = 0, i3.avail_out = s3), 1 !== (r3 = a2.deflate(i3, n3)) && r3 !== l2) return this.onEnd(r3), !(this.ended = true);
            0 !== i3.avail_out && (0 !== i3.avail_in || 4 !== n3 && 2 !== n3) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o2.shrinkBuf(i3.output, i3.next_out))) : this.onData(o2.shrinkBuf(i3.output, i3.next_out)));
          } while ((0 < i3.avail_in || 0 === i3.avail_out) && 1 !== r3);
          return 4 === n3 ? (r3 = a2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === l2) : 2 !== n3 || (this.onEnd(l2), !(i3.avail_out = 0));
        }, p2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, p2.prototype.onEnd = function(e3) {
          e3 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Deflate = p2, r2.deflate = n2, r2.deflateRaw = function(e3, t4) {
          return (t4 = t4 || {}).raw = true, n2(e3, t4);
        }, r2.gzip = function(e3, t4) {
          return (t4 = t4 || {}).gzip = true, n2(e3, t4);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t3, r2) {
        var c2 = e2("./zlib/inflate"), d2 = e2("./utils/common"), p2 = e2("./utils/strings"), m2 = e2("./zlib/constants"), n2 = e2("./zlib/messages"), i2 = e2("./zlib/zstream"), s2 = e2("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a2(e3) {
          if (!(this instanceof a2)) return new a2(e3);
          this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t4 = this.options;
          t4.raw && 0 <= t4.windowBits && t4.windowBits < 16 && (t4.windowBits = -t4.windowBits, 0 === t4.windowBits && (t4.windowBits = -15)), !(0 <= t4.windowBits && t4.windowBits < 16) || e3 && e3.windowBits || (t4.windowBits += 32), 15 < t4.windowBits && t4.windowBits < 48 && 0 == (15 & t4.windowBits) && (t4.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i2(), this.strm.avail_out = 0;
          var r3 = c2.inflateInit2(this.strm, t4.windowBits);
          if (r3 !== m2.Z_OK) throw new Error(n2[r3]);
          this.header = new s2(), c2.inflateGetHeader(this.strm, this.header);
        }
        function o2(e3, t4) {
          var r3 = new a2(t4);
          if (r3.push(e3, true), r3.err) throw r3.msg || n2[r3.err];
          return r3.result;
        }
        a2.prototype.push = function(e3, t4) {
          var r3, n3, i3, s3, a3, o3, h2 = this.strm, u2 = this.options.chunkSize, l2 = this.options.dictionary, f2 = false;
          if (this.ended) return false;
          n3 = t4 === ~~t4 ? t4 : true === t4 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e3 ? h2.input = p2.binstring2buf(e3) : "[object ArrayBuffer]" === _2.call(e3) ? h2.input = new Uint8Array(e3) : h2.input = e3, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d2.Buf8(u2), h2.next_out = 0, h2.avail_out = u2), (r3 = c2.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l2 && (o3 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _2.call(l2) ? new Uint8Array(l2) : l2, r3 = c2.inflateSetDictionary(this.strm, o3)), r3 === m2.Z_BUF_ERROR && true === f2 && (r3 = m2.Z_OK, f2 = false), r3 !== m2.Z_STREAM_END && r3 !== m2.Z_OK) return this.onEnd(r3), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r3 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n3 !== m2.Z_FINISH && n3 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i3 = p2.utf8border(h2.output, h2.next_out), s3 = h2.next_out - i3, a3 = p2.buf2string(h2.output, i3), h2.next_out = s3, h2.avail_out = u2 - s3, s3 && d2.arraySet(h2.output, h2.output, i3, s3, 0), this.onData(a3)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f2 = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r3 !== m2.Z_STREAM_END);
          return r3 === m2.Z_STREAM_END && (n3 = m2.Z_FINISH), n3 === m2.Z_FINISH ? (r3 = c2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === m2.Z_OK) : n3 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
        }, a2.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, a2.prototype.onEnd = function(e3) {
          e3 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r2.Inflate = a2, r2.inflate = o2, r2.inflateRaw = function(e3, t4) {
          return (t4 = t4 || {}).raw = true, o2(e3, t4);
        }, r2.ungzip = o2;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t3, r2) {
        var n2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e3) {
          for (var t4 = Array.prototype.slice.call(arguments, 1); t4.length; ) {
            var r3 = t4.shift();
            if (r3) {
              if ("object" != typeof r3) throw new TypeError(r3 + "must be non-object");
              for (var n3 in r3) r3.hasOwnProperty(n3) && (e3[n3] = r3[n3]);
            }
          }
          return e3;
        }, r2.shrinkBuf = function(e3, t4) {
          return e3.length === t4 ? e3 : e3.subarray ? e3.subarray(0, t4) : (e3.length = t4, e3);
        };
        var i2 = { arraySet: function(e3, t4, r3, n3, i3) {
          if (t4.subarray && e3.subarray) e3.set(t4.subarray(r3, r3 + n3), i3);
          else for (var s3 = 0; s3 < n3; s3++) e3[i3 + s3] = t4[r3 + s3];
        }, flattenChunks: function(e3) {
          var t4, r3, n3, i3, s3, a2;
          for (t4 = n3 = 0, r3 = e3.length; t4 < r3; t4++) n3 += e3[t4].length;
          for (a2 = new Uint8Array(n3), t4 = i3 = 0, r3 = e3.length; t4 < r3; t4++) s3 = e3[t4], a2.set(s3, i3), i3 += s3.length;
          return a2;
        } }, s2 = { arraySet: function(e3, t4, r3, n3, i3) {
          for (var s3 = 0; s3 < n3; s3++) e3[i3 + s3] = t4[r3 + s3];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        r2.setTyped = function(e3) {
          e3 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i2)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s2));
        }, r2.setTyped(n2);
      }, {}], 42: [function(e2, t3, r2) {
        var h2 = e2("./common"), i2 = true, s2 = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          i2 = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          s2 = false;
        }
        for (var u2 = new h2.Buf8(256), n2 = 0; n2 < 256; n2++) u2[n2] = 252 <= n2 ? 6 : 248 <= n2 ? 5 : 240 <= n2 ? 4 : 224 <= n2 ? 3 : 192 <= n2 ? 2 : 1;
        function l2(e3, t4) {
          if (t4 < 65537 && (e3.subarray && s2 || !e3.subarray && i2)) return String.fromCharCode.apply(null, h2.shrinkBuf(e3, t4));
          for (var r3 = "", n3 = 0; n3 < t4; n3++) r3 += String.fromCharCode(e3[n3]);
          return r3;
        }
        u2[254] = u2[254] = 1, r2.string2buf = function(e3) {
          var t4, r3, n3, i3, s3, a2 = e3.length, o2 = 0;
          for (i3 = 0; i3 < a2; i3++) 55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), o2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
          for (t4 = new h2.Buf8(o2), i3 = s3 = 0; s3 < o2; i3++) 55296 == (64512 & (r3 = e3.charCodeAt(i3))) && i3 + 1 < a2 && 56320 == (64512 & (n3 = e3.charCodeAt(i3 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320), i3++), r3 < 128 ? t4[s3++] = r3 : (r3 < 2048 ? t4[s3++] = 192 | r3 >>> 6 : (r3 < 65536 ? t4[s3++] = 224 | r3 >>> 12 : (t4[s3++] = 240 | r3 >>> 18, t4[s3++] = 128 | r3 >>> 12 & 63), t4[s3++] = 128 | r3 >>> 6 & 63), t4[s3++] = 128 | 63 & r3);
          return t4;
        }, r2.buf2binstring = function(e3) {
          return l2(e3, e3.length);
        }, r2.binstring2buf = function(e3) {
          for (var t4 = new h2.Buf8(e3.length), r3 = 0, n3 = t4.length; r3 < n3; r3++) t4[r3] = e3.charCodeAt(r3);
          return t4;
        }, r2.buf2string = function(e3, t4) {
          var r3, n3, i3, s3, a2 = t4 || e3.length, o2 = new Array(2 * a2);
          for (r3 = n3 = 0; r3 < a2; ) if ((i3 = e3[r3++]) < 128) o2[n3++] = i3;
          else if (4 < (s3 = u2[i3])) o2[n3++] = 65533, r3 += s3 - 1;
          else {
            for (i3 &= 2 === s3 ? 31 : 3 === s3 ? 15 : 7; 1 < s3 && r3 < a2; ) i3 = i3 << 6 | 63 & e3[r3++], s3--;
            1 < s3 ? o2[n3++] = 65533 : i3 < 65536 ? o2[n3++] = i3 : (i3 -= 65536, o2[n3++] = 55296 | i3 >> 10 & 1023, o2[n3++] = 56320 | 1023 & i3);
          }
          return l2(o2, n3);
        }, r2.utf8border = function(e3, t4) {
          var r3;
          for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
          return r3 < 0 ? t4 : 0 === r3 ? t4 : r3 + u2[e3[r3]] > t4 ? r3 : t4;
        };
      }, { "./common": 41 }], 43: [function(e2, t3, r2) {
        t3.exports = function(e3, t4, r3, n2) {
          for (var i2 = 65535 & e3 | 0, s2 = e3 >>> 16 & 65535 | 0, a2 = 0; 0 !== r3; ) {
            for (r3 -= a2 = 2e3 < r3 ? 2e3 : r3; s2 = s2 + (i2 = i2 + t4[n2++] | 0) | 0, --a2; ) ;
            i2 %= 65521, s2 %= 65521;
          }
          return i2 | s2 << 16 | 0;
        };
      }, {}], 44: [function(e2, t3, r2) {
        t3.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t3, r2) {
        var o2 = (function() {
          for (var e3, t4 = [], r3 = 0; r3 < 256; r3++) {
            e3 = r3;
            for (var n2 = 0; n2 < 8; n2++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t4[r3] = e3;
          }
          return t4;
        })();
        t3.exports = function(e3, t4, r3, n2) {
          var i2 = o2, s2 = n2 + r3;
          e3 ^= -1;
          for (var a2 = n2; a2 < s2; a2++) e3 = e3 >>> 8 ^ i2[255 & (e3 ^ t4[a2])];
          return -1 ^ e3;
        };
      }, {}], 46: [function(e2, t3, r2) {
        var h2, c2 = e2("../utils/common"), u2 = e2("./trees"), d2 = e2("./adler32"), p2 = e2("./crc32"), n2 = e2("./messages"), l2 = 0, f2 = 4, m2 = 0, _2 = -2, g2 = -1, b2 = 4, i2 = 2, v2 = 8, y2 = 9, s2 = 286, a2 = 30, o2 = 19, w2 = 2 * s2 + 1, k2 = 15, x2 = 3, S2 = 258, z2 = S2 + x2 + 1, C2 = 42, E2 = 113, A2 = 1, I2 = 2, O2 = 3, B3 = 4;
        function R2(e3, t4) {
          return e3.msg = n2[t4], t4;
        }
        function T2(e3) {
          return (e3 << 1) - (4 < e3 ? 9 : 0);
        }
        function D2(e3) {
          for (var t4 = e3.length; 0 <= --t4; ) e3[t4] = 0;
        }
        function F2(e3) {
          var t4 = e3.state, r3 = t4.pending;
          r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (c2.arraySet(e3.output, t4.pending_buf, t4.pending_out, r3, e3.next_out), e3.next_out += r3, t4.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t4.pending -= r3, 0 === t4.pending && (t4.pending_out = 0));
        }
        function N2(e3, t4) {
          u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t4), e3.block_start = e3.strstart, F2(e3.strm);
        }
        function U2(e3, t4) {
          e3.pending_buf[e3.pending++] = t4;
        }
        function P2(e3, t4) {
          e3.pending_buf[e3.pending++] = t4 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t4;
        }
        function L2(e3, t4) {
          var r3, n3, i3 = e3.max_chain_length, s3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match, h3 = e3.strstart > e3.w_size - z2 ? e3.strstart - (e3.w_size - z2) : 0, u3 = e3.window, l3 = e3.w_mask, f3 = e3.prev, c3 = e3.strstart + S2, d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
          e3.prev_length >= e3.good_match && (i3 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
          do {
            if (u3[(r3 = t4) + a3] === p3 && u3[r3 + a3 - 1] === d3 && u3[r3] === u3[s3] && u3[++r3] === u3[s3 + 1]) {
              s3 += 2, r3++;
              do {
              } while (u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && u3[++s3] === u3[++r3] && s3 < c3);
              if (n3 = S2 - (c3 - s3), s3 = c3 - S2, a3 < n3) {
                if (e3.match_start = t4, o3 <= (a3 = n3)) break;
                d3 = u3[s3 + a3 - 1], p3 = u3[s3 + a3];
              }
            }
          } while ((t4 = f3[t4 & l3]) > h3 && 0 != --i3);
          return a3 <= e3.lookahead ? a3 : e3.lookahead;
        }
        function j2(e3) {
          var t4, r3, n3, i3, s3, a3, o3, h3, u3, l3, f3 = e3.w_size;
          do {
            if (i3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f3 + (f3 - z2)) {
              for (c2.arraySet(e3.window, e3.window, f3, f3, 0), e3.match_start -= f3, e3.strstart -= f3, e3.block_start -= f3, t4 = r3 = e3.hash_size; n3 = e3.head[--t4], e3.head[t4] = f3 <= n3 ? n3 - f3 : 0, --r3; ) ;
              for (t4 = r3 = f3; n3 = e3.prev[--t4], e3.prev[t4] = f3 <= n3 ? n3 - f3 : 0, --r3; ) ;
              i3 += f3;
            }
            if (0 === e3.strm.avail_in) break;
            if (a3 = e3.strm, o3 = e3.window, h3 = e3.strstart + e3.lookahead, u3 = i3, l3 = void 0, l3 = a3.avail_in, u3 < l3 && (l3 = u3), r3 = 0 === l3 ? 0 : (a3.avail_in -= l3, c2.arraySet(o3, a3.input, a3.next_in, l3, h3), 1 === a3.state.wrap ? a3.adler = d2(a3.adler, o3, l3, h3) : 2 === a3.state.wrap && (a3.adler = p2(a3.adler, o3, l3, h3)), a3.next_in += l3, a3.total_in += l3, l3), e3.lookahead += r3, e3.lookahead + e3.insert >= x2) for (s3 = e3.strstart - e3.insert, e3.ins_h = e3.window[s3], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s3 + x2 - 1]) & e3.hash_mask, e3.prev[s3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s3, s3++, e3.insert--, !(e3.lookahead + e3.insert < x2)); ) ;
          } while (e3.lookahead < z2 && 0 !== e3.strm.avail_in);
        }
        function Z2(e3, t4) {
          for (var r3, n3; ; ) {
            if (e3.lookahead < z2) {
              if (j2(e3), e3.lookahead < z2 && t4 === l2) return A2;
              if (0 === e3.lookahead) break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3)), e3.match_length >= x2) if (n3 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x2) {
              for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; ) ;
              e3.strstart++;
            } else e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (n3 && (N2(e3, false), 0 === e3.strm.avail_out)) return A2;
          }
          return e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t4 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B3) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
        }
        function W2(e3, t4) {
          for (var r3, n3, i3; ; ) {
            if (e3.lookahead < z2) {
              if (j2(e3), e3.lookahead < z2 && t4 === l2) return A2;
              if (0 === e3.lookahead) break;
            }
            if (r3 = 0, e3.lookahead >= x2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x2 - 1, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - z2 && (e3.match_length = L2(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x2 && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x2 - 1)), e3.prev_length >= x2 && e3.match_length <= e3.prev_length) {
              for (i3 = e3.strstart + e3.lookahead - x2, n3 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x2), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x2 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; ) ;
              if (e3.match_available = 0, e3.match_length = x2 - 1, e3.strstart++, n3 && (N2(e3, false), 0 === e3.strm.avail_out)) return A2;
            } else if (e3.match_available) {
              if ((n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N2(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out) return A2;
            } else e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (n3 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x2 - 1 ? e3.strstart : x2 - 1, t4 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B3) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
        }
        function M2(e3, t4, r3, n3, i3) {
          this.good_length = e3, this.max_lazy = t4, this.nice_length = r3, this.max_chain = n3, this.func = i3;
        }
        function H4() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a2 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o2 + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k2 + 1), this.heap = new c2.Buf16(2 * s2 + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s2 + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G2(e3) {
          var t4;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i2, (t4 = e3.state).pending = 0, t4.pending_out = 0, t4.wrap < 0 && (t4.wrap = -t4.wrap), t4.status = t4.wrap ? C2 : E2, e3.adler = 2 === t4.wrap ? 0 : 1, t4.last_flush = l2, u2._tr_init(t4), m2) : R2(e3, _2);
        }
        function K2(e3) {
          var t4 = G2(e3);
          return t4 === m2 && (function(e4) {
            e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h2[e4.level].max_lazy, e4.good_match = h2[e4.level].good_length, e4.nice_match = h2[e4.level].nice_length, e4.max_chain_length = h2[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x2 - 1, e4.match_available = 0, e4.ins_h = 0;
          })(e3.state), t4;
        }
        function Y2(e3, t4, r3, n3, i3, s3) {
          if (!e3) return _2;
          var a3 = 1;
          if (t4 === g2 && (t4 = 6), n3 < 0 ? (a3 = 0, n3 = -n3) : 15 < n3 && (a3 = 2, n3 -= 16), i3 < 1 || y2 < i3 || r3 !== v2 || n3 < 8 || 15 < n3 || t4 < 0 || 9 < t4 || s3 < 0 || b2 < s3) return R2(e3, _2);
          8 === n3 && (n3 = 9);
          var o3 = new H4();
          return (e3.state = o3).strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = n3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = i3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + x2 - 1) / x2), o3.window = new c2.Buf8(2 * o3.w_size), o3.head = new c2.Buf16(o3.hash_size), o3.prev = new c2.Buf16(o3.w_size), o3.lit_bufsize = 1 << i3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new c2.Buf8(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t4, o3.strategy = s3, o3.method = r3, K2(e3);
        }
        h2 = [new M2(0, 0, 0, 0, function(e3, t4) {
          var r3 = 65535;
          for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (j2(e3), 0 === e3.lookahead && t4 === l2) return A2;
              if (0 === e3.lookahead) break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var n3 = e3.block_start + r3;
            if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, N2(e3, false), 0 === e3.strm.avail_out)) return A2;
            if (e3.strstart - e3.block_start >= e3.w_size - z2 && (N2(e3, false), 0 === e3.strm.avail_out)) return A2;
          }
          return e3.insert = 0, t4 === f2 ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B3) : (e3.strstart > e3.block_start && (N2(e3, false), e3.strm.avail_out), A2);
        }), new M2(4, 4, 8, 4, Z2), new M2(4, 5, 16, 8, Z2), new M2(4, 6, 32, 32, Z2), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r2.deflateInit = function(e3, t4) {
          return Y2(e3, t4, v2, 15, 8, 0);
        }, r2.deflateInit2 = Y2, r2.deflateReset = K2, r2.deflateResetKeep = G2, r2.deflateSetHeader = function(e3, t4) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? _2 : (e3.state.gzhead = t4, m2) : _2;
        }, r2.deflate = function(e3, t4) {
          var r3, n3, i3, s3;
          if (!e3 || !e3.state || 5 < t4 || t4 < 0) return e3 ? R2(e3, _2) : _2;
          if (n3 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n3.status && t4 !== f2) return R2(e3, 0 === e3.avail_out ? -5 : _2);
          if (n3.strm = e3, r3 = n3.last_flush, n3.last_flush = t4, n3.status === C2) if (2 === n3.wrap) e3.adler = 0, U2(n3, 31), U2(n3, 139), U2(n3, 8), n3.gzhead ? (U2(n3, (n3.gzhead.text ? 1 : 0) + (n3.gzhead.hcrc ? 2 : 0) + (n3.gzhead.extra ? 4 : 0) + (n3.gzhead.name ? 8 : 0) + (n3.gzhead.comment ? 16 : 0)), U2(n3, 255 & n3.gzhead.time), U2(n3, n3.gzhead.time >> 8 & 255), U2(n3, n3.gzhead.time >> 16 & 255), U2(n3, n3.gzhead.time >> 24 & 255), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 255 & n3.gzhead.os), n3.gzhead.extra && n3.gzhead.extra.length && (U2(n3, 255 & n3.gzhead.extra.length), U2(n3, n3.gzhead.extra.length >> 8 & 255)), n3.gzhead.hcrc && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending, 0)), n3.gzindex = 0, n3.status = 69) : (U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 0), U2(n3, 9 === n3.level ? 2 : 2 <= n3.strategy || n3.level < 2 ? 4 : 0), U2(n3, 3), n3.status = E2);
          else {
            var a3 = v2 + (n3.w_bits - 8 << 4) << 8;
            a3 |= (2 <= n3.strategy || n3.level < 2 ? 0 : n3.level < 6 ? 1 : 6 === n3.level ? 2 : 3) << 6, 0 !== n3.strstart && (a3 |= 32), a3 += 31 - a3 % 31, n3.status = E2, P2(n3, a3), 0 !== n3.strstart && (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), e3.adler = 1;
          }
          if (69 === n3.status) if (n3.gzhead.extra) {
            for (i3 = n3.pending; n3.gzindex < (65535 & n3.gzhead.extra.length) && (n3.pending !== n3.pending_buf_size || (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending !== n3.pending_buf_size)); ) U2(n3, 255 & n3.gzhead.extra[n3.gzindex]), n3.gzindex++;
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), n3.gzindex === n3.gzhead.extra.length && (n3.gzindex = 0, n3.status = 73);
          } else n3.status = 73;
          if (73 === n3.status) if (n3.gzhead.name) {
            i3 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.name.length ? 255 & n3.gzhead.name.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.gzindex = 0, n3.status = 91);
          } else n3.status = 91;
          if (91 === n3.status) if (n3.gzhead.comment) {
            i3 = n3.pending;
            do {
              if (n3.pending === n3.pending_buf_size && (n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), F2(e3), i3 = n3.pending, n3.pending === n3.pending_buf_size)) {
                s3 = 1;
                break;
              }
              s3 = n3.gzindex < n3.gzhead.comment.length ? 255 & n3.gzhead.comment.charCodeAt(n3.gzindex++) : 0, U2(n3, s3);
            } while (0 !== s3);
            n3.gzhead.hcrc && n3.pending > i3 && (e3.adler = p2(e3.adler, n3.pending_buf, n3.pending - i3, i3)), 0 === s3 && (n3.status = 103);
          } else n3.status = 103;
          if (103 === n3.status && (n3.gzhead.hcrc ? (n3.pending + 2 > n3.pending_buf_size && F2(e3), n3.pending + 2 <= n3.pending_buf_size && (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), e3.adler = 0, n3.status = E2)) : n3.status = E2), 0 !== n3.pending) {
            if (F2(e3), 0 === e3.avail_out) return n3.last_flush = -1, m2;
          } else if (0 === e3.avail_in && T2(t4) <= T2(r3) && t4 !== f2) return R2(e3, -5);
          if (666 === n3.status && 0 !== e3.avail_in) return R2(e3, -5);
          if (0 !== e3.avail_in || 0 !== n3.lookahead || t4 !== l2 && 666 !== n3.status) {
            var o3 = 2 === n3.strategy ? (function(e4, t5) {
              for (var r4; ; ) {
                if (0 === e4.lookahead && (j2(e4), 0 === e4.lookahead)) {
                  if (t5 === l2) return A2;
                  break;
                }
                if (e4.match_length = 0, r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (N2(e4, false), 0 === e4.strm.avail_out)) return A2;
              }
              return e4.insert = 0, t5 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B3) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
            })(n3, t4) : 3 === n3.strategy ? (function(e4, t5) {
              for (var r4, n4, i4, s4, a4 = e4.window; ; ) {
                if (e4.lookahead <= S2) {
                  if (j2(e4), e4.lookahead <= S2 && t5 === l2) return A2;
                  if (0 === e4.lookahead) break;
                }
                if (e4.match_length = 0, e4.lookahead >= x2 && 0 < e4.strstart && (n4 = a4[i4 = e4.strstart - 1]) === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4]) {
                  s4 = e4.strstart + S2;
                  do {
                  } while (n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && n4 === a4[++i4] && i4 < s4);
                  e4.match_length = S2 - (s4 - i4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= x2 ? (r4 = u2._tr_tally(e4, 1, e4.match_length - x2), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (N2(e4, false), 0 === e4.strm.avail_out)) return A2;
              }
              return e4.insert = 0, t5 === f2 ? (N2(e4, true), 0 === e4.strm.avail_out ? O2 : B3) : e4.last_lit && (N2(e4, false), 0 === e4.strm.avail_out) ? A2 : I2;
            })(n3, t4) : h2[n3.level].func(n3, t4);
            if (o3 !== O2 && o3 !== B3 || (n3.status = 666), o3 === A2 || o3 === O2) return 0 === e3.avail_out && (n3.last_flush = -1), m2;
            if (o3 === I2 && (1 === t4 ? u2._tr_align(n3) : 5 !== t4 && (u2._tr_stored_block(n3, 0, 0, false), 3 === t4 && (D2(n3.head), 0 === n3.lookahead && (n3.strstart = 0, n3.block_start = 0, n3.insert = 0))), F2(e3), 0 === e3.avail_out)) return n3.last_flush = -1, m2;
          }
          return t4 !== f2 ? m2 : n3.wrap <= 0 ? 1 : (2 === n3.wrap ? (U2(n3, 255 & e3.adler), U2(n3, e3.adler >> 8 & 255), U2(n3, e3.adler >> 16 & 255), U2(n3, e3.adler >> 24 & 255), U2(n3, 255 & e3.total_in), U2(n3, e3.total_in >> 8 & 255), U2(n3, e3.total_in >> 16 & 255), U2(n3, e3.total_in >> 24 & 255)) : (P2(n3, e3.adler >>> 16), P2(n3, 65535 & e3.adler)), F2(e3), 0 < n3.wrap && (n3.wrap = -n3.wrap), 0 !== n3.pending ? m2 : 1);
        }, r2.deflateEnd = function(e3) {
          var t4;
          return e3 && e3.state ? (t4 = e3.state.status) !== C2 && 69 !== t4 && 73 !== t4 && 91 !== t4 && 103 !== t4 && t4 !== E2 && 666 !== t4 ? R2(e3, _2) : (e3.state = null, t4 === E2 ? R2(e3, -3) : m2) : _2;
        }, r2.deflateSetDictionary = function(e3, t4) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l3 = t4.length;
          if (!e3 || !e3.state) return _2;
          if (2 === (s3 = (r3 = e3.state).wrap) || 1 === s3 && r3.status !== C2 || r3.lookahead) return _2;
          for (1 === s3 && (e3.adler = d2(e3.adler, t4, l3, 0)), r3.wrap = 0, l3 >= r3.w_size && (0 === s3 && (D2(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u3 = new c2.Buf8(r3.w_size), c2.arraySet(u3, t4, l3 - r3.w_size, r3.w_size, 0), t4 = u3, l3 = r3.w_size), a3 = e3.avail_in, o3 = e3.next_in, h3 = e3.input, e3.avail_in = l3, e3.next_in = 0, e3.input = t4, j2(r3); r3.lookahead >= x2; ) {
            for (n3 = r3.strstart, i3 = r3.lookahead - (x2 - 1); r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + x2 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++, --i3; ) ;
            r3.strstart = n3, r3.lookahead = x2 - 1, j2(r3);
          }
          return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = x2 - 1, r3.match_available = 0, e3.next_in = o3, e3.input = h3, e3.avail_in = a3, r3.wrap = s3, m2;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t3, r2) {
        t3.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t3, r2) {
        t3.exports = function(e3, t4) {
          var r3, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2;
          r3 = e3.state, n2 = e3.next_in, z2 = e3.input, i2 = n2 + (e3.avail_in - 5), s2 = e3.next_out, C2 = e3.output, a2 = s2 - (t4 - e3.avail_out), o2 = s2 + (e3.avail_out - 257), h2 = r3.dmax, u2 = r3.wsize, l2 = r3.whave, f2 = r3.wnext, c2 = r3.window, d2 = r3.hold, p2 = r3.bits, m2 = r3.lencode, _2 = r3.distcode, g2 = (1 << r3.lenbits) - 1, b2 = (1 << r3.distbits) - 1;
          e: do {
            p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = m2[d2 & g2];
            t: for (; ; ) {
              if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, 0 === (y2 = v2 >>> 16 & 255)) C2[s2++] = 65535 & v2;
              else {
                if (!(16 & y2)) {
                  if (0 == (64 & y2)) {
                    v2 = m2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                    continue t;
                  }
                  if (32 & y2) {
                    r3.mode = 12;
                    break e;
                  }
                  e3.msg = "invalid literal/length code", r3.mode = 30;
                  break e;
                }
                w2 = 65535 & v2, (y2 &= 15) && (p2 < y2 && (d2 += z2[n2++] << p2, p2 += 8), w2 += d2 & (1 << y2) - 1, d2 >>>= y2, p2 -= y2), p2 < 15 && (d2 += z2[n2++] << p2, p2 += 8, d2 += z2[n2++] << p2, p2 += 8), v2 = _2[d2 & b2];
                r: for (; ; ) {
                  if (d2 >>>= y2 = v2 >>> 24, p2 -= y2, !(16 & (y2 = v2 >>> 16 & 255))) {
                    if (0 == (64 & y2)) {
                      v2 = _2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                      continue r;
                    }
                    e3.msg = "invalid distance code", r3.mode = 30;
                    break e;
                  }
                  if (k2 = 65535 & v2, p2 < (y2 &= 15) && (d2 += z2[n2++] << p2, (p2 += 8) < y2 && (d2 += z2[n2++] << p2, p2 += 8)), h2 < (k2 += d2 & (1 << y2) - 1)) {
                    e3.msg = "invalid distance too far back", r3.mode = 30;
                    break e;
                  }
                  if (d2 >>>= y2, p2 -= y2, (y2 = s2 - a2) < k2) {
                    if (l2 < (y2 = k2 - y2) && r3.sane) {
                      e3.msg = "invalid distance too far back", r3.mode = 30;
                      break e;
                    }
                    if (S2 = c2, (x2 = 0) === f2) {
                      if (x2 += u2 - y2, y2 < w2) {
                        for (w2 -= y2; C2[s2++] = c2[x2++], --y2; ) ;
                        x2 = s2 - k2, S2 = C2;
                      }
                    } else if (f2 < y2) {
                      if (x2 += u2 + f2 - y2, (y2 -= f2) < w2) {
                        for (w2 -= y2; C2[s2++] = c2[x2++], --y2; ) ;
                        if (x2 = 0, f2 < w2) {
                          for (w2 -= y2 = f2; C2[s2++] = c2[x2++], --y2; ) ;
                          x2 = s2 - k2, S2 = C2;
                        }
                      }
                    } else if (x2 += f2 - y2, y2 < w2) {
                      for (w2 -= y2; C2[s2++] = c2[x2++], --y2; ) ;
                      x2 = s2 - k2, S2 = C2;
                    }
                    for (; 2 < w2; ) C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], C2[s2++] = S2[x2++], w2 -= 3;
                    w2 && (C2[s2++] = S2[x2++], 1 < w2 && (C2[s2++] = S2[x2++]));
                  } else {
                    for (x2 = s2 - k2; C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], C2[s2++] = C2[x2++], 2 < (w2 -= 3); ) ;
                    w2 && (C2[s2++] = C2[x2++], 1 < w2 && (C2[s2++] = C2[x2++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n2 < i2 && s2 < o2);
          n2 -= w2 = p2 >> 3, d2 &= (1 << (p2 -= w2 << 3)) - 1, e3.next_in = n2, e3.next_out = s2, e3.avail_in = n2 < i2 ? i2 - n2 + 5 : 5 - (n2 - i2), e3.avail_out = s2 < o2 ? o2 - s2 + 257 : 257 - (s2 - o2), r3.hold = d2, r3.bits = p2;
        };
      }, {}], 49: [function(e2, t3, r2) {
        var I2 = e2("../utils/common"), O2 = e2("./adler32"), B3 = e2("./crc32"), R2 = e2("./inffast"), T2 = e2("./inftrees"), D2 = 1, F2 = 2, N2 = 0, U2 = -2, P2 = 1, n2 = 852, i2 = 592;
        function L2(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        function s2() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a2(e3) {
          var t4;
          return e3 && e3.state ? (t4 = e3.state, e3.total_in = e3.total_out = t4.total = 0, e3.msg = "", t4.wrap && (e3.adler = 1 & t4.wrap), t4.mode = P2, t4.last = 0, t4.havedict = 0, t4.dmax = 32768, t4.head = null, t4.hold = 0, t4.bits = 0, t4.lencode = t4.lendyn = new I2.Buf32(n2), t4.distcode = t4.distdyn = new I2.Buf32(i2), t4.sane = 1, t4.back = -1, N2) : U2;
        }
        function o2(e3) {
          var t4;
          return e3 && e3.state ? ((t4 = e3.state).wsize = 0, t4.whave = 0, t4.wnext = 0, a2(e3)) : U2;
        }
        function h2(e3, t4) {
          var r3, n3;
          return e3 && e3.state ? (n3 = e3.state, t4 < 0 ? (r3 = 0, t4 = -t4) : (r3 = 1 + (t4 >> 4), t4 < 48 && (t4 &= 15)), t4 && (t4 < 8 || 15 < t4) ? U2 : (null !== n3.window && n3.wbits !== t4 && (n3.window = null), n3.wrap = r3, n3.wbits = t4, o2(e3))) : U2;
        }
        function u2(e3, t4) {
          var r3, n3;
          return e3 ? (n3 = new s2(), (e3.state = n3).window = null, (r3 = h2(e3, t4)) !== N2 && (e3.state = null), r3) : U2;
        }
        var l2, f2, c2 = true;
        function j2(e3) {
          if (c2) {
            var t4;
            for (l2 = new I2.Buf32(512), f2 = new I2.Buf32(32), t4 = 0; t4 < 144; ) e3.lens[t4++] = 8;
            for (; t4 < 256; ) e3.lens[t4++] = 9;
            for (; t4 < 280; ) e3.lens[t4++] = 7;
            for (; t4 < 288; ) e3.lens[t4++] = 8;
            for (T2(D2, e3.lens, 0, 288, l2, 0, e3.work, { bits: 9 }), t4 = 0; t4 < 32; ) e3.lens[t4++] = 5;
            T2(F2, e3.lens, 0, 32, f2, 0, e3.work, { bits: 5 }), c2 = false;
          }
          e3.lencode = l2, e3.lenbits = 9, e3.distcode = f2, e3.distbits = 5;
        }
        function Z2(e3, t4, r3, n3) {
          var i3, s3 = e3.state;
          return null === s3.window && (s3.wsize = 1 << s3.wbits, s3.wnext = 0, s3.whave = 0, s3.window = new I2.Buf8(s3.wsize)), n3 >= s3.wsize ? (I2.arraySet(s3.window, t4, r3 - s3.wsize, s3.wsize, 0), s3.wnext = 0, s3.whave = s3.wsize) : (n3 < (i3 = s3.wsize - s3.wnext) && (i3 = n3), I2.arraySet(s3.window, t4, r3 - n3, i3, s3.wnext), (n3 -= i3) ? (I2.arraySet(s3.window, t4, r3 - n3, n3, 0), s3.wnext = n3, s3.whave = s3.wsize) : (s3.wnext += i3, s3.wnext === s3.wsize && (s3.wnext = 0), s3.whave < s3.wsize && (s3.whave += i3))), 0;
        }
        r2.inflateReset = o2, r2.inflateReset2 = h2, r2.inflateResetKeep = a2, r2.inflateInit = function(e3) {
          return u2(e3, 15);
        }, r2.inflateInit2 = u2, r2.inflate = function(e3, t4) {
          var r3, n3, i3, s3, a3, o3, h3, u3, l3, f3, c3, d2, p2, m2, _2, g2, b2, v2, y2, w2, k2, x2, S2, z2, C2 = 0, E2 = new I2.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in) return U2;
          12 === (r3 = e3.state).mode && (r3.mode = 13), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, f3 = o3, c3 = h3, x2 = N2;
          e: for (; ; ) switch (r3.mode) {
            case P2:
              if (0 === r3.wrap) {
                r3.mode = 13;
                break;
              }
              for (; l3 < 16; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if (2 & r3.wrap && 35615 === u3) {
                E2[r3.check = 0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B3(r3.check, E2, 2, 0), l3 = u3 = 0, r3.mode = 2;
                break;
              }
              if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                e3.msg = "incorrect header check", r3.mode = 30;
                break;
              }
              if (8 != (15 & u3)) {
                e3.msg = "unknown compression method", r3.mode = 30;
                break;
              }
              if (l3 -= 4, k2 = 8 + (15 & (u3 >>>= 4)), 0 === r3.wbits) r3.wbits = k2;
              else if (k2 > r3.wbits) {
                e3.msg = "invalid window size", r3.mode = 30;
                break;
              }
              r3.dmax = 1 << k2, e3.adler = r3.check = 1, r3.mode = 512 & u3 ? 10 : 12, l3 = u3 = 0;
              break;
            case 2:
              for (; l3 < 16; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if (r3.flags = u3, 8 != (255 & r3.flags)) {
                e3.msg = "unknown compression method", r3.mode = 30;
                break;
              }
              if (57344 & r3.flags) {
                e3.msg = "unknown header flags set", r3.mode = 30;
                break;
              }
              r3.head && (r3.head.text = u3 >> 8 & 1), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B3(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 3;
            case 3:
              for (; l3 < 32; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              r3.head && (r3.head.time = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, E2[2] = u3 >>> 16 & 255, E2[3] = u3 >>> 24 & 255, r3.check = B3(r3.check, E2, 4, 0)), l3 = u3 = 0, r3.mode = 4;
            case 4:
              for (; l3 < 16; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              r3.head && (r3.head.xflags = 255 & u3, r3.head.os = u3 >> 8), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B3(r3.check, E2, 2, 0)), l3 = u3 = 0, r3.mode = 5;
            case 5:
              if (1024 & r3.flags) {
                for (; l3 < 16; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.length = u3, r3.head && (r3.head.extra_len = u3), 512 & r3.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r3.check = B3(r3.check, E2, 2, 0)), l3 = u3 = 0;
              } else r3.head && (r3.head.extra = null);
              r3.mode = 6;
            case 6:
              if (1024 & r3.flags && (o3 < (d2 = r3.length) && (d2 = o3), d2 && (r3.head && (k2 = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), I2.arraySet(r3.head.extra, n3, s3, d2, k2)), 512 & r3.flags && (r3.check = B3(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, r3.length -= d2), r3.length)) break e;
              r3.length = 0, r3.mode = 7;
            case 7:
              if (2048 & r3.flags) {
                if (0 === o3) break e;
                for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.name += String.fromCharCode(k2)), k2 && d2 < o3; ) ;
                if (512 & r3.flags && (r3.check = B3(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2) break e;
              } else r3.head && (r3.head.name = null);
              r3.length = 0, r3.mode = 8;
            case 8:
              if (4096 & r3.flags) {
                if (0 === o3) break e;
                for (d2 = 0; k2 = n3[s3 + d2++], r3.head && k2 && r3.length < 65536 && (r3.head.comment += String.fromCharCode(k2)), k2 && d2 < o3; ) ;
                if (512 & r3.flags && (r3.check = B3(r3.check, n3, d2, s3)), o3 -= d2, s3 += d2, k2) break e;
              } else r3.head && (r3.head.comment = null);
              r3.mode = 9;
            case 9:
              if (512 & r3.flags) {
                for (; l3 < 16; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (u3 !== (65535 & r3.check)) {
                  e3.msg = "header crc mismatch", r3.mode = 30;
                  break;
                }
                l3 = u3 = 0;
              }
              r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = 12;
              break;
            case 10:
              for (; l3 < 32; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              e3.adler = r3.check = L2(u3), l3 = u3 = 0, r3.mode = 11;
            case 11:
              if (0 === r3.havedict) return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, 2;
              e3.adler = r3.check = 1, r3.mode = 12;
            case 12:
              if (5 === t4 || 6 === t4) break e;
            case 13:
              if (r3.last) {
                u3 >>>= 7 & l3, l3 -= 7 & l3, r3.mode = 27;
                break;
              }
              for (; l3 < 3; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              switch (r3.last = 1 & u3, l3 -= 1, 3 & (u3 >>>= 1)) {
                case 0:
                  r3.mode = 14;
                  break;
                case 1:
                  if (j2(r3), r3.mode = 20, 6 !== t4) break;
                  u3 >>>= 2, l3 -= 2;
                  break e;
                case 2:
                  r3.mode = 17;
                  break;
                case 3:
                  e3.msg = "invalid block type", r3.mode = 30;
              }
              u3 >>>= 2, l3 -= 2;
              break;
            case 14:
              for (u3 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                e3.msg = "invalid stored block lengths", r3.mode = 30;
                break;
              }
              if (r3.length = 65535 & u3, l3 = u3 = 0, r3.mode = 15, 6 === t4) break e;
            case 15:
              r3.mode = 16;
            case 16:
              if (d2 = r3.length) {
                if (o3 < d2 && (d2 = o3), h3 < d2 && (d2 = h3), 0 === d2) break e;
                I2.arraySet(i3, n3, s3, d2, a3), o3 -= d2, s3 += d2, h3 -= d2, a3 += d2, r3.length -= d2;
                break;
              }
              r3.mode = 12;
              break;
            case 17:
              for (; l3 < 14; ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if (r3.nlen = 257 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ndist = 1 + (31 & u3), u3 >>>= 5, l3 -= 5, r3.ncode = 4 + (15 & u3), u3 >>>= 4, l3 -= 4, 286 < r3.nlen || 30 < r3.ndist) {
                e3.msg = "too many length or distance symbols", r3.mode = 30;
                break;
              }
              r3.have = 0, r3.mode = 18;
            case 18:
              for (; r3.have < r3.ncode; ) {
                for (; l3 < 3; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.lens[A2[r3.have++]] = 7 & u3, u3 >>>= 3, l3 -= 3;
              }
              for (; r3.have < 19; ) r3.lens[A2[r3.have++]] = 0;
              if (r3.lencode = r3.lendyn, r3.lenbits = 7, S2 = { bits: r3.lenbits }, x2 = T2(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                e3.msg = "invalid code lengths set", r3.mode = 30;
                break;
              }
              r3.have = 0, r3.mode = 19;
            case 19:
              for (; r3.have < r3.nlen + r3.ndist; ) {
                for (; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (b2 < 16) u3 >>>= _2, l3 -= _2, r3.lens[r3.have++] = b2;
                else {
                  if (16 === b2) {
                    for (z2 = _2 + 2; l3 < z2; ) {
                      if (0 === o3) break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    if (u3 >>>= _2, l3 -= _2, 0 === r3.have) {
                      e3.msg = "invalid bit length repeat", r3.mode = 30;
                      break;
                    }
                    k2 = r3.lens[r3.have - 1], d2 = 3 + (3 & u3), u3 >>>= 2, l3 -= 2;
                  } else if (17 === b2) {
                    for (z2 = _2 + 3; l3 < z2; ) {
                      if (0 === o3) break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    l3 -= _2, k2 = 0, d2 = 3 + (7 & (u3 >>>= _2)), u3 >>>= 3, l3 -= 3;
                  } else {
                    for (z2 = _2 + 7; l3 < z2; ) {
                      if (0 === o3) break e;
                      o3--, u3 += n3[s3++] << l3, l3 += 8;
                    }
                    l3 -= _2, k2 = 0, d2 = 11 + (127 & (u3 >>>= _2)), u3 >>>= 7, l3 -= 7;
                  }
                  if (r3.have + d2 > r3.nlen + r3.ndist) {
                    e3.msg = "invalid bit length repeat", r3.mode = 30;
                    break;
                  }
                  for (; d2--; ) r3.lens[r3.have++] = k2;
                }
              }
              if (30 === r3.mode) break;
              if (0 === r3.lens[256]) {
                e3.msg = "invalid code -- missing end-of-block", r3.mode = 30;
                break;
              }
              if (r3.lenbits = 9, S2 = { bits: r3.lenbits }, x2 = T2(D2, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, S2), r3.lenbits = S2.bits, x2) {
                e3.msg = "invalid literal/lengths set", r3.mode = 30;
                break;
              }
              if (r3.distbits = 6, r3.distcode = r3.distdyn, S2 = { bits: r3.distbits }, x2 = T2(F2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, S2), r3.distbits = S2.bits, x2) {
                e3.msg = "invalid distances set", r3.mode = 30;
                break;
              }
              if (r3.mode = 20, 6 === t4) break e;
            case 20:
              r3.mode = 21;
            case 21:
              if (6 <= o3 && 258 <= h3) {
                e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, R2(e3, c3), a3 = e3.next_out, i3 = e3.output, h3 = e3.avail_out, s3 = e3.next_in, n3 = e3.input, o3 = e3.avail_in, u3 = r3.hold, l3 = r3.bits, 12 === r3.mode && (r3.back = -1);
                break;
              }
              for (r3.back = 0; g2 = (C2 = r3.lencode[u3 & (1 << r3.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if (g2 && 0 == (240 & g2)) {
                for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.lencode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l3); ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                u3 >>>= v2, l3 -= v2, r3.back += v2;
              }
              if (u3 >>>= _2, l3 -= _2, r3.back += _2, r3.length = b2, 0 === g2) {
                r3.mode = 26;
                break;
              }
              if (32 & g2) {
                r3.back = -1, r3.mode = 12;
                break;
              }
              if (64 & g2) {
                e3.msg = "invalid literal/length code", r3.mode = 30;
                break;
              }
              r3.extra = 15 & g2, r3.mode = 22;
            case 22:
              if (r3.extra) {
                for (z2 = r3.extra; l3 < z2; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.length += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
              }
              r3.was = r3.length, r3.mode = 23;
            case 23:
              for (; g2 = (C2 = r3.distcode[u3 & (1 << r3.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l3); ) {
                if (0 === o3) break e;
                o3--, u3 += n3[s3++] << l3, l3 += 8;
              }
              if (0 == (240 & g2)) {
                for (v2 = _2, y2 = g2, w2 = b2; g2 = (C2 = r3.distcode[w2 + ((u3 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l3); ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                u3 >>>= v2, l3 -= v2, r3.back += v2;
              }
              if (u3 >>>= _2, l3 -= _2, r3.back += _2, 64 & g2) {
                e3.msg = "invalid distance code", r3.mode = 30;
                break;
              }
              r3.offset = b2, r3.extra = 15 & g2, r3.mode = 24;
            case 24:
              if (r3.extra) {
                for (z2 = r3.extra; l3 < z2; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                r3.offset += u3 & (1 << r3.extra) - 1, u3 >>>= r3.extra, l3 -= r3.extra, r3.back += r3.extra;
              }
              if (r3.offset > r3.dmax) {
                e3.msg = "invalid distance too far back", r3.mode = 30;
                break;
              }
              r3.mode = 25;
            case 25:
              if (0 === h3) break e;
              if (d2 = c3 - h3, r3.offset > d2) {
                if ((d2 = r3.offset - d2) > r3.whave && r3.sane) {
                  e3.msg = "invalid distance too far back", r3.mode = 30;
                  break;
                }
                p2 = d2 > r3.wnext ? (d2 -= r3.wnext, r3.wsize - d2) : r3.wnext - d2, d2 > r3.length && (d2 = r3.length), m2 = r3.window;
              } else m2 = i3, p2 = a3 - r3.offset, d2 = r3.length;
              for (h3 < d2 && (d2 = h3), h3 -= d2, r3.length -= d2; i3[a3++] = m2[p2++], --d2; ) ;
              0 === r3.length && (r3.mode = 21);
              break;
            case 26:
              if (0 === h3) break e;
              i3[a3++] = r3.length, h3--, r3.mode = 21;
              break;
            case 27:
              if (r3.wrap) {
                for (; l3 < 32; ) {
                  if (0 === o3) break e;
                  o3--, u3 |= n3[s3++] << l3, l3 += 8;
                }
                if (c3 -= h3, e3.total_out += c3, r3.total += c3, c3 && (e3.adler = r3.check = r3.flags ? B3(r3.check, i3, c3, a3 - c3) : O2(r3.check, i3, c3, a3 - c3)), c3 = h3, (r3.flags ? u3 : L2(u3)) !== r3.check) {
                  e3.msg = "incorrect data check", r3.mode = 30;
                  break;
                }
                l3 = u3 = 0;
              }
              r3.mode = 28;
            case 28:
              if (r3.wrap && r3.flags) {
                for (; l3 < 32; ) {
                  if (0 === o3) break e;
                  o3--, u3 += n3[s3++] << l3, l3 += 8;
                }
                if (u3 !== (4294967295 & r3.total)) {
                  e3.msg = "incorrect length check", r3.mode = 30;
                  break;
                }
                l3 = u3 = 0;
              }
              r3.mode = 29;
            case 29:
              x2 = 1;
              break e;
            case 30:
              x2 = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U2;
          }
          return e3.next_out = a3, e3.avail_out = h3, e3.next_in = s3, e3.avail_in = o3, r3.hold = u3, r3.bits = l3, (r3.wsize || c3 !== e3.avail_out && r3.mode < 30 && (r3.mode < 27 || 4 !== t4)) && Z2(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r3.mode = 31, -4) : (f3 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f3, e3.total_out += c3, r3.total += c3, r3.wrap && c3 && (e3.adler = r3.check = r3.flags ? B3(r3.check, i3, c3, e3.next_out - c3) : O2(r3.check, i3, c3, e3.next_out - c3)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (12 === r3.mode ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 == f3 && 0 === c3 || 4 === t4) && x2 === N2 && (x2 = -5), x2);
        }, r2.inflateEnd = function(e3) {
          if (!e3 || !e3.state) return U2;
          var t4 = e3.state;
          return t4.window && (t4.window = null), e3.state = null, N2;
        }, r2.inflateGetHeader = function(e3, t4) {
          var r3;
          return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? U2 : ((r3.head = t4).done = false, N2) : U2;
        }, r2.inflateSetDictionary = function(e3, t4) {
          var r3, n3 = t4.length;
          return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? U2 : 11 === r3.mode && O2(1, t4, n3, 0) !== r3.check ? -3 : Z2(e3, t4, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, N2) : U2;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t3, r2) {
        var D2 = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t3.exports = function(e3, t4, r3, n2, i2, s2, a2, o2) {
          var h2, u2, l2, f2, c2, d2, p2, m2, _2, g2 = o2.bits, b2 = 0, v2 = 0, y2 = 0, w2 = 0, k2 = 0, x2 = 0, S2 = 0, z2 = 0, C2 = 0, E2 = 0, A2 = null, I2 = 0, O2 = new D2.Buf16(16), B3 = new D2.Buf16(16), R2 = null, T2 = 0;
          for (b2 = 0; b2 <= 15; b2++) O2[b2] = 0;
          for (v2 = 0; v2 < n2; v2++) O2[t4[r3 + v2]]++;
          for (k2 = g2, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--) ;
          if (w2 < k2 && (k2 = w2), 0 === w2) return i2[s2++] = 20971520, i2[s2++] = 20971520, o2.bits = 1, 0;
          for (y2 = 1; y2 < w2 && 0 === O2[y2]; y2++) ;
          for (k2 < y2 && (k2 = y2), b2 = z2 = 1; b2 <= 15; b2++) if (z2 <<= 1, (z2 -= O2[b2]) < 0) return -1;
          if (0 < z2 && (0 === e3 || 1 !== w2)) return -1;
          for (B3[1] = 0, b2 = 1; b2 < 15; b2++) B3[b2 + 1] = B3[b2] + O2[b2];
          for (v2 = 0; v2 < n2; v2++) 0 !== t4[r3 + v2] && (a2[B3[t4[r3 + v2]]++] = v2);
          if (d2 = 0 === e3 ? (A2 = R2 = a2, 19) : 1 === e3 ? (A2 = F2, I2 -= 257, R2 = N2, T2 -= 257, 256) : (A2 = U2, R2 = P2, -1), b2 = y2, c2 = s2, S2 = v2 = E2 = 0, l2 = -1, f2 = (C2 = 1 << (x2 = k2)) - 1, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2) return 1;
          for (; ; ) {
            for (p2 = b2 - S2, _2 = a2[v2] < d2 ? (m2 = 0, a2[v2]) : a2[v2] > d2 ? (m2 = R2[T2 + a2[v2]], A2[I2 + a2[v2]]) : (m2 = 96, 0), h2 = 1 << b2 - S2, y2 = u2 = 1 << x2; i2[c2 + (E2 >> S2) + (u2 -= h2)] = p2 << 24 | m2 << 16 | _2 | 0, 0 !== u2; ) ;
            for (h2 = 1 << b2 - 1; E2 & h2; ) h2 >>= 1;
            if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v2++, 0 == --O2[b2]) {
              if (b2 === w2) break;
              b2 = t4[r3 + a2[v2]];
            }
            if (k2 < b2 && (E2 & f2) !== l2) {
              for (0 === S2 && (S2 = k2), c2 += y2, z2 = 1 << (x2 = b2 - S2); x2 + S2 < w2 && !((z2 -= O2[x2 + S2]) <= 0); ) x2++, z2 <<= 1;
              if (C2 += 1 << x2, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2) return 1;
              i2[l2 = E2 & f2] = k2 << 24 | x2 << 16 | c2 - s2 | 0;
            }
          }
          return 0 !== E2 && (i2[c2 + E2] = b2 - S2 << 24 | 64 << 16 | 0), o2.bits = k2, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t3, r2) {
        t3.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t3, r2) {
        var i2 = e2("../utils/common"), o2 = 0, h2 = 1;
        function n2(e3) {
          for (var t4 = e3.length; 0 <= --t4; ) e3[t4] = 0;
        }
        var s2 = 0, a2 = 29, u2 = 256, l2 = u2 + 1 + a2, f2 = 30, c2 = 19, _2 = 2 * l2 + 1, g2 = 15, d2 = 16, p2 = 7, m2 = 256, b2 = 16, v2 = 17, y2 = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l2 + 2));
        n2(z2);
        var C2 = new Array(2 * f2);
        n2(C2);
        var E2 = new Array(512);
        n2(E2);
        var A2 = new Array(256);
        n2(A2);
        var I2 = new Array(a2);
        n2(I2);
        var O2, B3, R2, T2 = new Array(f2);
        function D2(e3, t4, r3, n3, i3) {
          this.static_tree = e3, this.extra_bits = t4, this.extra_base = r3, this.elems = n3, this.max_length = i3, this.has_stree = e3 && e3.length;
        }
        function F2(e3, t4) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t4;
        }
        function N2(e3) {
          return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
        }
        function U2(e3, t4) {
          e3.pending_buf[e3.pending++] = 255 & t4, e3.pending_buf[e3.pending++] = t4 >>> 8 & 255;
        }
        function P2(e3, t4, r3) {
          e3.bi_valid > d2 - r3 ? (e3.bi_buf |= t4 << e3.bi_valid & 65535, U2(e3, e3.bi_buf), e3.bi_buf = t4 >> d2 - e3.bi_valid, e3.bi_valid += r3 - d2) : (e3.bi_buf |= t4 << e3.bi_valid & 65535, e3.bi_valid += r3);
        }
        function L2(e3, t4, r3) {
          P2(e3, r3[2 * t4], r3[2 * t4 + 1]);
        }
        function j2(e3, t4) {
          for (var r3 = 0; r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1, 0 < --t4; ) ;
          return r3 >>> 1;
        }
        function Z2(e3, t4, r3) {
          var n3, i3, s3 = new Array(g2 + 1), a3 = 0;
          for (n3 = 1; n3 <= g2; n3++) s3[n3] = a3 = a3 + r3[n3 - 1] << 1;
          for (i3 = 0; i3 <= t4; i3++) {
            var o3 = e3[2 * i3 + 1];
            0 !== o3 && (e3[2 * i3] = j2(s3[o3]++, o3));
          }
        }
        function W2(e3) {
          var t4;
          for (t4 = 0; t4 < l2; t4++) e3.dyn_ltree[2 * t4] = 0;
          for (t4 = 0; t4 < f2; t4++) e3.dyn_dtree[2 * t4] = 0;
          for (t4 = 0; t4 < c2; t4++) e3.bl_tree[2 * t4] = 0;
          e3.dyn_ltree[2 * m2] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        function M2(e3) {
          8 < e3.bi_valid ? U2(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        function H4(e3, t4, r3, n3) {
          var i3 = 2 * t4, s3 = 2 * r3;
          return e3[i3] < e3[s3] || e3[i3] === e3[s3] && n3[t4] <= n3[r3];
        }
        function G2(e3, t4, r3) {
          for (var n3 = e3.heap[r3], i3 = r3 << 1; i3 <= e3.heap_len && (i3 < e3.heap_len && H4(t4, e3.heap[i3 + 1], e3.heap[i3], e3.depth) && i3++, !H4(t4, n3, e3.heap[i3], e3.depth)); ) e3.heap[r3] = e3.heap[i3], r3 = i3, i3 <<= 1;
          e3.heap[r3] = n3;
        }
        function K2(e3, t4, r3) {
          var n3, i3, s3, a3, o3 = 0;
          if (0 !== e3.last_lit) for (; n3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], i3 = e3.pending_buf[e3.l_buf + o3], o3++, 0 === n3 ? L2(e3, i3, t4) : (L2(e3, (s3 = A2[i3]) + u2 + 1, t4), 0 !== (a3 = w2[s3]) && P2(e3, i3 -= I2[s3], a3), L2(e3, s3 = N2(--n3), r3), 0 !== (a3 = k2[s3]) && P2(e3, n3 -= T2[s3], a3)), o3 < e3.last_lit; ) ;
          L2(e3, m2, t4);
        }
        function Y2(e3, t4) {
          var r3, n3, i3, s3 = t4.dyn_tree, a3 = t4.stat_desc.static_tree, o3 = t4.stat_desc.has_stree, h3 = t4.stat_desc.elems, u3 = -1;
          for (e3.heap_len = 0, e3.heap_max = _2, r3 = 0; r3 < h3; r3++) 0 !== s3[2 * r3] ? (e3.heap[++e3.heap_len] = u3 = r3, e3.depth[r3] = 0) : s3[2 * r3 + 1] = 0;
          for (; e3.heap_len < 2; ) s3[2 * (i3 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i3] = 0, e3.opt_len--, o3 && (e3.static_len -= a3[2 * i3 + 1]);
          for (t4.max_code = u3, r3 = e3.heap_len >> 1; 1 <= r3; r3--) G2(e3, s3, r3);
          for (i3 = h3; r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s3, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, s3[2 * i3] = s3[2 * r3] + s3[2 * n3], e3.depth[i3] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, s3[2 * r3 + 1] = s3[2 * n3 + 1] = i3, e3.heap[1] = i3++, G2(e3, s3, 1), 2 <= e3.heap_len; ) ;
          e3.heap[--e3.heap_max] = e3.heap[1], (function(e4, t5) {
            var r4, n4, i4, s4, a4, o4, h4 = t5.dyn_tree, u4 = t5.max_code, l3 = t5.stat_desc.static_tree, f3 = t5.stat_desc.has_stree, c3 = t5.stat_desc.extra_bits, d3 = t5.stat_desc.extra_base, p3 = t5.stat_desc.max_length, m3 = 0;
            for (s4 = 0; s4 <= g2; s4++) e4.bl_count[s4] = 0;
            for (h4[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < _2; r4++) p3 < (s4 = h4[2 * h4[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) && (s4 = p3, m3++), h4[2 * n4 + 1] = s4, u4 < n4 || (e4.bl_count[s4]++, a4 = 0, d3 <= n4 && (a4 = c3[n4 - d3]), o4 = h4[2 * n4], e4.opt_len += o4 * (s4 + a4), f3 && (e4.static_len += o4 * (l3[2 * n4 + 1] + a4)));
            if (0 !== m3) {
              do {
                for (s4 = p3 - 1; 0 === e4.bl_count[s4]; ) s4--;
                e4.bl_count[s4]--, e4.bl_count[s4 + 1] += 2, e4.bl_count[p3]--, m3 -= 2;
              } while (0 < m3);
              for (s4 = p3; 0 !== s4; s4--) for (n4 = e4.bl_count[s4]; 0 !== n4; ) u4 < (i4 = e4.heap[--r4]) || (h4[2 * i4 + 1] !== s4 && (e4.opt_len += (s4 - h4[2 * i4 + 1]) * h4[2 * i4], h4[2 * i4 + 1] = s4), n4--);
            }
          })(e3, t4), Z2(s3, u3, e3.bl_count);
        }
        function X2(e3, t4, r3) {
          var n3, i3, s3 = -1, a3 = t4[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), t4[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++) i3 = a3, a3 = t4[2 * (n3 + 1) + 1], ++o3 < h3 && i3 === a3 || (o3 < u3 ? e3.bl_tree[2 * i3] += o3 : 0 !== i3 ? (i3 !== s3 && e3.bl_tree[2 * i3]++, e3.bl_tree[2 * b2]++) : o3 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y2]++, s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4));
        }
        function V2(e3, t4, r3) {
          var n3, i3, s3 = -1, a3 = t4[1], o3 = 0, h3 = 7, u3 = 4;
          for (0 === a3 && (h3 = 138, u3 = 3), n3 = 0; n3 <= r3; n3++) if (i3 = a3, a3 = t4[2 * (n3 + 1) + 1], !(++o3 < h3 && i3 === a3)) {
            if (o3 < u3) for (; L2(e3, i3, e3.bl_tree), 0 != --o3; ) ;
            else 0 !== i3 ? (i3 !== s3 && (L2(e3, i3, e3.bl_tree), o3--), L2(e3, b2, e3.bl_tree), P2(e3, o3 - 3, 2)) : o3 <= 10 ? (L2(e3, v2, e3.bl_tree), P2(e3, o3 - 3, 3)) : (L2(e3, y2, e3.bl_tree), P2(e3, o3 - 11, 7));
            s3 = i3, u3 = (o3 = 0) === a3 ? (h3 = 138, 3) : i3 === a3 ? (h3 = 6, 3) : (h3 = 7, 4);
          }
        }
        n2(T2);
        var q2 = false;
        function J2(e3, t4, r3, n3) {
          P2(e3, (s2 << 1) + (n3 ? 1 : 0), 3), (function(e4, t5, r4, n4) {
            M2(e4), U2(e4, r4), U2(e4, ~r4), i2.arraySet(e4.pending_buf, e4.window, t5, r4, e4.pending), e4.pending += r4;
          })(e3, t4, r3);
        }
        r2._tr_init = function(e3) {
          q2 || ((function() {
            var e4, t4, r3, n3, i3, s3 = new Array(g2 + 1);
            for (n3 = r3 = 0; n3 < a2 - 1; n3++) for (I2[n3] = r3, e4 = 0; e4 < 1 << w2[n3]; e4++) A2[r3++] = n3;
            for (A2[r3 - 1] = n3, n3 = i3 = 0; n3 < 16; n3++) for (T2[n3] = i3, e4 = 0; e4 < 1 << k2[n3]; e4++) E2[i3++] = n3;
            for (i3 >>= 7; n3 < f2; n3++) for (T2[n3] = i3 << 7, e4 = 0; e4 < 1 << k2[n3] - 7; e4++) E2[256 + i3++] = n3;
            for (t4 = 0; t4 <= g2; t4++) s3[t4] = 0;
            for (e4 = 0; e4 <= 143; ) z2[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (; e4 <= 255; ) z2[2 * e4 + 1] = 9, e4++, s3[9]++;
            for (; e4 <= 279; ) z2[2 * e4 + 1] = 7, e4++, s3[7]++;
            for (; e4 <= 287; ) z2[2 * e4 + 1] = 8, e4++, s3[8]++;
            for (Z2(z2, l2 + 1, s3), e4 = 0; e4 < f2; e4++) C2[2 * e4 + 1] = 5, C2[2 * e4] = j2(e4, 5);
            O2 = new D2(z2, w2, u2 + 1, l2, g2), B3 = new D2(C2, k2, 0, f2, g2), R2 = new D2(new Array(0), x2, 0, c2, p2);
          })(), q2 = true), e3.l_desc = new F2(e3.dyn_ltree, O2), e3.d_desc = new F2(e3.dyn_dtree, B3), e3.bl_desc = new F2(e3.bl_tree, R2), e3.bi_buf = 0, e3.bi_valid = 0, W2(e3);
        }, r2._tr_stored_block = J2, r2._tr_flush_block = function(e3, t4, r3, n3) {
          var i3, s3, a3 = 0;
          0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = (function(e4) {
            var t5, r4 = 4093624447;
            for (t5 = 0; t5 <= 31; t5++, r4 >>>= 1) if (1 & r4 && 0 !== e4.dyn_ltree[2 * t5]) return o2;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26]) return h2;
            for (t5 = 32; t5 < u2; t5++) if (0 !== e4.dyn_ltree[2 * t5]) return h2;
            return o2;
          })(e3)), Y2(e3, e3.l_desc), Y2(e3, e3.d_desc), a3 = (function(e4) {
            var t5;
            for (X2(e4, e4.dyn_ltree, e4.l_desc.max_code), X2(e4, e4.dyn_dtree, e4.d_desc.max_code), Y2(e4, e4.bl_desc), t5 = c2 - 1; 3 <= t5 && 0 === e4.bl_tree[2 * S2[t5] + 1]; t5--) ;
            return e4.opt_len += 3 * (t5 + 1) + 5 + 5 + 4, t5;
          })(e3), i3 = e3.opt_len + 3 + 7 >>> 3, (s3 = e3.static_len + 3 + 7 >>> 3) <= i3 && (i3 = s3)) : i3 = s3 = r3 + 5, r3 + 4 <= i3 && -1 !== t4 ? J2(e3, t4, r3, n3) : 4 === e3.strategy || s3 === i3 ? (P2(e3, 2 + (n3 ? 1 : 0), 3), K2(e3, z2, C2)) : (P2(e3, 4 + (n3 ? 1 : 0), 3), (function(e4, t5, r4, n4) {
            var i4;
            for (P2(e4, t5 - 257, 5), P2(e4, r4 - 1, 5), P2(e4, n4 - 4, 4), i4 = 0; i4 < n4; i4++) P2(e4, e4.bl_tree[2 * S2[i4] + 1], 3);
            V2(e4, e4.dyn_ltree, t5 - 1), V2(e4, e4.dyn_dtree, r4 - 1);
          })(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), K2(e3, e3.dyn_ltree, e3.dyn_dtree)), W2(e3), n3 && M2(e3);
        }, r2._tr_tally = function(e3, t4, r3) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t4 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t4, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t4 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t4--, e3.dyn_ltree[2 * (A2[r3] + u2 + 1)]++, e3.dyn_dtree[2 * N2(t4)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, r2._tr_align = function(e3) {
          P2(e3, 2, 3), L2(e3, m2, z2), (function(e4) {
            16 === e4.bi_valid ? (U2(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          })(e3);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t3, r2) {
        t3.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t3, r2) {
        (function(e3) {
          !(function(r3, n2) {
            if (!r3.setImmediate) {
              var i2, s2, t4, a2, o2 = 1, h2 = {}, u2 = false, l2 = r3.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r3);
              e4 = e4 && e4.setTimeout ? e4 : r3, i2 = "[object process]" === {}.toString.call(r3.process) ? function(e5) {
                process.nextTick(function() {
                  c2(e5);
                });
              } : (function() {
                if (r3.postMessage && !r3.importScripts) {
                  var e5 = true, t5 = r3.onmessage;
                  return r3.onmessage = function() {
                    e5 = false;
                  }, r3.postMessage("", "*"), r3.onmessage = t5, e5;
                }
              })() ? (a2 = "setImmediate$" + Math.random() + "$", r3.addEventListener ? r3.addEventListener("message", d2, false) : r3.attachEvent("onmessage", d2), function(e5) {
                r3.postMessage(a2 + e5, "*");
              }) : r3.MessageChannel ? ((t4 = new MessageChannel()).port1.onmessage = function(e5) {
                c2(e5.data);
              }, function(e5) {
                t4.port2.postMessage(e5);
              }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s2 = l2.documentElement, function(e5) {
                var t5 = l2.createElement("script");
                t5.onreadystatechange = function() {
                  c2(e5), t5.onreadystatechange = null, s2.removeChild(t5), t5 = null;
                }, s2.appendChild(t5);
              }) : function(e5) {
                setTimeout(c2, 0, e5);
              }, e4.setImmediate = function(e5) {
                "function" != typeof e5 && (e5 = new Function("" + e5));
                for (var t5 = new Array(arguments.length - 1), r4 = 0; r4 < t5.length; r4++) t5[r4] = arguments[r4 + 1];
                var n3 = { callback: e5, args: t5 };
                return h2[o2] = n3, i2(o2), o2++;
              }, e4.clearImmediate = f2;
            }
            function f2(e5) {
              delete h2[e5];
            }
            function c2(e5) {
              if (u2) setTimeout(c2, 0, e5);
              else {
                var t5 = h2[e5];
                if (t5) {
                  u2 = true;
                  try {
                    !(function(e6) {
                      var t6 = e6.callback, r4 = e6.args;
                      switch (r4.length) {
                        case 0:
                          t6();
                          break;
                        case 1:
                          t6(r4[0]);
                          break;
                        case 2:
                          t6(r4[0], r4[1]);
                          break;
                        case 3:
                          t6(r4[0], r4[1], r4[2]);
                          break;
                        default:
                          t6.apply(n2, r4);
                      }
                    })(t5);
                  } finally {
                    f2(e5), u2 = false;
                  }
                }
              }
            }
            function d2(e5) {
              e5.source === r3 && "string" == typeof e5.data && 0 === e5.data.indexOf(a2) && c2(+e5.data.slice(a2.length));
            }
          })("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
var jszip_minExports = requireJszip_min();
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
var fabric = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredFabric;
function requireFabric() {
  if (hasRequiredFabric) return fabric;
  hasRequiredFabric = 1;
  (function(exports) {
    /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
    var fabric$1 = fabric$1 || { version: "5.3.0" };
    {
      exports.fabric = fabric$1;
    }
    if (typeof document !== "undefined" && typeof window !== "undefined") {
      if (document instanceof (typeof HTMLDocument !== "undefined" ? HTMLDocument : Document)) {
        fabric$1.document = document;
      } else {
        fabric$1.document = document.implementation.createHTMLDocument("");
      }
      fabric$1.window = window;
    } else {
      var jsdom = require$$2;
      var virtualWindow = new jsdom.JSDOM(
        decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"),
        {
          features: {
            FetchExternalResources: ["img"]
          },
          resources: "usable"
        }
      ).window;
      fabric$1.document = virtualWindow.document;
      fabric$1.jsdomImplForWrapper = require$$2.implForWrapper;
      fabric$1.nodeCanvas = require$$2.Canvas;
      fabric$1.window = virtualWindow;
      DOMParser = fabric$1.window.DOMParser;
    }
    fabric$1.isTouchSupported = "ontouchstart" in fabric$1.window || "ontouchstart" in fabric$1.document || fabric$1.window && fabric$1.window.navigator && fabric$1.window.navigator.maxTouchPoints > 0;
    fabric$1.isLikelyNode = typeof Buffer !== "undefined" && typeof window === "undefined";
    fabric$1.SHARED_ATTRIBUTES = [
      "display",
      "transform",
      "fill",
      "fill-opacity",
      "fill-rule",
      "opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-linecap",
      "stroke-dashoffset",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "id",
      "paint-order",
      "vector-effect",
      "instantiated_by_use",
      "clip-path"
    ];
    fabric$1.DPI = 96;
    fabric$1.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)";
    fabric$1.commaWsp = "(?:\\s+,?\\s*|,\\s*)";
    fabric$1.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
    fabric$1.reNonWord = /[ \n\.,;!\?\-]/;
    fabric$1.fontPaths = {};
    fabric$1.iMatrix = [1, 0, 0, 1, 0, 0];
    fabric$1.svgNS = "http://www.w3.org/2000/svg";
    fabric$1.perfLimitSizeTotal = 2097152;
    fabric$1.maxCacheSideLimit = 4096;
    fabric$1.minCacheSideLimit = 256;
    fabric$1.charWidthsCache = {};
    fabric$1.textureSize = 2048;
    fabric$1.disableStyleCopyPaste = false;
    fabric$1.enableGLFiltering = true;
    fabric$1.devicePixelRatio = fabric$1.window.devicePixelRatio || fabric$1.window.webkitDevicePixelRatio || fabric$1.window.mozDevicePixelRatio || 1;
    fabric$1.browserShadowBlurConstant = 1;
    fabric$1.arcToSegmentsCache = {};
    fabric$1.boundsOfCurveCache = {};
    fabric$1.cachesBoundsOfCurve = true;
    fabric$1.forceGLPutImageData = false;
    fabric$1.initFilterBackend = function() {
      if (fabric$1.enableGLFiltering && fabric$1.isWebglSupported && fabric$1.isWebglSupported(fabric$1.textureSize)) {
        console.log("max texture size: " + fabric$1.maxTextureSize);
        return new fabric$1.WebglFilterBackend({ tileSize: fabric$1.textureSize });
      } else if (fabric$1.Canvas2dFilterBackend) {
        return new fabric$1.Canvas2dFilterBackend();
      }
    };
    if (typeof document !== "undefined" && typeof window !== "undefined") {
      window.fabric = fabric$1;
    }
    (function() {
      function _removeEventListener(eventName, handler) {
        if (!this.__eventListeners[eventName]) {
          return;
        }
        var eventListener = this.__eventListeners[eventName];
        if (handler) {
          eventListener[eventListener.indexOf(handler)] = false;
        } else {
          fabric$1.util.array.fill(eventListener, false);
        }
      }
      function on(eventName, handler) {
        if (!this.__eventListeners) {
          this.__eventListeners = {};
        }
        if (arguments.length === 1) {
          for (var prop in eventName) {
            this.on(prop, eventName[prop]);
          }
        } else {
          if (!this.__eventListeners[eventName]) {
            this.__eventListeners[eventName] = [];
          }
          this.__eventListeners[eventName].push(handler);
        }
        return this;
      }
      function _once(eventName, handler) {
        var _handler = (function() {
          handler.apply(this, arguments);
          this.off(eventName, _handler);
        }).bind(this);
        this.on(eventName, _handler);
      }
      function once(eventName, handler) {
        if (arguments.length === 1) {
          for (var prop in eventName) {
            _once.call(this, prop, eventName[prop]);
          }
        } else {
          _once.call(this, eventName, handler);
        }
        return this;
      }
      function off(eventName, handler) {
        if (!this.__eventListeners) {
          return this;
        }
        if (arguments.length === 0) {
          for (eventName in this.__eventListeners) {
            _removeEventListener.call(this, eventName);
          }
        } else if (arguments.length === 1 && typeof arguments[0] === "object") {
          for (var prop in eventName) {
            _removeEventListener.call(this, prop, eventName[prop]);
          }
        } else {
          _removeEventListener.call(this, eventName, handler);
        }
        return this;
      }
      function fire(eventName, options) {
        if (!this.__eventListeners) {
          return this;
        }
        var listenersForEvent = this.__eventListeners[eventName];
        if (!listenersForEvent) {
          return this;
        }
        for (var i2 = 0, len = listenersForEvent.length; i2 < len; i2++) {
          listenersForEvent[i2] && listenersForEvent[i2].call(this, options || {});
        }
        this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
          return value !== false;
        });
        return this;
      }
      fabric$1.Observable = {
        fire,
        on,
        once,
        off
      };
    })();
    fabric$1.Collection = {
      _objects: [],
      /**
       * Adds objects to collection, Canvas or Group, then renders canvas
       * (if `renderOnAddRemove` is not `false`).
       * in case of Group no changes to bounding box are made.
       * Objects should be instances of (or inherit from) fabric.Object
       * Use of this function is highly discouraged for groups.
       * you can add a bunch of objects with the add method but then you NEED
       * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
       * @param {...fabric.Object} object Zero or more fabric instances
       * @return {Self} thisArg
       * @chainable
       */
      add: function() {
        this._objects.push.apply(this._objects, arguments);
        if (this._onObjectAdded) {
          for (var i2 = 0, length = arguments.length; i2 < length; i2++) {
            this._onObjectAdded(arguments[i2]);
          }
        }
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },
      /**
       * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
       * An object should be an instance of (or inherit from) fabric.Object
       * Use of this function is highly discouraged for groups.
       * you can add a bunch of objects with the insertAt method but then you NEED
       * to run a addWithUpdate call for the Group class or position/bbox will be wrong.
       * @param {Object} object Object to insert
       * @param {Number} index Index to insert object at
       * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
       * @return {Self} thisArg
       * @chainable
       */
      insertAt: function(object, index2, nonSplicing) {
        var objects = this._objects;
        if (nonSplicing) {
          objects[index2] = object;
        } else {
          objects.splice(index2, 0, object);
        }
        this._onObjectAdded && this._onObjectAdded(object);
        this.renderOnAddRemove && this.requestRenderAll();
        return this;
      },
      /**
       * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
       * @param {...fabric.Object} object Zero or more fabric instances
       * @return {Self} thisArg
       * @chainable
       */
      remove: function() {
        var objects = this._objects, index2, somethingRemoved = false;
        for (var i2 = 0, length = arguments.length; i2 < length; i2++) {
          index2 = objects.indexOf(arguments[i2]);
          if (index2 !== -1) {
            somethingRemoved = true;
            objects.splice(index2, 1);
            this._onObjectRemoved && this._onObjectRemoved(arguments[i2]);
          }
        }
        this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
        return this;
      },
      /**
       * Executes given function for each object in this group
       * @param {Function} callback
       *                   Callback invoked with current object as first argument,
       *                   index - as second and an array of all objects - as third.
       *                   Callback is invoked in a context of Global Object (e.g. `window`)
       *                   when no `context` argument is given
       *
       * @param {Object} context Context (aka thisObject)
       * @return {Self} thisArg
       * @chainable
       */
      forEachObject: function(callback, context) {
        var objects = this.getObjects();
        for (var i2 = 0, len = objects.length; i2 < len; i2++) {
          callback.call(context, objects[i2], i2, objects);
        }
        return this;
      },
      /**
       * Returns an array of children objects of this instance
       * Type parameter introduced in 1.3.10
       * since 2.3.5 this method return always a COPY of the array;
       * @param {String} [type] When specified, only objects of this type are returned
       * @return {Array}
       */
      getObjects: function(type) {
        if (typeof type === "undefined") {
          return this._objects.concat();
        }
        return this._objects.filter(function(o2) {
          return o2.type === type;
        });
      },
      /**
       * Returns object at specified index
       * @param {Number} index
       * @return {Self} thisArg
       */
      item: function(index2) {
        return this._objects[index2];
      },
      /**
       * Returns true if collection contains no objects
       * @return {Boolean} true if collection is empty
       */
      isEmpty: function() {
        return this._objects.length === 0;
      },
      /**
       * Returns a size of a collection (i.e: length of an array containing its objects)
       * @return {Number} Collection size
       */
      size: function() {
        return this._objects.length;
      },
      /**
       * Returns true if collection contains an object
       * @param {Object} object Object to check against
       * @param {Boolean} [deep=false] `true` to check all descendants, `false` to check only `_objects`
       * @return {Boolean} `true` if collection contains an object
       */
      contains: function(object, deep) {
        if (this._objects.indexOf(object) > -1) {
          return true;
        } else if (deep) {
          return this._objects.some(function(obj) {
            return typeof obj.contains === "function" && obj.contains(object, true);
          });
        }
        return false;
      },
      /**
       * Returns number representation of a collection complexity
       * @return {Number} complexity
       */
      complexity: function() {
        return this._objects.reduce(function(memo, current) {
          memo += current.complexity ? current.complexity() : 0;
          return memo;
        }, 0);
      }
    };
    fabric$1.CommonMethods = {
      /**
       * Sets object's properties from options
       * @param {Object} [options] Options object
       */
      _setOptions: function(options) {
        for (var prop in options) {
          this.set(prop, options[prop]);
        }
      },
      /**
       * @private
       * @param {Object} [filler] Options object
       * @param {String} [property] property to set the Gradient to
       */
      _initGradient: function(filler, property) {
        if (filler && filler.colorStops && !(filler instanceof fabric$1.Gradient)) {
          this.set(property, new fabric$1.Gradient(filler));
        }
      },
      /**
       * @private
       * @param {Object} [filler] Options object
       * @param {String} [property] property to set the Pattern to
       * @param {Function} [callback] callback to invoke after pattern load
       */
      _initPattern: function(filler, property, callback) {
        if (filler && filler.source && !(filler instanceof fabric$1.Pattern)) {
          this.set(property, new fabric$1.Pattern(filler, callback));
        } else {
          callback && callback();
        }
      },
      /**
       * @private
       */
      _setObject: function(obj) {
        for (var prop in obj) {
          this._set(prop, obj[prop]);
        }
      },
      /**
       * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
       * @param {String|Object} key Property name or object (if object, iterate over the object properties)
       * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
       * @return {fabric.Object} thisArg
       * @chainable
       */
      set: function(key, value) {
        if (typeof key === "object") {
          this._setObject(key);
        } else {
          this._set(key, value);
        }
        return this;
      },
      _set: function(key, value) {
        this[key] = value;
      },
      /**
       * Toggles specified property from `true` to `false` or from `false` to `true`
       * @param {String} property Property to toggle
       * @return {fabric.Object} thisArg
       * @chainable
       */
      toggle: function(property) {
        var value = this.get(property);
        if (typeof value === "boolean") {
          this.set(property, !value);
        }
        return this;
      },
      /**
       * Basic getter
       * @param {String} property Property name
       * @return {*} value of a property
       */
      get: function(property) {
        return this[property];
      }
    };
    (function(global2) {
      var sqrt = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;
      fabric$1.util = {
        /**
         * Calculate the cos of an angle, avoiding returning floats for known results
         * @static
         * @memberOf fabric.util
         * @param {Number} angle the angle in radians or in degree
         * @return {Number}
         */
        cos: function(angle2) {
          if (angle2 === 0) {
            return 1;
          }
          if (angle2 < 0) {
            angle2 = -angle2;
          }
          var angleSlice = angle2 / PiBy2;
          switch (angleSlice) {
            case 1:
            case 3:
              return 0;
            case 2:
              return -1;
          }
          return Math.cos(angle2);
        },
        /**
         * Calculate the sin of an angle, avoiding returning floats for known results
         * @static
         * @memberOf fabric.util
         * @param {Number} angle the angle in radians or in degree
         * @return {Number}
         */
        sin: function(angle2) {
          if (angle2 === 0) {
            return 0;
          }
          var angleSlice = angle2 / PiBy2, sign = 1;
          if (angle2 < 0) {
            sign = -1;
          }
          switch (angleSlice) {
            case 1:
              return sign;
            case 2:
              return 0;
            case 3:
              return -sign;
          }
          return Math.sin(angle2);
        },
        /**
         * Removes value from an array.
         * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
         * @static
         * @memberOf fabric.util
         * @param {Array} array
         * @param {*} value
         * @return {Array} original array
         */
        removeFromArray: function(array, value) {
          var idx = array.indexOf(value);
          if (idx !== -1) {
            array.splice(idx, 1);
          }
          return array;
        },
        /**
         * Returns random number between 2 specified ones.
         * @static
         * @memberOf fabric.util
         * @param {Number} min lower limit
         * @param {Number} max upper limit
         * @return {Number} random value (between min and max)
         */
        getRandomInt: function(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        },
        /**
         * Transforms degrees to radians.
         * @static
         * @memberOf fabric.util
         * @param {Number} degrees value in degrees
         * @return {Number} value in radians
         */
        degreesToRadians: function(degrees) {
          return degrees * PiBy180;
        },
        /**
         * Transforms radians to degrees.
         * @static
         * @memberOf fabric.util
         * @param {Number} radians value in radians
         * @return {Number} value in degrees
         */
        radiansToDegrees: function(radians) {
          return radians / PiBy180;
        },
        /**
         * Rotates `point` around `origin` with `radians`
         * @static
         * @memberOf fabric.util
         * @param {fabric.Point} point The point to rotate
         * @param {fabric.Point} origin The origin of the rotation
         * @param {Number} radians The radians of the angle for the rotation
         * @return {fabric.Point} The new rotated point
         */
        rotatePoint: function(point, origin2, radians) {
          var newPoint = new fabric$1.Point(point.x - origin2.x, point.y - origin2.y), v2 = fabric$1.util.rotateVector(newPoint, radians);
          return new fabric$1.Point(v2.x, v2.y).addEquals(origin2);
        },
        /**
         * Rotates `vector` with `radians`
         * @static
         * @memberOf fabric.util
         * @param {Object} vector The vector to rotate (x and y)
         * @param {Number} radians The radians of the angle for the rotation
         * @return {Object} The new rotated point
         */
        rotateVector: function(vector, radians) {
          var sin = fabric$1.util.sin(radians), cos = fabric$1.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;
          return {
            x: rx,
            y: ry
          };
        },
        /**
         * Creates a vetor from points represented as a point
         * @static
         * @memberOf fabric.util
         *
         * @typedef {Object} Point
         * @property {number} x
         * @property {number} y
         *
         * @param {Point} from
         * @param {Point} to
         * @returns {Point} vector
         */
        createVector: function(from, to) {
          return new fabric$1.Point(to.x - from.x, to.y - from.y);
        },
        /**
         * Calculates angle between 2 vectors using dot product
         * @static
         * @memberOf fabric.util
         * @param {Point} a
         * @param {Point} b
         * @returns the angle in radian between the vectors
         */
        calcAngleBetweenVectors: function(a2, b2) {
          return Math.acos((a2.x * b2.x + a2.y * b2.y) / (Math.hypot(a2.x, a2.y) * Math.hypot(b2.x, b2.y)));
        },
        /**
         * @static
         * @memberOf fabric.util
         * @param {Point} v
         * @returns {Point} vector representing the unit vector of pointing to the direction of `v`
         */
        getHatVector: function(v2) {
          return new fabric$1.Point(v2.x, v2.y).multiply(1 / Math.hypot(v2.x, v2.y));
        },
        /**
         * @static
         * @memberOf fabric.util
         * @param {Point} A
         * @param {Point} B
         * @param {Point} C
         * @returns {{ vector: Point, angle: number }} vector representing the bisector of A and A's angle
         */
        getBisector: function(A2, B3, C2) {
          var AB = fabric$1.util.createVector(A2, B3), AC = fabric$1.util.createVector(A2, C2);
          var alpha = fabric$1.util.calcAngleBetweenVectors(AB, AC);
          var ro = fabric$1.util.calcAngleBetweenVectors(fabric$1.util.rotateVector(AB, alpha), AC);
          var phi = alpha * (ro === 0 ? 1 : -1) / 2;
          return {
            vector: fabric$1.util.getHatVector(fabric$1.util.rotateVector(AB, phi)),
            angle: alpha
          };
        },
        /**
         * Project stroke width on points returning 2 projections for each point as follows:
         * - `miter`: 2 points corresponding to the outer boundary and the inner boundary of stroke.
         * - `bevel`: 2 points corresponding to the bevel boundaries, tangent to the bisector.
         * - `round`: same as `bevel`
         * Used to calculate object's bounding box
         * @static
         * @memberOf fabric.util
         * @param {Point[]} points
         * @param {Object} options
         * @param {number} options.strokeWidth
         * @param {'miter'|'bevel'|'round'} options.strokeLineJoin
         * @param {number} options.strokeMiterLimit https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit
         * @param {boolean} options.strokeUniform
         * @param {number} options.scaleX
         * @param {number} options.scaleY
         * @param {boolean} [openPath] whether the shape is open or not, affects the calculations of the first and last points
         * @returns {fabric.Point[]} array of size 2n/4n of all suspected points
         */
        projectStrokeOnPoints: function(points, options, openPath) {
          var coords = [], s2 = options.strokeWidth / 2, strokeUniformScalar = options.strokeUniform ? new fabric$1.Point(1 / options.scaleX, 1 / options.scaleY) : new fabric$1.Point(1, 1), getStrokeHatVector = function(v2) {
            var scalar = s2 / Math.hypot(v2.x, v2.y);
            return new fabric$1.Point(v2.x * scalar * strokeUniformScalar.x, v2.y * scalar * strokeUniformScalar.y);
          };
          if (points.length <= 1) {
            return coords;
          }
          points.forEach(function(p2, index2) {
            var A2 = new fabric$1.Point(p2.x, p2.y), B3, C2;
            if (index2 === 0) {
              C2 = points[index2 + 1];
              B3 = openPath ? getStrokeHatVector(fabric$1.util.createVector(C2, A2)).addEquals(A2) : points[points.length - 1];
            } else if (index2 === points.length - 1) {
              B3 = points[index2 - 1];
              C2 = openPath ? getStrokeHatVector(fabric$1.util.createVector(B3, A2)).addEquals(A2) : points[0];
            } else {
              B3 = points[index2 - 1];
              C2 = points[index2 + 1];
            }
            var bisector = fabric$1.util.getBisector(A2, B3, C2), bisectorVector = bisector.vector, alpha = bisector.angle, scalar, miterVector;
            if (options.strokeLineJoin === "miter") {
              scalar = -s2 / Math.sin(alpha / 2);
              miterVector = new fabric$1.Point(
                bisectorVector.x * scalar * strokeUniformScalar.x,
                bisectorVector.y * scalar * strokeUniformScalar.y
              );
              if (Math.hypot(miterVector.x, miterVector.y) / s2 <= options.strokeMiterLimit) {
                coords.push(A2.add(miterVector));
                coords.push(A2.subtract(miterVector));
                return;
              }
            }
            scalar = -s2 * Math.SQRT2;
            miterVector = new fabric$1.Point(
              bisectorVector.x * scalar * strokeUniformScalar.x,
              bisectorVector.y * scalar * strokeUniformScalar.y
            );
            coords.push(A2.add(miterVector));
            coords.push(A2.subtract(miterVector));
          });
          return coords;
        },
        /**
         * Apply transform t to point p
         * @static
         * @memberOf fabric.util
         * @param  {fabric.Point} p The point to transform
         * @param  {Array} t The transform
         * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
         * @return {fabric.Point} The transformed point
         */
        transformPoint: function(p2, t3, ignoreOffset) {
          if (ignoreOffset) {
            return new fabric$1.Point(
              t3[0] * p2.x + t3[2] * p2.y,
              t3[1] * p2.x + t3[3] * p2.y
            );
          }
          return new fabric$1.Point(
            t3[0] * p2.x + t3[2] * p2.y + t3[4],
            t3[1] * p2.x + t3[3] * p2.y + t3[5]
          );
        },
        /**
         * Returns coordinates of points's bounding rectangle (left, top, width, height)
         * @param {Array} points 4 points array
         * @param {Array} [transform] an array of 6 numbers representing a 2x3 transform matrix
         * @return {Object} Object with left, top, width, height properties
         */
        makeBoundingBoxFromPoints: function(points, transform2) {
          if (transform2) {
            for (var i2 = 0; i2 < points.length; i2++) {
              points[i2] = fabric$1.util.transformPoint(points[i2], transform2);
            }
          }
          var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x], minX = fabric$1.util.array.min(xPoints), maxX = fabric$1.util.array.max(xPoints), width = maxX - minX, yPoints = [points[0].y, points[1].y, points[2].y, points[3].y], minY = fabric$1.util.array.min(yPoints), maxY = fabric$1.util.array.max(yPoints), height = maxY - minY;
          return {
            left: minX,
            top: minY,
            width,
            height
          };
        },
        /**
         * Invert transformation t
         * @static
         * @memberOf fabric.util
         * @param {Array} t The transform
         * @return {Array} The inverted transform
         */
        invertTransform: function(t3) {
          var a2 = 1 / (t3[0] * t3[3] - t3[1] * t3[2]), r2 = [a2 * t3[3], -a2 * t3[1], -a2 * t3[2], a2 * t3[0]], o2 = fabric$1.util.transformPoint({ x: t3[4], y: t3[5] }, r2, true);
          r2[4] = -o2.x;
          r2[5] = -o2.y;
          return r2;
        },
        /**
         * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
         * @static
         * @memberOf fabric.util
         * @param {Number|String} number number to operate on
         * @param {Number} fractionDigits number of fraction digits to "leave"
         * @return {Number}
         */
        toFixed: function(number, fractionDigits) {
          return parseFloat(Number(number).toFixed(fractionDigits));
        },
        /**
         * Converts from attribute value to pixel value if applicable.
         * Returns converted pixels or original value not converted.
         * @param {Number|String} value number to operate on
         * @param {Number} fontSize
         * @return {Number|String}
         */
        parseUnit: function(value, fontSize2) {
          var unit = /\D{0,2}$/.exec(value), number = parseFloat(value);
          if (!fontSize2) {
            fontSize2 = fabric$1.Text.DEFAULT_SVG_FONT_SIZE;
          }
          switch (unit[0]) {
            case "mm":
              return number * fabric$1.DPI / 25.4;
            case "cm":
              return number * fabric$1.DPI / 2.54;
            case "in":
              return number * fabric$1.DPI;
            case "pt":
              return number * fabric$1.DPI / 72;
            // or * 4 / 3
            case "pc":
              return number * fabric$1.DPI / 72 * 12;
            // or * 16
            case "em":
              return number * fontSize2;
            default:
              return number;
          }
        },
        /**
         * Function which always returns `false`.
         * @static
         * @memberOf fabric.util
         * @return {Boolean}
         */
        falseFunction: function() {
          return false;
        },
        /**
         * Returns klass "Class" object of given namespace
         * @memberOf fabric.util
         * @param {String} type Type of object (eg. 'circle')
         * @param {String} namespace Namespace to get klass "Class" object from
         * @return {Object} klass "Class"
         */
        getKlass: function(type, namespace) {
          type = fabric$1.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
          return fabric$1.util.resolveNamespace(namespace)[type];
        },
        /**
         * Returns array of attributes for given svg that fabric parses
         * @memberOf fabric.util
         * @param {String} type Type of svg element (eg. 'circle')
         * @return {Array} string names of supported attributes
         */
        getSvgAttributes: function(type) {
          var attributes = [
            "instantiated_by_use",
            "style",
            "id",
            "class"
          ];
          switch (type) {
            case "linearGradient":
              attributes = attributes.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
              break;
            case "radialGradient":
              attributes = attributes.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
              break;
            case "stop":
              attributes = attributes.concat(["offset", "stop-color", "stop-opacity"]);
              break;
          }
          return attributes;
        },
        /**
         * Returns object of given namespace
         * @memberOf fabric.util
         * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
         * @return {Object} Object for given namespace (default fabric)
         */
        resolveNamespace: function(namespace) {
          if (!namespace) {
            return fabric$1;
          }
          var parts = namespace.split("."), len = parts.length, i2, obj = global2 || fabric$1.window;
          for (i2 = 0; i2 < len; ++i2) {
            obj = obj[parts[i2]];
          }
          return obj;
        },
        /**
         * Loads image element from given url and passes it to a callback
         * @memberOf fabric.util
         * @param {String} url URL representing an image
         * @param {Function} callback Callback; invoked with loaded image
         * @param {*} [context] Context to invoke callback in
         * @param {Object} [crossOrigin] crossOrigin value to set image element to
         */
        loadImage: function(url, callback, context, crossOrigin) {
          if (!url) {
            callback && callback.call(context, url);
            return;
          }
          var img = fabric$1.util.createImage();
          var onLoadCallback = function() {
            callback && callback.call(context, img, false);
            img = img.onload = img.onerror = null;
          };
          img.onload = onLoadCallback;
          img.onerror = function() {
            fabric$1.log("Error loading " + img.src);
            callback && callback.call(context, null, true);
            img = img.onload = img.onerror = null;
          };
          if (url.indexOf("data") !== 0 && crossOrigin !== void 0 && crossOrigin !== null) {
            img.crossOrigin = crossOrigin;
          }
          if (url.substring(0, 14) === "data:image/svg") {
            img.onload = null;
            fabric$1.util.loadImageInDom(img, onLoadCallback);
          }
          img.src = url;
        },
        /**
         * Attaches SVG image with data: URL to the dom
         * @memberOf fabric.util
         * @param {Object} img Image object with data:image/svg src
         * @param {Function} callback Callback; invoked with loaded image
         * @return {Object} DOM element (div containing the SVG image)
         */
        loadImageInDom: function(img, onLoadCallback) {
          var div = fabric$1.document.createElement("div");
          div.style.width = div.style.height = "1px";
          div.style.left = div.style.top = "-100%";
          div.style.position = "absolute";
          div.appendChild(img);
          fabric$1.document.querySelector("body").appendChild(div);
          img.onload = function() {
            onLoadCallback();
            div.parentNode.removeChild(div);
            div = null;
          };
        },
        /**
         * Creates corresponding fabric instances from their object representations
         * @static
         * @memberOf fabric.util
         * @param {Array} objects Objects to enliven
         * @param {Function} callback Callback to invoke when all objects are created
         * @param {String} namespace Namespace to get klass "Class" object from
         * @param {Function} reviver Method for further parsing of object elements,
         * called after each fabric object created.
         */
        enlivenObjects: function(objects, callback, namespace, reviver) {
          objects = objects || [];
          var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;
          function onLoaded() {
            if (++numLoadedObjects === numTotalObjects) {
              callback && callback(enlivenedObjects.filter(function(obj) {
                return obj;
              }));
            }
          }
          if (!numTotalObjects) {
            callback && callback(enlivenedObjects);
            return;
          }
          objects.forEach(function(o2, index2) {
            if (!o2 || !o2.type) {
              onLoaded();
              return;
            }
            var klass = fabric$1.util.getKlass(o2.type, namespace);
            klass.fromObject(o2, function(obj, error) {
              error || (enlivenedObjects[index2] = obj);
              reviver && reviver(o2, obj, error);
              onLoaded();
            });
          });
        },
        /**
         * Creates corresponding fabric instances residing in an object, e.g. `clipPath`
         * @see {@link fabric.Object.ENLIVEN_PROPS}
         * @param {Object} object
         * @param {Object} [context] assign enlived props to this object (pass null to skip this)
         * @param {(objects:fabric.Object[]) => void} callback
         */
        enlivenObjectEnlivables: function(object, context, callback) {
          var enlivenProps = fabric$1.Object.ENLIVEN_PROPS.filter(function(key) {
            return !!object[key];
          });
          fabric$1.util.enlivenObjects(enlivenProps.map(function(key) {
            return object[key];
          }), function(enlivedProps) {
            var objects = {};
            enlivenProps.forEach(function(key, index2) {
              objects[key] = enlivedProps[index2];
              context && (context[key] = enlivedProps[index2]);
            });
            callback && callback(objects);
          });
        },
        /**
         * Create and wait for loading of patterns
         * @static
         * @memberOf fabric.util
         * @param {Array} patterns Objects to enliven
         * @param {Function} callback Callback to invoke when all objects are created
         * called after each fabric object created.
         */
        enlivenPatterns: function(patterns, callback) {
          patterns = patterns || [];
          function onLoaded() {
            if (++numLoadedPatterns === numPatterns) {
              callback && callback(enlivenedPatterns);
            }
          }
          var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;
          if (!numPatterns) {
            callback && callback(enlivenedPatterns);
            return;
          }
          patterns.forEach(function(p2, index2) {
            if (p2 && p2.source) {
              new fabric$1.Pattern(p2, function(pattern) {
                enlivenedPatterns[index2] = pattern;
                onLoaded();
              });
            } else {
              enlivenedPatterns[index2] = p2;
              onLoaded();
            }
          });
        },
        /**
         * Groups SVG elements (usually those retrieved from SVG document)
         * @static
         * @memberOf fabric.util
         * @param {Array} elements SVG elements to group
         * @param {Object} [options] Options object
         * @param {String} path Value to set sourcePath to
         * @return {fabric.Object|fabric.Group}
         */
        groupSVGElements: function(elements2, options, path2) {
          var object;
          if (elements2 && elements2.length === 1) {
            if (typeof path2 !== "undefined") {
              elements2[0].sourcePath = path2;
            }
            return elements2[0];
          }
          if (options) {
            if (options.width && options.height) {
              options.centerPoint = {
                x: options.width / 2,
                y: options.height / 2
              };
            } else {
              delete options.width;
              delete options.height;
            }
          }
          object = new fabric$1.Group(elements2, options);
          if (typeof path2 !== "undefined") {
            object.sourcePath = path2;
          }
          return object;
        },
        /**
         * Populates an object with properties of another object
         * @static
         * @memberOf fabric.util
         * @param {Object} source Source object
         * @param {Object} destination Destination object
         * @return {Array} properties Properties names to include
         */
        populateWithProperties: function(source, destination, properties) {
          if (properties && Array.isArray(properties)) {
            for (var i2 = 0, len = properties.length; i2 < len; i2++) {
              if (properties[i2] in source) {
                destination[properties[i2]] = source[properties[i2]];
              }
            }
          }
        },
        /**
         * Creates canvas element
         * @static
         * @memberOf fabric.util
         * @return {CanvasElement} initialized canvas element
         */
        createCanvasElement: function() {
          return fabric$1.document.createElement("canvas");
        },
        /**
         * Creates a canvas element that is a copy of another and is also painted
         * @param {CanvasElement} canvas to copy size and content of
         * @static
         * @memberOf fabric.util
         * @return {CanvasElement} initialized canvas element
         */
        copyCanvasElement: function(canvas) {
          var newCanvas = fabric$1.util.createCanvasElement();
          newCanvas.width = canvas.width;
          newCanvas.height = canvas.height;
          newCanvas.getContext("2d").drawImage(canvas, 0, 0);
          return newCanvas;
        },
        /**
         * since 2.6.0 moved from canvas instance to utility.
         * @param {CanvasElement} canvasEl to copy size and content of
         * @param {String} format 'jpeg' or 'png', in some browsers 'webp' is ok too
         * @param {Number} quality <= 1 and > 0
         * @static
         * @memberOf fabric.util
         * @return {String} data url
         */
        toDataURL: function(canvasEl, format, quality) {
          return canvasEl.toDataURL("image/" + format, quality);
        },
        /**
         * Creates image element (works on client and node)
         * @static
         * @memberOf fabric.util
         * @return {HTMLImageElement} HTML image element
         */
        createImage: function() {
          return fabric$1.document.createElement("img");
        },
        /**
         * Multiply matrix A by matrix B to nest transformations
         * @static
         * @memberOf fabric.util
         * @param  {Array} a First transformMatrix
         * @param  {Array} b Second transformMatrix
         * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
         * @return {Array} The product of the two transform matrices
         */
        multiplyTransformMatrices: function(a2, b2, is2x2) {
          return [
            a2[0] * b2[0] + a2[2] * b2[1],
            a2[1] * b2[0] + a2[3] * b2[1],
            a2[0] * b2[2] + a2[2] * b2[3],
            a2[1] * b2[2] + a2[3] * b2[3],
            is2x2 ? 0 : a2[0] * b2[4] + a2[2] * b2[5] + a2[4],
            is2x2 ? 0 : a2[1] * b2[4] + a2[3] * b2[5] + a2[5]
          ];
        },
        /**
         * Decomposes standard 2x3 matrix into transform components
         * @static
         * @memberOf fabric.util
         * @param  {Array} a transformMatrix
         * @return {Object} Components of transform
         */
        qrDecompose: function(a2) {
          var angle2 = atan2(a2[1], a2[0]), denom = pow(a2[0], 2) + pow(a2[1], 2), scaleX = sqrt(denom), scaleY = (a2[0] * a2[3] - a2[2] * a2[1]) / scaleX, skewX = atan2(a2[0] * a2[2] + a2[1] * a2[3], denom);
          return {
            angle: angle2 / PiBy180,
            scaleX,
            scaleY,
            skewX: skewX / PiBy180,
            skewY: 0,
            translateX: a2[4],
            translateY: a2[5]
          };
        },
        /**
         * Returns a transform matrix starting from an object of the same kind of
         * the one returned from qrDecompose, useful also if you want to calculate some
         * transformations from an object that is not enlived yet
         * @static
         * @memberOf fabric.util
         * @param  {Object} options
         * @param  {Number} [options.angle] angle in degrees
         * @return {Number[]} transform matrix
         */
        calcRotateMatrix: function(options) {
          if (!options.angle) {
            return fabric$1.iMatrix.concat();
          }
          var theta = fabric$1.util.degreesToRadians(options.angle), cos = fabric$1.util.cos(theta), sin = fabric$1.util.sin(theta);
          return [cos, sin, -sin, cos, 0, 0];
        },
        /**
         * Returns a transform matrix starting from an object of the same kind of
         * the one returned from qrDecompose, useful also if you want to calculate some
         * transformations from an object that is not enlived yet.
         * is called DimensionsTransformMatrix because those properties are the one that influence
         * the size of the resulting box of the object.
         * @static
         * @memberOf fabric.util
         * @param  {Object} options
         * @param  {Number} [options.scaleX]
         * @param  {Number} [options.scaleY]
         * @param  {Boolean} [options.flipX]
         * @param  {Boolean} [options.flipY]
         * @param  {Number} [options.skewX]
         * @param  {Number} [options.skewY]
         * @return {Number[]} transform matrix
         */
        calcDimensionsMatrix: function(options) {
          var scaleX = typeof options.scaleX === "undefined" ? 1 : options.scaleX, scaleY = typeof options.scaleY === "undefined" ? 1 : options.scaleY, scaleMatrix = [
            options.flipX ? -scaleX : scaleX,
            0,
            0,
            options.flipY ? -scaleY : scaleY,
            0,
            0
          ], multiply = fabric$1.util.multiplyTransformMatrices, degreesToRadians = fabric$1.util.degreesToRadians;
          if (options.skewX) {
            scaleMatrix = multiply(
              scaleMatrix,
              [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
              true
            );
          }
          if (options.skewY) {
            scaleMatrix = multiply(
              scaleMatrix,
              [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
              true
            );
          }
          return scaleMatrix;
        },
        /**
         * Returns a transform matrix starting from an object of the same kind of
         * the one returned from qrDecompose, useful also if you want to calculate some
         * transformations from an object that is not enlived yet
         * @static
         * @memberOf fabric.util
         * @param  {Object} options
         * @param  {Number} [options.angle]
         * @param  {Number} [options.scaleX]
         * @param  {Number} [options.scaleY]
         * @param  {Boolean} [options.flipX]
         * @param  {Boolean} [options.flipY]
         * @param  {Number} [options.skewX]
         * @param  {Number} [options.skewX]
         * @param  {Number} [options.translateX]
         * @param  {Number} [options.translateY]
         * @return {Number[]} transform matrix
         */
        composeMatrix: function(options) {
          var matrix2 = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0], multiply = fabric$1.util.multiplyTransformMatrices;
          if (options.angle) {
            matrix2 = multiply(matrix2, fabric$1.util.calcRotateMatrix(options));
          }
          if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {
            matrix2 = multiply(matrix2, fabric$1.util.calcDimensionsMatrix(options));
          }
          return matrix2;
        },
        /**
         * reset an object transform state to neutral. Top and left are not accounted for
         * @static
         * @memberOf fabric.util
         * @param  {fabric.Object} target object to transform
         */
        resetObjectTransform: function(target) {
          target.scaleX = 1;
          target.scaleY = 1;
          target.skewX = 0;
          target.skewY = 0;
          target.flipX = false;
          target.flipY = false;
          target.rotate(0);
        },
        /**
         * Extract Object transform values
         * @static
         * @memberOf fabric.util
         * @param  {fabric.Object} target object to read from
         * @return {Object} Components of transform
         */
        saveObjectTransform: function(target) {
          return {
            scaleX: target.scaleX,
            scaleY: target.scaleY,
            skewX: target.skewX,
            skewY: target.skewY,
            angle: target.angle,
            left: target.left,
            flipX: target.flipX,
            flipY: target.flipY,
            top: target.top
          };
        },
        /**
         * Returns true if context has transparent pixel
         * at specified location (taking tolerance into account)
         * @param {CanvasRenderingContext2D} ctx context
         * @param {Number} x x coordinate
         * @param {Number} y y coordinate
         * @param {Number} tolerance Tolerance
         */
        isTransparent: function(ctx, x2, y2, tolerance) {
          if (tolerance > 0) {
            if (x2 > tolerance) {
              x2 -= tolerance;
            } else {
              x2 = 0;
            }
            if (y2 > tolerance) {
              y2 -= tolerance;
            } else {
              y2 = 0;
            }
          }
          var _isTransparent = true, i2, temp, imageData = ctx.getImageData(x2, y2, tolerance * 2 || 1, tolerance * 2 || 1), l2 = imageData.data.length;
          for (i2 = 3; i2 < l2; i2 += 4) {
            temp = imageData.data[i2];
            _isTransparent = temp <= 0;
            if (_isTransparent === false) {
              break;
            }
          }
          imageData = null;
          return _isTransparent;
        },
        /**
         * Parse preserveAspectRatio attribute from element
         * @param {string} attribute to be parsed
         * @return {Object} an object containing align and meetOrSlice attribute
         */
        parsePreserveAspectRatioAttribute: function(attribute) {
          var meetOrSlice = "meet", alignX = "Mid", alignY = "Mid", aspectRatioAttrs = attribute.split(" "), align;
          if (aspectRatioAttrs && aspectRatioAttrs.length) {
            meetOrSlice = aspectRatioAttrs.pop();
            if (meetOrSlice !== "meet" && meetOrSlice !== "slice") {
              align = meetOrSlice;
              meetOrSlice = "meet";
            } else if (aspectRatioAttrs.length) {
              align = aspectRatioAttrs.pop();
            }
          }
          alignX = align !== "none" ? align.slice(1, 4) : "none";
          alignY = align !== "none" ? align.slice(5, 8) : "none";
          return {
            meetOrSlice,
            alignX,
            alignY
          };
        },
        /**
         * Clear char widths cache for the given font family or all the cache if no
         * fontFamily is specified.
         * Use it if you know you are loading fonts in a lazy way and you are not waiting
         * for custom fonts to load properly when adding text objects to the canvas.
         * If a text object is added when its own font is not loaded yet, you will get wrong
         * measurement and so wrong bounding boxes.
         * After the font cache is cleared, either change the textObject text content or call
         * initDimensions() to trigger a recalculation
         * @memberOf fabric.util
         * @param {String} [fontFamily] font family to clear
         */
        clearFabricFontCache: function(fontFamily2) {
          fontFamily2 = (fontFamily2 || "").toLowerCase();
          if (!fontFamily2) {
            fabric$1.charWidthsCache = {};
          } else if (fabric$1.charWidthsCache[fontFamily2]) {
            delete fabric$1.charWidthsCache[fontFamily2];
          }
        },
        /**
         * Given current aspect ratio, determines the max width and height that can
         * respect the total allowed area for the cache.
         * @memberOf fabric.util
         * @param {Number} ar aspect ratio
         * @param {Number} maximumArea Maximum area you want to achieve
         * @return {Object.x} Limited dimensions by X
         * @return {Object.y} Limited dimensions by Y
         */
        limitDimsByArea: function(ar, maximumArea) {
          var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);
          return { x: Math.floor(roughWidth), y: perfLimitSizeY };
        },
        capValue: function(min, value, max) {
          return Math.max(min, Math.min(value, max));
        },
        /**
         * Finds the scale for the object source to fit inside the object destination,
         * keeping aspect ratio intact.
         * respect the total allowed area for the cache.
         * @memberOf fabric.util
         * @param {Object | fabric.Object} source
         * @param {Number} source.height natural unscaled height of the object
         * @param {Number} source.width natural unscaled width of the object
         * @param {Object | fabric.Object} destination
         * @param {Number} destination.height natural unscaled height of the object
         * @param {Number} destination.width natural unscaled width of the object
         * @return {Number} scale factor to apply to source to fit into destination
         */
        findScaleToFit: function(source, destination) {
          return Math.min(destination.width / source.width, destination.height / source.height);
        },
        /**
         * Finds the scale for the object source to cover entirely the object destination,
         * keeping aspect ratio intact.
         * respect the total allowed area for the cache.
         * @memberOf fabric.util
         * @param {Object | fabric.Object} source
         * @param {Number} source.height natural unscaled height of the object
         * @param {Number} source.width natural unscaled width of the object
         * @param {Object | fabric.Object} destination
         * @param {Number} destination.height natural unscaled height of the object
         * @param {Number} destination.width natural unscaled width of the object
         * @return {Number} scale factor to apply to source to cover destination
         */
        findScaleToCover: function(source, destination) {
          return Math.max(destination.width / source.width, destination.height / source.height);
        },
        /**
         * given an array of 6 number returns something like `"matrix(...numbers)"`
         * @memberOf fabric.util
         * @param {Array} transform an array with 6 numbers
         * @return {String} transform matrix for svg
         * @return {Object.y} Limited dimensions by Y
         */
        matrixToSVG: function(transform2) {
          return "matrix(" + transform2.map(function(value) {
            return fabric$1.util.toFixed(value, fabric$1.Object.NUM_FRACTION_DIGITS);
          }).join(" ") + ")";
        },
        /**
         * given an object and a transform, apply the inverse transform to the object,
         * this is equivalent to remove from that object that transformation, so that
         * added in a space with the removed transform, the object will be the same as before.
         * Removing from an object a transform that scale by 2 is like scaling it by 1/2.
         * Removing from an object a transfrom that rotate by 30deg is like rotating by 30deg
         * in the opposite direction.
         * This util is used to add objects inside transformed groups or nested groups.
         * @memberOf fabric.util
         * @param {fabric.Object} object the object you want to transform
         * @param {Array} transform the destination transform
         */
        removeTransformFromObject: function(object, transform2) {
          var inverted = fabric$1.util.invertTransform(transform2), finalTransform = fabric$1.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());
          fabric$1.util.applyTransformToObject(object, finalTransform);
        },
        /**
         * given an object and a transform, apply the transform to the object.
         * this is equivalent to change the space where the object is drawn.
         * Adding to an object a transform that scale by 2 is like scaling it by 2.
         * This is used when removing an object from an active selection for example.
         * @memberOf fabric.util
         * @param {fabric.Object} object the object you want to transform
         * @param {Array} transform the destination transform
         */
        addTransformToObject: function(object, transform2) {
          fabric$1.util.applyTransformToObject(
            object,
            fabric$1.util.multiplyTransformMatrices(transform2, object.calcOwnMatrix())
          );
        },
        /**
         * discard an object transform state and apply the one from the matrix.
         * @memberOf fabric.util
         * @param {fabric.Object} object the object you want to transform
         * @param {Array} transform the destination transform
         */
        applyTransformToObject: function(object, transform2) {
          var options = fabric$1.util.qrDecompose(transform2), center = new fabric$1.Point(options.translateX, options.translateY);
          object.flipX = false;
          object.flipY = false;
          object.set("scaleX", options.scaleX);
          object.set("scaleY", options.scaleY);
          object.skewX = options.skewX;
          object.skewY = options.skewY;
          object.angle = options.angle;
          object.setPositionByOrigin(center, "center", "center");
        },
        /**
         * given a width and height, return the size of the bounding box
         * that can contains the box with width/height with applied transform
         * described in options.
         * Use to calculate the boxes around objects for controls.
         * @memberOf fabric.util
         * @param {Number} width
         * @param {Number} height
         * @param {Object} options
         * @param {Number} options.scaleX
         * @param {Number} options.scaleY
         * @param {Number} options.skewX
         * @param {Number} options.skewY
         * @return {Object.x} width of containing
         * @return {Object.y} height of containing
         */
        sizeAfterTransform: function(width, height, options) {
          var dimX = width / 2, dimY = height / 2, points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }
          ], transformMatrix = fabric$1.util.calcDimensionsMatrix(options), bbox = fabric$1.util.makeBoundingBoxFromPoints(points, transformMatrix);
          return {
            x: bbox.width,
            y: bbox.height
          };
        },
        /**
         * Merges 2 clip paths into one visually equal clip path
         *
         * **IMPORTANT**:\
         * Does **NOT** clone the arguments, clone them proir if necessary.
         *
         * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.
         * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.
         *
         * In order to handle the `inverted` property we follow logic described in the following cases:\
         * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\
         * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\
         * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.
         *
         * @memberOf fabric.util
         * @param {fabric.Object} c1
         * @param {fabric.Object} c2
         * @returns {fabric.Object} merged clip path
         */
        mergeClipPaths: function(c1, c2) {
          var a2 = c1, b2 = c2;
          if (a2.inverted && !b2.inverted) {
            a2 = c2;
            b2 = c1;
          }
          fabric$1.util.applyTransformToObject(
            b2,
            fabric$1.util.multiplyTransformMatrices(
              fabric$1.util.invertTransform(a2.calcTransformMatrix()),
              b2.calcTransformMatrix()
            )
          );
          var inverted = a2.inverted && b2.inverted;
          if (inverted) {
            a2.inverted = b2.inverted = false;
          }
          return new fabric$1.Group([a2], { clipPath: b2, inverted });
        },
        /**
         * @memberOf fabric.util
         * @param {Object} prevStyle first style to compare
         * @param {Object} thisStyle second style to compare
         * @param {boolean} forTextSpans whether to check overline, underline, and line-through properties
         * @return {boolean} true if the style changed
         */
        hasStyleChanged: function(prevStyle, thisStyle, forTextSpans) {
          forTextSpans = forTextSpans || false;
          return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor || prevStyle.deltaY !== thisStyle.deltaY || forTextSpans && (prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough);
        },
        /**
         * Returns the array form of a text object's inline styles property with styles grouped in ranges
         * rather than per character. This format is less verbose, and is better suited for storage
         * so it is used in serialization (not during runtime).
         * @memberOf fabric.util
         * @param {object} styles per character styles for a text object
         * @param {String} text the text string that the styles are applied to
         * @return {{start: number, end: number, style: object}[]}
         */
        stylesToArray: function(styles, text2) {
          var styles = fabric$1.util.object.clone(styles, true), textLines = text2.split("\n"), charIndex = -1, prevStyle = {}, stylesArray = [];
          for (var i2 = 0; i2 < textLines.length; i2++) {
            if (!styles[i2]) {
              charIndex += textLines[i2].length;
              continue;
            }
            for (var c2 = 0; c2 < textLines[i2].length; c2++) {
              charIndex++;
              var thisStyle = styles[i2][c2];
              if (thisStyle && Object.keys(thisStyle).length > 0) {
                var styleChanged = fabric$1.util.hasStyleChanged(prevStyle, thisStyle, true);
                if (styleChanged) {
                  stylesArray.push({
                    start: charIndex,
                    end: charIndex + 1,
                    style: thisStyle
                  });
                } else {
                  stylesArray[stylesArray.length - 1].end++;
                }
              }
              prevStyle = thisStyle || {};
            }
          }
          return stylesArray;
        },
        /**
         * Returns the object form of the styles property with styles that are assigned per
         * character rather than grouped by range. This format is more verbose, and is
         * only used during runtime (not for serialization/storage)
         * @memberOf fabric.util
         * @param {Array} styles the serialized form of a text object's styles
         * @param {String} text the text string that the styles are applied to
         * @return {Object}
         */
        stylesFromArray: function(styles, text2) {
          if (!Array.isArray(styles)) {
            return styles;
          }
          var textLines = text2.split("\n"), charIndex = -1, styleIndex = 0, stylesObject = {};
          for (var i2 = 0; i2 < textLines.length; i2++) {
            for (var c2 = 0; c2 < textLines[i2].length; c2++) {
              charIndex++;
              if (styles[styleIndex] && styles[styleIndex].start <= charIndex && charIndex < styles[styleIndex].end) {
                stylesObject[i2] = stylesObject[i2] || {};
                stylesObject[i2][c2] = Object.assign({}, styles[styleIndex].style);
                if (charIndex === styles[styleIndex].end - 1) {
                  styleIndex++;
                }
              }
            }
          }
          return stylesObject;
        }
      };
    })(exports);
    (function() {
      var _join = Array.prototype.join, commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      }, repeatedCommands = {
        m: "l",
        M: "L"
      };
      function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
        var costh2 = fabric$1.util.cos(th2), sinth2 = fabric$1.util.sin(th2), costh3 = fabric$1.util.cos(th3), sinth3 = fabric$1.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);
        return [
          "C",
          cp1X,
          cp1Y,
          cp2X,
          cp2Y,
          toX,
          toY
        ];
      }
      function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
        var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric$1.util.sin(th), cosTh = fabric$1.util.cos(th), fromX = 0, fromY = 0;
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;
        if (pl < 0) {
          var s2 = Math.sqrt(1 - pl / (rx2 * ry2));
          rx *= s2;
          ry *= s2;
        } else {
          root = (large === sweep ? -1 : 1) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
        }
        var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
        if (sweep === 0 && dtheta > 0) {
          dtheta -= 2 * PI;
        } else if (sweep === 1 && dtheta < 0) {
          dtheta += 2 * PI;
        }
        var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;
        for (var i2 = 0; i2 < segments; i2++) {
          result[i2] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
          fromX = result[i2][5];
          fromY = result[i2][6];
          mTheta = th3;
          th3 += mDelta;
        }
        return result;
      }
      function calcVectorAngle(ux, uy, vx, vy) {
        var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);
        if (tb >= ta) {
          return tb - ta;
        } else {
          return 2 * Math.PI - (ta - tb);
        }
      }
      function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
        var argsString;
        if (fabric$1.cachesBoundsOfCurve) {
          argsString = _join.call(arguments);
          if (fabric$1.boundsOfCurveCache[argsString]) {
            return fabric$1.boundsOfCurveCache[argsString];
          }
        }
        var sqrt = Math.sqrt, min = Math.min, max = Math.max, abs = Math.abs, tvalues = [], bounds = [[], []], a2, b2, c2, t3, t1, t22, b2ac, sqrtb2ac;
        b2 = 6 * x0 - 12 * x1 + 6 * x2;
        a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c2 = 3 * x1 - 3 * x0;
        for (var i2 = 0; i2 < 2; ++i2) {
          if (i2 > 0) {
            b2 = 6 * y0 - 12 * y1 + 6 * y2;
            a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
            c2 = 3 * y1 - 3 * y0;
          }
          if (abs(a2) < 1e-12) {
            if (abs(b2) < 1e-12) {
              continue;
            }
            t3 = -c2 / b2;
            if (0 < t3 && t3 < 1) {
              tvalues.push(t3);
            }
            continue;
          }
          b2ac = b2 * b2 - 4 * c2 * a2;
          if (b2ac < 0) {
            continue;
          }
          sqrtb2ac = sqrt(b2ac);
          t1 = (-b2 + sqrtb2ac) / (2 * a2);
          if (0 < t1 && t1 < 1) {
            tvalues.push(t1);
          }
          t22 = (-b2 - sqrtb2ac) / (2 * a2);
          if (0 < t22 && t22 < 1) {
            tvalues.push(t22);
          }
        }
        var x4, y4, j2 = tvalues.length, jlen = j2, mt2;
        while (j2--) {
          t3 = tvalues[j2];
          mt2 = 1 - t3;
          x4 = mt2 * mt2 * mt2 * x0 + 3 * mt2 * mt2 * t3 * x1 + 3 * mt2 * t3 * t3 * x2 + t3 * t3 * t3 * x3;
          bounds[0][j2] = x4;
          y4 = mt2 * mt2 * mt2 * y0 + 3 * mt2 * mt2 * t3 * y1 + 3 * mt2 * t3 * t3 * y2 + t3 * t3 * t3 * y3;
          bounds[1][j2] = y4;
        }
        bounds[0][jlen] = x0;
        bounds[1][jlen] = y0;
        bounds[0][jlen + 1] = x3;
        bounds[1][jlen + 1] = y3;
        var result = [
          {
            x: min.apply(null, bounds[0]),
            y: min.apply(null, bounds[1])
          },
          {
            x: max.apply(null, bounds[0]),
            y: max.apply(null, bounds[1])
          }
        ];
        if (fabric$1.cachesBoundsOfCurve) {
          fabric$1.boundsOfCurveCache[argsString] = result;
        }
        return result;
      }
      function fromArcToBeziers(fx, fy, coords) {
        var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
        for (var i2 = 0, len = segsNorm.length; i2 < len; i2++) {
          segsNorm[i2][1] += fx;
          segsNorm[i2][2] += fy;
          segsNorm[i2][3] += fx;
          segsNorm[i2][4] += fy;
          segsNorm[i2][5] += fx;
          segsNorm[i2][6] += fy;
        }
        return segsNorm;
      }
      function makePathSimpler(path2) {
        var x2 = 0, y2 = 0, len = path2.length, x1 = 0, y1 = 0, current, i2, converted, destinationPath = [], previous, controlX, controlY;
        for (i2 = 0; i2 < len; ++i2) {
          converted = false;
          current = path2[i2].slice(0);
          switch (current[0]) {
            // first letter
            case "l":
              current[0] = "L";
              current[1] += x2;
              current[2] += y2;
            // falls through
            case "L":
              x2 = current[1];
              y2 = current[2];
              break;
            case "h":
              current[1] += x2;
            // falls through
            case "H":
              current[0] = "L";
              current[2] = y2;
              x2 = current[1];
              break;
            case "v":
              current[1] += y2;
            // falls through
            case "V":
              current[0] = "L";
              y2 = current[1];
              current[1] = x2;
              current[2] = y2;
              break;
            case "m":
              current[0] = "M";
              current[1] += x2;
              current[2] += y2;
            // falls through
            case "M":
              x2 = current[1];
              y2 = current[2];
              x1 = current[1];
              y1 = current[2];
              break;
            case "c":
              current[0] = "C";
              current[1] += x2;
              current[2] += y2;
              current[3] += x2;
              current[4] += y2;
              current[5] += x2;
              current[6] += y2;
            // falls through
            case "C":
              controlX = current[3];
              controlY = current[4];
              x2 = current[5];
              y2 = current[6];
              break;
            case "s":
              current[0] = "S";
              current[1] += x2;
              current[2] += y2;
              current[3] += x2;
              current[4] += y2;
            // falls through
            case "S":
              if (previous === "C") {
                controlX = 2 * x2 - controlX;
                controlY = 2 * y2 - controlY;
              } else {
                controlX = x2;
                controlY = y2;
              }
              x2 = current[3];
              y2 = current[4];
              current[0] = "C";
              current[5] = current[3];
              current[6] = current[4];
              current[3] = current[1];
              current[4] = current[2];
              current[1] = controlX;
              current[2] = controlY;
              controlX = current[3];
              controlY = current[4];
              break;
            case "q":
              current[0] = "Q";
              current[1] += x2;
              current[2] += y2;
              current[3] += x2;
              current[4] += y2;
            // falls through
            case "Q":
              controlX = current[1];
              controlY = current[2];
              x2 = current[3];
              y2 = current[4];
              break;
            case "t":
              current[0] = "T";
              current[1] += x2;
              current[2] += y2;
            // falls through
            case "T":
              if (previous === "Q") {
                controlX = 2 * x2 - controlX;
                controlY = 2 * y2 - controlY;
              } else {
                controlX = x2;
                controlY = y2;
              }
              current[0] = "Q";
              x2 = current[1];
              y2 = current[2];
              current[1] = controlX;
              current[2] = controlY;
              current[3] = x2;
              current[4] = y2;
              break;
            case "a":
              current[0] = "A";
              current[6] += x2;
              current[7] += y2;
            // falls through
            case "A":
              converted = true;
              destinationPath = destinationPath.concat(fromArcToBeziers(x2, y2, current));
              x2 = current[6];
              y2 = current[7];
              break;
            case "z":
            case "Z":
              x2 = x1;
              y2 = y1;
              break;
          }
          if (!converted) {
            destinationPath.push(current);
          }
          previous = current[0];
        }
        return destinationPath;
      }
      function calcLineLength(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      }
      function CB12(t3) {
        return t3 * t3 * t3;
      }
      function CB22(t3) {
        return 3 * t3 * t3 * (1 - t3);
      }
      function CB32(t3) {
        return 3 * t3 * (1 - t3) * (1 - t3);
      }
      function CB42(t3) {
        return (1 - t3) * (1 - t3) * (1 - t3);
      }
      function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        return function(pct) {
          var c1 = CB12(pct), c2 = CB22(pct), c3 = CB32(pct), c4 = CB42(pct);
          return {
            x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
            y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
          };
        };
      }
      function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
        return function(pct) {
          var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);
          return Math.atan2(tangentY, tangentX);
        };
      }
      function QB12(t3) {
        return t3 * t3;
      }
      function QB22(t3) {
        return 2 * t3 * (1 - t3);
      }
      function QB32(t3) {
        return (1 - t3) * (1 - t3);
      }
      function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
        return function(pct) {
          var c1 = QB12(pct), c2 = QB22(pct), c3 = QB32(pct);
          return {
            x: p3x * c1 + p2x * c2 + p1x * c3,
            y: p3y * c1 + p2y * c2 + p1y * c3
          };
        };
      }
      function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
        return function(pct) {
          var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);
          return Math.atan2(tangentY, tangentX);
        };
      }
      function pathIterator(iterator2, x1, y1) {
        var tempP = { x: x1, y: y1 }, p2, tmpLen = 0, perc;
        for (perc = 1; perc <= 100; perc += 1) {
          p2 = iterator2(perc / 100);
          tmpLen += calcLineLength(tempP.x, tempP.y, p2.x, p2.y);
          tempP = p2;
        }
        return tmpLen;
      }
      function findPercentageForDistance(segInfo, distance2) {
        var perc = 0, tmpLen = 0, iterator2 = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y }, p2, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
        while (tmpLen < distance2 && nextStep > 1e-4) {
          p2 = iterator2(perc);
          lastPerc = perc;
          nextLen = calcLineLength(tempP.x, tempP.y, p2.x, p2.y);
          if (nextLen + tmpLen > distance2) {
            perc -= nextStep;
            nextStep /= 2;
          } else {
            tempP = p2;
            perc += nextStep;
            tmpLen += nextLen;
          }
        }
        p2.angle = angleFinder(lastPerc);
        return p2;
      }
      function getPathSegmentsInfo(path2) {
        var totalLength = 0, len = path2.length, current, x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator2, tempInfo, angleFinder;
        for (var i2 = 0; i2 < len; i2++) {
          current = path2[i2];
          tempInfo = {
            x: x1,
            y: y1,
            command: current[0]
          };
          switch (current[0]) {
            //first letter
            case "M":
              tempInfo.length = 0;
              x2 = x1 = current[1];
              y2 = y1 = current[2];
              break;
            case "L":
              tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
              x1 = current[1];
              y1 = current[2];
              break;
            case "C":
              iterator2 = getPointOnCubicBezierIterator(
                x1,
                y1,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6]
              );
              angleFinder = getTangentCubicIterator(
                x1,
                y1,
                current[1],
                current[2],
                current[3],
                current[4],
                current[5],
                current[6]
              );
              tempInfo.iterator = iterator2;
              tempInfo.angleFinder = angleFinder;
              tempInfo.length = pathIterator(iterator2, x1, y1);
              x1 = current[5];
              y1 = current[6];
              break;
            case "Q":
              iterator2 = getPointOnQuadraticBezierIterator(
                x1,
                y1,
                current[1],
                current[2],
                current[3],
                current[4]
              );
              angleFinder = getTangentQuadraticIterator(
                x1,
                y1,
                current[1],
                current[2],
                current[3],
                current[4]
              );
              tempInfo.iterator = iterator2;
              tempInfo.angleFinder = angleFinder;
              tempInfo.length = pathIterator(iterator2, x1, y1);
              x1 = current[3];
              y1 = current[4];
              break;
            case "Z":
            case "z":
              tempInfo.destX = x2;
              tempInfo.destY = y2;
              tempInfo.length = calcLineLength(x1, y1, x2, y2);
              x1 = x2;
              y1 = y2;
              break;
          }
          totalLength += tempInfo.length;
          info.push(tempInfo);
        }
        info.push({ length: totalLength, x: x1, y: y1 });
        return info;
      }
      function getPointOnPath(path2, distance2, infos) {
        if (!infos) {
          infos = getPathSegmentsInfo(path2);
        }
        var i2 = 0;
        while (distance2 - infos[i2].length > 0 && i2 < infos.length - 2) {
          distance2 -= infos[i2].length;
          i2++;
        }
        var segInfo = infos[i2], segPercent = distance2 / segInfo.length, command = segInfo.command, segment = path2[i2], info;
        switch (command) {
          case "M":
            return { x: segInfo.x, y: segInfo.y, angle: 0 };
          case "Z":
          case "z":
            info = new fabric$1.Point(segInfo.x, segInfo.y).lerp(
              new fabric$1.Point(segInfo.destX, segInfo.destY),
              segPercent
            );
            info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
            return info;
          case "L":
            info = new fabric$1.Point(segInfo.x, segInfo.y).lerp(
              new fabric$1.Point(segment[1], segment[2]),
              segPercent
            );
            info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
            return info;
          case "C":
            return findPercentageForDistance(segInfo, distance2);
          case "Q":
            return findPercentageForDistance(segInfo, distance2);
        }
      }
      function parsePath(pathString) {
        var result = [], coords = [], currentPath, parsed, re2 = fabric$1.rePathCommand, rNumber = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", rNumberCommaWsp = "(" + rNumber + ")" + fabric$1.commaWsp, rFlagCommaWsp = "([01])" + fabric$1.commaWsp + "?", rArcSeq = rNumberCommaWsp + "?" + rNumberCommaWsp + "?" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + "?(" + rNumber + ")", regArcArgumentSequence = new RegExp(rArcSeq, "g"), match, coordsStr, path2;
        if (!pathString || !pathString.match) {
          return result;
        }
        path2 = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
        for (var i2 = 0, coordsParsed, len = path2.length; i2 < len; i2++) {
          currentPath = path2[i2];
          coordsStr = currentPath.slice(1).trim();
          coords.length = 0;
          var command = currentPath.charAt(0);
          coordsParsed = [command];
          if (command.toLowerCase() === "a") {
            for (var args; args = regArcArgumentSequence.exec(coordsStr); ) {
              for (var j2 = 1; j2 < args.length; j2++) {
                coords.push(args[j2]);
              }
            }
          } else {
            while (match = re2.exec(coordsStr)) {
              coords.push(match[0]);
            }
          }
          for (var j2 = 0, jlen = coords.length; j2 < jlen; j2++) {
            parsed = parseFloat(coords[j2]);
            if (!isNaN(parsed)) {
              coordsParsed.push(parsed);
            }
          }
          var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;
          if (coordsParsed.length - 1 > commandLength) {
            for (var k2 = 1, klen = coordsParsed.length; k2 < klen; k2 += commandLength) {
              result.push([command].concat(coordsParsed.slice(k2, k2 + commandLength)));
              command = repeatedCommand;
            }
          } else {
            result.push(coordsParsed);
          }
        }
        return result;
      }
      function getSmoothPathFromPoints(points, correction) {
        var path2 = [], i2, p1 = new fabric$1.Point(points[0].x, points[0].y), p2 = new fabric$1.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;
        correction = correction || 0;
        if (manyPoints) {
          multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
          multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
        }
        path2.push(["M", p1.x - multSignX * correction, p1.y - multSignY * correction]);
        for (i2 = 1; i2 < len; i2++) {
          if (!p1.eq(p2)) {
            var midPoint = p1.midPointFrom(p2);
            path2.push(["Q", p1.x, p1.y, midPoint.x, midPoint.y]);
          }
          p1 = points[i2];
          if (i2 + 1 < points.length) {
            p2 = points[i2 + 1];
          }
        }
        if (manyPoints) {
          multSignX = p1.x > points[i2 - 2].x ? 1 : p1.x === points[i2 - 2].x ? 0 : -1;
          multSignY = p1.y > points[i2 - 2].y ? 1 : p1.y === points[i2 - 2].y ? 0 : -1;
        }
        path2.push(["L", p1.x + multSignX * correction, p1.y + multSignY * correction]);
        return path2;
      }
      function transformPath2(path2, transform2, pathOffset) {
        if (pathOffset) {
          transform2 = fabric$1.util.multiplyTransformMatrices(
            transform2,
            [1, 0, 0, 1, -pathOffset.x, -pathOffset.y]
          );
        }
        return path2.map(function(pathSegment) {
          var newSegment = pathSegment.slice(0), point = {};
          for (var i2 = 1; i2 < pathSegment.length - 1; i2 += 2) {
            point.x = pathSegment[i2];
            point.y = pathSegment[i2 + 1];
            point = fabric$1.util.transformPoint(point, transform2);
            newSegment[i2] = point.x;
            newSegment[i2 + 1] = point.y;
          }
          return newSegment;
        });
      }
      fabric$1.util.joinPath = function(pathData) {
        return pathData.map(function(segment) {
          return segment.join(" ");
        }).join(" ");
      };
      fabric$1.util.parsePath = parsePath;
      fabric$1.util.makePathSimpler = makePathSimpler;
      fabric$1.util.getSmoothPathFromPoints = getSmoothPathFromPoints;
      fabric$1.util.getPathSegmentsInfo = getPathSegmentsInfo;
      fabric$1.util.getBoundsOfCurve = getBoundsOfCurve;
      fabric$1.util.getPointOnPath = getPointOnPath;
      fabric$1.util.transformPath = transformPath2;
    })();
    (function() {
      var slice = Array.prototype.slice;
      function invoke(array, method) {
        var args = slice.call(arguments, 2), result = [];
        for (var i2 = 0, len = array.length; i2 < len; i2++) {
          result[i2] = args.length ? array[i2][method].apply(array[i2], args) : array[i2][method].call(array[i2]);
        }
        return result;
      }
      function max(array, byProperty) {
        return find(array, byProperty, function(value1, value2) {
          return value1 >= value2;
        });
      }
      function min(array, byProperty) {
        return find(array, byProperty, function(value1, value2) {
          return value1 < value2;
        });
      }
      function fill2(array, value) {
        var k2 = array.length;
        while (k2--) {
          array[k2] = value;
        }
        return array;
      }
      function find(array, byProperty, condition) {
        if (!array || array.length === 0) {
          return;
        }
        var i2 = array.length - 1, result = byProperty ? array[i2][byProperty] : array[i2];
        if (byProperty) {
          while (i2--) {
            if (condition(array[i2][byProperty], result)) {
              result = array[i2][byProperty];
            }
          }
        } else {
          while (i2--) {
            if (condition(array[i2], result)) {
              result = array[i2];
            }
          }
        }
        return result;
      }
      fabric$1.util.array = {
        fill: fill2,
        invoke,
        min,
        max
      };
    })();
    (function() {
      function extend2(destination, source, deep) {
        if (deep) {
          if (!fabric$1.isLikelyNode && source instanceof Element) {
            destination = source;
          } else if (source instanceof Array) {
            destination = [];
            for (var i2 = 0, len = source.length; i2 < len; i2++) {
              destination[i2] = extend2({}, source[i2], deep);
            }
          } else if (source && typeof source === "object") {
            for (var property in source) {
              if (property === "canvas" || property === "group") {
                destination[property] = null;
              } else if (source.hasOwnProperty(property)) {
                destination[property] = extend2({}, source[property], deep);
              }
            }
          } else {
            destination = source;
          }
        } else {
          for (var property in source) {
            destination[property] = source[property];
          }
        }
        return destination;
      }
      function clone2(object, deep) {
        return extend2({}, object, deep);
      }
      fabric$1.util.object = {
        extend: extend2,
        clone: clone2
      };
      fabric$1.util.object.extend(fabric$1.util, fabric$1.Observable);
    })();
    (function() {
      function camelize(string) {
        return string.replace(/-+(.)?/g, function(match, character) {
          return character ? character.toUpperCase() : "";
        });
      }
      function capitalize2(string, firstLetterOnly) {
        return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
      }
      function escapeXml(string) {
        return string.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      function graphemeSplit(textstring) {
        var i2 = 0, chr, graphemes = [];
        for (i2 = 0, chr; i2 < textstring.length; i2++) {
          if ((chr = getWholeChar(textstring, i2)) === false) {
            continue;
          }
          graphemes.push(chr);
        }
        return graphemes;
      }
      function getWholeChar(str, i2) {
        var code = str.charCodeAt(i2);
        if (isNaN(code)) {
          return "";
        }
        if (code < 55296 || code > 57343) {
          return str.charAt(i2);
        }
        if (55296 <= code && code <= 56319) {
          if (str.length <= i2 + 1) {
            throw "High surrogate without following low surrogate";
          }
          var next = str.charCodeAt(i2 + 1);
          if (56320 > next || next > 57343) {
            throw "High surrogate without following low surrogate";
          }
          return str.charAt(i2) + str.charAt(i2 + 1);
        }
        if (i2 === 0) {
          throw "Low surrogate without preceding high surrogate";
        }
        var prev = str.charCodeAt(i2 - 1);
        if (55296 > prev || prev > 56319) {
          throw "Low surrogate without preceding high surrogate";
        }
        return false;
      }
      fabric$1.util.string = {
        camelize,
        capitalize: capitalize2,
        escapeXml,
        graphemeSplit
      };
    })();
    (function() {
      var slice = Array.prototype.slice, emptyFunction = function() {
      }, IS_DONTENUM_BUGGY = (function() {
        for (var p2 in { toString: 1 }) {
          if (p2 === "toString") {
            return false;
          }
        }
        return true;
      })(), addMethods = function(klass, source, parent) {
        for (var property in source) {
          if (property in klass.prototype && typeof klass.prototype[property] === "function" && (source[property] + "").indexOf("callSuper") > -1) {
            klass.prototype[property] = /* @__PURE__ */ (function(property2) {
              return function() {
                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property2].apply(this, arguments);
                this.constructor.superclass = superclass;
                if (property2 !== "initialize") {
                  return returnValue;
                }
              };
            })(property);
          } else {
            klass.prototype[property] = source[property];
          }
          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };
      function Subclass() {
      }
      function callSuper(methodName) {
        var parentMethod = null, _this = this;
        while (_this.constructor.superclass) {
          var superClassMethod = _this.constructor.superclass.prototype[methodName];
          if (_this[methodName] !== superClassMethod) {
            parentMethod = superClassMethod;
            break;
          }
          _this = _this.constructor.superclass.prototype;
        }
        if (!parentMethod) {
          return console.log("tried to callSuper " + methodName + ", method not found in prototype chain", this);
        }
        return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);
      }
      function createClass() {
        var parent = null, properties = slice.call(arguments, 0);
        if (typeof properties[0] === "function") {
          parent = properties.shift();
        }
        function klass() {
          this.initialize.apply(this, arguments);
        }
        klass.superclass = parent;
        klass.subclasses = [];
        if (parent) {
          Subclass.prototype = parent.prototype;
          klass.prototype = new Subclass();
          parent.subclasses.push(klass);
        }
        for (var i2 = 0, length = properties.length; i2 < length; i2++) {
          addMethods(klass, properties[i2], parent);
        }
        if (!klass.prototype.initialize) {
          klass.prototype.initialize = emptyFunction;
        }
        klass.prototype.constructor = klass;
        klass.prototype.callSuper = callSuper;
        return klass;
      }
      fabric$1.util.createClass = createClass;
    })();
    (function() {
      var couldUseAttachEvent = !!fabric$1.document.createElement("div").attachEvent, touchEvents = ["touchstart", "touchmove", "touchend"];
      fabric$1.util.addListener = function(element, eventName, handler, options) {
        element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
      };
      fabric$1.util.removeListener = function(element, eventName, handler, options) {
        element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
      };
      function getTouchInfo(event) {
        var touchProp = event.changedTouches;
        if (touchProp && touchProp[0]) {
          return touchProp[0];
        }
        return event;
      }
      fabric$1.util.getPointer = function(event) {
        var element = event.target, scroll = fabric$1.util.getScrollLeftTop(element), _evt = getTouchInfo(event);
        return {
          x: _evt.clientX + scroll.left,
          y: _evt.clientY + scroll.top
        };
      };
      fabric$1.util.isTouchEvent = function(event) {
        return touchEvents.indexOf(event.type) > -1 || event.pointerType === "touch";
      };
    })();
    (function() {
      function setStyle(element, styles) {
        var elementStyle = element.style;
        if (!elementStyle) {
          return element;
        }
        if (typeof styles === "string") {
          element.style.cssText += ";" + styles;
          return styles.indexOf("opacity") > -1 ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
        }
        for (var property in styles) {
          if (property === "opacity") {
            setOpacity(element, styles[property]);
          } else {
            var normalizedProperty = property === "float" || property === "cssFloat" ? typeof elementStyle.styleFloat === "undefined" ? "cssFloat" : "styleFloat" : property;
            elementStyle.setProperty(normalizedProperty, styles[property]);
          }
        }
        return element;
      }
      var parseEl = fabric$1.document.createElement("div"), supportsOpacity = typeof parseEl.style.opacity === "string", supportsFilters = typeof parseEl.style.filter === "string", reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, setOpacity = function(element) {
        return element;
      };
      if (supportsOpacity) {
        setOpacity = function(element, value) {
          element.style.opacity = value;
          return element;
        };
      } else if (supportsFilters) {
        setOpacity = function(element, value) {
          var es = element.style;
          if (element.currentStyle && !element.currentStyle.hasLayout) {
            es.zoom = 1;
          }
          if (reOpacity.test(es.filter)) {
            value = value >= 0.9999 ? "" : "alpha(opacity=" + value * 100 + ")";
            es.filter = es.filter.replace(reOpacity, value);
          } else {
            es.filter += " alpha(opacity=" + value * 100 + ")";
          }
          return element;
        };
      }
      fabric$1.util.setStyle = setStyle;
    })();
    (function() {
      var _slice = Array.prototype.slice;
      function getById(id) {
        return typeof id === "string" ? fabric$1.document.getElementById(id) : id;
      }
      var sliceCanConvertNodelists, toArray2 = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };
      try {
        sliceCanConvertNodelists = toArray2(fabric$1.document.childNodes) instanceof Array;
      } catch (err) {
      }
      if (!sliceCanConvertNodelists) {
        toArray2 = function(arrayLike) {
          var arr = new Array(arrayLike.length), i2 = arrayLike.length;
          while (i2--) {
            arr[i2] = arrayLike[i2];
          }
          return arr;
        };
      }
      function makeElement(tagName, attributes) {
        var el = fabric$1.document.createElement(tagName);
        for (var prop in attributes) {
          if (prop === "class") {
            el.className = attributes[prop];
          } else if (prop === "for") {
            el.htmlFor = attributes[prop];
          } else {
            el.setAttribute(prop, attributes[prop]);
          }
        }
        return el;
      }
      function addClass(element, className) {
        if (element && (" " + element.className + " ").indexOf(" " + className + " ") === -1) {
          element.className += (element.className ? " " : "") + className;
        }
      }
      function wrapElement(element, wrapper, attributes) {
        if (typeof wrapper === "string") {
          wrapper = makeElement(wrapper, attributes);
        }
        if (element.parentNode) {
          element.parentNode.replaceChild(wrapper, element);
        }
        wrapper.appendChild(element);
        return wrapper;
      }
      function getScrollLeftTop(element) {
        var left = 0, top = 0, docElement = fabric$1.document.documentElement, body = fabric$1.document.body || {
          scrollLeft: 0,
          scrollTop: 0
        };
        while (element && (element.parentNode || element.host)) {
          element = element.parentNode || element.host;
          if (element === fabric$1.document) {
            left = body.scrollLeft || docElement.scrollLeft || 0;
            top = body.scrollTop || docElement.scrollTop || 0;
          } else {
            left += element.scrollLeft || 0;
            top += element.scrollTop || 0;
          }
          if (element.nodeType === 1 && element.style.position === "fixed") {
            break;
          }
        }
        return { left, top };
      }
      function getElementOffset(element) {
        var docElem, doc = element && element.ownerDocument, box = { left: 0, top: 0 }, offset = { left: 0, top: 0 }, scrollLeftTop, offsetAttributes = {
          borderLeftWidth: "left",
          borderTopWidth: "top",
          paddingLeft: "left",
          paddingTop: "top"
        };
        if (!doc) {
          return offset;
        }
        for (var attr in offsetAttributes) {
          offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
        }
        docElem = doc.documentElement;
        if (typeof element.getBoundingClientRect !== "undefined") {
          box = element.getBoundingClientRect();
        }
        scrollLeftTop = getScrollLeftTop(element);
        return {
          left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
          top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top
        };
      }
      var getElementStyle;
      if (fabric$1.document.defaultView && fabric$1.document.defaultView.getComputedStyle) {
        getElementStyle = function(element, attr) {
          var style = fabric$1.document.defaultView.getComputedStyle(element, null);
          return style ? style[attr] : void 0;
        };
      } else {
        getElementStyle = function(element, attr) {
          var value = element.style[attr];
          if (!value && element.currentStyle) {
            value = element.currentStyle[attr];
          }
          return value;
        };
      }
      (function() {
        var style = fabric$1.document.documentElement.style, selectProp = "userSelect" in style ? "userSelect" : "MozUserSelect" in style ? "MozUserSelect" : "WebkitUserSelect" in style ? "WebkitUserSelect" : "KhtmlUserSelect" in style ? "KhtmlUserSelect" : "";
        function makeElementUnselectable(element) {
          if (typeof element.onselectstart !== "undefined") {
            element.onselectstart = fabric$1.util.falseFunction;
          }
          if (selectProp) {
            element.style[selectProp] = "none";
          } else if (typeof element.unselectable === "string") {
            element.unselectable = "on";
          }
          return element;
        }
        function makeElementSelectable(element) {
          if (typeof element.onselectstart !== "undefined") {
            element.onselectstart = null;
          }
          if (selectProp) {
            element.style[selectProp] = "";
          } else if (typeof element.unselectable === "string") {
            element.unselectable = "";
          }
          return element;
        }
        fabric$1.util.makeElementUnselectable = makeElementUnselectable;
        fabric$1.util.makeElementSelectable = makeElementSelectable;
      })();
      function getNodeCanvas(element) {
        var impl = fabric$1.jsdomImplForWrapper(element);
        return impl._canvas || impl._image;
      }
      function cleanUpJsdomNode(element) {
        if (!fabric$1.isLikelyNode) {
          return;
        }
        var impl = fabric$1.jsdomImplForWrapper(element);
        if (impl) {
          impl._image = null;
          impl._canvas = null;
          impl._currentSrc = null;
          impl._attributes = null;
          impl._classList = null;
        }
      }
      function setImageSmoothing(ctx, value) {
        ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
        ctx.imageSmoothingEnabled = value;
      }
      fabric$1.util.setImageSmoothing = setImageSmoothing;
      fabric$1.util.getById = getById;
      fabric$1.util.toArray = toArray2;
      fabric$1.util.addClass = addClass;
      fabric$1.util.makeElement = makeElement;
      fabric$1.util.wrapElement = wrapElement;
      fabric$1.util.getScrollLeftTop = getScrollLeftTop;
      fabric$1.util.getElementOffset = getElementOffset;
      fabric$1.util.getNodeCanvas = getNodeCanvas;
      fabric$1.util.cleanUpJsdomNode = cleanUpJsdomNode;
    })();
    (function() {
      function addParamToUrl(url, param) {
        return url + (/\?/.test(url) ? "&" : "?") + param;
      }
      function emptyFn() {
      }
      function request(url, options) {
        options || (options = {});
        var method = options.method ? options.method.toUpperCase() : "GET", onComplete = options.onComplete || function() {
        }, xhr = new fabric$1.window.XMLHttpRequest(), body = options.body || options.parameters;
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            onComplete(xhr);
            xhr.onreadystatechange = emptyFn;
          }
        };
        if (method === "GET") {
          body = null;
          if (typeof options.parameters === "string") {
            url = addParamToUrl(url, options.parameters);
          }
        }
        xhr.open(method, url, true);
        if (method === "POST" || method === "PUT") {
          xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        }
        xhr.send(body);
        return xhr;
      }
      fabric$1.util.request = request;
    })();
    fabric$1.log = console.log;
    fabric$1.warn = console.warn;
    (function() {
      var extend2 = fabric$1.util.object.extend, clone2 = fabric$1.util.object.clone;
      var RUNNING_ANIMATIONS = [];
      fabric$1.util.object.extend(RUNNING_ANIMATIONS, {
        /**
         * cancel all running animations at the next requestAnimFrame
         * @returns {AnimationContext[]}
         */
        cancelAll: function() {
          var animations = this.splice(0);
          animations.forEach(function(animation) {
            animation.cancel();
          });
          return animations;
        },
        /**
         * cancel all running animations attached to canvas at the next requestAnimFrame
         * @param {fabric.Canvas} canvas
         * @returns {AnimationContext[]}
         */
        cancelByCanvas: function(canvas) {
          if (!canvas) {
            return [];
          }
          var cancelled = this.filter(function(animation) {
            return typeof animation.target === "object" && animation.target.canvas === canvas;
          });
          cancelled.forEach(function(animation) {
            animation.cancel();
          });
          return cancelled;
        },
        /**
         * cancel all running animations for target at the next requestAnimFrame
         * @param {*} target
         * @returns {AnimationContext[]}
         */
        cancelByTarget: function(target) {
          var cancelled = this.findAnimationsByTarget(target);
          cancelled.forEach(function(animation) {
            animation.cancel();
          });
          return cancelled;
        },
        /**
         *
         * @param {CancelFunction} cancelFunc the function returned by animate
         * @returns {number}
         */
        findAnimationIndex: function(cancelFunc) {
          return this.indexOf(this.findAnimation(cancelFunc));
        },
        /**
         *
         * @param {CancelFunction} cancelFunc the function returned by animate
         * @returns {AnimationContext | undefined} animation's options object
         */
        findAnimation: function(cancelFunc) {
          return this.find(function(animation) {
            return animation.cancel === cancelFunc;
          });
        },
        /**
         *
         * @param {*} target the object that is assigned to the target property of the animation context
         * @returns {AnimationContext[]} array of animation options object associated with target
         */
        findAnimationsByTarget: function(target) {
          if (!target) {
            return [];
          }
          return this.filter(function(animation) {
            return animation.target === target;
          });
        }
      });
      function noop2() {
        return false;
      }
      function defaultEasing(t3, b2, c2, d2) {
        return -c2 * Math.cos(t3 / d2 * (Math.PI / 2)) + c2 + b2;
      }
      function animate(options) {
        options || (options = {});
        var cancel = false, context, removeFromRegistry = function() {
          var index2 = fabric$1.runningAnimations.indexOf(context);
          return index2 > -1 && fabric$1.runningAnimations.splice(index2, 1)[0];
        };
        context = extend2(clone2(options), {
          cancel: function() {
            cancel = true;
            return removeFromRegistry();
          },
          currentValue: "startValue" in options ? options.startValue : 0,
          completionRate: 0,
          durationRate: 0
        });
        fabric$1.runningAnimations.push(context);
        requestAnimFrame(function(timestamp) {
          var start = timestamp || +/* @__PURE__ */ new Date(), duration2 = options.duration || 500, finish = start + duration2, time2, onChange = options.onChange || noop2, abort = options.abort || noop2, onComplete = options.onComplete || noop2, easing = options.easing || defaultEasing, isMany = "startValue" in options ? options.startValue.length > 0 : false, startValue = "startValue" in options ? options.startValue : 0, endValue = "endValue" in options ? options.endValue : 100, byValue = options.byValue || (isMany ? startValue.map(function(value, i2) {
            return endValue[i2] - startValue[i2];
          }) : endValue - startValue);
          options.onStart && options.onStart();
          (function tick(ticktime) {
            time2 = ticktime || +/* @__PURE__ */ new Date();
            var currentTime = time2 > finish ? duration2 : time2 - start, timePerc = currentTime / duration2, current = isMany ? startValue.map(function(_value, i2) {
              return easing(currentTime, startValue[i2], byValue[i2], duration2);
            }) : easing(currentTime, startValue, byValue, duration2), valuePerc = isMany ? Math.abs((current[0] - startValue[0]) / byValue[0]) : Math.abs((current - startValue) / byValue);
            context.currentValue = isMany ? current.slice() : current;
            context.completionRate = valuePerc;
            context.durationRate = timePerc;
            if (cancel) {
              return;
            }
            if (abort(current, valuePerc, timePerc)) {
              removeFromRegistry();
              return;
            }
            if (time2 > finish) {
              context.currentValue = isMany ? endValue.slice() : endValue;
              context.completionRate = 1;
              context.durationRate = 1;
              onChange(isMany ? endValue.slice() : endValue, 1, 1);
              onComplete(endValue, 1, 1);
              removeFromRegistry();
              return;
            } else {
              onChange(current, valuePerc, timePerc);
              requestAnimFrame(tick);
            }
          })(start);
        });
        return context.cancel;
      }
      var _requestAnimFrame = fabric$1.window.requestAnimationFrame || fabric$1.window.webkitRequestAnimationFrame || fabric$1.window.mozRequestAnimationFrame || fabric$1.window.oRequestAnimationFrame || fabric$1.window.msRequestAnimationFrame || function(callback) {
        return fabric$1.window.setTimeout(callback, 1e3 / 60);
      };
      var _cancelAnimFrame = fabric$1.window.cancelAnimationFrame || fabric$1.window.clearTimeout;
      function requestAnimFrame() {
        return _requestAnimFrame.apply(fabric$1.window, arguments);
      }
      function cancelAnimFrame() {
        return _cancelAnimFrame.apply(fabric$1.window, arguments);
      }
      fabric$1.util.animate = animate;
      fabric$1.util.requestAnimFrame = requestAnimFrame;
      fabric$1.util.cancelAnimFrame = cancelAnimFrame;
      fabric$1.runningAnimations = RUNNING_ANIMATIONS;
    })();
    (function() {
      function calculateColor(begin, end, pos) {
        var color2 = "rgba(" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + "," + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + "," + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);
        color2 += "," + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
        color2 += ")";
        return color2;
      }
      function animateColor(fromColor, toColor, duration2, options) {
        var startColor = new fabric$1.Color(fromColor).getSource(), endColor = new fabric$1.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;
        options = options || {};
        return fabric$1.util.animate(fabric$1.util.object.extend(options, {
          duration: duration2 || 500,
          startValue: startColor,
          endValue: endColor,
          byValue: endColor,
          easing: function(currentTime, startValue, byValue, duration3) {
            var posValue = options.colorEasing ? options.colorEasing(currentTime, duration3) : 1 - Math.cos(currentTime / duration3 * (Math.PI / 2));
            return calculateColor(startValue, byValue, posValue);
          },
          // has to take in account for color restoring;
          onComplete: function(current, valuePerc, timePerc) {
            if (originalOnComplete) {
              return originalOnComplete(
                calculateColor(endColor, endColor, 0),
                valuePerc,
                timePerc
              );
            }
          },
          onChange: function(current, valuePerc, timePerc) {
            if (originalOnChange) {
              if (Array.isArray(current)) {
                return originalOnChange(
                  calculateColor(current, current, 0),
                  valuePerc,
                  timePerc
                );
              }
              originalOnChange(current, valuePerc, timePerc);
            }
          }
        }));
      }
      fabric$1.util.animateColor = animateColor;
    })();
    (function() {
      function normalize(a2, c2, p2, s2) {
        if (a2 < Math.abs(c2)) {
          a2 = c2;
          s2 = p2 / 4;
        } else {
          if (c2 === 0 && a2 === 0) {
            s2 = p2 / (2 * Math.PI) * Math.asin(1);
          } else {
            s2 = p2 / (2 * Math.PI) * Math.asin(c2 / a2);
          }
        }
        return { a: a2, c: c2, p: p2, s: s2 };
      }
      function elastic(opts, t3, d2) {
        return opts.a * Math.pow(2, 10 * (t3 -= 1)) * Math.sin((t3 * d2 - opts.s) * (2 * Math.PI) / opts.p);
      }
      function easeOutCubic(t3, b2, c2, d2) {
        return c2 * ((t3 = t3 / d2 - 1) * t3 * t3 + 1) + b2;
      }
      function easeInOutCubic(t3, b2, c2, d2) {
        t3 /= d2 / 2;
        if (t3 < 1) {
          return c2 / 2 * t3 * t3 * t3 + b2;
        }
        return c2 / 2 * ((t3 -= 2) * t3 * t3 + 2) + b2;
      }
      function easeInQuart(t3, b2, c2, d2) {
        return c2 * (t3 /= d2) * t3 * t3 * t3 + b2;
      }
      function easeOutQuart(t3, b2, c2, d2) {
        return -c2 * ((t3 = t3 / d2 - 1) * t3 * t3 * t3 - 1) + b2;
      }
      function easeInOutQuart(t3, b2, c2, d2) {
        t3 /= d2 / 2;
        if (t3 < 1) {
          return c2 / 2 * t3 * t3 * t3 * t3 + b2;
        }
        return -c2 / 2 * ((t3 -= 2) * t3 * t3 * t3 - 2) + b2;
      }
      function easeInQuint(t3, b2, c2, d2) {
        return c2 * (t3 /= d2) * t3 * t3 * t3 * t3 + b2;
      }
      function easeOutQuint(t3, b2, c2, d2) {
        return c2 * ((t3 = t3 / d2 - 1) * t3 * t3 * t3 * t3 + 1) + b2;
      }
      function easeInOutQuint(t3, b2, c2, d2) {
        t3 /= d2 / 2;
        if (t3 < 1) {
          return c2 / 2 * t3 * t3 * t3 * t3 * t3 + b2;
        }
        return c2 / 2 * ((t3 -= 2) * t3 * t3 * t3 * t3 + 2) + b2;
      }
      function easeInSine(t3, b2, c2, d2) {
        return -c2 * Math.cos(t3 / d2 * (Math.PI / 2)) + c2 + b2;
      }
      function easeOutSine(t3, b2, c2, d2) {
        return c2 * Math.sin(t3 / d2 * (Math.PI / 2)) + b2;
      }
      function easeInOutSine(t3, b2, c2, d2) {
        return -c2 / 2 * (Math.cos(Math.PI * t3 / d2) - 1) + b2;
      }
      function easeInExpo(t3, b2, c2, d2) {
        return t3 === 0 ? b2 : c2 * Math.pow(2, 10 * (t3 / d2 - 1)) + b2;
      }
      function easeOutExpo(t3, b2, c2, d2) {
        return t3 === d2 ? b2 + c2 : c2 * (-Math.pow(2, -10 * t3 / d2) + 1) + b2;
      }
      function easeInOutExpo(t3, b2, c2, d2) {
        if (t3 === 0) {
          return b2;
        }
        if (t3 === d2) {
          return b2 + c2;
        }
        t3 /= d2 / 2;
        if (t3 < 1) {
          return c2 / 2 * Math.pow(2, 10 * (t3 - 1)) + b2;
        }
        return c2 / 2 * (-Math.pow(2, -10 * --t3) + 2) + b2;
      }
      function easeInCirc(t3, b2, c2, d2) {
        return -c2 * (Math.sqrt(1 - (t3 /= d2) * t3) - 1) + b2;
      }
      function easeOutCirc(t3, b2, c2, d2) {
        return c2 * Math.sqrt(1 - (t3 = t3 / d2 - 1) * t3) + b2;
      }
      function easeInOutCirc(t3, b2, c2, d2) {
        t3 /= d2 / 2;
        if (t3 < 1) {
          return -c2 / 2 * (Math.sqrt(1 - t3 * t3) - 1) + b2;
        }
        return c2 / 2 * (Math.sqrt(1 - (t3 -= 2) * t3) + 1) + b2;
      }
      function easeInElastic(t3, b2, c2, d2) {
        var s2 = 1.70158, p2 = 0, a2 = c2;
        if (t3 === 0) {
          return b2;
        }
        t3 /= d2;
        if (t3 === 1) {
          return b2 + c2;
        }
        if (!p2) {
          p2 = d2 * 0.3;
        }
        var opts = normalize(a2, c2, p2, s2);
        return -elastic(opts, t3, d2) + b2;
      }
      function easeOutElastic(t3, b2, c2, d2) {
        var s2 = 1.70158, p2 = 0, a2 = c2;
        if (t3 === 0) {
          return b2;
        }
        t3 /= d2;
        if (t3 === 1) {
          return b2 + c2;
        }
        if (!p2) {
          p2 = d2 * 0.3;
        }
        var opts = normalize(a2, c2, p2, s2);
        return opts.a * Math.pow(2, -10 * t3) * Math.sin((t3 * d2 - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b2;
      }
      function easeInOutElastic(t3, b2, c2, d2) {
        var s2 = 1.70158, p2 = 0, a2 = c2;
        if (t3 === 0) {
          return b2;
        }
        t3 /= d2 / 2;
        if (t3 === 2) {
          return b2 + c2;
        }
        if (!p2) {
          p2 = d2 * (0.3 * 1.5);
        }
        var opts = normalize(a2, c2, p2, s2);
        if (t3 < 1) {
          return -0.5 * elastic(opts, t3, d2) + b2;
        }
        return opts.a * Math.pow(2, -10 * (t3 -= 1)) * Math.sin((t3 * d2 - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b2;
      }
      function easeInBack(t3, b2, c2, d2, s2) {
        if (s2 === void 0) {
          s2 = 1.70158;
        }
        return c2 * (t3 /= d2) * t3 * ((s2 + 1) * t3 - s2) + b2;
      }
      function easeOutBack(t3, b2, c2, d2, s2) {
        if (s2 === void 0) {
          s2 = 1.70158;
        }
        return c2 * ((t3 = t3 / d2 - 1) * t3 * ((s2 + 1) * t3 + s2) + 1) + b2;
      }
      function easeInOutBack(t3, b2, c2, d2, s2) {
        if (s2 === void 0) {
          s2 = 1.70158;
        }
        t3 /= d2 / 2;
        if (t3 < 1) {
          return c2 / 2 * (t3 * t3 * (((s2 *= 1.525) + 1) * t3 - s2)) + b2;
        }
        return c2 / 2 * ((t3 -= 2) * t3 * (((s2 *= 1.525) + 1) * t3 + s2) + 2) + b2;
      }
      function easeInBounce(t3, b2, c2, d2) {
        return c2 - easeOutBounce(d2 - t3, 0, c2, d2) + b2;
      }
      function easeOutBounce(t3, b2, c2, d2) {
        if ((t3 /= d2) < 1 / 2.75) {
          return c2 * (7.5625 * t3 * t3) + b2;
        } else if (t3 < 2 / 2.75) {
          return c2 * (7.5625 * (t3 -= 1.5 / 2.75) * t3 + 0.75) + b2;
        } else if (t3 < 2.5 / 2.75) {
          return c2 * (7.5625 * (t3 -= 2.25 / 2.75) * t3 + 0.9375) + b2;
        } else {
          return c2 * (7.5625 * (t3 -= 2.625 / 2.75) * t3 + 0.984375) + b2;
        }
      }
      function easeInOutBounce(t3, b2, c2, d2) {
        if (t3 < d2 / 2) {
          return easeInBounce(t3 * 2, 0, c2, d2) * 0.5 + b2;
        }
        return easeOutBounce(t3 * 2 - d2, 0, c2, d2) * 0.5 + c2 * 0.5 + b2;
      }
      fabric$1.util.ease = {
        /**
         * Quadratic easing in
         * @memberOf fabric.util.ease
         */
        easeInQuad: function(t3, b2, c2, d2) {
          return c2 * (t3 /= d2) * t3 + b2;
        },
        /**
         * Quadratic easing out
         * @memberOf fabric.util.ease
         */
        easeOutQuad: function(t3, b2, c2, d2) {
          return -c2 * (t3 /= d2) * (t3 - 2) + b2;
        },
        /**
         * Quadratic easing in and out
         * @memberOf fabric.util.ease
         */
        easeInOutQuad: function(t3, b2, c2, d2) {
          t3 /= d2 / 2;
          if (t3 < 1) {
            return c2 / 2 * t3 * t3 + b2;
          }
          return -c2 / 2 * (--t3 * (t3 - 2) - 1) + b2;
        },
        /**
         * Cubic easing in
         * @memberOf fabric.util.ease
         */
        easeInCubic: function(t3, b2, c2, d2) {
          return c2 * (t3 /= d2) * t3 * t3 + b2;
        },
        easeOutCubic,
        easeInOutCubic,
        easeInQuart,
        easeOutQuart,
        easeInOutQuart,
        easeInQuint,
        easeOutQuint,
        easeInOutQuint,
        easeInSine,
        easeOutSine,
        easeInOutSine,
        easeInExpo,
        easeOutExpo,
        easeInOutExpo,
        easeInCirc,
        easeOutCirc,
        easeInOutCirc,
        easeInElastic,
        easeOutElastic,
        easeInOutElastic,
        easeInBack,
        easeOutBack,
        easeInOutBack,
        easeInBounce,
        easeOutBounce,
        easeInOutBounce
      };
    })();
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, toFixed = fabric2.util.toFixed, parseUnit = fabric2.util.parseUnit, multiplyTransformMatrices = fabric2.util.multiplyTransformMatrices, svgValidTagNames = [
        "path",
        "circle",
        "polygon",
        "polyline",
        "ellipse",
        "rect",
        "line",
        "image",
        "text"
      ], svgViewBoxElements = ["symbol", "image", "marker", "pattern", "view", "svg"], svgInvalidAncestors = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], svgValidParents = ["symbol", "g", "a", "svg", "clipPath", "defs"], attributesMap = {
        cx: "left",
        x: "left",
        r: "radius",
        cy: "top",
        y: "top",
        display: "visible",
        visibility: "visible",
        transform: "transformMatrix",
        "fill-opacity": "fillOpacity",
        "fill-rule": "fillRule",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "font-style": "fontStyle",
        "font-weight": "fontWeight",
        "letter-spacing": "charSpacing",
        "paint-order": "paintFirst",
        "stroke-dasharray": "strokeDashArray",
        "stroke-dashoffset": "strokeDashOffset",
        "stroke-linecap": "strokeLineCap",
        "stroke-linejoin": "strokeLineJoin",
        "stroke-miterlimit": "strokeMiterLimit",
        "stroke-opacity": "strokeOpacity",
        "stroke-width": "strokeWidth",
        "text-decoration": "textDecoration",
        "text-anchor": "textAnchor",
        opacity: "opacity",
        "clip-path": "clipPath",
        "clip-rule": "clipRule",
        "vector-effect": "strokeUniform",
        "image-rendering": "imageSmoothing"
      }, colorAttributes = {
        stroke: "strokeOpacity",
        fill: "fillOpacity"
      }, fSize = "font-size", cPath = "clip-path";
      fabric2.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
      fabric2.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
      fabric2.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
      fabric2.svgValidParentsRegEx = getSvgRegex(svgValidParents);
      fabric2.cssRules = {};
      fabric2.gradientDefs = {};
      fabric2.clipPaths = {};
      function normalizeAttr(attr) {
        if (attr in attributesMap) {
          return attributesMap[attr];
        }
        return attr;
      }
      function normalizeValue2(attr, value, parentAttributes, fontSize2) {
        var isArray2 = Array.isArray(value), parsed;
        if ((attr === "fill" || attr === "stroke") && value === "none") {
          value = "";
        } else if (attr === "strokeUniform") {
          return value === "non-scaling-stroke";
        } else if (attr === "strokeDashArray") {
          if (value === "none") {
            value = null;
          } else {
            value = value.replace(/,/g, " ").split(/\s+/).map(parseFloat);
          }
        } else if (attr === "transformMatrix") {
          if (parentAttributes && parentAttributes.transformMatrix) {
            value = multiplyTransformMatrices(
              parentAttributes.transformMatrix,
              fabric2.parseTransformAttribute(value)
            );
          } else {
            value = fabric2.parseTransformAttribute(value);
          }
        } else if (attr === "visible") {
          value = value !== "none" && value !== "hidden";
          if (parentAttributes && parentAttributes.visible === false) {
            value = false;
          }
        } else if (attr === "opacity") {
          value = parseFloat(value);
          if (parentAttributes && typeof parentAttributes.opacity !== "undefined") {
            value *= parentAttributes.opacity;
          }
        } else if (attr === "textAnchor") {
          value = value === "start" ? "left" : value === "end" ? "right" : "center";
        } else if (attr === "charSpacing") {
          parsed = parseUnit(value, fontSize2) / fontSize2 * 1e3;
        } else if (attr === "paintFirst") {
          var fillIndex = value.indexOf("fill");
          var strokeIndex = value.indexOf("stroke");
          var value = "fill";
          if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
            value = "stroke";
          } else if (fillIndex === -1 && strokeIndex > -1) {
            value = "stroke";
          }
        } else if (attr === "href" || attr === "xlink:href" || attr === "font") {
          return value;
        } else if (attr === "imageSmoothing") {
          return value === "optimizeQuality";
        } else {
          parsed = isArray2 ? value.map(parseUnit) : parseUnit(value, fontSize2);
        }
        return !isArray2 && isNaN(parsed) ? value : parsed;
      }
      function getSvgRegex(arr) {
        return new RegExp("^(" + arr.join("|") + ")\\b", "i");
      }
      function _setStrokeFillOpacity(attributes) {
        for (var attr in colorAttributes) {
          if (typeof attributes[colorAttributes[attr]] === "undefined" || attributes[attr] === "") {
            continue;
          }
          if (typeof attributes[attr] === "undefined") {
            if (!fabric2.Object.prototype[attr]) {
              continue;
            }
            attributes[attr] = fabric2.Object.prototype[attr];
          }
          if (attributes[attr].indexOf("url(") === 0) {
            continue;
          }
          var color2 = new fabric2.Color(attributes[attr]);
          attributes[attr] = color2.setAlpha(toFixed(color2.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
        }
        return attributes;
      }
      function _getMultipleNodes(doc, nodeNames) {
        var nodeName, nodeArray = [], nodeList, i2, len;
        for (i2 = 0, len = nodeNames.length; i2 < len; i2++) {
          nodeName = nodeNames[i2];
          nodeList = doc.getElementsByTagName(nodeName);
          nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
        }
        return nodeArray;
      }
      fabric2.parseTransformAttribute = (function() {
        function rotateMatrix(matrix3, args) {
          var cos = fabric2.util.cos(args[0]), sin = fabric2.util.sin(args[0]), x2 = 0, y2 = 0;
          if (args.length === 3) {
            x2 = args[1];
            y2 = args[2];
          }
          matrix3[0] = cos;
          matrix3[1] = sin;
          matrix3[2] = -sin;
          matrix3[3] = cos;
          matrix3[4] = x2 - (cos * x2 - sin * y2);
          matrix3[5] = y2 - (sin * x2 + cos * y2);
        }
        function scaleMatrix(matrix3, args) {
          var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];
          matrix3[0] = multiplierX;
          matrix3[3] = multiplierY;
        }
        function skewMatrix(matrix3, args, pos) {
          matrix3[pos] = Math.tan(fabric2.util.degreesToRadians(args[0]));
        }
        function translateMatrix(matrix3, args) {
          matrix3[4] = args[0];
          if (args.length === 2) {
            matrix3[5] = args[1];
          }
        }
        var iMatrix = fabric2.iMatrix, number = fabric2.reNum, commaWsp = fabric2.commaWsp, skewX = "(?:(skewX)\\s*\\(\\s*(" + number + ")\\s*\\))", skewY = "(?:(skewY)\\s*\\(\\s*(" + number + ")\\s*\\))", rotate = "(?:(rotate)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + "))?\\s*\\))", scale = "(?:(scale)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + "))?\\s*\\))", translate = "(?:(translate)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + "))?\\s*\\))", matrix2 = "(?:(matrix)\\s*\\(\\s*(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")\\s*\\))", transform2 = "(?:" + matrix2 + "|" + translate + "|" + scale + "|" + rotate + "|" + skewX + "|" + skewY + ")", transforms = "(?:" + transform2 + "(?:" + commaWsp + "*" + transform2 + ")*)", transformList = "^\\s*(?:" + transforms + "?)\\s*$", reTransformList = new RegExp(transformList), reTransform = new RegExp(transform2, "g");
        return function(attributeValue) {
          var matrix3 = iMatrix.concat(), matrices = [];
          if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {
            return matrix3;
          }
          attributeValue.replace(reTransform, function(match) {
            var m2 = new RegExp(transform2).exec(match).filter(function(match2) {
              return !!match2;
            }), operation = m2[1], args = m2.slice(2).map(parseFloat);
            switch (operation) {
              case "translate":
                translateMatrix(matrix3, args);
                break;
              case "rotate":
                args[0] = fabric2.util.degreesToRadians(args[0]);
                rotateMatrix(matrix3, args);
                break;
              case "scale":
                scaleMatrix(matrix3, args);
                break;
              case "skewX":
                skewMatrix(matrix3, args, 2);
                break;
              case "skewY":
                skewMatrix(matrix3, args, 1);
                break;
              case "matrix":
                matrix3 = args;
                break;
            }
            matrices.push(matrix3.concat());
            matrix3 = iMatrix.concat();
          });
          var combinedMatrix = matrices[0];
          while (matrices.length > 1) {
            matrices.shift();
            combinedMatrix = fabric2.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
          }
          return combinedMatrix;
        };
      })();
      function parseStyleString(style, oStyle) {
        var attr, value;
        style.replace(/;\s*$/, "").split(";").forEach(function(chunk) {
          var pair = chunk.split(":");
          attr = pair[0].trim().toLowerCase();
          value = pair[1].trim();
          oStyle[attr] = value;
        });
      }
      function parseStyleObject(style, oStyle) {
        var attr, value;
        for (var prop in style) {
          if (typeof style[prop] === "undefined") {
            continue;
          }
          attr = prop.toLowerCase();
          value = style[prop];
          oStyle[attr] = value;
        }
      }
      function getGlobalStylesForElement(element, svgUid) {
        var styles = {};
        for (var rule in fabric2.cssRules[svgUid]) {
          if (elementMatchesRule(element, rule.split(" "))) {
            for (var property in fabric2.cssRules[svgUid][rule]) {
              styles[property] = fabric2.cssRules[svgUid][rule][property];
            }
          }
        }
        return styles;
      }
      function elementMatchesRule(element, selectors) {
        var firstMatching, parentMatching = true;
        firstMatching = selectorMatches(element, selectors.pop());
        if (firstMatching && selectors.length) {
          parentMatching = doesSomeParentMatch(element, selectors);
        }
        return firstMatching && parentMatching && selectors.length === 0;
      }
      function doesSomeParentMatch(element, selectors) {
        var selector, parentMatching = true;
        while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
          if (parentMatching) {
            selector = selectors.pop();
          }
          element = element.parentNode;
          parentMatching = selectorMatches(element, selector);
        }
        return selectors.length === 0;
      }
      function selectorMatches(element, selector) {
        var nodeName = element.nodeName, classNames = element.getAttribute("class"), id = element.getAttribute("id"), matcher, i2;
        matcher = new RegExp("^" + nodeName, "i");
        selector = selector.replace(matcher, "");
        if (id && selector.length) {
          matcher = new RegExp("#" + id + "(?![a-zA-Z\\-]+)", "i");
          selector = selector.replace(matcher, "");
        }
        if (classNames && selector.length) {
          classNames = classNames.split(" ");
          for (i2 = classNames.length; i2--; ) {
            matcher = new RegExp("\\." + classNames[i2] + "(?![a-zA-Z\\-]+)", "i");
            selector = selector.replace(matcher, "");
          }
        }
        return selector.length === 0;
      }
      function elementById(doc, id) {
        var el;
        doc.getElementById && (el = doc.getElementById(id));
        if (el) {
          return el;
        }
        var node2, i2, len, nodelist = doc.getElementsByTagName("*");
        for (i2 = 0, len = nodelist.length; i2 < len; i2++) {
          node2 = nodelist[i2];
          if (id === node2.getAttribute("id")) {
            return node2;
          }
        }
      }
      function parseUseDirectives(doc) {
        var nodelist = _getMultipleNodes(doc, ["use", "svg:use"]), i2 = 0;
        while (nodelist.length && i2 < nodelist.length) {
          var el = nodelist[i2], xlinkAttribute = el.getAttribute("xlink:href") || el.getAttribute("href");
          if (xlinkAttribute === null) {
            return;
          }
          var xlink = xlinkAttribute.slice(1), x2 = el.getAttribute("x") || 0, y2 = el.getAttribute("y") || 0, el2 = elementById(doc, xlink).cloneNode(true), currentTrans = (el2.getAttribute("transform") || "") + " translate(" + x2 + ", " + y2 + ")", parentNode, oldLength = nodelist.length, attr, j2, attrs, len, namespace = fabric2.svgNS;
          applyViewboxTransform(el2);
          if (/^svg$/i.test(el2.nodeName)) {
            var el3 = el2.ownerDocument.createElementNS(namespace, "g");
            for (j2 = 0, attrs = el2.attributes, len = attrs.length; j2 < len; j2++) {
              attr = attrs.item(j2);
              el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
            }
            while (el2.firstChild) {
              el3.appendChild(el2.firstChild);
            }
            el2 = el3;
          }
          for (j2 = 0, attrs = el.attributes, len = attrs.length; j2 < len; j2++) {
            attr = attrs.item(j2);
            if (attr.nodeName === "x" || attr.nodeName === "y" || attr.nodeName === "xlink:href" || attr.nodeName === "href") {
              continue;
            }
            if (attr.nodeName === "transform") {
              currentTrans = attr.nodeValue + " " + currentTrans;
            } else {
              el2.setAttribute(attr.nodeName, attr.nodeValue);
            }
          }
          el2.setAttribute("transform", currentTrans);
          el2.setAttribute("instantiated_by_use", "1");
          el2.removeAttribute("id");
          parentNode = el.parentNode;
          parentNode.replaceChild(el2, el);
          if (nodelist.length === oldLength) {
            i2++;
          }
        }
      }
      var reViewBoxAttrValue = new RegExp(
        "^\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*$"
      );
      function applyViewboxTransform(element) {
        if (!fabric2.svgViewBoxElementsRegEx.test(element.nodeName)) {
          return {};
        }
        var viewBoxAttr = element.getAttribute("viewBox"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix2, el, widthAttr = element.getAttribute("width"), heightAttr = element.getAttribute("height"), x2 = element.getAttribute("x") || 0, y2 = element.getAttribute("y") || 0, preserveAspectRatio = element.getAttribute("preserveAspectRatio") || "", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === "100%" || heightAttr === "100%", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = "", widthDiff = 0, heightDiff = 0;
        parsedDim.width = 0;
        parsedDim.height = 0;
        parsedDim.toBeParsed = toBeParsed;
        if (missingViewBox) {
          if ((x2 || y2) && element.parentNode && element.parentNode.nodeName !== "#document") {
            translateMatrix = " translate(" + parseUnit(x2) + " " + parseUnit(y2) + ") ";
            matrix2 = (element.getAttribute("transform") || "") + translateMatrix;
            element.setAttribute("transform", matrix2);
            element.removeAttribute("x");
            element.removeAttribute("y");
          }
        }
        if (toBeParsed) {
          return parsedDim;
        }
        if (missingViewBox) {
          parsedDim.width = parseUnit(widthAttr);
          parsedDim.height = parseUnit(heightAttr);
          return parsedDim;
        }
        minX = -parseFloat(viewBoxAttr[1]);
        minY = -parseFloat(viewBoxAttr[2]);
        viewBoxWidth = parseFloat(viewBoxAttr[3]);
        viewBoxHeight = parseFloat(viewBoxAttr[4]);
        parsedDim.minX = minX;
        parsedDim.minY = minY;
        parsedDim.viewBoxWidth = viewBoxWidth;
        parsedDim.viewBoxHeight = viewBoxHeight;
        if (!missingDimAttr) {
          parsedDim.width = parseUnit(widthAttr);
          parsedDim.height = parseUnit(heightAttr);
          scaleX = parsedDim.width / viewBoxWidth;
          scaleY = parsedDim.height / viewBoxHeight;
        } else {
          parsedDim.width = viewBoxWidth;
          parsedDim.height = viewBoxHeight;
        }
        preserveAspectRatio = fabric2.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
        if (preserveAspectRatio.alignX !== "none") {
          if (preserveAspectRatio.meetOrSlice === "meet") {
            scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;
          }
          if (preserveAspectRatio.meetOrSlice === "slice") {
            scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;
          }
          widthDiff = parsedDim.width - viewBoxWidth * scaleX;
          heightDiff = parsedDim.height - viewBoxHeight * scaleX;
          if (preserveAspectRatio.alignX === "Mid") {
            widthDiff /= 2;
          }
          if (preserveAspectRatio.alignY === "Mid") {
            heightDiff /= 2;
          }
          if (preserveAspectRatio.alignX === "Min") {
            widthDiff = 0;
          }
          if (preserveAspectRatio.alignY === "Min") {
            heightDiff = 0;
          }
        }
        if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x2 === 0 && y2 === 0) {
          return parsedDim;
        }
        if ((x2 || y2) && element.parentNode.nodeName !== "#document") {
          translateMatrix = " translate(" + parseUnit(x2) + " " + parseUnit(y2) + ") ";
        }
        matrix2 = translateMatrix + " matrix(" + scaleX + " 0 0 " + scaleY + " " + (minX * scaleX + widthDiff) + " " + (minY * scaleY + heightDiff) + ") ";
        if (element.nodeName === "svg") {
          el = element.ownerDocument.createElementNS(fabric2.svgNS, "g");
          while (element.firstChild) {
            el.appendChild(element.firstChild);
          }
          element.appendChild(el);
        } else {
          el = element;
          el.removeAttribute("x");
          el.removeAttribute("y");
          matrix2 = el.getAttribute("transform") + matrix2;
        }
        el.setAttribute("transform", matrix2);
        return parsedDim;
      }
      function hasAncestorWithNodeName(element, nodeName) {
        while (element && (element = element.parentNode)) {
          if (element.nodeName && nodeName.test(element.nodeName.replace("svg:", "")) && !element.getAttribute("instantiated_by_use")) {
            return true;
          }
        }
        return false;
      }
      fabric2.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
        if (!doc) {
          return;
        }
        parseUseDirectives(doc);
        var svgUid = fabric2.Object.__uid++, i2, len, options = applyViewboxTransform(doc), descendants = fabric2.util.toArray(doc.getElementsByTagName("*"));
        options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
        options.svgUid = svgUid;
        if (descendants.length === 0 && fabric2.isLikelyNode) {
          descendants = doc.selectNodes('//*[name(.)!="svg"]');
          var arr = [];
          for (i2 = 0, len = descendants.length; i2 < len; i2++) {
            arr[i2] = descendants[i2];
          }
          descendants = arr;
        }
        var elements2 = descendants.filter(function(el) {
          applyViewboxTransform(el);
          return fabric2.svgValidTagNamesRegEx.test(el.nodeName.replace("svg:", "")) && !hasAncestorWithNodeName(el, fabric2.svgInvalidAncestorsRegEx);
        });
        if (!elements2 || elements2 && !elements2.length) {
          callback && callback([], {});
          return;
        }
        var clipPaths = {};
        descendants.filter(function(el) {
          return el.nodeName.replace("svg:", "") === "clipPath";
        }).forEach(function(el) {
          var id = el.getAttribute("id");
          clipPaths[id] = fabric2.util.toArray(el.getElementsByTagName("*")).filter(function(el2) {
            return fabric2.svgValidTagNamesRegEx.test(el2.nodeName.replace("svg:", ""));
          });
        });
        fabric2.gradientDefs[svgUid] = fabric2.getGradientDefs(doc);
        fabric2.cssRules[svgUid] = fabric2.getCSSRules(doc);
        fabric2.clipPaths[svgUid] = clipPaths;
        fabric2.parseElements(elements2, function(instances, elements3) {
          if (callback) {
            callback(instances, options, elements3, descendants);
            delete fabric2.gradientDefs[svgUid];
            delete fabric2.cssRules[svgUid];
            delete fabric2.clipPaths[svgUid];
          }
        }, clone2(options), reviver, parsingOptions);
      };
      function recursivelyParseGradientsXlink(doc, gradient) {
        var gradientsAttrs = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], xlinkAttr = "xlink:href", xLink = gradient.getAttribute(xlinkAttr).slice(1), referencedGradient = elementById(doc, xLink);
        if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
          recursivelyParseGradientsXlink(doc, referencedGradient);
        }
        gradientsAttrs.forEach(function(attr) {
          if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
            gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
          }
        });
        if (!gradient.children.length) {
          var referenceClone = referencedGradient.cloneNode(true);
          while (referenceClone.firstChild) {
            gradient.appendChild(referenceClone.firstChild);
          }
        }
        gradient.removeAttribute(xlinkAttr);
      }
      var reFontDeclaration = new RegExp(
        "(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + fabric2.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + fabric2.reNum + "))?\\s+(.*)"
      );
      extend2(fabric2, {
        /**
         * Parses a short font declaration, building adding its properties to a style object
         * @static
         * @function
         * @memberOf fabric
         * @param {String} value font declaration
         * @param {Object} oStyle definition
         */
        parseFontDeclaration: function(value, oStyle) {
          var match = value.match(reFontDeclaration);
          if (!match) {
            return;
          }
          var fontStyle2 = match[1], fontWeight2 = match[3], fontSize2 = match[4], lineHeight2 = match[5], fontFamily2 = match[6];
          if (fontStyle2) {
            oStyle.fontStyle = fontStyle2;
          }
          if (fontWeight2) {
            oStyle.fontWeight = isNaN(parseFloat(fontWeight2)) ? fontWeight2 : parseFloat(fontWeight2);
          }
          if (fontSize2) {
            oStyle.fontSize = parseUnit(fontSize2);
          }
          if (fontFamily2) {
            oStyle.fontFamily = fontFamily2;
          }
          if (lineHeight2) {
            oStyle.lineHeight = lineHeight2 === "normal" ? 1 : lineHeight2;
          }
        },
        /**
         * Parses an SVG document, returning all of the gradient declarations found in it
         * @static
         * @function
         * @memberOf fabric
         * @param {SVGDocument} doc SVG document to parse
         * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
         */
        getGradientDefs: function(doc) {
          var tagArray = [
            "linearGradient",
            "radialGradient",
            "svg:linearGradient",
            "svg:radialGradient"
          ], elList = _getMultipleNodes(doc, tagArray), el, j2 = 0, gradientDefs = {};
          j2 = elList.length;
          while (j2--) {
            el = elList[j2];
            if (el.getAttribute("xlink:href")) {
              recursivelyParseGradientsXlink(doc, el);
            }
            gradientDefs[el.getAttribute("id")] = el;
          }
          return gradientDefs;
        },
        /**
         * Returns an object of attributes' name/value, given element and an array of attribute names;
         * Parses parent "g" nodes recursively upwards.
         * @static
         * @memberOf fabric
         * @param {DOMElement} element Element to parse
         * @param {Array} attributes Array of attributes to parse
         * @return {Object} object containing parsed attributes' names/values
         */
        parseAttributes: function(element, attributes, svgUid) {
          if (!element) {
            return;
          }
          var value, parentAttributes = {}, fontSize2, parentFontSize;
          if (typeof svgUid === "undefined") {
            svgUid = element.getAttribute("svgUid");
          }
          if (element.parentNode && fabric2.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
            parentAttributes = fabric2.parseAttributes(element.parentNode, attributes, svgUid);
          }
          var ownAttributes = attributes.reduce(function(memo, attr2) {
            value = element.getAttribute(attr2);
            if (value) {
              memo[attr2] = value;
            }
            return memo;
          }, {});
          var cssAttrs = extend2(
            getGlobalStylesForElement(element, svgUid),
            fabric2.parseStyleAttribute(element)
          );
          ownAttributes = extend2(
            ownAttributes,
            cssAttrs
          );
          if (cssAttrs[cPath]) {
            element.setAttribute(cPath, cssAttrs[cPath]);
          }
          fontSize2 = parentFontSize = parentAttributes.fontSize || fabric2.Text.DEFAULT_SVG_FONT_SIZE;
          if (ownAttributes[fSize]) {
            ownAttributes[fSize] = fontSize2 = parseUnit(ownAttributes[fSize], parentFontSize);
          }
          var normalizedAttr, normalizedValue, normalizedStyle = {};
          for (var attr in ownAttributes) {
            normalizedAttr = normalizeAttr(attr);
            normalizedValue = normalizeValue2(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize2);
            normalizedStyle[normalizedAttr] = normalizedValue;
          }
          if (normalizedStyle && normalizedStyle.font) {
            fabric2.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
          }
          var mergedAttrs = extend2(parentAttributes, normalizedStyle);
          return fabric2.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
        },
        /**
         * Transforms an array of svg elements to corresponding fabric.* instances
         * @static
         * @memberOf fabric
         * @param {Array} elements Array of elements to parse
         * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
         * @param {Object} [options] Options object
         * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
         */
        parseElements: function(elements2, callback, options, reviver, parsingOptions) {
          new fabric2.ElementsParser(elements2, callback, options, reviver, parsingOptions).parse();
        },
        /**
         * Parses "style" attribute, retuning an object with values
         * @static
         * @memberOf fabric
         * @param {SVGElement} element Element to parse
         * @return {Object} Objects with values parsed from style attribute of an element
         */
        parseStyleAttribute: function(element) {
          var oStyle = {}, style = element.getAttribute("style");
          if (!style) {
            return oStyle;
          }
          if (typeof style === "string") {
            parseStyleString(style, oStyle);
          } else {
            parseStyleObject(style, oStyle);
          }
          return oStyle;
        },
        /**
         * Parses "points" attribute, returning an array of values
         * @static
         * @memberOf fabric
         * @param {String} points points attribute string
         * @return {Array} array of points
         */
        parsePointsAttribute: function(points) {
          if (!points) {
            return null;
          }
          points = points.replace(/,/g, " ").trim();
          points = points.split(/\s+/);
          var parsedPoints = [], i2, len;
          for (i2 = 0, len = points.length; i2 < len; i2 += 2) {
            parsedPoints.push({
              x: parseFloat(points[i2]),
              y: parseFloat(points[i2 + 1])
            });
          }
          return parsedPoints;
        },
        /**
         * Returns CSS rules for a given SVG document
         * @static
         * @function
         * @memberOf fabric
         * @param {SVGDocument} doc SVG document to parse
         * @return {Object} CSS rules of this document
         */
        getCSSRules: function(doc) {
          var styles = doc.getElementsByTagName("style"), i2, len, allRules = {}, rules;
          for (i2 = 0, len = styles.length; i2 < len; i2++) {
            var styleContents = styles[i2].textContent;
            styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, "");
            if (styleContents.trim() === "") {
              continue;
            }
            rules = styleContents.split("}");
            rules = rules.filter(function(rule) {
              return rule.trim();
            });
            rules.forEach(function(rule) {
              var match = rule.split("{"), ruleObj = {}, declaration = match[1].trim(), propertyValuePairs = declaration.split(";").filter(function(pair2) {
                return pair2.trim();
              });
              for (i2 = 0, len = propertyValuePairs.length; i2 < len; i2++) {
                var pair = propertyValuePairs[i2].split(":"), property = pair[0].trim(), value = pair[1].trim();
                ruleObj[property] = value;
              }
              rule = match[0].trim();
              rule.split(",").forEach(function(_rule) {
                _rule = _rule.replace(/^svg/i, "").trim();
                if (_rule === "") {
                  return;
                }
                if (allRules[_rule]) {
                  fabric2.util.object.extend(allRules[_rule], ruleObj);
                } else {
                  allRules[_rule] = fabric2.util.object.clone(ruleObj);
                }
              });
            });
          }
          return allRules;
        },
        /**
         * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
         * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
         * @memberOf fabric
         * @param {String} url
         * @param {Function} callback
         * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
         * @param {Object} [options] Object containing options for parsing
         * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
         */
        loadSVGFromURL: function(url, callback, reviver, options) {
          url = url.replace(/^\n\s*/, "").trim();
          new fabric2.util.request(url, {
            method: "get",
            onComplete
          });
          function onComplete(r2) {
            var xml2 = r2.responseXML;
            if (!xml2 || !xml2.documentElement) {
              callback && callback(null);
              return false;
            }
            fabric2.parseSVGDocument(xml2.documentElement, function(results, _options, elements2, allElements) {
              callback && callback(results, _options, elements2, allElements);
            }, reviver, options);
          }
        },
        /**
         * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
         * @memberOf fabric
         * @param {String} string
         * @param {Function} callback
         * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
         * @param {Object} [options] Object containing options for parsing
         * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
         */
        loadSVGFromString: function(string, callback, reviver, options) {
          var parser = new fabric2.window.DOMParser(), doc = parser.parseFromString(string.trim(), "text/xml");
          fabric2.parseSVGDocument(doc.documentElement, function(results, _options, elements2, allElements) {
            callback(results, _options, elements2, allElements);
          }, reviver, options);
        }
      });
    })(exports);
    fabric$1.ElementsParser = function(elements2, callback, options, reviver, parsingOptions, doc) {
      this.elements = elements2;
      this.callback = callback;
      this.options = options;
      this.reviver = reviver;
      this.svgUid = options && options.svgUid || 0;
      this.parsingOptions = parsingOptions;
      this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
      this.doc = doc;
    };
    (function(proto) {
      proto.parse = function() {
        this.instances = new Array(this.elements.length);
        this.numElements = this.elements.length;
        this.createObjects();
      };
      proto.createObjects = function() {
        var _this = this;
        this.elements.forEach(function(element, i2) {
          element.setAttribute("svgUid", _this.svgUid);
          _this.createObject(element, i2);
        });
      };
      proto.findTag = function(el) {
        return fabric$1[fabric$1.util.string.capitalize(el.tagName.replace("svg:", ""))];
      };
      proto.createObject = function(el, index2) {
        var klass = this.findTag(el);
        if (klass && klass.fromElement) {
          try {
            klass.fromElement(el, this.createCallback(index2, el), this.options);
          } catch (err) {
            fabric$1.log(err);
          }
        } else {
          this.checkIfDone();
        }
      };
      proto.createCallback = function(index2, el) {
        var _this = this;
        return function(obj) {
          var _options;
          _this.resolveGradient(obj, el, "fill");
          _this.resolveGradient(obj, el, "stroke");
          if (obj instanceof fabric$1.Image && obj._originalElement) {
            _options = obj.parsePreserveAspectRatioAttribute(el);
          }
          obj._removeTransformMatrix(_options);
          _this.resolveClipPath(obj, el);
          _this.reviver && _this.reviver(el, obj);
          _this.instances[index2] = obj;
          _this.checkIfDone();
        };
      };
      proto.extractPropertyDefinition = function(obj, property, storage) {
        var value = obj[property], regex = this.regexUrl;
        if (!regex.test(value)) {
          return;
        }
        regex.lastIndex = 0;
        var id = regex.exec(value)[1];
        regex.lastIndex = 0;
        return fabric$1[storage][this.svgUid][id];
      };
      proto.resolveGradient = function(obj, el, property) {
        var gradientDef = this.extractPropertyDefinition(obj, property, "gradientDefs");
        if (gradientDef) {
          var opacityAttr = el.getAttribute(property + "-opacity");
          var gradient = fabric$1.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
          obj.set(property, gradient);
        }
      };
      proto.createClipPathCallback = function(obj, container) {
        return function(_newObj) {
          _newObj._removeTransformMatrix();
          _newObj.fillRule = _newObj.clipRule;
          container.push(_newObj);
        };
      };
      proto.resolveClipPath = function(obj, usingElement) {
        var clipPath = this.extractPropertyDefinition(obj, "clipPath", "clipPaths"), element, klass, objTransformInv, container, gTransform, options;
        if (clipPath) {
          container = [];
          objTransformInv = fabric$1.util.invertTransform(obj.calcTransformMatrix());
          var clipPathTag = clipPath[0].parentNode;
          var clipPathOwner = usingElement;
          while (clipPathOwner.parentNode && clipPathOwner.getAttribute("clip-path") !== obj.clipPath) {
            clipPathOwner = clipPathOwner.parentNode;
          }
          clipPathOwner.parentNode.appendChild(clipPathTag);
          for (var i2 = 0; i2 < clipPath.length; i2++) {
            element = clipPath[i2];
            klass = this.findTag(element);
            klass.fromElement(
              element,
              this.createClipPathCallback(obj, container),
              this.options
            );
          }
          if (container.length === 1) {
            clipPath = container[0];
          } else {
            clipPath = new fabric$1.Group(container);
          }
          gTransform = fabric$1.util.multiplyTransformMatrices(
            objTransformInv,
            clipPath.calcTransformMatrix()
          );
          if (clipPath.clipPath) {
            this.resolveClipPath(clipPath, clipPathOwner);
          }
          var options = fabric$1.util.qrDecompose(gTransform);
          clipPath.flipX = false;
          clipPath.flipY = false;
          clipPath.set("scaleX", options.scaleX);
          clipPath.set("scaleY", options.scaleY);
          clipPath.angle = options.angle;
          clipPath.skewX = options.skewX;
          clipPath.skewY = 0;
          clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, "center", "center");
          obj.clipPath = clipPath;
        } else {
          delete obj.clipPath;
        }
      };
      proto.checkIfDone = function() {
        if (--this.numElements === 0) {
          this.instances = this.instances.filter(function(el) {
            return el != null;
          });
          this.callback(this.instances, this.elements);
        }
      };
    })(fabric$1.ElementsParser.prototype);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      if (fabric2.Point) {
        fabric2.warn("fabric.Point is already defined");
        return;
      }
      fabric2.Point = Point2;
      function Point2(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      Point2.prototype = /** @lends fabric.Point.prototype */
      {
        type: "point",
        constructor: Point2,
        /**
         * Adds another point to this one and returns another one
         * @param {fabric.Point} that
         * @return {fabric.Point} new Point instance with added values
         */
        add: function(that) {
          return new Point2(this.x + that.x, this.y + that.y);
        },
        /**
         * Adds another point to this one
         * @param {fabric.Point} that
         * @return {fabric.Point} thisArg
         * @chainable
         */
        addEquals: function(that) {
          this.x += that.x;
          this.y += that.y;
          return this;
        },
        /**
         * Adds value to this point and returns a new one
         * @param {Number} scalar
         * @return {fabric.Point} new Point with added value
         */
        scalarAdd: function(scalar) {
          return new Point2(this.x + scalar, this.y + scalar);
        },
        /**
         * Adds value to this point
         * @param {Number} scalar
         * @return {fabric.Point} thisArg
         * @chainable
         */
        scalarAddEquals: function(scalar) {
          this.x += scalar;
          this.y += scalar;
          return this;
        },
        /**
         * Subtracts another point from this point and returns a new one
         * @param {fabric.Point} that
         * @return {fabric.Point} new Point object with subtracted values
         */
        subtract: function(that) {
          return new Point2(this.x - that.x, this.y - that.y);
        },
        /**
         * Subtracts another point from this point
         * @param {fabric.Point} that
         * @return {fabric.Point} thisArg
         * @chainable
         */
        subtractEquals: function(that) {
          this.x -= that.x;
          this.y -= that.y;
          return this;
        },
        /**
         * Subtracts value from this point and returns a new one
         * @param {Number} scalar
         * @return {fabric.Point}
         */
        scalarSubtract: function(scalar) {
          return new Point2(this.x - scalar, this.y - scalar);
        },
        /**
         * Subtracts value from this point
         * @param {Number} scalar
         * @return {fabric.Point} thisArg
         * @chainable
         */
        scalarSubtractEquals: function(scalar) {
          this.x -= scalar;
          this.y -= scalar;
          return this;
        },
        /**
         * Multiplies this point by a value and returns a new one
         * TODO: rename in scalarMultiply in 2.0
         * @param {Number} scalar
         * @return {fabric.Point}
         */
        multiply: function(scalar) {
          return new Point2(this.x * scalar, this.y * scalar);
        },
        /**
         * Multiplies this point by a value
         * TODO: rename in scalarMultiplyEquals in 2.0
         * @param {Number} scalar
         * @return {fabric.Point} thisArg
         * @chainable
         */
        multiplyEquals: function(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          return this;
        },
        /**
         * Divides this point by a value and returns a new one
         * TODO: rename in scalarDivide in 2.0
         * @param {Number} scalar
         * @return {fabric.Point}
         */
        divide: function(scalar) {
          return new Point2(this.x / scalar, this.y / scalar);
        },
        /**
         * Divides this point by a value
         * TODO: rename in scalarDivideEquals in 2.0
         * @param {Number} scalar
         * @return {fabric.Point} thisArg
         * @chainable
         */
        divideEquals: function(scalar) {
          this.x /= scalar;
          this.y /= scalar;
          return this;
        },
        /**
         * Returns true if this point is equal to another one
         * @param {fabric.Point} that
         * @return {Boolean}
         */
        eq: function(that) {
          return this.x === that.x && this.y === that.y;
        },
        /**
         * Returns true if this point is less than another one
         * @param {fabric.Point} that
         * @return {Boolean}
         */
        lt: function(that) {
          return this.x < that.x && this.y < that.y;
        },
        /**
         * Returns true if this point is less than or equal to another one
         * @param {fabric.Point} that
         * @return {Boolean}
         */
        lte: function(that) {
          return this.x <= that.x && this.y <= that.y;
        },
        /**
        
        		     * Returns true if this point is greater another one
        		     * @param {fabric.Point} that
        		     * @return {Boolean}
        		     */
        gt: function(that) {
          return this.x > that.x && this.y > that.y;
        },
        /**
         * Returns true if this point is greater than or equal to another one
         * @param {fabric.Point} that
         * @return {Boolean}
         */
        gte: function(that) {
          return this.x >= that.x && this.y >= that.y;
        },
        /**
         * Returns new point which is the result of linear interpolation with this one and another one
         * @param {fabric.Point} that
         * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
         * @return {fabric.Point}
         */
        lerp: function(that, t3) {
          if (typeof t3 === "undefined") {
            t3 = 0.5;
          }
          t3 = Math.max(Math.min(1, t3), 0);
          return new Point2(this.x + (that.x - this.x) * t3, this.y + (that.y - this.y) * t3);
        },
        /**
         * Returns distance from this point and another one
         * @param {fabric.Point} that
         * @return {Number}
         */
        distanceFrom: function(that) {
          var dx = this.x - that.x, dy = this.y - that.y;
          return Math.sqrt(dx * dx + dy * dy);
        },
        /**
         * Returns the point between this point and another one
         * @param {fabric.Point} that
         * @return {fabric.Point}
         */
        midPointFrom: function(that) {
          return this.lerp(that);
        },
        /**
         * Returns a new point which is the min of this and another one
         * @param {fabric.Point} that
         * @return {fabric.Point}
         */
        min: function(that) {
          return new Point2(Math.min(this.x, that.x), Math.min(this.y, that.y));
        },
        /**
         * Returns a new point which is the max of this and another one
         * @param {fabric.Point} that
         * @return {fabric.Point}
         */
        max: function(that) {
          return new Point2(Math.max(this.x, that.x), Math.max(this.y, that.y));
        },
        /**
         * Returns string representation of this point
         * @return {String}
         */
        toString: function() {
          return this.x + "," + this.y;
        },
        /**
         * Sets x/y of this point
         * @param {Number} x
         * @param {Number} y
         * @chainable
         */
        setXY: function(x2, y2) {
          this.x = x2;
          this.y = y2;
          return this;
        },
        /**
         * Sets x of this point
         * @param {Number} x
         * @chainable
         */
        setX: function(x2) {
          this.x = x2;
          return this;
        },
        /**
         * Sets y of this point
         * @param {Number} y
         * @chainable
         */
        setY: function(y2) {
          this.y = y2;
          return this;
        },
        /**
         * Sets x/y of this point from another point
         * @param {fabric.Point} that
         * @chainable
         */
        setFromPoint: function(that) {
          this.x = that.x;
          this.y = that.y;
          return this;
        },
        /**
         * Swaps x/y of this point and another point
         * @param {fabric.Point} that
         */
        swap: function(that) {
          var x2 = this.x, y2 = this.y;
          this.x = that.x;
          this.y = that.y;
          that.x = x2;
          that.y = y2;
        },
        /**
         * return a cloned instance of the point
         * @return {fabric.Point}
         */
        clone: function() {
          return new Point2(this.x, this.y);
        }
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      if (fabric2.Intersection) {
        fabric2.warn("fabric.Intersection is already defined");
        return;
      }
      function Intersection(status) {
        this.status = status;
        this.points = [];
      }
      fabric2.Intersection = Intersection;
      fabric2.Intersection.prototype = /** @lends fabric.Intersection.prototype */
      {
        constructor: Intersection,
        /**
         * Appends a point to intersection
         * @param {fabric.Point} point
         * @return {fabric.Intersection} thisArg
         * @chainable
         */
        appendPoint: function(point) {
          this.points.push(point);
          return this;
        },
        /**
         * Appends points to intersection
         * @param {Array} points
         * @return {fabric.Intersection} thisArg
         * @chainable
         */
        appendPoints: function(points) {
          this.points = this.points.concat(points);
          return this;
        }
      };
      fabric2.Intersection.intersectLineLine = function(a1, a2, b1, b2) {
        var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
        if (uB !== 0) {
          var ua = uaT / uB, ub = ubT / uB;
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
            result = new Intersection("Intersection");
            result.appendPoint(new fabric2.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
          } else {
            result = new Intersection();
          }
        } else {
          if (uaT === 0 || ubT === 0) {
            result = new Intersection("Coincident");
          } else {
            result = new Intersection("Parallel");
          }
        }
        return result;
      };
      fabric2.Intersection.intersectLinePolygon = function(a1, a2, points) {
        var result = new Intersection(), length = points.length, b1, b2, inter, i2;
        for (i2 = 0; i2 < length; i2++) {
          b1 = points[i2];
          b2 = points[(i2 + 1) % length];
          inter = Intersection.intersectLineLine(a1, a2, b1, b2);
          result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
          result.status = "Intersection";
        }
        return result;
      };
      fabric2.Intersection.intersectPolygonPolygon = function(points1, points2) {
        var result = new Intersection(), length = points1.length, i2;
        for (i2 = 0; i2 < length; i2++) {
          var a1 = points1[i2], a2 = points1[(i2 + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);
          result.appendPoints(inter.points);
        }
        if (result.points.length > 0) {
          result.status = "Intersection";
        }
        return result;
      };
      fabric2.Intersection.intersectPolygonRectangle = function(points, r1, r2) {
        var min = r1.min(r2), max = r1.max(r2), topRight = new fabric2.Point(max.x, min.y), bottomLeft = new fabric2.Point(min.x, max.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max, points), inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();
        result.appendPoints(inter1.points);
        result.appendPoints(inter2.points);
        result.appendPoints(inter3.points);
        result.appendPoints(inter4.points);
        if (result.points.length > 0) {
          result.status = "Intersection";
        }
        return result;
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      if (fabric2.Color) {
        fabric2.warn("fabric.Color is already defined.");
        return;
      }
      function Color(color2) {
        if (!color2) {
          this.setSource([0, 0, 0, 1]);
        } else {
          this._tryParsingColor(color2);
        }
      }
      fabric2.Color = Color;
      fabric2.Color.prototype = /** @lends fabric.Color.prototype */
      {
        /**
         * @private
         * @param {String|Array} color Color value to parse
         */
        _tryParsingColor: function(color2) {
          var source;
          if (color2 in Color.colorNameMap) {
            color2 = Color.colorNameMap[color2];
          }
          if (color2 === "transparent") {
            source = [255, 255, 255, 0];
          }
          if (!source) {
            source = Color.sourceFromHex(color2);
          }
          if (!source) {
            source = Color.sourceFromRgb(color2);
          }
          if (!source) {
            source = Color.sourceFromHsl(color2);
          }
          if (!source) {
            source = [0, 0, 0, 1];
          }
          if (source) {
            this.setSource(source);
          }
        },
        /**
         * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
         * @private
         * @param {Number} r Red color value
         * @param {Number} g Green color value
         * @param {Number} b Blue color value
         * @return {Array} Hsl color
         */
        _rgbToHsl: function(r2, g2, b2) {
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          var h2, s2, l2, max = fabric2.util.array.max([r2, g2, b2]), min = fabric2.util.array.min([r2, g2, b2]);
          l2 = (max + min) / 2;
          if (max === min) {
            h2 = s2 = 0;
          } else {
            var d2 = max - min;
            s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
            switch (max) {
              case r2:
                h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                break;
              case g2:
                h2 = (b2 - r2) / d2 + 2;
                break;
              case b2:
                h2 = (r2 - g2) / d2 + 4;
                break;
            }
            h2 /= 6;
          }
          return [
            Math.round(h2 * 360),
            Math.round(s2 * 100),
            Math.round(l2 * 100)
          ];
        },
        /**
         * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
         * @return {Array}
         */
        getSource: function() {
          return this._source;
        },
        /**
         * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
         * @param {Array} source
         */
        setSource: function(source) {
          this._source = source;
        },
        /**
         * Returns color representation in RGB format
         * @return {String} ex: rgb(0-255,0-255,0-255)
         */
        toRgb: function() {
          var source = this.getSource();
          return "rgb(" + source[0] + "," + source[1] + "," + source[2] + ")";
        },
        /**
         * Returns color representation in RGBA format
         * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
         */
        toRgba: function() {
          var source = this.getSource();
          return "rgba(" + source[0] + "," + source[1] + "," + source[2] + "," + source[3] + ")";
        },
        /**
         * Returns color representation in HSL format
         * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
         */
        toHsl: function() {
          var source = this.getSource(), hsl2 = this._rgbToHsl(source[0], source[1], source[2]);
          return "hsl(" + hsl2[0] + "," + hsl2[1] + "%," + hsl2[2] + "%)";
        },
        /**
         * Returns color representation in HSLA format
         * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
         */
        toHsla: function() {
          var source = this.getSource(), hsl2 = this._rgbToHsl(source[0], source[1], source[2]);
          return "hsla(" + hsl2[0] + "," + hsl2[1] + "%," + hsl2[2] + "%," + source[3] + ")";
        },
        /**
         * Returns color representation in HEX format
         * @return {String} ex: FF5555
         */
        toHex: function() {
          var source = this.getSource(), r2, g2, b2;
          r2 = source[0].toString(16);
          r2 = r2.length === 1 ? "0" + r2 : r2;
          g2 = source[1].toString(16);
          g2 = g2.length === 1 ? "0" + g2 : g2;
          b2 = source[2].toString(16);
          b2 = b2.length === 1 ? "0" + b2 : b2;
          return r2.toUpperCase() + g2.toUpperCase() + b2.toUpperCase();
        },
        /**
         * Returns color representation in HEXA format
         * @return {String} ex: FF5555CC
         */
        toHexa: function() {
          var source = this.getSource(), a2;
          a2 = Math.round(source[3] * 255);
          a2 = a2.toString(16);
          a2 = a2.length === 1 ? "0" + a2 : a2;
          return this.toHex() + a2.toUpperCase();
        },
        /**
         * Gets value of alpha channel for this color
         * @return {Number} 0-1
         */
        getAlpha: function() {
          return this.getSource()[3];
        },
        /**
         * Sets value of alpha channel for this color
         * @param {Number} alpha Alpha value 0-1
         * @return {fabric.Color} thisArg
         */
        setAlpha: function(alpha) {
          var source = this.getSource();
          source[3] = alpha;
          this.setSource(source);
          return this;
        },
        /**
         * Transforms color to its grayscale representation
         * @return {fabric.Color} thisArg
         */
        toGrayscale: function() {
          var source = this.getSource(), average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10), currentAlpha = source[3];
          this.setSource([average, average, average, currentAlpha]);
          return this;
        },
        /**
         * Transforms color to its black and white representation
         * @param {Number} threshold
         * @return {fabric.Color} thisArg
         */
        toBlackWhite: function(threshold) {
          var source = this.getSource(), average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), currentAlpha = source[3];
          threshold = threshold || 127;
          average = Number(average) < Number(threshold) ? 0 : 255;
          this.setSource([average, average, average, currentAlpha]);
          return this;
        },
        /**
         * Overlays color with another color
         * @param {String|fabric.Color} otherColor
         * @return {fabric.Color} thisArg
         */
        overlayWith: function(otherColor) {
          if (!(otherColor instanceof Color)) {
            otherColor = new Color(otherColor);
          }
          var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source = this.getSource(), otherSource = otherColor.getSource(), i2;
          for (i2 = 0; i2 < 3; i2++) {
            result.push(Math.round(source[i2] * (1 - otherAlpha) + otherSource[i2] * otherAlpha));
          }
          result[3] = alpha;
          this.setSource(result);
          return this;
        }
      };
      fabric2.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;
      fabric2.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;
      fabric2.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
      fabric2.Color.colorNameMap = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aqua: "#00FFFF",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000000",
        blanchedalmond: "#FFEBCD",
        blue: "#0000FF",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#00FFFF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgrey: "#A9A9A9",
        darkgreen: "#006400",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        fuchsia: "#FF00FF",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        gray: "#808080",
        grey: "#808080",
        green: "#008000",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgray: "#D3D3D3",
        lightgrey: "#D3D3D3",
        lightgreen: "#90EE90",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        lime: "#00FF00",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#FF00FF",
        maroon: "#800000",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        navy: "#000080",
        oldlace: "#FDF5E6",
        olive: "#808000",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#FF0000",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        silver: "#C0C0C0",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        teal: "#008080",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        white: "#FFFFFF",
        whitesmoke: "#F5F5F5",
        yellow: "#FFFF00",
        yellowgreen: "#9ACD32"
      };
      function hue2rgb2(p2, q2, t3) {
        if (t3 < 0) {
          t3 += 1;
        }
        if (t3 > 1) {
          t3 -= 1;
        }
        if (t3 < 1 / 6) {
          return p2 + (q2 - p2) * 6 * t3;
        }
        if (t3 < 1 / 2) {
          return q2;
        }
        if (t3 < 2 / 3) {
          return p2 + (q2 - p2) * (2 / 3 - t3) * 6;
        }
        return p2;
      }
      fabric2.Color.fromRgb = function(color2) {
        return Color.fromSource(Color.sourceFromRgb(color2));
      };
      fabric2.Color.sourceFromRgb = function(color2) {
        var match = color2.match(Color.reRGBa);
        if (match) {
          var r2 = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g2 = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b2 = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
          return [
            parseInt(r2, 10),
            parseInt(g2, 10),
            parseInt(b2, 10),
            match[4] ? parseFloat(match[4]) : 1
          ];
        }
      };
      fabric2.Color.fromRgba = Color.fromRgb;
      fabric2.Color.fromHsl = function(color2) {
        return Color.fromSource(Color.sourceFromHsl(color2));
      };
      fabric2.Color.sourceFromHsl = function(color2) {
        var match = color2.match(Color.reHSLa);
        if (!match) {
          return;
        }
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s2 = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l2 = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r2, g2, b2;
        if (s2 === 0) {
          r2 = g2 = b2 = l2;
        } else {
          var q2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2, p2 = l2 * 2 - q2;
          r2 = hue2rgb2(p2, q2, h2 + 1 / 3);
          g2 = hue2rgb2(p2, q2, h2);
          b2 = hue2rgb2(p2, q2, h2 - 1 / 3);
        }
        return [
          Math.round(r2 * 255),
          Math.round(g2 * 255),
          Math.round(b2 * 255),
          match[4] ? parseFloat(match[4]) : 1
        ];
      };
      fabric2.Color.fromHsla = Color.fromHsl;
      fabric2.Color.fromHex = function(color2) {
        return Color.fromSource(Color.sourceFromHex(color2));
      };
      fabric2.Color.sourceFromHex = function(color2) {
        if (color2.match(Color.reHex)) {
          var value = color2.slice(color2.indexOf("#") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r2 = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g2 = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b2 = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a2 = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : "FF";
          return [
            parseInt(r2, 16),
            parseInt(g2, 16),
            parseInt(b2, 16),
            parseFloat((parseInt(a2, 16) / 255).toFixed(2))
          ];
        }
      };
      fabric2.Color.fromSource = function(source) {
        var oColor = new Color();
        oColor.setSource(source);
        return oColor;
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), scaleMap = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], skewMap = ["ns", "nesw", "ew", "nwse"], controls = {}, LEFT = "left", TOP = "top", RIGHT = "right", BOTTOM = "bottom", CENTER = "center", opposite = {
        top: BOTTOM,
        bottom: TOP,
        left: RIGHT,
        right: LEFT,
        center: CENTER
      }, radiansToDegrees = fabric2.util.radiansToDegrees, sign = Math.sign || function(x2) {
        return (x2 > 0) - (x2 < 0) || +x2;
      };
      function findCornerQuadrant(fabricObject, control) {
        var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;
        return Math.round(cornerAngle % 360 / 45);
      }
      function fireEvent(eventName, options) {
        var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric2.util.object.clone(options);
        canvasOptions.target = target;
        canvas && canvas.fire("object:" + eventName, canvasOptions);
        target.fire(eventName, options);
      }
      function scaleIsProportional(eventData, fabricObject) {
        var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];
        return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;
      }
      function isTransformCentered(transform2) {
        return transform2.originX === CENTER && transform2.originY === CENTER;
      }
      function scalingIsForbidden(fabricObject, by, scaleProportionally) {
        var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;
        if (lockX && lockY) {
          return true;
        }
        if (!by && (lockX || lockY) && scaleProportionally) {
          return true;
        }
        if (lockX && by === "x") {
          return true;
        }
        if (lockY && by === "y") {
          return true;
        }
        return false;
      }
      function scaleCursorStyleHandler(eventData, control, fabricObject) {
        var notAllowed = "not-allowed", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = "";
        if (control.x !== 0 && control.y === 0) {
          by = "x";
        } else if (control.x === 0 && control.y !== 0) {
          by = "y";
        }
        if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {
          return notAllowed;
        }
        var n2 = findCornerQuadrant(fabricObject, control);
        return scaleMap[n2] + "-resize";
      }
      function skewCursorStyleHandler(eventData, control, fabricObject) {
        var notAllowed = "not-allowed";
        if (control.x !== 0 && fabricObject.lockSkewingY) {
          return notAllowed;
        }
        if (control.y !== 0 && fabricObject.lockSkewingX) {
          return notAllowed;
        }
        var n2 = findCornerQuadrant(fabricObject, control) % 4;
        return skewMap[n2] + "-resize";
      }
      function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {
        if (eventData[fabricObject.canvas.altActionKey]) {
          return controls.skewCursorStyleHandler(eventData, control, fabricObject);
        }
        return controls.scaleCursorStyleHandler(eventData, control, fabricObject);
      }
      function scaleOrSkewActionName(eventData, control, fabricObject) {
        var isAlternative = eventData[fabricObject.canvas.altActionKey];
        if (control.x === 0) {
          return isAlternative ? "skewX" : "scaleY";
        }
        if (control.y === 0) {
          return isAlternative ? "skewY" : "scaleX";
        }
      }
      function rotationStyleHandler(eventData, control, fabricObject) {
        if (fabricObject.lockRotation) {
          return "not-allowed";
        }
        return control.cursorStyle;
      }
      function commonEventInfo(eventData, transform2, x2, y2) {
        return {
          e: eventData,
          transform: transform2,
          pointer: {
            x: x2,
            y: y2
          }
        };
      }
      function wrapWithFixedAnchor(actionHandler) {
        return function(eventData, transform2, x2, y2) {
          var target = transform2.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform2.originX, transform2.originY), actionPerformed = actionHandler(eventData, transform2, x2, y2);
          target.setPositionByOrigin(constraint, transform2.originX, transform2.originY);
          return actionPerformed;
        };
      }
      function wrapWithFireEvent(eventName, actionHandler) {
        return function(eventData, transform2, x2, y2) {
          var actionPerformed = actionHandler(eventData, transform2, x2, y2);
          if (actionPerformed) {
            fireEvent(eventName, commonEventInfo(eventData, transform2, x2, y2));
          }
          return actionPerformed;
        };
      }
      function getLocalPoint(transform2, originX, originY, x2, y2) {
        var target = transform2.target, control = target.controls[transform2.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric2.Point(x2, y2), originX, originY);
        if (localPoint.x >= padding) {
          localPoint.x -= padding;
        }
        if (localPoint.x <= -padding) {
          localPoint.x += padding;
        }
        if (localPoint.y >= padding) {
          localPoint.y -= padding;
        }
        if (localPoint.y <= padding) {
          localPoint.y += padding;
        }
        localPoint.x -= control.offsetX;
        localPoint.y -= control.offsetY;
        return localPoint;
      }
      function targetHasOneFlip(target) {
        return target.flipX !== target.flipY;
      }
      function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {
        if (target[oppositeSkew] !== 0) {
          var newDim = target._getTransformedDimensions()[axis];
          var newValue = reference / newDim * target[scaleToCompensate];
          target.set(scaleToCompensate, newValue);
        }
      }
      function skewObjectX(eventData, transform2, x2, y2) {
        var target = transform2.target, dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x2, y2), totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;
        if (totalSkewSize < 2) {
          newSkew = 0;
        } else {
          newSkew = radiansToDegrees(
            Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY)
          );
          if (transform2.originX === LEFT && transform2.originY === BOTTOM) {
            newSkew = -newSkew;
          }
          if (transform2.originX === RIGHT && transform2.originY === TOP) {
            newSkew = -newSkew;
          }
          if (targetHasOneFlip(target)) {
            newSkew = -newSkew;
          }
        }
        var hasSkewed = currentSkew !== newSkew;
        if (hasSkewed) {
          var dimBeforeSkewing = target._getTransformedDimensions().y;
          target.set("skewX", newSkew);
          compensateScaleForSkew(target, "skewY", "scaleY", "y", dimBeforeSkewing);
        }
        return hasSkewed;
      }
      function skewObjectY(eventData, transform2, x2, y2) {
        var target = transform2.target, dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x2, y2), totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;
        if (totalSkewSize < 2) {
          newSkew = 0;
        } else {
          newSkew = radiansToDegrees(
            Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX)
          );
          if (transform2.originX === LEFT && transform2.originY === BOTTOM) {
            newSkew = -newSkew;
          }
          if (transform2.originX === RIGHT && transform2.originY === TOP) {
            newSkew = -newSkew;
          }
          if (targetHasOneFlip(target)) {
            newSkew = -newSkew;
          }
        }
        var hasSkewed = currentSkew !== newSkew;
        if (hasSkewed) {
          var dimBeforeSkewing = target._getTransformedDimensions().x;
          target.set("skewY", newSkew);
          compensateScaleForSkew(target, "skewX", "scaleX", "x", dimBeforeSkewing);
        }
        return hasSkewed;
      }
      function skewHandlerX(eventData, transform2, x2, y2) {
        var target = transform2.target, currentSkew = target.skewX, originX, originY = transform2.originY;
        if (target.lockSkewingX) {
          return false;
        }
        if (currentSkew === 0) {
          var localPointFromCenter = getLocalPoint(transform2, CENTER, CENTER, x2, y2);
          if (localPointFromCenter.x > 0) {
            originX = LEFT;
          } else {
            originX = RIGHT;
          }
        } else {
          if (currentSkew > 0) {
            originX = originY === TOP ? LEFT : RIGHT;
          }
          if (currentSkew < 0) {
            originX = originY === TOP ? RIGHT : LEFT;
          }
          if (targetHasOneFlip(target)) {
            originX = originX === LEFT ? RIGHT : LEFT;
          }
        }
        transform2.originX = originX;
        var finalHandler = wrapWithFireEvent("skewing", wrapWithFixedAnchor(skewObjectX));
        return finalHandler(eventData, transform2, x2, y2);
      }
      function skewHandlerY(eventData, transform2, x2, y2) {
        var target = transform2.target, currentSkew = target.skewY, originY, originX = transform2.originX;
        if (target.lockSkewingY) {
          return false;
        }
        if (currentSkew === 0) {
          var localPointFromCenter = getLocalPoint(transform2, CENTER, CENTER, x2, y2);
          if (localPointFromCenter.y > 0) {
            originY = TOP;
          } else {
            originY = BOTTOM;
          }
        } else {
          if (currentSkew > 0) {
            originY = originX === LEFT ? TOP : BOTTOM;
          }
          if (currentSkew < 0) {
            originY = originX === LEFT ? BOTTOM : TOP;
          }
          if (targetHasOneFlip(target)) {
            originY = originY === TOP ? BOTTOM : TOP;
          }
        }
        transform2.originY = originY;
        var finalHandler = wrapWithFireEvent("skewing", wrapWithFixedAnchor(skewObjectY));
        return finalHandler(eventData, transform2, x2, y2);
      }
      function rotationWithSnapping(eventData, transform2, x2, y2) {
        var t3 = transform2, target = t3.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t3.originX, t3.originY);
        if (target.lockRotation) {
          return false;
        }
        var lastAngle = Math.atan2(t3.ey - pivotPoint.y, t3.ex - pivotPoint.x), curAngle = Math.atan2(y2 - pivotPoint.y, x2 - pivotPoint.x), angle2 = radiansToDegrees(curAngle - lastAngle + t3.theta), hasRotated = true;
        if (target.snapAngle > 0) {
          var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle2 / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle2 / snapAngle) * snapAngle;
          if (Math.abs(angle2 - leftAngleLocked) < snapThreshold) {
            angle2 = leftAngleLocked;
          } else if (Math.abs(angle2 - rightAngleLocked) < snapThreshold) {
            angle2 = rightAngleLocked;
          }
        }
        if (angle2 < 0) {
          angle2 = 360 + angle2;
        }
        angle2 %= 360;
        hasRotated = target.angle !== angle2;
        target.angle = angle2;
        return hasRotated;
      }
      function scaleObject(eventData, transform2, x2, y2, options) {
        options = options || {};
        var target = transform2.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform2.gestureScale;
        if (forbidScaling) {
          return false;
        }
        if (gestureScale) {
          scaleX = transform2.scaleX * gestureScale;
          scaleY = transform2.scaleY * gestureScale;
        } else {
          newPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x2, y2);
          signX = by !== "y" ? sign(newPoint.x) : 1;
          signY = by !== "x" ? sign(newPoint.y) : 1;
          if (!transform2.signX) {
            transform2.signX = signX;
          }
          if (!transform2.signY) {
            transform2.signY = signY;
          }
          if (target.lockScalingFlip && (transform2.signX !== signX || transform2.signY !== signY)) {
            return false;
          }
          dim = target._getTransformedDimensions();
          if (scaleProportionally && !by) {
            var distance2 = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform2.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance2 / originalDistance;
            scaleX = original.scaleX * scale;
            scaleY = original.scaleY * scale;
          } else {
            scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);
            scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);
          }
          if (isTransformCentered(transform2)) {
            scaleX *= 2;
            scaleY *= 2;
          }
          if (transform2.signX !== signX && by !== "y") {
            transform2.originX = opposite[transform2.originX];
            scaleX *= -1;
            transform2.signX = signX;
          }
          if (transform2.signY !== signY && by !== "x") {
            transform2.originY = opposite[transform2.originY];
            scaleY *= -1;
            transform2.signY = signY;
          }
        }
        var oldScaleX = target.scaleX, oldScaleY = target.scaleY;
        if (!by) {
          !lockScalingX && target.set("scaleX", scaleX);
          !lockScalingY && target.set("scaleY", scaleY);
        } else {
          by === "x" && target.set("scaleX", scaleX);
          by === "y" && target.set("scaleY", scaleY);
        }
        return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;
      }
      function scaleObjectFromCorner(eventData, transform2, x2, y2) {
        return scaleObject(eventData, transform2, x2, y2);
      }
      function scaleObjectX(eventData, transform2, x2, y2) {
        return scaleObject(eventData, transform2, x2, y2, { by: "x" });
      }
      function scaleObjectY(eventData, transform2, x2, y2) {
        return scaleObject(eventData, transform2, x2, y2, { by: "y" });
      }
      function scalingYOrSkewingX(eventData, transform2, x2, y2) {
        if (eventData[transform2.target.canvas.altActionKey]) {
          return controls.skewHandlerX(eventData, transform2, x2, y2);
        }
        return controls.scalingY(eventData, transform2, x2, y2);
      }
      function scalingXOrSkewingY(eventData, transform2, x2, y2) {
        if (eventData[transform2.target.canvas.altActionKey]) {
          return controls.skewHandlerY(eventData, transform2, x2, y2);
        }
        return controls.scalingX(eventData, transform2, x2, y2);
      }
      function changeWidth(eventData, transform2, x2, y2) {
        var target = transform2.target, localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x2, y2), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform2) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;
        target.set("width", Math.max(newWidth, 0));
        return oldWidth !== newWidth;
      }
      function dragHandler(eventData, transform2, x2, y2) {
        var target = transform2.target, newLeft = x2 - transform2.offsetX, newTop = y2 - transform2.offsetY, moveX = !target.get("lockMovementX") && target.left !== newLeft, moveY = !target.get("lockMovementY") && target.top !== newTop;
        moveX && target.set("left", newLeft);
        moveY && target.set("top", newTop);
        if (moveX || moveY) {
          fireEvent("moving", commonEventInfo(eventData, transform2, x2, y2));
        }
        return moveX || moveY;
      }
      controls.scaleCursorStyleHandler = scaleCursorStyleHandler;
      controls.skewCursorStyleHandler = skewCursorStyleHandler;
      controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;
      controls.rotationWithSnapping = wrapWithFireEvent("rotating", wrapWithFixedAnchor(rotationWithSnapping));
      controls.scalingEqually = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectFromCorner));
      controls.scalingX = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectX));
      controls.scalingY = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectY));
      controls.scalingYOrSkewingX = scalingYOrSkewingX;
      controls.scalingXOrSkewingY = scalingXOrSkewingY;
      controls.changeWidth = wrapWithFireEvent("resizing", wrapWithFixedAnchor(changeWidth));
      controls.skewHandlerX = skewHandlerX;
      controls.skewHandlerY = skewHandlerY;
      controls.dragHandler = dragHandler;
      controls.scaleOrSkewActionName = scaleOrSkewActionName;
      controls.rotationStyleHandler = rotationStyleHandler;
      controls.fireEvent = fireEvent;
      controls.wrapWithFixedAnchor = wrapWithFixedAnchor;
      controls.wrapWithFireEvent = wrapWithFireEvent;
      controls.getLocalPoint = getLocalPoint;
      fabric2.controlsUtils = controls;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), degreesToRadians = fabric2.util.degreesToRadians, controls = fabric2.controlsUtils;
      function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {
        styleOverride = styleOverride || {};
        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== "undefined" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? "stroke" : "fill", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;
        ctx.save();
        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
        if (xSize > ySize) {
          size = xSize;
          ctx.scale(1, ySize / xSize);
          myTop = top * xSize / ySize;
        } else if (ySize > xSize) {
          size = ySize;
          ctx.scale(xSize / ySize, 1);
          myLeft = left * ySize / xSize;
        } else {
          size = xSize;
        }
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);
        ctx[methodName]();
        if (stroke) {
          ctx.stroke();
        }
        ctx.restore();
      }
      function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {
        styleOverride = styleOverride || {};
        var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== "undefined" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? "stroke" : "fill", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;
        ctx.save();
        ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
        ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
        ctx.lineWidth = 1;
        ctx.translate(left, top);
        ctx.rotate(degreesToRadians(fabricObject.angle));
        ctx[methodName + "Rect"](-xSizeBy2, -ySizeBy2, xSize, ySize);
        if (stroke) {
          ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
        }
        ctx.restore();
      }
      controls.renderCircleControl = renderCircleControl;
      controls.renderSquareControl = renderSquareControl;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      function Control2(options) {
        for (var i2 in options) {
          this[i2] = options[i2];
        }
      }
      fabric2.Control = Control2;
      fabric2.Control.prototype = /** @lends fabric.Control.prototype */
      {
        /**
         * keep track of control visibility.
         * mainly for backward compatibility.
         * if you do not want to see a control, you can remove it
         * from the controlset.
         * @type {Boolean}
         * @default true
         */
        visible: true,
        /**
         * Name of the action that the control will likely execute.
         * This is optional. FabricJS uses to identify what the user is doing for some
         * extra optimizations. If you are writing a custom control and you want to know
         * somewhere else in the code what is going on, you can use this string here.
         * you can also provide a custom getActionName if your control run multiple actions
         * depending on some external state.
         * default to scale since is the most common, used on 4 corners by default
         * @type {String}
         * @default 'scale'
         */
        actionName: "scale",
        /**
         * Drawing angle of the control.
         * NOT used for now, but name marked as needed for internal logic
         * example: to reuse the same drawing function for different rotated controls
         * @type {Number}
         * @default 0
         */
        angle: 0,
        /**
         * Relative position of the control. X
         * 0,0 is the center of the Object, while -0.5 (left) or 0.5 (right) are the extremities
         * of the bounding box.
         * @type {Number}
         * @default 0
         */
        x: 0,
        /**
         * Relative position of the control. Y
         * 0,0 is the center of the Object, while -0.5 (top) or 0.5 (bottom) are the extremities
         * of the bounding box.
         * @type {Number}
         * @default 0
         */
        y: 0,
        /**
         * Horizontal offset of the control from the defined position. In pixels
         * Positive offset moves the control to the right, negative to the left.
         * It used when you want to have position of control that does not scale with
         * the bounding box. Example: rotation control is placed at x:0, y: 0.5 on
         * the boundindbox, with an offset of 30 pixels vertically. Those 30 pixels will
         * stay 30 pixels no matter how the object is big. Another example is having 2
         * controls in the corner, that stay in the same position when the object scale.
         * of the bounding box.
         * @type {Number}
         * @default 0
         */
        offsetX: 0,
        /**
         * Vertical offset of the control from the defined position. In pixels
         * Positive offset moves the control to the bottom, negative to the top.
         * @type {Number}
         * @default 0
         */
        offsetY: 0,
        /**
         * Sets the length of the control. If null, defaults to object's cornerSize.
         * Expects both sizeX and sizeY to be set when set.
         * @type {?Number}
         * @default null
         */
        sizeX: null,
        /**
         * Sets the height of the control. If null, defaults to object's cornerSize.
         * Expects both sizeX and sizeY to be set when set.
         * @type {?Number}
         * @default null
         */
        sizeY: null,
        /**
         * Sets the length of the touch area of the control. If null, defaults to object's touchCornerSize.
         * Expects both touchSizeX and touchSizeY to be set when set.
         * @type {?Number}
         * @default null
         */
        touchSizeX: null,
        /**
         * Sets the height of the touch area of the control. If null, defaults to object's touchCornerSize.
         * Expects both touchSizeX and touchSizeY to be set when set.
         * @type {?Number}
         * @default null
         */
        touchSizeY: null,
        /**
         * Css cursor style to display when the control is hovered.
         * if the method `cursorStyleHandler` is provided, this property is ignored.
         * @type {String}
         * @default 'crosshair'
         */
        cursorStyle: "crosshair",
        /**
         * If controls has an offsetY or offsetX, draw a line that connects
         * the control to the bounding box
         * @type {Boolean}
         * @default false
         */
        withConnection: false,
        /**
         * The control actionHandler, provide one to handle action ( control being moved )
         * @param {Event} eventData the native mouse event
         * @param {Object} transformData properties of the current transform
         * @param {Number} x x position of the cursor
         * @param {Number} y y position of the cursor
         * @return {Boolean} true if the action/event modified the object
         */
        actionHandler: function() {
        },
        /**
         * The control handler for mouse down, provide one to handle mouse down on control
         * @param {Event} eventData the native mouse event
         * @param {Object} transformData properties of the current transform
         * @param {Number} x x position of the cursor
         * @param {Number} y y position of the cursor
         * @return {Boolean} true if the action/event modified the object
         */
        mouseDownHandler: function() {
        },
        /**
         * The control mouseUpHandler, provide one to handle an effect on mouse up.
         * @param {Event} eventData the native mouse event
         * @param {Object} transformData properties of the current transform
         * @param {Number} x x position of the cursor
         * @param {Number} y y position of the cursor
         * @return {Boolean} true if the action/event modified the object
         */
        mouseUpHandler: function() {
        },
        /**
         * Returns control actionHandler
         * @param {Event} eventData the native mouse event
         * @param {fabric.Object} fabricObject on which the control is displayed
         * @param {fabric.Control} control control for which the action handler is being asked
         * @return {Function} the action handler
         */
        getActionHandler: function() {
          return this.actionHandler;
        },
        /**
         * Returns control mouseDown handler
         * @param {Event} eventData the native mouse event
         * @param {fabric.Object} fabricObject on which the control is displayed
         * @param {fabric.Control} control control for which the action handler is being asked
         * @return {Function} the action handler
         */
        getMouseDownHandler: function() {
          return this.mouseDownHandler;
        },
        /**
         * Returns control mouseUp handler
         * @param {Event} eventData the native mouse event
         * @param {fabric.Object} fabricObject on which the control is displayed
         * @param {fabric.Control} control control for which the action handler is being asked
         * @return {Function} the action handler
         */
        getMouseUpHandler: function() {
          return this.mouseUpHandler;
        },
        /**
         * Returns control cursorStyle for css using cursorStyle. If you need a more elaborate
         * function you can pass one in the constructor
         * the cursorStyle property
         * @param {Event} eventData the native mouse event
         * @param {fabric.Control} control the current control ( likely this)
         * @param {fabric.Object} object on which the control is displayed
         * @return {String}
         */
        cursorStyleHandler: function(eventData, control) {
          return control.cursorStyle;
        },
        /**
         * Returns the action name. The basic implementation just return the actionName property.
         * @param {Event} eventData the native mouse event
         * @param {fabric.Control} control the current control ( likely this)
         * @param {fabric.Object} object on which the control is displayed
         * @return {String}
         */
        getActionName: function(eventData, control) {
          return control.actionName;
        },
        /**
         * Returns controls visibility
         * @param {fabric.Object} object on which the control is displayed
         * @param {String} controlKey key where the control is memorized on the
         * @return {Boolean}
         */
        getVisibility: function(fabricObject, controlKey) {
          var objectVisibility = fabricObject._controlsVisibility;
          if (objectVisibility && typeof objectVisibility[controlKey] !== "undefined") {
            return objectVisibility[controlKey];
          }
          return this.visible;
        },
        /**
         * Sets controls visibility
         * @param {Boolean} visibility for the object
         * @return {Void}
         */
        setVisibility: function(visibility2) {
          this.visible = visibility2;
        },
        positionHandler: function(dim, finalMatrix) {
          var point = fabric2.util.transformPoint({
            x: this.x * dim.x + this.offsetX,
            y: this.y * dim.y + this.offsetY
          }, finalMatrix);
          return point;
        },
        /**
         * Returns the coords for this control based on object values.
         * @param {Number} objectAngle angle from the fabric object holding the control
         * @param {Number} objectCornerSize cornerSize from the fabric object holding the control (or touchCornerSize if
         *   isTouch is true)
         * @param {Number} centerX x coordinate where the control center should be
         * @param {Number} centerY y coordinate where the control center should be
         * @param {boolean} isTouch true if touch corner, false if normal corner
         */
        calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {
          var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;
          if (xSize && ySize && xSize !== ySize) {
            var controlTriangleAngle = Math.atan2(ySize, xSize);
            var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;
            var newTheta = controlTriangleAngle - fabric2.util.degreesToRadians(objectAngle);
            var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric2.util.degreesToRadians(objectAngle);
            cosHalfOffset = cornerHypotenuse * fabric2.util.cos(newTheta);
            sinHalfOffset = cornerHypotenuse * fabric2.util.sin(newTheta);
            cosHalfOffsetComp = cornerHypotenuse * fabric2.util.cos(newThetaComp);
            sinHalfOffsetComp = cornerHypotenuse * fabric2.util.sin(newThetaComp);
          } else {
            var cornerSize = xSize && ySize ? xSize : objectCornerSize;
            cornerHypotenuse = cornerSize * 0.7071067812;
            var newTheta = fabric2.util.degreesToRadians(45 - objectAngle);
            cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric2.util.cos(newTheta);
            sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric2.util.sin(newTheta);
          }
          return {
            tl: {
              x: centerX - sinHalfOffsetComp,
              y: centerY - cosHalfOffsetComp
            },
            tr: {
              x: centerX + cosHalfOffset,
              y: centerY - sinHalfOffset
            },
            bl: {
              x: centerX - cosHalfOffset,
              y: centerY + sinHalfOffset
            },
            br: {
              x: centerX + sinHalfOffsetComp,
              y: centerY + cosHalfOffsetComp
            }
          };
        },
        /**
        * Render function for the control.
        * When this function runs the context is unscaled. unrotate. Just retina scaled.
        * all the functions will have to translate to the point left,top before starting Drawing
        * if they want to draw a control where the position is detected.
        * left and top are the result of the positionHandler function
        * @param {RenderingContext2D} ctx the context where the control will be drawn
        * @param {Number} left position of the canvas where we are about to render the control.
        * @param {Number} top position of the canvas where we are about to render the control.
        * @param {Object} styleOverride
        * @param {fabric.Object} fabricObject the object where the control is about to be rendered
        */
        render: function(ctx, left, top, styleOverride, fabricObject) {
          styleOverride = styleOverride || {};
          switch (styleOverride.cornerStyle || fabricObject.cornerStyle) {
            case "circle":
              fabric2.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);
              break;
            default:
              fabric2.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);
          }
        }
      };
    })(exports);
    (function() {
      function getColorStop(el, multiplier) {
        var style = el.getAttribute("style"), offset = el.getAttribute("offset") || 0, color2, colorAlpha, opacity2, i2;
        offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
        offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
        if (style) {
          var keyValuePairs = style.split(/\s*;\s*/);
          if (keyValuePairs[keyValuePairs.length - 1] === "") {
            keyValuePairs.pop();
          }
          for (i2 = keyValuePairs.length; i2--; ) {
            var split = keyValuePairs[i2].split(/\s*:\s*/), key = split[0].trim(), value = split[1].trim();
            if (key === "stop-color") {
              color2 = value;
            } else if (key === "stop-opacity") {
              opacity2 = value;
            }
          }
        }
        if (!color2) {
          color2 = el.getAttribute("stop-color") || "rgb(0,0,0)";
        }
        if (!opacity2) {
          opacity2 = el.getAttribute("stop-opacity");
        }
        color2 = new fabric$1.Color(color2);
        colorAlpha = color2.getAlpha();
        opacity2 = isNaN(parseFloat(opacity2)) ? 1 : parseFloat(opacity2);
        opacity2 *= colorAlpha * multiplier;
        return {
          offset,
          color: color2.toRgb(),
          opacity: opacity2
        };
      }
      function getLinearCoords(el) {
        return {
          x1: el.getAttribute("x1") || 0,
          y1: el.getAttribute("y1") || 0,
          x2: el.getAttribute("x2") || "100%",
          y2: el.getAttribute("y2") || 0
        };
      }
      function getRadialCoords(el) {
        return {
          x1: el.getAttribute("fx") || el.getAttribute("cx") || "50%",
          y1: el.getAttribute("fy") || el.getAttribute("cy") || "50%",
          r1: 0,
          x2: el.getAttribute("cx") || "50%",
          y2: el.getAttribute("cy") || "50%",
          r2: el.getAttribute("r") || "50%"
        };
      }
      var clone2 = fabric$1.util.object.clone;
      fabric$1.Gradient = fabric$1.util.createClass(
        /** @lends fabric.Gradient.prototype */
        {
          /**
           * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
           * @type Number
           * @default 0
           */
          offsetX: 0,
          /**
           * Vertical offset for aligning gradients coming from SVG when outside pathgroups
           * @type Number
           * @default 0
           */
          offsetY: 0,
          /**
           * A transform matrix to apply to the gradient before painting.
           * Imported from svg gradients, is not applied with the current transform in the center.
           * Before this transform is applied, the origin point is at the top left corner of the object
           * plus the addition of offsetY and offsetX.
           * @type Number[]
           * @default null
           */
          gradientTransform: null,
          /**
           * coordinates units for coords.
           * If `pixels`, the number of coords are in the same unit of width / height.
           * If set as `percentage` the coords are still a number, but 1 means 100% of width
           * for the X and 100% of the height for the y. It can be bigger than 1 and negative.
           * allowed values pixels or percentage.
           * @type String
           * @default 'pixels'
           */
          gradientUnits: "pixels",
          /**
           * Gradient type linear or radial
           * @type String
           * @default 'pixels'
           */
          type: "linear",
          /**
           * Constructor
           * @param {Object} options Options object with type, coords, gradientUnits and colorStops
           * @param {Object} [options.type] gradient type linear or radial
           * @param {Object} [options.gradientUnits] gradient units
           * @param {Object} [options.offsetX] SVG import compatibility
           * @param {Object} [options.offsetY] SVG import compatibility
           * @param {Object[]} options.colorStops contains the colorstops.
           * @param {Object} options.coords contains the coords of the gradient
           * @param {Number} [options.coords.x1] X coordiante of the first point for linear or of the focal point for radial
           * @param {Number} [options.coords.y1] Y coordiante of the first point for linear or of the focal point for radial
           * @param {Number} [options.coords.x2] X coordiante of the second point for linear or of the center point for radial
           * @param {Number} [options.coords.y2] Y coordiante of the second point for linear or of the center point for radial
           * @param {Number} [options.coords.r1] only for radial gradient, radius of the inner circle
           * @param {Number} [options.coords.r2] only for radial gradient, radius of the external circle
           * @return {fabric.Gradient} thisArg
           */
          initialize: function(options) {
            options || (options = {});
            options.coords || (options.coords = {});
            var coords, _this = this;
            Object.keys(options).forEach(function(option) {
              _this[option] = options[option];
            });
            if (this.id) {
              this.id += "_" + fabric$1.Object.__uid++;
            } else {
              this.id = fabric$1.Object.__uid++;
            }
            coords = {
              x1: options.coords.x1 || 0,
              y1: options.coords.y1 || 0,
              x2: options.coords.x2 || 0,
              y2: options.coords.y2 || 0
            };
            if (this.type === "radial") {
              coords.r1 = options.coords.r1 || 0;
              coords.r2 = options.coords.r2 || 0;
            }
            this.coords = coords;
            this.colorStops = options.colorStops.slice();
          },
          /**
           * Adds another colorStop
           * @param {Object} colorStop Object with offset and color
           * @return {fabric.Gradient} thisArg
           */
          addColorStop: function(colorStops) {
            for (var position2 in colorStops) {
              var color2 = new fabric$1.Color(colorStops[position2]);
              this.colorStops.push({
                offset: parseFloat(position2),
                color: color2.toRgb(),
                opacity: color2.getAlpha()
              });
            }
            return this;
          },
          /**
           * Returns object representation of a gradient
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object}
           */
          toObject: function(propertiesToInclude) {
            var object = {
              type: this.type,
              coords: this.coords,
              colorStops: this.colorStops,
              offsetX: this.offsetX,
              offsetY: this.offsetY,
              gradientUnits: this.gradientUnits,
              gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
            };
            fabric$1.util.populateWithProperties(this, object, propertiesToInclude);
            return object;
          },
          /* _TO_SVG_START_ */
          /**
           * Returns SVG representation of an gradient
           * @param {Object} object Object to create a gradient for
           * @return {String} SVG representation of an gradient (linear/radial)
           */
          toSVG: function(object, options) {
            var coords = clone2(this.coords, true), i2, len, options = options || {}, markup, commonAttributes, colorStops = clone2(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform2 = this.gradientTransform ? this.gradientTransform.concat() : fabric$1.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox";
            colorStops.sort(function(a2, b2) {
              return a2.offset - b2.offset;
            });
            if (gradientUnits === "objectBoundingBox") {
              offsetX /= object.width;
              offsetY /= object.height;
            } else {
              offsetX += object.width / 2;
              offsetY += object.height / 2;
            }
            if (object.type === "path" && this.gradientUnits !== "percentage") {
              offsetX -= object.pathOffset.x;
              offsetY -= object.pathOffset.y;
            }
            transform2[4] -= offsetX;
            transform2[5] -= offsetY;
            commonAttributes = 'id="SVGID_' + this.id + '" gradientUnits="' + gradientUnits + '"';
            commonAttributes += ' gradientTransform="' + (withViewport ? options.additionalTransform + " " : "") + fabric$1.util.matrixToSVG(transform2) + '" ';
            if (this.type === "linear") {
              markup = [
                "<linearGradient ",
                commonAttributes,
                ' x1="',
                coords.x1,
                '" y1="',
                coords.y1,
                '" x2="',
                coords.x2,
                '" y2="',
                coords.y2,
                '">\n'
              ];
            } else if (this.type === "radial") {
              markup = [
                "<radialGradient ",
                commonAttributes,
                ' cx="',
                needsSwap ? coords.x1 : coords.x2,
                '" cy="',
                needsSwap ? coords.y1 : coords.y2,
                '" r="',
                needsSwap ? coords.r1 : coords.r2,
                '" fx="',
                needsSwap ? coords.x2 : coords.x1,
                '" fy="',
                needsSwap ? coords.y2 : coords.y1,
                '">\n'
              ];
            }
            if (this.type === "radial") {
              if (needsSwap) {
                colorStops = colorStops.concat();
                colorStops.reverse();
                for (i2 = 0, len = colorStops.length; i2 < len; i2++) {
                  colorStops[i2].offset = 1 - colorStops[i2].offset;
                }
              }
              var minRadius = Math.min(coords.r1, coords.r2);
              if (minRadius > 0) {
                var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;
                for (i2 = 0, len = colorStops.length; i2 < len; i2++) {
                  colorStops[i2].offset += percentageShift * (1 - colorStops[i2].offset);
                }
              }
            }
            for (i2 = 0, len = colorStops.length; i2 < len; i2++) {
              var colorStop = colorStops[i2];
              markup.push(
                "<stop ",
                'offset="',
                colorStop.offset * 100 + "%",
                '" style="stop-color:',
                colorStop.color,
                typeof colorStop.opacity !== "undefined" ? ";stop-opacity: " + colorStop.opacity : ";",
                '"/>\n'
              );
            }
            markup.push(this.type === "linear" ? "</linearGradient>\n" : "</radialGradient>\n");
            return markup.join("");
          },
          /* _TO_SVG_END_ */
          /**
           * Returns an instance of CanvasGradient
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @return {CanvasGradient}
           */
          toLive: function(ctx) {
            var gradient, coords = fabric$1.util.object.clone(this.coords), i2, len;
            if (!this.type) {
              return;
            }
            if (this.type === "linear") {
              gradient = ctx.createLinearGradient(
                coords.x1,
                coords.y1,
                coords.x2,
                coords.y2
              );
            } else if (this.type === "radial") {
              gradient = ctx.createRadialGradient(
                coords.x1,
                coords.y1,
                coords.r1,
                coords.x2,
                coords.y2,
                coords.r2
              );
            }
            for (i2 = 0, len = this.colorStops.length; i2 < len; i2++) {
              var color2 = this.colorStops[i2].color, opacity2 = this.colorStops[i2].opacity, offset = this.colorStops[i2].offset;
              if (typeof opacity2 !== "undefined") {
                color2 = new fabric$1.Color(color2).setAlpha(opacity2).toRgba();
              }
              gradient.addColorStop(offset, color2);
            }
            return gradient;
          }
        }
      );
      fabric$1.util.object.extend(fabric$1.Gradient, {
        /* _FROM_SVG_START_ */
        /**
         * Returns {@link fabric.Gradient} instance from an SVG element
         * @static
         * @memberOf fabric.Gradient
         * @param {SVGGradientElement} el SVG gradient element
         * @param {fabric.Object} instance
         * @param {String} opacityAttr A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.
         * @param {Object} svgOptions an object containing the size of the SVG in order to parse correctly gradients
         * that uses gradientUnits as 'userSpaceOnUse' and percentages.
         * @param {Object.number} viewBoxWidth width part of the viewBox attribute on svg
         * @param {Object.number} viewBoxHeight height part of the viewBox attribute on svg
         * @param {Object.number} width width part of the svg tag if viewBox is not specified
         * @param {Object.number} height height part of the svg tag if viewBox is not specified
         * @return {fabric.Gradient} Gradient instance
         * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
         * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
         */
        fromElement: function(el, instance, opacityAttr, svgOptions) {
          var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
          multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
          if (isNaN(multiplier)) {
            multiplier = 1;
          }
          var colorStopEls = el.getElementsByTagName("stop"), type, gradientUnits = el.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", gradientTransform = el.getAttribute("gradientTransform") || "", colorStops = [], coords, i2, offsetX = 0, offsetY = 0, transformMatrix;
          if (el.nodeName === "linearGradient" || el.nodeName === "LINEARGRADIENT") {
            type = "linear";
            coords = getLinearCoords(el);
          } else {
            type = "radial";
            coords = getRadialCoords(el);
          }
          for (i2 = colorStopEls.length; i2--; ) {
            colorStops.push(getColorStop(colorStopEls[i2], multiplier));
          }
          transformMatrix = fabric$1.parseTransformAttribute(gradientTransform);
          __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);
          if (gradientUnits === "pixels") {
            offsetX = -instance.left;
            offsetY = -instance.top;
          }
          var gradient = new fabric$1.Gradient({
            id: el.getAttribute("id"),
            type,
            coords,
            colorStops,
            gradientUnits,
            gradientTransform: transformMatrix,
            offsetX,
            offsetY
          });
          return gradient;
        }
        /* _FROM_SVG_END_ */
      });
      function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
        var propValue, finalValue;
        Object.keys(options).forEach(function(prop) {
          propValue = options[prop];
          if (propValue === "Infinity") {
            finalValue = 1;
          } else if (propValue === "-Infinity") {
            finalValue = 0;
          } else {
            finalValue = parseFloat(options[prop], 10);
            if (typeof propValue === "string" && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
              finalValue *= 0.01;
              if (gradientUnits === "pixels") {
                if (prop === "x1" || prop === "x2" || prop === "r2") {
                  finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
                }
                if (prop === "y1" || prop === "y2") {
                  finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
                }
              }
            }
          }
          options[prop] = finalValue;
        });
      }
    })();
    (function() {
      var toFixed = fabric$1.util.toFixed;
      fabric$1.Pattern = fabric$1.util.createClass(
        /** @lends fabric.Pattern.prototype */
        {
          /**
           * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
           * @type String
           * @default
           */
          repeat: "repeat",
          /**
           * Pattern horizontal offset from object's left/top corner
           * @type Number
           * @default
           */
          offsetX: 0,
          /**
           * Pattern vertical offset from object's left/top corner
           * @type Number
           * @default
           */
          offsetY: 0,
          /**
           * crossOrigin value (one of "", "anonymous", "use-credentials")
           * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
           * @type String
           * @default
           */
          crossOrigin: "",
          /**
           * transform matrix to change the pattern, imported from svgs.
           * @type Array
           * @default
           */
          patternTransform: null,
          /**
           * Constructor
           * @param {Object} [options] Options object
           * @param {Function} [callback] function to invoke after callback init.
           * @return {fabric.Pattern} thisArg
           */
          initialize: function(options, callback) {
            options || (options = {});
            this.id = fabric$1.Object.__uid++;
            this.setOptions(options);
            if (!options.source || options.source && typeof options.source !== "string") {
              callback && callback(this);
              return;
            } else {
              var _this = this;
              this.source = fabric$1.util.createImage();
              fabric$1.util.loadImage(options.source, function(img, isError) {
                _this.source = img;
                callback && callback(_this, isError);
              }, null, this.crossOrigin);
            }
          },
          /**
           * Returns object representation of a pattern
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of a pattern instance
           */
          toObject: function(propertiesToInclude) {
            var NUM_FRACTION_DIGITS = fabric$1.Object.NUM_FRACTION_DIGITS, source, object;
            if (typeof this.source.src === "string") {
              source = this.source.src;
            } else if (typeof this.source === "object" && this.source.toDataURL) {
              source = this.source.toDataURL();
            }
            object = {
              type: "pattern",
              source,
              repeat: this.repeat,
              crossOrigin: this.crossOrigin,
              offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
              offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
              patternTransform: this.patternTransform ? this.patternTransform.concat() : null
            };
            fabric$1.util.populateWithProperties(this, object, propertiesToInclude);
            return object;
          },
          /* _TO_SVG_START_ */
          /**
           * Returns SVG representation of a pattern
           * @param {fabric.Object} object
           * @return {String} SVG representation of a pattern
           */
          toSVG: function(object) {
            var patternSource = typeof this.source === "function" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = "";
            if (this.repeat === "repeat-x" || this.repeat === "no-repeat") {
              patternHeight = 1;
              if (patternOffsetY) {
                patternHeight += Math.abs(patternOffsetY);
              }
            }
            if (this.repeat === "repeat-y" || this.repeat === "no-repeat") {
              patternWidth = 1;
              if (patternOffsetX) {
                patternWidth += Math.abs(patternOffsetX);
              }
            }
            if (patternSource.src) {
              patternImgSrc = patternSource.src;
            } else if (patternSource.toDataURL) {
              patternImgSrc = patternSource.toDataURL();
            }
            return '<pattern id="SVGID_' + this.id + '" x="' + patternOffsetX + '" y="' + patternOffsetY + '" width="' + patternWidth + '" height="' + patternHeight + '">\n<image x="0" y="0" width="' + patternSource.width + '" height="' + patternSource.height + '" xlink:href="' + patternImgSrc + '"></image>\n</pattern>\n';
          },
          /* _TO_SVG_END_ */
          setOptions: function(options) {
            for (var prop in options) {
              this[prop] = options[prop];
            }
          },
          /**
           * Returns an instance of CanvasPattern
           * @param {CanvasRenderingContext2D} ctx Context to create pattern
           * @return {CanvasPattern}
           */
          toLive: function(ctx) {
            var source = this.source;
            if (!source) {
              return "";
            }
            if (typeof source.src !== "undefined") {
              if (!source.complete) {
                return "";
              }
              if (source.naturalWidth === 0 || source.naturalHeight === 0) {
                return "";
              }
            }
            return ctx.createPattern(source, this.repeat);
          }
        }
      );
    })();
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), toFixed = fabric2.util.toFixed;
      if (fabric2.Shadow) {
        fabric2.warn("fabric.Shadow is already defined.");
        return;
      }
      fabric2.Shadow = fabric2.util.createClass(
        /** @lends fabric.Shadow.prototype */
        {
          /**
           * Shadow color
           * @type String
           * @default
           */
          color: "rgb(0,0,0)",
          /**
           * Shadow blur
           * @type Number
           */
          blur: 0,
          /**
           * Shadow horizontal offset
           * @type Number
           * @default
           */
          offsetX: 0,
          /**
           * Shadow vertical offset
           * @type Number
           * @default
           */
          offsetY: 0,
          /**
           * Whether the shadow should affect stroke operations
           * @type Boolean
           * @default
           */
          affectStroke: false,
          /**
           * Indicates whether toObject should include default values
           * @type Boolean
           * @default
           */
          includeDefaultValues: true,
          /**
           * When `false`, the shadow will scale with the object.
           * When `true`, the shadow's offsetX, offsetY, and blur will not be affected by the object's scale.
           * default to false
           * @type Boolean
           * @default
           */
          nonScaling: false,
          /**
           * Constructor
           * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetY properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px")
           * @return {fabric.Shadow} thisArg
           */
          initialize: function(options) {
            if (typeof options === "string") {
              options = this._parseShadow(options);
            }
            for (var prop in options) {
              this[prop] = options[prop];
            }
            this.id = fabric2.Object.__uid++;
          },
          /**
           * @private
           * @param {String} shadow Shadow value to parse
           * @return {Object} Shadow object with color, offsetX, offsetY and blur
           */
          _parseShadow: function(shadow) {
            var shadowStr = shadow.trim(), offsetsAndBlur = fabric2.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color2 = shadowStr.replace(fabric2.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)";
            return {
              color: color2.trim(),
              offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,
              offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,
              blur: parseFloat(offsetsAndBlur[3], 10) || 0
            };
          },
          /**
           * Returns a string representation of an instance
           * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
           * @return {String} Returns CSS3 text-shadow declaration
           */
          toString: function() {
            return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
          },
          /* _TO_SVG_START_ */
          /**
           * Returns SVG representation of a shadow
           * @param {fabric.Object} object
           * @return {String} SVG representation of a shadow
           */
          toSVG: function(object) {
            var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS, offset = fabric2.util.rotateVector(
              { x: this.offsetX, y: this.offsetY },
              fabric2.util.degreesToRadians(-object.angle)
            ), BLUR_BOX = 20, color2 = new fabric2.Color(this.color);
            if (object.width && object.height) {
              fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
              fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
            }
            if (object.flipX) {
              offset.x *= -1;
            }
            if (object.flipY) {
              offset.y *= -1;
            }
            return '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" >\n	<feGaussianBlur in="SourceAlpha" stdDeviation="' + toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n	<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) + '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n	<feFlood flood-color="' + color2.toRgb() + '" flood-opacity="' + color2.getAlpha() + '"/>\n	<feComposite in2="oBlur" operator="in" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in="SourceGraphic"></feMergeNode>\n	</feMerge>\n</filter>\n';
          },
          /* _TO_SVG_END_ */
          /**
           * Returns object representation of a shadow
           * @return {Object} Object representation of a shadow instance
           */
          toObject: function() {
            if (this.includeDefaultValues) {
              return {
                color: this.color,
                blur: this.blur,
                offsetX: this.offsetX,
                offsetY: this.offsetY,
                affectStroke: this.affectStroke,
                nonScaling: this.nonScaling
              };
            }
            var obj = {}, proto = fabric2.Shadow.prototype;
            ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function(prop) {
              if (this[prop] !== proto[prop]) {
                obj[prop] = this[prop];
              }
            }, this);
            return obj;
          }
        }
      );
      fabric2.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/;
    })(exports);
    (function() {
      if (fabric$1.StaticCanvas) {
        fabric$1.warn("fabric.StaticCanvas is already defined.");
        return;
      }
      var extend2 = fabric$1.util.object.extend, getElementOffset = fabric$1.util.getElementOffset, removeFromArray = fabric$1.util.removeFromArray, toFixed = fabric$1.util.toFixed, transformPoint = fabric$1.util.transformPoint, invertTransform = fabric$1.util.invertTransform, getNodeCanvas = fabric$1.util.getNodeCanvas, createCanvasElement = fabric$1.util.createCanvasElement, CANVAS_INIT_ERROR = new Error("Could not initialize `canvas` element");
      fabric$1.StaticCanvas = fabric$1.util.createClass(
        fabric$1.CommonMethods,
        /** @lends fabric.StaticCanvas.prototype */
        {
          /**
           * Constructor
           * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
           * @param {Object} [options] Options object
           * @return {Object} thisArg
           */
          initialize: function(el, options) {
            options || (options = {});
            this.renderAndResetBound = this.renderAndReset.bind(this);
            this.requestRenderAllBound = this.requestRenderAll.bind(this);
            this._initStatic(el, options);
          },
          /**
           * Background color of canvas instance.
           * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
           * @type {(String|fabric.Pattern)}
           * @default
           */
          backgroundColor: "",
          /**
           * Background image of canvas instance.
           * since 2.4.0 image caching is active, please when putting an image as background, add to the
           * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
           * vale. As an alternative you can disable image objectCaching
           * @type fabric.Image
           * @default
           */
          backgroundImage: null,
          /**
           * Overlay color of canvas instance.
           * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
           * @since 1.3.9
           * @type {(String|fabric.Pattern)}
           * @default
           */
          overlayColor: "",
          /**
           * Overlay image of canvas instance.
           * since 2.4.0 image caching is active, please when putting an image as overlay, add to the
           * canvas property a reference to the canvas it is on. Otherwise the image cannot detect the zoom
           * vale. As an alternative you can disable image objectCaching
           * @type fabric.Image
           * @default
           */
          overlayImage: null,
          /**
           * Indicates whether toObject/toDatalessObject should include default values
           * if set to false, takes precedence over the object value.
           * @type Boolean
           * @default
           */
          includeDefaultValues: true,
          /**
           * Indicates whether objects' state should be saved
           * @type Boolean
           * @default
           */
          stateful: false,
          /**
           * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
           * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
           * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
           * since the renders are quequed and executed one per frame.
           * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
           * Left default to true to do not break documentation and old app, fiddles.
           * @type Boolean
           * @default
           */
          renderOnAddRemove: true,
          /**
           * Indicates whether object controls (borders/controls) are rendered above overlay image
           * @type Boolean
           * @default
           */
          controlsAboveOverlay: false,
          /**
           * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
           * @type Boolean
           * @default
           */
          allowTouchScrolling: false,
          /**
           * Indicates whether this canvas will use image smoothing, this is on by default in browsers
           * @type Boolean
           * @default
           */
          imageSmoothingEnabled: true,
          /**
           * The transformation (a Canvas 2D API transform matrix) which focuses the viewport
           * @type Array
           * @example <caption>Default transform</caption>
           * canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
           * @example <caption>Scale by 70% and translate toward bottom-right by 50, without skewing</caption>
           * canvas.viewportTransform = [0.7, 0, 0, 0.7, 50, 50];
           * @default
           */
          viewportTransform: fabric$1.iMatrix.concat(),
          /**
           * if set to false background image is not affected by viewport transform
           * @since 1.6.3
           * @type Boolean
           * @default
           */
          backgroundVpt: true,
          /**
           * if set to false overlya image is not affected by viewport transform
           * @since 1.6.3
           * @type Boolean
           * @default
           */
          overlayVpt: true,
          /**
           * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
           * @type Boolean
           * @default
           */
          enableRetinaScaling: true,
          /**
           * Describe canvas element extension over design
           * properties are tl,tr,bl,br.
           * if canvas is not zoomed/panned those points are the four corner of canvas
           * if canvas is viewportTransformed you those points indicate the extension
           * of canvas element in plain untrasformed coordinates
           * The coordinates get updated with @method calcViewportBoundaries.
           * @memberOf fabric.StaticCanvas.prototype
           */
          vptCoords: {},
          /**
           * Based on vptCoords and object.aCoords, skip rendering of objects that
           * are not included in current viewport.
           * May greatly help in applications with crowded canvas and use of zoom/pan
           * If One of the corner of the bounding box of the object is on the canvas
           * the objects get rendered.
           * @memberOf fabric.StaticCanvas.prototype
           * @type Boolean
           * @default
           */
          skipOffscreen: true,
          /**
           * a fabricObject that, without stroke define a clipping area with their shape. filled in black
           * the clipPath object gets used when the canvas has rendered, and the context is placed in the
           * top left corner of the canvas.
           * clipPath will clip away controls, if you do not want this to happen use controlsAboveOverlay = true
           * @type fabric.Object
           */
          clipPath: void 0,
          /**
           * @private
           * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
           * @param {Object} [options] Options object
           */
          _initStatic: function(el, options) {
            var cb = this.requestRenderAllBound;
            this._objects = [];
            this._createLowerCanvas(el);
            this._initOptions(options);
            if (!this.interactive) {
              this._initRetinaScaling();
            }
            if (options.overlayImage) {
              this.setOverlayImage(options.overlayImage, cb);
            }
            if (options.backgroundImage) {
              this.setBackgroundImage(options.backgroundImage, cb);
            }
            if (options.backgroundColor) {
              this.setBackgroundColor(options.backgroundColor, cb);
            }
            if (options.overlayColor) {
              this.setOverlayColor(options.overlayColor, cb);
            }
            this.calcOffset();
          },
          /**
           * @private
           */
          _isRetinaScaling: function() {
            return fabric$1.devicePixelRatio > 1 && this.enableRetinaScaling;
          },
          /**
           * @private
           * @return {Number} retinaScaling if applied, otherwise 1;
           */
          getRetinaScaling: function() {
            return this._isRetinaScaling() ? Math.max(1, fabric$1.devicePixelRatio) : 1;
          },
          /**
           * @private
           */
          _initRetinaScaling: function() {
            if (!this._isRetinaScaling()) {
              return;
            }
            var scaleRatio = fabric$1.devicePixelRatio;
            this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
            if (this.upperCanvasEl) {
              this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
            }
          },
          __initRetinaScaling: function(scaleRatio, canvas, context) {
            canvas.setAttribute("width", this.width * scaleRatio);
            canvas.setAttribute("height", this.height * scaleRatio);
            context.scale(scaleRatio, scaleRatio);
          },
          /**
           * Calculates canvas element offset relative to the document
           * This method is also attached as "resize" event handler of window
           * @return {fabric.Canvas} instance
           * @chainable
           */
          calcOffset: function() {
            this._offset = getElementOffset(this.lowerCanvasEl);
            return this;
          },
          /**
           * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
           * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
           * @param {Function} callback callback to invoke when image is loaded and set as an overlay
           * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
           * @return {fabric.Canvas} thisArg
           * @chainable
           * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
           * @example <caption>Normal overlayImage with left/top = 0</caption>
           * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
           *   // Needed to position overlayImage at 0/0
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>overlayImage with different properties</caption>
           * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
           *   opacity: 0.5,
           *   angle: 45,
           *   left: 400,
           *   top: 400,
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
           * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img, isError) {
           *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
           *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
           * });
           * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
           * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
           *   width: canvas.width,
           *   height: canvas.height,
           *   // Needed to position overlayImage at 0/0
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>overlayImage loaded from cross-origin</caption>
           * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
           *   opacity: 0.5,
           *   angle: 45,
           *   left: 400,
           *   top: 400,
           *   originX: 'left',
           *   originY: 'top',
           *   crossOrigin: 'anonymous'
           * });
           */
          setOverlayImage: function(image2, callback, options) {
            return this.__setBgOverlayImage("overlayImage", image2, callback, options);
          },
          /**
           * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
           * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
           * @param {Function} callback Callback to invoke when image is loaded and set as background
           * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
           * @return {fabric.Canvas} thisArg
           * @chainable
           * @see {@link http://jsfiddle.net/djnr8o7a/28/|jsFiddle demo}
           * @example <caption>Normal backgroundImage with left/top = 0</caption>
           * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
           *   // Needed to position backgroundImage at 0/0
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>backgroundImage with different properties</caption>
           * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
           *   opacity: 0.5,
           *   angle: 45,
           *   left: 400,
           *   top: 400,
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
           * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img, isError) {
           *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
           *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
           * });
           * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
           * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
           *   width: canvas.width,
           *   height: canvas.height,
           *   // Needed to position backgroundImage at 0/0
           *   originX: 'left',
           *   originY: 'top'
           * });
           * @example <caption>backgroundImage loaded from cross-origin</caption>
           * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
           *   opacity: 0.5,
           *   angle: 45,
           *   left: 400,
           *   top: 400,
           *   originX: 'left',
           *   originY: 'top',
           *   crossOrigin: 'anonymous'
           * });
           */
          // TODO: fix stretched examples
          setBackgroundImage: function(image2, callback, options) {
            return this.__setBgOverlayImage("backgroundImage", image2, callback, options);
          },
          /**
           * Sets {@link fabric.StaticCanvas#overlayColor|foreground color} for this canvas
           * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set foreground color to
           * @param {Function} callback Callback to invoke when foreground color is set
           * @return {fabric.Canvas} thisArg
           * @chainable
           * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
           * @example <caption>Normal overlayColor - color value</caption>
           * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
           * @example <caption>fabric.Pattern used as overlayColor</caption>
           * canvas.setOverlayColor({
           *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
           * }, canvas.renderAll.bind(canvas));
           * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
           * canvas.setOverlayColor({
           *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
           *   repeat: 'repeat',
           *   offsetX: 200,
           *   offsetY: 100
           * }, canvas.renderAll.bind(canvas));
           */
          setOverlayColor: function(overlayColor, callback) {
            return this.__setBgOverlayColor("overlayColor", overlayColor, callback);
          },
          /**
           * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
           * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
           * @param {Function} callback Callback to invoke when background color is set
           * @return {fabric.Canvas} thisArg
           * @chainable
           * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
           * @example <caption>Normal backgroundColor - color value</caption>
           * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
           * @example <caption>fabric.Pattern used as backgroundColor</caption>
           * canvas.setBackgroundColor({
           *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
           * }, canvas.renderAll.bind(canvas));
           * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
           * canvas.setBackgroundColor({
           *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
           *   repeat: 'repeat',
           *   offsetX: 200,
           *   offsetY: 100
           * }, canvas.renderAll.bind(canvas));
           */
          setBackgroundColor: function(backgroundColor2, callback) {
            return this.__setBgOverlayColor("backgroundColor", backgroundColor2, callback);
          },
          /**
           * @private
           * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
           * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
           * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
           * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay. The first argument is the created image, the second argument is a flag indicating whether an error occurred or not.
           * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
           */
          __setBgOverlayImage: function(property, image2, callback, options) {
            if (typeof image2 === "string") {
              fabric$1.util.loadImage(image2, function(img, isError) {
                if (img) {
                  var instance = new fabric$1.Image(img, options);
                  this[property] = instance;
                  instance.canvas = this;
                }
                callback && callback(img, isError);
              }, this, options && options.crossOrigin);
            } else {
              options && image2.setOptions(options);
              this[property] = image2;
              image2 && (image2.canvas = this);
              callback && callback(image2, false);
            }
            return this;
          },
          /**
           * @private
           * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
           * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
           * @param {(Object|String|null)} color Object with pattern information, color value or null
           * @param {Function} [callback] Callback is invoked when color is set
           */
          __setBgOverlayColor: function(property, color2, callback) {
            this[property] = color2;
            this._initGradient(color2, property);
            this._initPattern(color2, property, callback);
            return this;
          },
          /**
           * @private
           */
          _createCanvasElement: function() {
            var element = createCanvasElement();
            if (!element) {
              throw CANVAS_INIT_ERROR;
            }
            if (!element.style) {
              element.style = {};
            }
            if (typeof element.getContext === "undefined") {
              throw CANVAS_INIT_ERROR;
            }
            return element;
          },
          /**
           * @private
           * @param {Object} [options] Options object
           */
          _initOptions: function(options) {
            var lowerCanvasEl = this.lowerCanvasEl;
            this._setOptions(options);
            this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
            this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;
            if (!this.lowerCanvasEl.style) {
              return;
            }
            lowerCanvasEl.width = this.width;
            lowerCanvasEl.height = this.height;
            lowerCanvasEl.style.width = this.width + "px";
            lowerCanvasEl.style.height = this.height + "px";
            this.viewportTransform = this.viewportTransform.slice();
          },
          /**
           * Creates a bottom canvas
           * @private
           * @param {HTMLElement} [canvasEl]
           */
          _createLowerCanvas: function(canvasEl) {
            if (canvasEl && canvasEl.getContext) {
              this.lowerCanvasEl = canvasEl;
            } else {
              this.lowerCanvasEl = fabric$1.util.getById(canvasEl) || this._createCanvasElement();
            }
            fabric$1.util.addClass(this.lowerCanvasEl, "lower-canvas");
            this._originalCanvasStyle = this.lowerCanvasEl.style;
            if (this.interactive) {
              this._applyCanvasStyle(this.lowerCanvasEl);
            }
            this.contextContainer = this.lowerCanvasEl.getContext("2d");
          },
          /**
           * Returns canvas width (in px)
           * @return {Number}
           */
          getWidth: function() {
            return this.width;
          },
          /**
           * Returns canvas height (in px)
           * @return {Number}
           */
          getHeight: function() {
            return this.height;
          },
          /**
           * Sets width of this canvas instance
           * @param {Number|String} value                         Value to set width to
           * @param {Object}        [options]                     Options object
           * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
           * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          setWidth: function(value, options) {
            return this.setDimensions({ width: value }, options);
          },
          /**
           * Sets height of this canvas instance
           * @param {Number|String} value                         Value to set height to
           * @param {Object}        [options]                     Options object
           * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
           * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          setHeight: function(value, options) {
            return this.setDimensions({ height: value }, options);
          },
          /**
           * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
           * @param {Object}        dimensions                    Object with width/height properties
           * @param {Number|String} [dimensions.width]            Width of canvas element
           * @param {Number|String} [dimensions.height]           Height of canvas element
           * @param {Object}        [options]                     Options object
           * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
           * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          setDimensions: function(dimensions, options) {
            var cssValue;
            options = options || {};
            for (var prop in dimensions) {
              cssValue = dimensions[prop];
              if (!options.cssOnly) {
                this._setBackstoreDimension(prop, dimensions[prop]);
                cssValue += "px";
                this.hasLostContext = true;
              }
              if (!options.backstoreOnly) {
                this._setCssDimension(prop, cssValue);
              }
            }
            if (this._isCurrentlyDrawing) {
              this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
            }
            this._initRetinaScaling();
            this.calcOffset();
            if (!options.cssOnly) {
              this.requestRenderAll();
            }
            return this;
          },
          /**
           * Helper for setting width/height
           * @private
           * @param {String} prop property (width|height)
           * @param {Number} value value to set property to
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          _setBackstoreDimension: function(prop, value) {
            this.lowerCanvasEl[prop] = value;
            if (this.upperCanvasEl) {
              this.upperCanvasEl[prop] = value;
            }
            if (this.cacheCanvasEl) {
              this.cacheCanvasEl[prop] = value;
            }
            this[prop] = value;
            return this;
          },
          /**
           * Helper for setting css width/height
           * @private
           * @param {String} prop property (width|height)
           * @param {String} value value to set property to
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          _setCssDimension: function(prop, value) {
            this.lowerCanvasEl.style[prop] = value;
            if (this.upperCanvasEl) {
              this.upperCanvasEl.style[prop] = value;
            }
            if (this.wrapperEl) {
              this.wrapperEl.style[prop] = value;
            }
            return this;
          },
          /**
           * Returns canvas zoom level
           * @return {Number}
           */
          getZoom: function() {
            return this.viewportTransform[0];
          },
          /**
           * Sets viewport transformation of this canvas instance
           * @param {Array} vpt a Canvas 2D API transform matrix
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          setViewportTransform: function(vpt) {
            var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i2, len;
            this.viewportTransform = vpt;
            for (i2 = 0, len = this._objects.length; i2 < len; i2++) {
              object = this._objects[i2];
              object.group || object.setCoords(true);
            }
            if (activeObject) {
              activeObject.setCoords();
            }
            if (backgroundObject) {
              backgroundObject.setCoords(true);
            }
            if (overlayObject) {
              overlayObject.setCoords(true);
            }
            this.calcViewportBoundaries();
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * Sets zoom level of this canvas instance, the zoom centered around point
           * meaning that following zoom to point with the same point will have the visual
           * effect of the zoom originating from that point. The point won't move.
           * It has nothing to do with canvas center or visual center of the viewport.
           * @param {fabric.Point} point to zoom with respect to
           * @param {Number} value to set zoom to, less than 1 zooms out
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          zoomToPoint: function(point, value) {
            var before = point, vpt = this.viewportTransform.slice(0);
            point = transformPoint(point, invertTransform(this.viewportTransform));
            vpt[0] = value;
            vpt[3] = value;
            var after = transformPoint(point, vpt);
            vpt[4] += before.x - after.x;
            vpt[5] += before.y - after.y;
            return this.setViewportTransform(vpt);
          },
          /**
           * Sets zoom level of this canvas instance
           * @param {Number} value to set zoom to, less than 1 zooms out
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          setZoom: function(value) {
            this.zoomToPoint(new fabric$1.Point(0, 0), value);
            return this;
          },
          /**
           * Pan viewport so as to place point at top left corner of canvas
           * @param {fabric.Point} point to move to
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          absolutePan: function(point) {
            var vpt = this.viewportTransform.slice(0);
            vpt[4] = -point.x;
            vpt[5] = -point.y;
            return this.setViewportTransform(vpt);
          },
          /**
           * Pans viewpoint relatively
           * @param {fabric.Point} point (position vector) to move by
           * @return {fabric.Canvas} instance
           * @chainable true
           */
          relativePan: function(point) {
            return this.absolutePan(new fabric$1.Point(
              -point.x - this.viewportTransform[4],
              -point.y - this.viewportTransform[5]
            ));
          },
          /**
           * Returns &lt;canvas> element corresponding to this instance
           * @return {HTMLCanvasElement}
           */
          getElement: function() {
            return this.lowerCanvasEl;
          },
          /**
           * @private
           * @param {fabric.Object} obj Object that was added
           */
          _onObjectAdded: function(obj) {
            this.stateful && obj.setupState();
            obj._set("canvas", this);
            obj.setCoords();
            this.fire("object:added", { target: obj });
            obj.fire("added");
          },
          /**
           * @private
           * @param {fabric.Object} obj Object that was removed
           */
          _onObjectRemoved: function(obj) {
            this.fire("object:removed", { target: obj });
            obj.fire("removed");
            delete obj.canvas;
          },
          /**
           * Clears specified context of canvas element
           * @param {CanvasRenderingContext2D} ctx Context to clear
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          clearContext: function(ctx) {
            ctx.clearRect(0, 0, this.width, this.height);
            return this;
          },
          /**
           * Returns context of canvas where objects are drawn
           * @return {CanvasRenderingContext2D}
           */
          getContext: function() {
            return this.contextContainer;
          },
          /**
           * Clears all contexts (background, main, top) of an instance
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          clear: function() {
            this.remove.apply(this, this.getObjects());
            this.backgroundImage = null;
            this.overlayImage = null;
            this.backgroundColor = "";
            this.overlayColor = "";
            if (this._hasITextHandlers) {
              this.off("mouse:up", this._mouseUpITextHandler);
              this._iTextInstances = null;
              this._hasITextHandlers = false;
            }
            this.clearContext(this.contextContainer);
            this.fire("canvas:cleared");
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * Renders the canvas
           * @return {fabric.Canvas} instance
           * @chainable
           */
          renderAll: function() {
            var canvasToDrawOn = this.contextContainer;
            this.renderCanvas(canvasToDrawOn, this._objects);
            return this;
          },
          /**
           * Function created to be instance bound at initialization
           * used in requestAnimationFrame rendering
           * Let the fabricJS call it. If you call it manually you could have more
           * animationFrame stacking on to of each other
           * for an imperative rendering, use canvas.renderAll
           * @private
           * @return {fabric.Canvas} instance
           * @chainable
           */
          renderAndReset: function() {
            this.isRendering = 0;
            this.renderAll();
          },
          /**
           * Append a renderAll request to next animation frame.
           * unless one is already in progress, in that case nothing is done
           * a boolean flag will avoid appending more.
           * @return {fabric.Canvas} instance
           * @chainable
           */
          requestRenderAll: function() {
            if (!this.isRendering) {
              this.isRendering = fabric$1.util.requestAnimFrame(this.renderAndResetBound);
            }
            return this;
          },
          /**
           * Calculate the position of the 4 corner of canvas with current viewportTransform.
           * helps to determinate when an object is in the current rendering viewport using
           * object absolute coordinates ( aCoords )
           * @return {Object} points.tl
           * @chainable
           */
          calcViewportBoundaries: function() {
            var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);
            points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
            points.br = transformPoint({ x: width, y: height }, iVpt);
            points.tr = new fabric$1.Point(points.br.x, points.tl.y);
            points.bl = new fabric$1.Point(points.tl.x, points.br.y);
            this.vptCoords = points;
            return points;
          },
          cancelRequestedRender: function() {
            if (this.isRendering) {
              fabric$1.util.cancelAnimFrame(this.isRendering);
              this.isRendering = 0;
            }
          },
          /**
           * Renders background, objects, overlay and controls.
           * @param {CanvasRenderingContext2D} ctx
           * @param {Array} objects to render
           * @return {fabric.Canvas} instance
           * @chainable
           */
          renderCanvas: function(ctx, objects) {
            var v2 = this.viewportTransform, path2 = this.clipPath;
            this.cancelRequestedRender();
            this.calcViewportBoundaries();
            this.clearContext(ctx);
            fabric$1.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);
            this.fire("before:render", { ctx });
            this._renderBackground(ctx);
            ctx.save();
            ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
            this._renderObjects(ctx, objects);
            ctx.restore();
            if (!this.controlsAboveOverlay && this.interactive) {
              this.drawControls(ctx);
            }
            if (path2) {
              path2.canvas = this;
              path2.shouldCache();
              path2._transformDone = true;
              path2.renderCache({ forClipping: true });
              this.drawClipPathOnCanvas(ctx);
            }
            this._renderOverlay(ctx);
            if (this.controlsAboveOverlay && this.interactive) {
              this.drawControls(ctx);
            }
            this.fire("after:render", { ctx });
          },
          /**
           * Paint the cached clipPath on the lowerCanvasEl
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          drawClipPathOnCanvas: function(ctx) {
            var v2 = this.viewportTransform, path2 = this.clipPath;
            ctx.save();
            ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
            ctx.globalCompositeOperation = "destination-in";
            path2.transform(ctx);
            ctx.scale(1 / path2.zoomX, 1 / path2.zoomY);
            ctx.drawImage(path2._cacheCanvas, -path2.cacheTranslationX, -path2.cacheTranslationY);
            ctx.restore();
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Array} objects to render
           */
          _renderObjects: function(ctx, objects) {
            var i2, len;
            for (i2 = 0, len = objects.length; i2 < len; ++i2) {
              objects[i2] && objects[i2].render(ctx);
            }
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {string} property 'background' or 'overlay'
           */
          _renderBackgroundOrOverlay: function(ctx, property) {
            var fill2 = this[property + "Color"], object = this[property + "Image"], v2 = this.viewportTransform, needsVpt = this[property + "Vpt"];
            if (!fill2 && !object) {
              return;
            }
            if (fill2) {
              ctx.save();
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(this.width, 0);
              ctx.lineTo(this.width, this.height);
              ctx.lineTo(0, this.height);
              ctx.closePath();
              ctx.fillStyle = fill2.toLive ? fill2.toLive(ctx, this) : fill2;
              if (needsVpt) {
                ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
              }
              ctx.transform(1, 0, 0, 1, fill2.offsetX || 0, fill2.offsetY || 0);
              var m2 = fill2.gradientTransform || fill2.patternTransform;
              m2 && ctx.transform(m2[0], m2[1], m2[2], m2[3], m2[4], m2[5]);
              ctx.fill();
              ctx.restore();
            }
            if (object) {
              ctx.save();
              if (needsVpt) {
                ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
              }
              object.render(ctx);
              ctx.restore();
            }
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderBackground: function(ctx) {
            this._renderBackgroundOrOverlay(ctx, "background");
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderOverlay: function(ctx) {
            this._renderBackgroundOrOverlay(ctx, "overlay");
          },
          /**
           * Returns coordinates of a center of canvas.
           * Returned value is an object with top and left properties
           * @return {Object} object with "top" and "left" number values
           * @deprecated migrate to `getCenterPoint`
           */
          getCenter: function() {
            return {
              top: this.height / 2,
              left: this.width / 2
            };
          },
          /**
           * Returns coordinates of a center of canvas.
           * @return {fabric.Point} 
           */
          getCenterPoint: function() {
            return new fabric$1.Point(this.width / 2, this.height / 2);
          },
          /**
           * Centers object horizontally in the canvas
           * @param {fabric.Object} object Object to center horizontally
           * @return {fabric.Canvas} thisArg
           */
          centerObjectH: function(object) {
            return this._centerObject(object, new fabric$1.Point(this.getCenterPoint().x, object.getCenterPoint().y));
          },
          /**
           * Centers object vertically in the canvas
           * @param {fabric.Object} object Object to center vertically
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          centerObjectV: function(object) {
            return this._centerObject(object, new fabric$1.Point(object.getCenterPoint().x, this.getCenterPoint().y));
          },
          /**
           * Centers object vertically and horizontally in the canvas
           * @param {fabric.Object} object Object to center vertically and horizontally
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          centerObject: function(object) {
            var center = this.getCenterPoint();
            return this._centerObject(object, center);
          },
          /**
           * Centers object vertically and horizontally in the viewport
           * @param {fabric.Object} object Object to center vertically and horizontally
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          viewportCenterObject: function(object) {
            var vpCenter = this.getVpCenter();
            return this._centerObject(object, vpCenter);
          },
          /**
           * Centers object horizontally in the viewport, object.top is unchanged
           * @param {fabric.Object} object Object to center vertically and horizontally
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          viewportCenterObjectH: function(object) {
            var vpCenter = this.getVpCenter();
            this._centerObject(object, new fabric$1.Point(vpCenter.x, object.getCenterPoint().y));
            return this;
          },
          /**
           * Centers object Vertically in the viewport, object.top is unchanged
           * @param {fabric.Object} object Object to center vertically and horizontally
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          viewportCenterObjectV: function(object) {
            var vpCenter = this.getVpCenter();
            return this._centerObject(object, new fabric$1.Point(object.getCenterPoint().x, vpCenter.y));
          },
          /**
           * Calculate the point in canvas that correspond to the center of actual viewport.
           * @return {fabric.Point} vpCenter, viewport center
           * @chainable
           */
          getVpCenter: function() {
            var center = this.getCenterPoint(), iVpt = invertTransform(this.viewportTransform);
            return transformPoint(center, iVpt);
          },
          /**
           * @private
           * @param {fabric.Object} object Object to center
           * @param {fabric.Point} center Center point
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          _centerObject: function(object, center) {
            object.setPositionByOrigin(center, "center", "center");
            object.setCoords();
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * Returns dataless JSON representation of canvas
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {String} json string
           */
          toDatalessJSON: function(propertiesToInclude) {
            return this.toDatalessObject(propertiesToInclude);
          },
          /**
           * Returns object representation of canvas
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return this._toObjectMethod("toObject", propertiesToInclude);
          },
          /**
           * Returns dataless object representation of canvas
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toDatalessObject: function(propertiesToInclude) {
            return this._toObjectMethod("toDatalessObject", propertiesToInclude);
          },
          /**
           * @private
           */
          _toObjectMethod: function(methodName, propertiesToInclude) {
            var clipPath = this.clipPath, data = {
              version: fabric$1.version,
              objects: this._toObjects(methodName, propertiesToInclude)
            };
            if (clipPath && !clipPath.excludeFromExport) {
              data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
            }
            extend2(data, this.__serializeBgOverlay(methodName, propertiesToInclude));
            fabric$1.util.populateWithProperties(this, data, propertiesToInclude);
            return data;
          },
          /**
           * @private
           */
          _toObjects: function(methodName, propertiesToInclude) {
            return this._objects.filter(function(object) {
              return !object.excludeFromExport;
            }).map(function(instance) {
              return this._toObject(instance, methodName, propertiesToInclude);
            }, this);
          },
          /**
           * @private
           */
          _toObject: function(instance, methodName, propertiesToInclude) {
            var originalValue;
            if (!this.includeDefaultValues) {
              originalValue = instance.includeDefaultValues;
              instance.includeDefaultValues = false;
            }
            var object = instance[methodName](propertiesToInclude);
            if (!this.includeDefaultValues) {
              instance.includeDefaultValues = originalValue;
            }
            return object;
          },
          /**
           * @private
           */
          __serializeBgOverlay: function(methodName, propertiesToInclude) {
            var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;
            if (bgColor && bgColor.toObject) {
              if (!bgColor.excludeFromExport) {
                data.background = bgColor.toObject(propertiesToInclude);
              }
            } else if (bgColor) {
              data.background = bgColor;
            }
            if (overlayColor && overlayColor.toObject) {
              if (!overlayColor.excludeFromExport) {
                data.overlay = overlayColor.toObject(propertiesToInclude);
              }
            } else if (overlayColor) {
              data.overlay = overlayColor;
            }
            if (bgImage && !bgImage.excludeFromExport) {
              data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
            }
            if (overlayImage && !overlayImage.excludeFromExport) {
              data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);
            }
            return data;
          },
          /* _TO_SVG_START_ */
          /**
           * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
           * a zoomed canvas will then produce zoomed SVG output.
           * @type Boolean
           * @default
           */
          svgViewportTransformation: true,
          /**
           * Returns SVG representation of canvas
           * @function
           * @param {Object} [options] Options object for SVG output
           * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
           * @param {Object} [options.viewBox] SVG viewbox object
           * @param {Number} [options.viewBox.x] x-coordinate of viewbox
           * @param {Number} [options.viewBox.y] y-coordinate of viewbox
           * @param {Number} [options.viewBox.width] Width of viewbox
           * @param {Number} [options.viewBox.height] Height of viewbox
           * @param {String} [options.encoding=UTF-8] Encoding of SVG output
           * @param {String} [options.width] desired width of svg with or without units
           * @param {String} [options.height] desired height of svg with or without units
           * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
           * @return {String} SVG string
           * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
           * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
           * @example <caption>Normal SVG output</caption>
           * var svg = canvas.toSVG();
           * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
           * var svg = canvas.toSVG({suppressPreamble: true});
           * @example <caption>SVG output with viewBox attribute</caption>
           * var svg = canvas.toSVG({
           *   viewBox: {
           *     x: 100,
           *     y: 100,
           *     width: 200,
           *     height: 300
           *   }
           * });
           * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
           * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
           * @example <caption>Modify SVG output with reviver function</caption>
           * var svg = canvas.toSVG(null, function(svg) {
           *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
           * });
           */
          toSVG: function(options, reviver) {
            options || (options = {});
            options.reviver = reviver;
            var markup = [];
            this._setSVGPreamble(markup, options);
            this._setSVGHeader(markup, options);
            if (this.clipPath) {
              markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
            }
            this._setSVGBgOverlayColor(markup, "background");
            this._setSVGBgOverlayImage(markup, "backgroundImage", reviver);
            this._setSVGObjects(markup, reviver);
            if (this.clipPath) {
              markup.push("</g>\n");
            }
            this._setSVGBgOverlayColor(markup, "overlay");
            this._setSVGBgOverlayImage(markup, "overlayImage", reviver);
            markup.push("</svg>");
            return markup.join("");
          },
          /**
           * @private
           */
          _setSVGPreamble: function(markup, options) {
            if (options.suppressPreamble) {
              return;
            }
            markup.push(
              '<?xml version="1.0" encoding="',
              options.encoding || "UTF-8",
              '" standalone="no" ?>\n',
              '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
              '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
            );
          },
          /**
           * @private
           */
          _setSVGHeader: function(markup, options) {
            var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', NUM_FRACTION_DIGITS = fabric$1.Object.NUM_FRACTION_DIGITS;
            if (options.viewBox) {
              viewBox = 'viewBox="' + options.viewBox.x + " " + options.viewBox.y + " " + options.viewBox.width + " " + options.viewBox.height + '" ';
            } else {
              if (this.svgViewportTransformation) {
                vpt = this.viewportTransform;
                viewBox = 'viewBox="' + toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + " " + toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + " " + toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + " " + toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
              }
            }
            markup.push(
              "<svg ",
              'xmlns="http://www.w3.org/2000/svg" ',
              'xmlns:xlink="http://www.w3.org/1999/xlink" ',
              'version="1.1" ',
              'width="',
              width,
              '" ',
              'height="',
              height,
              '" ',
              viewBox,
              'xml:space="preserve">\n',
              "<desc>Created with Fabric.js ",
              fabric$1.version,
              "</desc>\n",
              "<defs>\n",
              this.createSVGFontFacesMarkup(),
              this.createSVGRefElementsMarkup(),
              this.createSVGClipPathMarkup(options),
              "</defs>\n"
            );
          },
          createSVGClipPathMarkup: function(options) {
            var clipPath = this.clipPath;
            if (clipPath) {
              clipPath.clipPathId = "CLIPPATH_" + fabric$1.Object.__uid++;
              return '<clipPath id="' + clipPath.clipPathId + '" >\n' + this.clipPath.toClipPathSVG(options.reviver) + "</clipPath>\n";
            }
            return "";
          },
          /**
           * Creates markup containing SVG referenced elements like patterns, gradients etc.
           * @return {String}
           */
          createSVGRefElementsMarkup: function() {
            var _this = this, markup = ["background", "overlay"].map(function(prop) {
              var fill2 = _this[prop + "Color"];
              if (fill2 && fill2.toLive) {
                var shouldTransform = _this[prop + "Vpt"], vpt = _this.viewportTransform, object = {
                  width: _this.width / (shouldTransform ? vpt[0] : 1),
                  height: _this.height / (shouldTransform ? vpt[3] : 1)
                };
                return fill2.toSVG(
                  object,
                  { additionalTransform: shouldTransform ? fabric$1.util.matrixToSVG(vpt) : "" }
                );
              }
            });
            return markup.join("");
          },
          /**
           * Creates markup containing SVG font faces,
           * font URLs for font faces must be collected by developers
           * and are not extracted from the DOM by fabricjs
           * @param {Array} objects Array of fabric objects
           * @return {String}
           */
          createSVGFontFacesMarkup: function() {
            var markup = "", fontList = {}, obj, fontFamily2, style, row, rowIndex, _char, charIndex, i2, len, fontPaths = fabric$1.fontPaths, objects = [];
            this._objects.forEach(function add(object) {
              objects.push(object);
              if (object._objects) {
                object._objects.forEach(add);
              }
            });
            for (i2 = 0, len = objects.length; i2 < len; i2++) {
              obj = objects[i2];
              fontFamily2 = obj.fontFamily;
              if (obj.type.indexOf("text") === -1 || fontList[fontFamily2] || !fontPaths[fontFamily2]) {
                continue;
              }
              fontList[fontFamily2] = true;
              if (!obj.styles) {
                continue;
              }
              style = obj.styles;
              for (rowIndex in style) {
                row = style[rowIndex];
                for (charIndex in row) {
                  _char = row[charIndex];
                  fontFamily2 = _char.fontFamily;
                  if (!fontList[fontFamily2] && fontPaths[fontFamily2]) {
                    fontList[fontFamily2] = true;
                  }
                }
              }
            }
            for (var j2 in fontList) {
              markup += [
                "		@font-face {\n",
                "			font-family: '",
                j2,
                "';\n",
                "			src: url('",
                fontPaths[j2],
                "');\n",
                "		}\n"
              ].join("");
            }
            if (markup) {
              markup = [
                '	<style type="text/css">',
                "<![CDATA[\n",
                markup,
                "]]>",
                "</style>\n"
              ].join("");
            }
            return markup;
          },
          /**
           * @private
           */
          _setSVGObjects: function(markup, reviver) {
            var instance, i2, len, objects = this._objects;
            for (i2 = 0, len = objects.length; i2 < len; i2++) {
              instance = objects[i2];
              if (instance.excludeFromExport) {
                continue;
              }
              this._setSVGObject(markup, instance, reviver);
            }
          },
          /**
           * @private
           */
          _setSVGObject: function(markup, instance, reviver) {
            markup.push(instance.toSVG(reviver));
          },
          /**
           * @private
           */
          _setSVGBgOverlayImage: function(markup, property, reviver) {
            if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
              markup.push(this[property].toSVG(reviver));
            }
          },
          /**
           * @private
           */
          _setSVGBgOverlayColor: function(markup, property) {
            var filler = this[property + "Color"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;
            if (!filler) {
              return;
            }
            if (filler.toLive) {
              var repeat = filler.repeat, iVpt = fabric$1.util.invertTransform(vpt), shouldInvert = this[property + "Vpt"], additionalTransform = shouldInvert ? fabric$1.util.matrixToSVG(iVpt) : "";
              markup.push(
                '<rect transform="' + additionalTransform + " translate(",
                finalWidth / 2,
                ",",
                finalHeight / 2,
                ')"',
                ' x="',
                filler.offsetX - finalWidth / 2,
                '" y="',
                filler.offsetY - finalHeight / 2,
                '" ',
                'width="',
                repeat === "repeat-y" || repeat === "no-repeat" ? filler.source.width : finalWidth,
                '" height="',
                repeat === "repeat-x" || repeat === "no-repeat" ? filler.source.height : finalHeight,
                '" fill="url(#SVGID_' + filler.id + ')"',
                "></rect>\n"
              );
            } else {
              markup.push(
                '<rect x="0" y="0" width="100%" height="100%" ',
                'fill="',
                filler,
                '"',
                "></rect>\n"
              );
            }
          },
          /* _TO_SVG_END_ */
          /**
           * Moves an object or the objects of a multiple selection
           * to the bottom of the stack of drawn objects
           * @param {fabric.Object} object Object to send to back
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          sendToBack: function(object) {
            if (!object) {
              return this;
            }
            var activeSelection = this._activeObject, i2, obj, objs;
            if (object === activeSelection && object.type === "activeSelection") {
              objs = activeSelection._objects;
              for (i2 = objs.length; i2--; ) {
                obj = objs[i2];
                removeFromArray(this._objects, obj);
                this._objects.unshift(obj);
              }
            } else {
              removeFromArray(this._objects, object);
              this._objects.unshift(object);
            }
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * Moves an object or the objects of a multiple selection
           * to the top of the stack of drawn objects
           * @param {fabric.Object} object Object to send
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          bringToFront: function(object) {
            if (!object) {
              return this;
            }
            var activeSelection = this._activeObject, i2, obj, objs;
            if (object === activeSelection && object.type === "activeSelection") {
              objs = activeSelection._objects;
              for (i2 = 0; i2 < objs.length; i2++) {
                obj = objs[i2];
                removeFromArray(this._objects, obj);
                this._objects.push(obj);
              }
            } else {
              removeFromArray(this._objects, object);
              this._objects.push(object);
            }
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * Moves an object or a selection down in stack of drawn objects
           * An optional parameter, intersecting allows to move the object in behind
           * the first intersecting object. Where intersection is calculated with
           * bounding box. If no intersection is found, there will not be change in the
           * stack.
           * @param {fabric.Object} object Object to send
           * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          sendBackwards: function(object, intersecting) {
            if (!object) {
              return this;
            }
            var activeSelection = this._activeObject, i2, obj, idx, newIdx, objs, objsMoved = 0;
            if (object === activeSelection && object.type === "activeSelection") {
              objs = activeSelection._objects;
              for (i2 = 0; i2 < objs.length; i2++) {
                obj = objs[i2];
                idx = this._objects.indexOf(obj);
                if (idx > 0 + objsMoved) {
                  newIdx = idx - 1;
                  removeFromArray(this._objects, obj);
                  this._objects.splice(newIdx, 0, obj);
                }
                objsMoved++;
              }
            } else {
              idx = this._objects.indexOf(object);
              if (idx !== 0) {
                newIdx = this._findNewLowerIndex(object, idx, intersecting);
                removeFromArray(this._objects, object);
                this._objects.splice(newIdx, 0, object);
              }
            }
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * @private
           */
          _findNewLowerIndex: function(object, idx, intersecting) {
            var newIdx, i2;
            if (intersecting) {
              newIdx = idx;
              for (i2 = idx - 1; i2 >= 0; --i2) {
                var isIntersecting = object.intersectsWithObject(this._objects[i2]) || object.isContainedWithinObject(this._objects[i2]) || this._objects[i2].isContainedWithinObject(object);
                if (isIntersecting) {
                  newIdx = i2;
                  break;
                }
              }
            } else {
              newIdx = idx - 1;
            }
            return newIdx;
          },
          /**
           * Moves an object or a selection up in stack of drawn objects
           * An optional parameter, intersecting allows to move the object in front
           * of the first intersecting object. Where intersection is calculated with
           * bounding box. If no intersection is found, there will not be change in the
           * stack.
           * @param {fabric.Object} object Object to send
           * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          bringForward: function(object, intersecting) {
            if (!object) {
              return this;
            }
            var activeSelection = this._activeObject, i2, obj, idx, newIdx, objs, objsMoved = 0;
            if (object === activeSelection && object.type === "activeSelection") {
              objs = activeSelection._objects;
              for (i2 = objs.length; i2--; ) {
                obj = objs[i2];
                idx = this._objects.indexOf(obj);
                if (idx < this._objects.length - 1 - objsMoved) {
                  newIdx = idx + 1;
                  removeFromArray(this._objects, obj);
                  this._objects.splice(newIdx, 0, obj);
                }
                objsMoved++;
              }
            } else {
              idx = this._objects.indexOf(object);
              if (idx !== this._objects.length - 1) {
                newIdx = this._findNewUpperIndex(object, idx, intersecting);
                removeFromArray(this._objects, object);
                this._objects.splice(newIdx, 0, object);
              }
            }
            this.renderOnAddRemove && this.requestRenderAll();
            return this;
          },
          /**
           * @private
           */
          _findNewUpperIndex: function(object, idx, intersecting) {
            var newIdx, i2, len;
            if (intersecting) {
              newIdx = idx;
              for (i2 = idx + 1, len = this._objects.length; i2 < len; ++i2) {
                var isIntersecting = object.intersectsWithObject(this._objects[i2]) || object.isContainedWithinObject(this._objects[i2]) || this._objects[i2].isContainedWithinObject(object);
                if (isIntersecting) {
                  newIdx = i2;
                  break;
                }
              }
            } else {
              newIdx = idx + 1;
            }
            return newIdx;
          },
          /**
           * Moves an object to specified level in stack of drawn objects
           * @param {fabric.Object} object Object to send
           * @param {Number} index Position to move to
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          moveTo: function(object, index2) {
            removeFromArray(this._objects, object);
            this._objects.splice(index2, 0, object);
            return this.renderOnAddRemove && this.requestRenderAll();
          },
          /**
           * Clears a canvas element and dispose objects
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          dispose: function() {
            if (this.isRendering) {
              fabric$1.util.cancelAnimFrame(this.isRendering);
              this.isRendering = 0;
            }
            this.forEachObject(function(object) {
              object.dispose && object.dispose();
            });
            this._objects = [];
            if (this.backgroundImage && this.backgroundImage.dispose) {
              this.backgroundImage.dispose();
            }
            this.backgroundImage = null;
            if (this.overlayImage && this.overlayImage.dispose) {
              this.overlayImage.dispose();
            }
            this.overlayImage = null;
            this._iTextInstances = null;
            this.contextContainer = null;
            this.lowerCanvasEl.classList.remove("lower-canvas");
            fabric$1.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle);
            delete this._originalCanvasStyle;
            this.lowerCanvasEl.setAttribute("width", this.width);
            this.lowerCanvasEl.setAttribute("height", this.height);
            fabric$1.util.cleanUpJsdomNode(this.lowerCanvasEl);
            this.lowerCanvasEl = void 0;
            return this;
          },
          /**
           * Returns a string representation of an instance
           * @return {String} string representation of an instance
           */
          toString: function() {
            return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>";
          }
        }
      );
      extend2(fabric$1.StaticCanvas.prototype, fabric$1.Observable);
      extend2(fabric$1.StaticCanvas.prototype, fabric$1.Collection);
      extend2(fabric$1.StaticCanvas.prototype, fabric$1.DataURLExporter);
      extend2(
        fabric$1.StaticCanvas,
        /** @lends fabric.StaticCanvas */
        {
          /**
           * @static
           * @type String
           * @default
           */
          EMPTY_JSON: '{"objects": [], "background": "white"}',
          /**
           * Provides a way to check support of some of the canvas methods
           * (either those of HTMLCanvasElement itself, or rendering context)
           *
           * @param {String} methodName Method to check support for;
           *                            Could be one of "setLineDash"
           * @return {Boolean | null} `true` if method is supported (or at least exists),
           *                          `null` if canvas element or context can not be initialized
           */
          supports: function(methodName) {
            var el = createCanvasElement();
            if (!el || !el.getContext) {
              return null;
            }
            var ctx = el.getContext("2d");
            if (!ctx) {
              return null;
            }
            switch (methodName) {
              case "setLineDash":
                return typeof ctx.setLineDash !== "undefined";
              default:
                return null;
            }
          }
        }
      );
      fabric$1.StaticCanvas.prototype.toJSON = fabric$1.StaticCanvas.prototype.toObject;
      if (fabric$1.isLikelyNode) {
        fabric$1.StaticCanvas.prototype.createPNGStream = function() {
          var impl = getNodeCanvas(this.lowerCanvasEl);
          return impl && impl.createPNGStream();
        };
        fabric$1.StaticCanvas.prototype.createJPEGStream = function(opts) {
          var impl = getNodeCanvas(this.lowerCanvasEl);
          return impl && impl.createJPEGStream(opts);
        };
      }
    })();
    fabric$1.BaseBrush = fabric$1.util.createClass(
      /** @lends fabric.BaseBrush.prototype */
      {
        /**
         * Color of a brush
         * @type String
         * @default
         */
        color: "rgb(0, 0, 0)",
        /**
         * Width of a brush, has to be a Number, no string literals
         * @type Number
         * @default
         */
        width: 1,
        /**
         * Shadow object representing shadow of this shape.
         * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
         * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
         * @type fabric.Shadow
         * @default
         */
        shadow: null,
        /**
         * Line endings style of a brush (one of "butt", "round", "square")
         * @type String
         * @default
         */
        strokeLineCap: "round",
        /**
         * Corner style of a brush (one of "bevel", "round", "miter")
         * @type String
         * @default
         */
        strokeLineJoin: "round",
        /**
         * Maximum miter length (used for strokeLineJoin = "miter") of a brush's
         * @type Number
         * @default
         */
        strokeMiterLimit: 10,
        /**
         * Stroke Dash Array.
         * @type Array
         * @default
         */
        strokeDashArray: null,
        /**
         * When `true`, the free drawing is limited to the whiteboard size. Default to false.
         * @type Boolean
         * @default false
        */
        limitedToCanvasSize: false,
        /**
         * Sets brush styles
         * @private
         * @param {CanvasRenderingContext2D} ctx
         */
        _setBrushStyles: function(ctx) {
          ctx.strokeStyle = this.color;
          ctx.lineWidth = this.width;
          ctx.lineCap = this.strokeLineCap;
          ctx.miterLimit = this.strokeMiterLimit;
          ctx.lineJoin = this.strokeLineJoin;
          ctx.setLineDash(this.strokeDashArray || []);
        },
        /**
         * Sets the transformation on given context
         * @param {RenderingContext2d} ctx context to render on
         * @private
         */
        _saveAndTransform: function(ctx) {
          var v2 = this.canvas.viewportTransform;
          ctx.save();
          ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
        },
        /**
         * Sets brush shadow styles
         * @private
         */
        _setShadow: function() {
          if (!this.shadow) {
            return;
          }
          var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();
          if (canvas && canvas._isRetinaScaling()) {
            zoom *= fabric$1.devicePixelRatio;
          }
          ctx.shadowColor = shadow.color;
          ctx.shadowBlur = shadow.blur * zoom;
          ctx.shadowOffsetX = shadow.offsetX * zoom;
          ctx.shadowOffsetY = shadow.offsetY * zoom;
        },
        needsFullRender: function() {
          var color2 = new fabric$1.Color(this.color);
          return color2.getAlpha() < 1 || !!this.shadow;
        },
        /**
         * Removes brush shadow styles
         * @private
         */
        _resetShadow: function() {
          var ctx = this.canvas.contextTop;
          ctx.shadowColor = "";
          ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
        },
        /**
         * Check is pointer is outside canvas boundaries
         * @param {Object} pointer
         * @private
        */
        _isOutSideCanvas: function(pointer) {
          return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();
        }
      }
    );
    (function() {
      fabric$1.PencilBrush = fabric$1.util.createClass(
        fabric$1.BaseBrush,
        /** @lends fabric.PencilBrush.prototype */
        {
          /**
           * Discard points that are less than `decimate` pixel distant from each other
           * @type Number
           * @default 0.4
           */
          decimate: 0.4,
          /**
           * Draws a straight line between last recorded point to current pointer
           * Used for `shift` functionality
           *
           * @type boolean
           * @default false
           */
          drawStraightLine: false,
          /**
           * The event modifier key that makes the brush draw a straight line.
           * If `null` or 'none' or any other string that is not a modifier key the feature is disabled.
           * @type {'altKey' | 'shiftKey' | 'ctrlKey' | 'none' | undefined | null}
           */
          straightLineKey: "shiftKey",
          /**
           * Constructor
           * @param {fabric.Canvas} canvas
           * @return {fabric.PencilBrush} Instance of a pencil brush
           */
          initialize: function(canvas) {
            this.canvas = canvas;
            this._points = [];
          },
          needsFullRender: function() {
            return this.callSuper("needsFullRender") || this._hasStraightLine;
          },
          /**
           * Invoked inside on mouse down and mouse move
           * @param {Object} pointer
           */
          _drawSegment: function(ctx, p1, p2) {
            var midPoint = p1.midPointFrom(p2);
            ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
            return midPoint;
          },
          /**
           * Invoked on mouse down
           * @param {Object} pointer
           */
          onMouseDown: function(pointer, options) {
            if (!this.canvas._isMainEvent(options.e)) {
              return;
            }
            this.drawStraightLine = options.e[this.straightLineKey];
            this._prepareForDrawing(pointer);
            this._captureDrawingPath(pointer);
            this._render();
          },
          /**
           * Invoked on mouse move
           * @param {Object} pointer
           */
          onMouseMove: function(pointer, options) {
            if (!this.canvas._isMainEvent(options.e)) {
              return;
            }
            this.drawStraightLine = options.e[this.straightLineKey];
            if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
              return;
            }
            if (this._captureDrawingPath(pointer) && this._points.length > 1) {
              if (this.needsFullRender()) {
                this.canvas.clearContext(this.canvas.contextTop);
                this._render();
              } else {
                var points = this._points, length = points.length, ctx = this.canvas.contextTop;
                this._saveAndTransform(ctx);
                if (this.oldEnd) {
                  ctx.beginPath();
                  ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
                }
                this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
                ctx.stroke();
                ctx.restore();
              }
            }
          },
          /**
           * Invoked on mouse up
           */
          onMouseUp: function(options) {
            if (!this.canvas._isMainEvent(options.e)) {
              return true;
            }
            this.drawStraightLine = false;
            this.oldEnd = void 0;
            this._finalizeAndAddPath();
            return false;
          },
          /**
           * @private
           * @param {Object} pointer Actual mouse position related to the canvas.
           */
          _prepareForDrawing: function(pointer) {
            var p2 = new fabric$1.Point(pointer.x, pointer.y);
            this._reset();
            this._addPoint(p2);
            this.canvas.contextTop.moveTo(p2.x, p2.y);
          },
          /**
           * @private
           * @param {fabric.Point} point Point to be added to points array
           */
          _addPoint: function(point) {
            if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
              return false;
            }
            if (this.drawStraightLine && this._points.length > 1) {
              this._hasStraightLine = true;
              this._points.pop();
            }
            this._points.push(point);
            return true;
          },
          /**
           * Clear points array and set contextTop canvas style.
           * @private
           */
          _reset: function() {
            this._points = [];
            this._setBrushStyles(this.canvas.contextTop);
            this._setShadow();
            this._hasStraightLine = false;
          },
          /**
           * @private
           * @param {Object} pointer Actual mouse position related to the canvas.
           */
          _captureDrawingPath: function(pointer) {
            var pointerPoint = new fabric$1.Point(pointer.x, pointer.y);
            return this._addPoint(pointerPoint);
          },
          /**
           * Draw a smooth path on the topCanvas using quadraticCurveTo
           * @private
           * @param {CanvasRenderingContext2D} [ctx]
           */
          _render: function(ctx) {
            var i2, len, p1 = this._points[0], p2 = this._points[1];
            ctx = ctx || this.canvas.contextTop;
            this._saveAndTransform(ctx);
            ctx.beginPath();
            if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
              var width = this.width / 1e3;
              p1 = new fabric$1.Point(p1.x, p1.y);
              p2 = new fabric$1.Point(p2.x, p2.y);
              p1.x -= width;
              p2.x += width;
            }
            ctx.moveTo(p1.x, p1.y);
            for (i2 = 1, len = this._points.length; i2 < len; i2++) {
              this._drawSegment(ctx, p1, p2);
              p1 = this._points[i2];
              p2 = this._points[i2 + 1];
            }
            ctx.lineTo(p1.x, p1.y);
            ctx.stroke();
            ctx.restore();
          },
          /**
           * Converts points to SVG path
           * @param {Array} points Array of points
           * @return {(string|number)[][]} SVG path commands
           */
          convertPointsToSVGPath: function(points) {
            var correction = this.width / 1e3;
            return fabric$1.util.getSmoothPathFromPoints(points, correction);
          },
          /**
           * @private
           * @param {(string|number)[][]} pathData SVG path commands
           * @returns {boolean}
           */
          _isEmptySVGPath: function(pathData) {
            var pathString = fabric$1.util.joinPath(pathData);
            return pathString === "M 0 0 Q 0 0 0 0 L 0 0";
          },
          /**
           * Creates fabric.Path object to add on canvas
           * @param {(string|number)[][]} pathData Path data
           * @return {fabric.Path} Path to add on canvas
           */
          createPath: function(pathData) {
            var path2 = new fabric$1.Path(pathData, {
              fill: null,
              stroke: this.color,
              strokeWidth: this.width,
              strokeLineCap: this.strokeLineCap,
              strokeMiterLimit: this.strokeMiterLimit,
              strokeLineJoin: this.strokeLineJoin,
              strokeDashArray: this.strokeDashArray
            });
            if (this.shadow) {
              this.shadow.affectStroke = true;
              path2.shadow = new fabric$1.Shadow(this.shadow);
            }
            return path2;
          },
          /**
           * Decimate points array with the decimate value
           */
          decimatePoints: function(points, distance2) {
            if (points.length <= 2) {
              return points;
            }
            var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance2 / zoom, 2), i2, l2 = points.length - 1, lastPoint = points[0], newPoints = [lastPoint], cDistance;
            for (i2 = 1; i2 < l2 - 1; i2++) {
              cDistance = Math.pow(lastPoint.x - points[i2].x, 2) + Math.pow(lastPoint.y - points[i2].y, 2);
              if (cDistance >= adjustedDistance) {
                lastPoint = points[i2];
                newPoints.push(lastPoint);
              }
            }
            newPoints.push(points[l2]);
            return newPoints;
          },
          /**
           * On mouseup after drawing the path on contextTop canvas
           * we use the points captured to create an new fabric path object
           * and add it to the fabric canvas.
           */
          _finalizeAndAddPath: function() {
            var ctx = this.canvas.contextTop;
            ctx.closePath();
            if (this.decimate) {
              this._points = this.decimatePoints(this._points, this.decimate);
            }
            var pathData = this.convertPointsToSVGPath(this._points);
            if (this._isEmptySVGPath(pathData)) {
              this.canvas.requestRenderAll();
              return;
            }
            var path2 = this.createPath(pathData);
            this.canvas.clearContext(this.canvas.contextTop);
            this.canvas.fire("before:path:created", { path: path2 });
            this.canvas.add(path2);
            this.canvas.requestRenderAll();
            path2.setCoords();
            this._resetShadow();
            this.canvas.fire("path:created", { path: path2 });
          }
        }
      );
    })();
    fabric$1.CircleBrush = fabric$1.util.createClass(
      fabric$1.BaseBrush,
      /** @lends fabric.CircleBrush.prototype */
      {
        /**
         * Width of a brush
         * @type Number
         * @default
         */
        width: 10,
        /**
         * Constructor
         * @param {fabric.Canvas} canvas
         * @return {fabric.CircleBrush} Instance of a circle brush
         */
        initialize: function(canvas) {
          this.canvas = canvas;
          this.points = [];
        },
        /**
         * Invoked inside on mouse down and mouse move
         * @param {Object} pointer
         */
        drawDot: function(pointer) {
          var point = this.addPoint(pointer), ctx = this.canvas.contextTop;
          this._saveAndTransform(ctx);
          this.dot(ctx, point);
          ctx.restore();
        },
        dot: function(ctx, point) {
          ctx.fillStyle = point.fill;
          ctx.beginPath();
          ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
          ctx.closePath();
          ctx.fill();
        },
        /**
         * Invoked on mouse down
         */
        onMouseDown: function(pointer) {
          this.points.length = 0;
          this.canvas.clearContext(this.canvas.contextTop);
          this._setShadow();
          this.drawDot(pointer);
        },
        /**
         * Render the full state of the brush
         * @private
         */
        _render: function() {
          var ctx = this.canvas.contextTop, i2, len, points = this.points;
          this._saveAndTransform(ctx);
          for (i2 = 0, len = points.length; i2 < len; i2++) {
            this.dot(ctx, points[i2]);
          }
          ctx.restore();
        },
        /**
         * Invoked on mouse move
         * @param {Object} pointer
         */
        onMouseMove: function(pointer) {
          if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
            return;
          }
          if (this.needsFullRender()) {
            this.canvas.clearContext(this.canvas.contextTop);
            this.addPoint(pointer);
            this._render();
          } else {
            this.drawDot(pointer);
          }
        },
        /**
         * Invoked on mouse up
         */
        onMouseUp: function() {
          var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i2, len;
          this.canvas.renderOnAddRemove = false;
          var circles = [];
          for (i2 = 0, len = this.points.length; i2 < len; i2++) {
            var point = this.points[i2], circle = new fabric$1.Circle({
              radius: point.radius,
              left: point.x,
              top: point.y,
              originX: "center",
              originY: "center",
              fill: point.fill
            });
            this.shadow && (circle.shadow = new fabric$1.Shadow(this.shadow));
            circles.push(circle);
          }
          var group = new fabric$1.Group(circles);
          group.canvas = this.canvas;
          this.canvas.fire("before:path:created", { path: group });
          this.canvas.add(group);
          this.canvas.fire("path:created", { path: group });
          this.canvas.clearContext(this.canvas.contextTop);
          this._resetShadow();
          this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
          this.canvas.requestRenderAll();
        },
        /**
         * @param {Object} pointer
         * @return {fabric.Point} Just added pointer point
         */
        addPoint: function(pointer) {
          var pointerPoint = new fabric$1.Point(pointer.x, pointer.y), circleRadius = fabric$1.util.getRandomInt(
            Math.max(0, this.width - 20),
            this.width + 20
          ) / 2, circleColor = new fabric$1.Color(this.color).setAlpha(fabric$1.util.getRandomInt(0, 100) / 100).toRgba();
          pointerPoint.radius = circleRadius;
          pointerPoint.fill = circleColor;
          this.points.push(pointerPoint);
          return pointerPoint;
        }
      }
    );
    fabric$1.SprayBrush = fabric$1.util.createClass(
      fabric$1.BaseBrush,
      /** @lends fabric.SprayBrush.prototype */
      {
        /**
         * Width of a spray
         * @type Number
         * @default
         */
        width: 10,
        /**
         * Density of a spray (number of dots per chunk)
         * @type Number
         * @default
         */
        density: 20,
        /**
         * Width of spray dots
         * @type Number
         * @default
         */
        dotWidth: 1,
        /**
         * Width variance of spray dots
         * @type Number
         * @default
         */
        dotWidthVariance: 1,
        /**
         * Whether opacity of a dot should be random
         * @type Boolean
         * @default
         */
        randomOpacity: false,
        /**
         * Whether overlapping dots (rectangles) should be removed (for performance reasons)
         * @type Boolean
         * @default
         */
        optimizeOverlapping: true,
        /**
         * Constructor
         * @param {fabric.Canvas} canvas
         * @return {fabric.SprayBrush} Instance of a spray brush
         */
        initialize: function(canvas) {
          this.canvas = canvas;
          this.sprayChunks = [];
        },
        /**
         * Invoked on mouse down
         * @param {Object} pointer
         */
        onMouseDown: function(pointer) {
          this.sprayChunks.length = 0;
          this.canvas.clearContext(this.canvas.contextTop);
          this._setShadow();
          this.addSprayChunk(pointer);
          this.render(this.sprayChunkPoints);
        },
        /**
         * Invoked on mouse move
         * @param {Object} pointer
         */
        onMouseMove: function(pointer) {
          if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
            return;
          }
          this.addSprayChunk(pointer);
          this.render(this.sprayChunkPoints);
        },
        /**
         * Invoked on mouse up
         */
        onMouseUp: function() {
          var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
          this.canvas.renderOnAddRemove = false;
          var rects = [];
          for (var i2 = 0, ilen = this.sprayChunks.length; i2 < ilen; i2++) {
            var sprayChunk = this.sprayChunks[i2];
            for (var j2 = 0, jlen = sprayChunk.length; j2 < jlen; j2++) {
              var rect = new fabric$1.Rect({
                width: sprayChunk[j2].width,
                height: sprayChunk[j2].width,
                left: sprayChunk[j2].x + 1,
                top: sprayChunk[j2].y + 1,
                originX: "center",
                originY: "center",
                fill: this.color
              });
              rects.push(rect);
            }
          }
          if (this.optimizeOverlapping) {
            rects = this._getOptimizedRects(rects);
          }
          var group = new fabric$1.Group(rects);
          this.shadow && group.set("shadow", new fabric$1.Shadow(this.shadow));
          this.canvas.fire("before:path:created", { path: group });
          this.canvas.add(group);
          this.canvas.fire("path:created", { path: group });
          this.canvas.clearContext(this.canvas.contextTop);
          this._resetShadow();
          this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
          this.canvas.requestRenderAll();
        },
        /**
         * @private
         * @param {Array} rects
         */
        _getOptimizedRects: function(rects) {
          var uniqueRects = {}, key, i2, len;
          for (i2 = 0, len = rects.length; i2 < len; i2++) {
            key = rects[i2].left + "" + rects[i2].top;
            if (!uniqueRects[key]) {
              uniqueRects[key] = rects[i2];
            }
          }
          var uniqueRectsArray = [];
          for (key in uniqueRects) {
            uniqueRectsArray.push(uniqueRects[key]);
          }
          return uniqueRectsArray;
        },
        /**
         * Render new chunk of spray brush
         */
        render: function(sprayChunk) {
          var ctx = this.canvas.contextTop, i2, len;
          ctx.fillStyle = this.color;
          this._saveAndTransform(ctx);
          for (i2 = 0, len = sprayChunk.length; i2 < len; i2++) {
            var point = sprayChunk[i2];
            if (typeof point.opacity !== "undefined") {
              ctx.globalAlpha = point.opacity;
            }
            ctx.fillRect(point.x, point.y, point.width, point.width);
          }
          ctx.restore();
        },
        /**
         * Render all spray chunks
         */
        _render: function() {
          var ctx = this.canvas.contextTop, i2, ilen;
          ctx.fillStyle = this.color;
          this._saveAndTransform(ctx);
          for (i2 = 0, ilen = this.sprayChunks.length; i2 < ilen; i2++) {
            this.render(this.sprayChunks[i2]);
          }
          ctx.restore();
        },
        /**
         * @param {Object} pointer
         */
        addSprayChunk: function(pointer) {
          this.sprayChunkPoints = [];
          var x2, y2, width, radius = this.width / 2, i2;
          for (i2 = 0; i2 < this.density; i2++) {
            x2 = fabric$1.util.getRandomInt(pointer.x - radius, pointer.x + radius);
            y2 = fabric$1.util.getRandomInt(pointer.y - radius, pointer.y + radius);
            if (this.dotWidthVariance) {
              width = fabric$1.util.getRandomInt(
                // bottom clamp width to 1
                Math.max(1, this.dotWidth - this.dotWidthVariance),
                this.dotWidth + this.dotWidthVariance
              );
            } else {
              width = this.dotWidth;
            }
            var point = new fabric$1.Point(x2, y2);
            point.width = width;
            if (this.randomOpacity) {
              point.opacity = fabric$1.util.getRandomInt(0, 100) / 100;
            }
            this.sprayChunkPoints.push(point);
          }
          this.sprayChunks.push(this.sprayChunkPoints);
        }
      }
    );
    fabric$1.PatternBrush = fabric$1.util.createClass(
      fabric$1.PencilBrush,
      /** @lends fabric.PatternBrush.prototype */
      {
        getPatternSrc: function() {
          var dotWidth = 20, dotDistance = 5, patternCanvas = fabric$1.util.createCanvasElement(), patternCtx = patternCanvas.getContext("2d");
          patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
          patternCtx.fillStyle = this.color;
          patternCtx.beginPath();
          patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
          patternCtx.closePath();
          patternCtx.fill();
          return patternCanvas;
        },
        getPatternSrcFunction: function() {
          return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"');
        },
        /**
         * Creates "pattern" instance property
         * @param {CanvasRenderingContext2D} ctx
         */
        getPattern: function(ctx) {
          return ctx.createPattern(this.source || this.getPatternSrc(), "repeat");
        },
        /**
         * Sets brush styles
         * @param {CanvasRenderingContext2D} ctx
         */
        _setBrushStyles: function(ctx) {
          this.callSuper("_setBrushStyles", ctx);
          ctx.strokeStyle = this.getPattern(ctx);
        },
        /**
         * Creates path
         */
        createPath: function(pathData) {
          var path2 = this.callSuper("createPath", pathData), topLeft = path2._getLeftTopCoords().scalarAdd(path2.strokeWidth / 2);
          path2.stroke = new fabric$1.Pattern({
            source: this.source || this.getPatternSrcFunction(),
            offsetX: -topLeft.x,
            offsetY: -topLeft.y
          });
          return path2;
        }
      }
    );
    (function() {
      var getPointer = fabric$1.util.getPointer, degreesToRadians = fabric$1.util.degreesToRadians, isTouchEvent = fabric$1.util.isTouchEvent;
      fabric$1.Canvas = fabric$1.util.createClass(
        fabric$1.StaticCanvas,
        /** @lends fabric.Canvas.prototype */
        {
          /**
           * Constructor
           * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
           * @param {Object} [options] Options object
           * @return {Object} thisArg
           */
          initialize: function(el, options) {
            options || (options = {});
            this.renderAndResetBound = this.renderAndReset.bind(this);
            this.requestRenderAllBound = this.requestRenderAll.bind(this);
            this._initStatic(el, options);
            this._initInteractive();
            this._createCacheCanvas();
          },
          /**
           * When true, objects can be transformed by one side (unproportionally)
           * when dragged on the corners that normally would not do that.
           * @type Boolean
           * @default
           * @since fabric 4.0 // changed name and default value
           */
          uniformScaling: true,
          /**
           * Indicates which key switches uniform scaling.
           * values: 'altKey', 'shiftKey', 'ctrlKey'.
           * If `null` or 'none' or any other string that is not a modifier key
           * feature is disabled.
           * totally wrong named. this sounds like `uniform scaling`
           * if Canvas.uniformScaling is true, pressing this will set it to false
           * and viceversa.
           * @since 1.6.2
           * @type String
           * @default
           */
          uniScaleKey: "shiftKey",
          /**
           * When true, objects use center point as the origin of scale transformation.
           * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
           * @since 1.3.4
           * @type Boolean
           * @default
           */
          centeredScaling: false,
          /**
           * When true, objects use center point as the origin of rotate transformation.
           * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
           * @since 1.3.4
           * @type Boolean
           * @default
           */
          centeredRotation: false,
          /**
           * Indicates which key enable centered Transform
           * values: 'altKey', 'shiftKey', 'ctrlKey'.
           * If `null` or 'none' or any other string that is not a modifier key
           * feature is disabled feature disabled.
           * @since 1.6.2
           * @type String
           * @default
           */
          centeredKey: "altKey",
          /**
           * Indicates which key enable alternate action on corner
           * values: 'altKey', 'shiftKey', 'ctrlKey'.
           * If `null` or 'none' or any other string that is not a modifier key
           * feature is disabled feature disabled.
           * @since 1.6.2
           * @type String
           * @default
           */
          altActionKey: "shiftKey",
          /**
           * Indicates that canvas is interactive. This property should not be changed.
           * @type Boolean
           * @default
           */
          interactive: true,
          /**
           * Indicates whether group selection should be enabled
           * @type Boolean
           * @default
           */
          selection: true,
          /**
           * Indicates which key or keys enable multiple click selection
           * Pass value as a string or array of strings
           * values: 'altKey', 'shiftKey', 'ctrlKey'.
           * If `null` or empty or containing any other string that is not a modifier key
           * feature is disabled.
           * @since 1.6.2
           * @type String|Array
           * @default
           */
          selectionKey: "shiftKey",
          /**
           * Indicates which key enable alternative selection
           * in case of target overlapping with active object
           * values: 'altKey', 'shiftKey', 'ctrlKey'.
           * For a series of reason that come from the general expectations on how
           * things should work, this feature works only for preserveObjectStacking true.
           * If `null` or 'none' or any other string that is not a modifier key
           * feature is disabled.
           * @since 1.6.5
           * @type null|String
           * @default
           */
          altSelectionKey: null,
          /**
           * Color of selection
           * @type String
           * @default
           */
          selectionColor: "rgba(100, 100, 255, 0.3)",
          // blue
          /**
           * Default dash array pattern
           * If not empty the selection border is dashed
           * @type Array
           */
          selectionDashArray: [],
          /**
           * Color of the border of selection (usually slightly darker than color of selection itself)
           * @type String
           * @default
           */
          selectionBorderColor: "rgba(255, 255, 255, 0.3)",
          /**
           * Width of a line used in object/group selection
           * @type Number
           * @default
           */
          selectionLineWidth: 1,
          /**
           * Select only shapes that are fully contained in the dragged selection rectangle.
           * @type Boolean
           * @default
           */
          selectionFullyContained: false,
          /**
           * Default cursor value used when hovering over an object on canvas
           * @type String
           * @default
           */
          hoverCursor: "move",
          /**
           * Default cursor value used when moving an object on canvas
           * @type String
           * @default
           */
          moveCursor: "move",
          /**
           * Default cursor value used for the entire canvas
           * @type String
           * @default
           */
          defaultCursor: "default",
          /**
           * Cursor value used during free drawing
           * @type String
           * @default
           */
          freeDrawingCursor: "crosshair",
          /**
           * Cursor value used for disabled elements ( corners with disabled action )
           * @type String
           * @since 2.0.0
           * @default
           */
          notAllowedCursor: "not-allowed",
          /**
           * Default element class that's given to wrapper (div) element of canvas
           * @type String
           * @default
           */
          containerClass: "canvas-container",
          /**
           * When true, object detection happens on per-pixel basis rather than on per-bounding-box
           * @type Boolean
           * @default
           */
          perPixelTargetFind: false,
          /**
           * Number of pixels around target pixel to tolerate (consider active) during object detection
           * @type Number
           * @default
           */
          targetFindTolerance: 0,
          /**
           * When true, target detection is skipped. Target detection will return always undefined.
           * click selection won't work anymore, events will fire with no targets.
           * if something is selected before setting it to true, it will be deselected at the first click.
           * area selection will still work. check the `selection` property too.
           * if you deactivate both, you should look into staticCanvas.
           * @type Boolean
           * @default
           */
          skipTargetFind: false,
          /**
           * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
           * After mousedown, mousemove creates a shape,
           * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
           * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
           * @type Boolean
           * @default
           */
          isDrawingMode: false,
          /**
           * Indicates whether objects should remain in current stack position when selected.
           * When false objects are brought to top and rendered as part of the selection group
           * @type Boolean
           * @default
           */
          preserveObjectStacking: false,
          /**
           * Indicates the angle that an object will lock to while rotating.
           * @type Number
           * @since 1.6.7
           * @default
           */
          snapAngle: 0,
          /**
           * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
           * When `null`, the snapThreshold will default to the snapAngle.
           * @type null|Number
           * @since 1.6.7
           * @default
           */
          snapThreshold: null,
          /**
           * Indicates if the right click on canvas can output the context menu or not
           * @type Boolean
           * @since 1.6.5
           * @default
           */
          stopContextMenu: false,
          /**
           * Indicates if the canvas can fire right click events
           * @type Boolean
           * @since 1.6.5
           * @default
           */
          fireRightClick: false,
          /**
           * Indicates if the canvas can fire middle click events
           * @type Boolean
           * @since 1.7.8
           * @default
           */
          fireMiddleClick: false,
          /**
           * Keep track of the subTargets for Mouse Events
           * @type fabric.Object[]
           */
          targets: [],
          /**
           * When the option is enabled, PointerEvent is used instead of MouseEvent.
           * @type Boolean
           * @default
           */
          enablePointerEvents: false,
          /**
           * Keep track of the hovered target
           * @type fabric.Object
           * @private
           */
          _hoveredTarget: null,
          /**
           * hold the list of nested targets hovered
           * @type fabric.Object[]
           * @private
           */
          _hoveredTargets: [],
          /**
           * @private
           */
          _initInteractive: function() {
            this._currentTransform = null;
            this._groupSelector = null;
            this._initWrapperElement();
            this._createUpperCanvas();
            this._initEventListeners();
            this._initRetinaScaling();
            this.freeDrawingBrush = fabric$1.PencilBrush && new fabric$1.PencilBrush(this);
            this.calcOffset();
          },
          /**
           * Divides objects in two groups, one to render immediately
           * and one to render as activeGroup.
           * @return {Array} objects to render immediately and pushes the other in the activeGroup.
           */
          _chooseObjectsToRender: function() {
            var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;
            if (activeObjects.length > 0 && !this.preserveObjectStacking) {
              objsToRender = [];
              activeGroupObjects = [];
              for (var i2 = 0, length = this._objects.length; i2 < length; i2++) {
                object = this._objects[i2];
                if (activeObjects.indexOf(object) === -1) {
                  objsToRender.push(object);
                } else {
                  activeGroupObjects.push(object);
                }
              }
              if (activeObjects.length > 1) {
                this._activeObject._objects = activeGroupObjects;
              }
              objsToRender.push.apply(objsToRender, activeGroupObjects);
            } else {
              objsToRender = this._objects;
            }
            return objsToRender;
          },
          /**
           * Renders both the top canvas and the secondary container canvas.
           * @return {fabric.Canvas} instance
           * @chainable
           */
          renderAll: function() {
            if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
              this.clearContext(this.contextTop);
              this.contextTopDirty = false;
            }
            if (this.hasLostContext) {
              this.renderTopLayer(this.contextTop);
              this.hasLostContext = false;
            }
            var canvasToDrawOn = this.contextContainer;
            this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
            return this;
          },
          renderTopLayer: function(ctx) {
            ctx.save();
            if (this.isDrawingMode && this._isCurrentlyDrawing) {
              this.freeDrawingBrush && this.freeDrawingBrush._render();
              this.contextTopDirty = true;
            }
            if (this.selection && this._groupSelector) {
              this._drawSelection(ctx);
              this.contextTopDirty = true;
            }
            ctx.restore();
          },
          /**
           * Method to render only the top canvas.
           * Also used to render the group selection box.
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          renderTop: function() {
            var ctx = this.contextTop;
            this.clearContext(ctx);
            this.renderTopLayer(ctx);
            this.fire("after:render");
            return this;
          },
          /**
           * @private
           */
          _normalizePointer: function(object, pointer) {
            var m2 = object.calcTransformMatrix(), invertedM = fabric$1.util.invertTransform(m2), vptPointer = this.restorePointerVpt(pointer);
            return fabric$1.util.transformPoint(vptPointer, invertedM);
          },
          /**
           * Returns true if object is transparent at a certain location
           * @param {fabric.Object} target Object to check
           * @param {Number} x Left coordinate
           * @param {Number} y Top coordinate
           * @return {Boolean}
           */
          isTargetTransparent: function(target, x2, y2) {
            if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
              var normalizedPointer = this._normalizePointer(target, { x: x2, y: y2 }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);
              var isTransparent2 = fabric$1.util.isTransparent(
                target._cacheContext,
                Math.round(targetRelativeX),
                Math.round(targetRelativeY),
                this.targetFindTolerance
              );
              return isTransparent2;
            }
            var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v2 = this.viewportTransform;
            target.selectionBackgroundColor = "";
            this.clearContext(ctx);
            ctx.save();
            ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
            target.render(ctx);
            ctx.restore();
            target.selectionBackgroundColor = originalColor;
            var isTransparent2 = fabric$1.util.isTransparent(
              ctx,
              x2,
              y2,
              this.targetFindTolerance
            );
            return isTransparent2;
          },
          /**
           * takes an event and determines if selection key has been pressed
           * @private
           * @param {Event} e Event object
           */
          _isSelectionKeyPressed: function(e2) {
            var selectionKeyPressed = false;
            if (Array.isArray(this.selectionKey)) {
              selectionKeyPressed = !!this.selectionKey.find(function(key) {
                return e2[key] === true;
              });
            } else {
              selectionKeyPressed = e2[this.selectionKey];
            }
            return selectionKeyPressed;
          },
          /**
           * @private
           * @param {Event} e Event object
           * @param {fabric.Object} target
           */
          _shouldClearSelection: function(e2, target) {
            var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;
            return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e2) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;
          },
          /**
           * centeredScaling from object can't override centeredScaling from canvas.
           * this should be fixed, since object setting should take precedence over canvas.
           * also this should be something that will be migrated in the control properties.
           * as ability to define the origin of the transformation that the control provide.
           * @private
           * @param {fabric.Object} target
           * @param {String} action
           * @param {Boolean} altKey
           */
          _shouldCenterTransform: function(target, action, altKey) {
            if (!target) {
              return;
            }
            var centerTransform;
            if (action === "scale" || action === "scaleX" || action === "scaleY" || action === "resizing") {
              centerTransform = this.centeredScaling || target.centeredScaling;
            } else if (action === "rotate") {
              centerTransform = this.centeredRotation || target.centeredRotation;
            }
            return centerTransform ? !altKey : altKey;
          },
          /**
           * should disappear before release 4.0
           * @private
           */
          _getOriginFromCorner: function(target, corner) {
            var origin2 = {
              x: target.originX,
              y: target.originY
            };
            if (corner === "ml" || corner === "tl" || corner === "bl") {
              origin2.x = "right";
            } else if (corner === "mr" || corner === "tr" || corner === "br") {
              origin2.x = "left";
            }
            if (corner === "tl" || corner === "mt" || corner === "tr") {
              origin2.y = "bottom";
            } else if (corner === "bl" || corner === "mb" || corner === "br") {
              origin2.y = "top";
            }
            return origin2;
          },
          /**
           * @private
           * @param {Boolean} alreadySelected true if target is already selected
           * @param {String} corner a string representing the corner ml, mr, tl ...
           * @param {Event} e Event object
           * @param {fabric.Object} [target] inserted back to help overriding. Unused
           */
          _getActionFromCorner: function(alreadySelected, corner, e2, target) {
            if (!corner || !alreadySelected) {
              return "drag";
            }
            var control = target.controls[corner];
            return control.getActionName(e2, control, target);
          },
          /**
           * @private
           * @param {Event} e Event object
           * @param {fabric.Object} target
           */
          _setupCurrentTransform: function(e2, target, alreadySelected) {
            if (!target) {
              return;
            }
            var pointer = this.getPointer(e2), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e2, target, control) : fabric$1.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e2, target), origin2 = this._getOriginFromCorner(target, corner), altKey = e2[this.centeredKey], transform2 = {
              target,
              action,
              actionHandler,
              corner,
              scaleX: target.scaleX,
              scaleY: target.scaleY,
              skewX: target.skewX,
              skewY: target.skewY,
              // used by transation
              offsetX: pointer.x - target.left,
              offsetY: pointer.y - target.top,
              originX: origin2.x,
              originY: origin2.y,
              ex: pointer.x,
              ey: pointer.y,
              lastX: pointer.x,
              lastY: pointer.y,
              // unsure they are useful anymore.
              // left: target.left,
              // top: target.top,
              theta: degreesToRadians(target.angle),
              // end of unsure
              width: target.width * target.scaleX,
              shiftKey: e2.shiftKey,
              altKey,
              original: fabric$1.util.saveObjectTransform(target)
            };
            if (this._shouldCenterTransform(target, action, altKey)) {
              transform2.originX = "center";
              transform2.originY = "center";
            }
            transform2.original.originX = origin2.x;
            transform2.original.originY = origin2.y;
            this._currentTransform = transform2;
            this._beforeTransform(e2);
          },
          /**
           * Set the cursor type of the canvas element
           * @param {String} value Cursor type of the canvas element.
           * @see http://www.w3.org/TR/css3-ui/#cursor
           */
          setCursor: function(value) {
            this.upperCanvasEl.style.cursor = value;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx to draw the selection on
           */
          _drawSelection: function(ctx) {
            var selector = this._groupSelector, viewportStart = new fabric$1.Point(selector.ex, selector.ey), start = fabric$1.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric$1.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric$1.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;
            if (this.selectionColor) {
              ctx.fillStyle = this.selectionColor;
              ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
            }
            if (!this.selectionLineWidth || !this.selectionBorderColor) {
              return;
            }
            ctx.lineWidth = this.selectionLineWidth;
            ctx.strokeStyle = this.selectionBorderColor;
            minX += strokeOffset;
            minY += strokeOffset;
            maxX -= strokeOffset;
            maxY -= strokeOffset;
            fabric$1.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
          },
          /**
           * Method that determines what object we are clicking on
           * the skipGroup parameter is for internal use, is needed for shift+click action
           * 11/09/2018 TODO: would be cool if findTarget could discern between being a full target
           * or the outside part of the corner.
           * @param {Event} e mouse event
           * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
           * @return {fabric.Object} the target found
           */
          findTarget: function(e2, skipGroup) {
            if (this.skipTargetFind) {
              return;
            }
            var ignoreZoom = true, pointer = this.getPointer(e2, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e2), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;
            this.targets = [];
            if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {
              return activeObject;
            }
            if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
              return activeObject;
            }
            if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
              if (!this.preserveObjectStacking) {
                return activeObject;
              } else {
                activeTarget = activeObject;
                activeTargetSubs = this.targets;
                this.targets = [];
              }
            }
            var target = this._searchPossibleTargets(this._objects, pointer);
            if (e2[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
              target = activeTarget;
              this.targets = activeTargetSubs;
            }
            return target;
          },
          /**
           * Checks point is inside the object.
           * @param {Object} [pointer] x,y object of point coordinates we want to check.
           * @param {fabric.Object} obj Object to test against
           * @param {Object} [globalPointer] x,y object of point coordinates relative to canvas used to search per pixel target.
           * @return {Boolean} true if point is contained within an area of given object
           * @private
           */
          _checkTarget: function(pointer, obj, globalPointer) {
            if (obj && obj.visible && obj.evented && // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
            // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
            obj.containsPoint(pointer)) {
              if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
                var isTransparent2 = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
                if (!isTransparent2) {
                  return true;
                }
              } else {
                return true;
              }
            }
          },
          /**
           * Function used to search inside objects an object that contains pointer in bounding box or that contains pointerOnCanvas when painted
           * @param {Array} [objects] objects array to look into
           * @param {Object} [pointer] x,y object of point coordinates we want to check.
           * @return {fabric.Object} object that contains pointer
           * @private
           */
          _searchPossibleTargets: function(objects, pointer) {
            var target, i2 = objects.length, subTarget;
            while (i2--) {
              var objToCheck = objects[i2];
              var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;
              if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
                target = objects[i2];
                if (target.subTargetCheck && target instanceof fabric$1.Group) {
                  subTarget = this._searchPossibleTargets(target._objects, pointer);
                  subTarget && this.targets.push(subTarget);
                }
                break;
              }
            }
            return target;
          },
          /**
           * Returns pointer coordinates without the effect of the viewport
           * @param {Object} pointer with "x" and "y" number values
           * @return {Object} object with "x" and "y" number values
           */
          restorePointerVpt: function(pointer) {
            return fabric$1.util.transformPoint(
              pointer,
              fabric$1.util.invertTransform(this.viewportTransform)
            );
          },
          /**
           * Returns pointer coordinates relative to canvas.
           * Can return coordinates with or without viewportTransform.
           * ignoreZoom false gives back coordinates that represent
           * the point clicked on canvas element.
           * ignoreZoom true gives back coordinates after being processed
           * by the viewportTransform ( sort of coordinates of what is displayed
           * on the canvas where you are clicking.
           * ignoreZoom true = HTMLElement coordinates relative to top,left
           * ignoreZoom false, default = fabric space coordinates, the same used for shape position
           * To interact with your shapes top and left you want to use ignoreZoom true
           * most of the time, while ignoreZoom false will give you coordinates
           * compatible with the object.oCoords system.
           * of the time.
           * @param {Event} e
           * @param {Boolean} ignoreZoom
           * @return {Object} object with "x" and "y" number values
           */
          getPointer: function(e2, ignoreZoom) {
            if (this._absolutePointer && !ignoreZoom) {
              return this._absolutePointer;
            }
            if (this._pointer && ignoreZoom) {
              return this._pointer;
            }
            var pointer = getPointer(e2), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;
            if (!boundsWidth || !boundsHeight) {
              if ("top" in bounds && "bottom" in bounds) {
                boundsHeight = Math.abs(bounds.top - bounds.bottom);
              }
              if ("right" in bounds && "left" in bounds) {
                boundsWidth = Math.abs(bounds.right - bounds.left);
              }
            }
            this.calcOffset();
            pointer.x = pointer.x - this._offset.left;
            pointer.y = pointer.y - this._offset.top;
            if (!ignoreZoom) {
              pointer = this.restorePointerVpt(pointer);
            }
            var retinaScaling = this.getRetinaScaling();
            if (retinaScaling !== 1) {
              pointer.x /= retinaScaling;
              pointer.y /= retinaScaling;
            }
            if (boundsWidth === 0 || boundsHeight === 0) {
              cssScale = { width: 1, height: 1 };
            } else {
              cssScale = {
                width: upperCanvasEl.width / boundsWidth,
                height: upperCanvasEl.height / boundsHeight
              };
            }
            return {
              x: pointer.x * cssScale.width,
              y: pointer.y * cssScale.height
            };
          },
          /**
           * @private
           * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
           */
          _createUpperCanvas: function() {
            var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;
            if (upperCanvasEl) {
              upperCanvasEl.className = "";
            } else {
              upperCanvasEl = this._createCanvasElement();
              this.upperCanvasEl = upperCanvasEl;
            }
            fabric$1.util.addClass(upperCanvasEl, "upper-canvas " + lowerCanvasClass);
            this.wrapperEl.appendChild(upperCanvasEl);
            this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
            this._applyCanvasStyle(upperCanvasEl);
            this.contextTop = upperCanvasEl.getContext("2d");
          },
          /**
           * Returns context of top canvas where interactions are drawn
           * @returns {CanvasRenderingContext2D}
           */
          getTopContext: function() {
            return this.contextTop;
          },
          /**
           * @private
           */
          _createCacheCanvas: function() {
            this.cacheCanvasEl = this._createCanvasElement();
            this.cacheCanvasEl.setAttribute("width", this.width);
            this.cacheCanvasEl.setAttribute("height", this.height);
            this.contextCache = this.cacheCanvasEl.getContext("2d");
          },
          /**
           * @private
           */
          _initWrapperElement: function() {
            this.wrapperEl = fabric$1.util.wrapElement(this.lowerCanvasEl, "div", {
              "class": this.containerClass
            });
            fabric$1.util.setStyle(this.wrapperEl, {
              width: this.width + "px",
              height: this.height + "px",
              position: "relative"
            });
            fabric$1.util.makeElementUnselectable(this.wrapperEl);
          },
          /**
           * @private
           * @param {HTMLElement} element canvas element to apply styles on
           */
          _applyCanvasStyle: function(element) {
            var width = this.width || element.width, height = this.height || element.height;
            fabric$1.util.setStyle(element, {
              position: "absolute",
              width: width + "px",
              height: height + "px",
              left: 0,
              top: 0,
              "touch-action": this.allowTouchScrolling ? "manipulation" : "none",
              "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none"
            });
            element.width = width;
            element.height = height;
            fabric$1.util.makeElementUnselectable(element);
          },
          /**
           * Copy the entire inline style from one element (fromEl) to another (toEl)
           * @private
           * @param {Element} fromEl Element style is copied from
           * @param {Element} toEl Element copied style is applied to
           */
          _copyCanvasStyle: function(fromEl, toEl) {
            toEl.style.cssText = fromEl.style.cssText;
          },
          /**
           * Returns context of canvas where object selection is drawn
           * @return {CanvasRenderingContext2D}
           */
          getSelectionContext: function() {
            return this.contextTop;
          },
          /**
           * Returns &lt;canvas> element on which object selection is drawn
           * @return {HTMLCanvasElement}
           */
          getSelectionElement: function() {
            return this.upperCanvasEl;
          },
          /**
           * Returns currently active object
           * @return {fabric.Object} active object
           */
          getActiveObject: function() {
            return this._activeObject;
          },
          /**
           * Returns an array with the current selected objects
           * @return {fabric.Object} active object
           */
          getActiveObjects: function() {
            var active = this._activeObject;
            if (active) {
              if (active.type === "activeSelection" && active._objects) {
                return active._objects.slice(0);
              } else {
                return [active];
              }
            }
            return [];
          },
          /**
           * @private
           * @param {fabric.Object} obj Object that was removed
           */
          _onObjectRemoved: function(obj) {
            if (obj === this._activeObject) {
              this.fire("before:selection:cleared", { target: obj });
              this._discardActiveObject();
              this.fire("selection:cleared", { target: obj });
              obj.fire("deselected");
            }
            if (obj === this._hoveredTarget) {
              this._hoveredTarget = null;
              this._hoveredTargets = [];
            }
            this.callSuper("_onObjectRemoved", obj);
          },
          /**
           * @private
           * Compares the old activeObject with the current one and fires correct events
           * @param {fabric.Object} obj old activeObject
           */
          _fireSelectionEvents: function(oldObjects, e2) {
            var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];
            oldObjects.forEach(function(oldObject) {
              if (objects.indexOf(oldObject) === -1) {
                somethingChanged = true;
                oldObject.fire("deselected", {
                  e: e2,
                  target: oldObject
                });
                removed.push(oldObject);
              }
            });
            objects.forEach(function(object) {
              if (oldObjects.indexOf(object) === -1) {
                somethingChanged = true;
                object.fire("selected", {
                  e: e2,
                  target: object
                });
                added.push(object);
              }
            });
            if (oldObjects.length > 0 && objects.length > 0) {
              somethingChanged && this.fire("selection:updated", {
                e: e2,
                selected: added,
                deselected: removed
              });
            } else if (objects.length > 0) {
              this.fire("selection:created", {
                e: e2,
                selected: added
              });
            } else if (oldObjects.length > 0) {
              this.fire("selection:cleared", {
                e: e2,
                deselected: removed
              });
            }
          },
          /**
           * Sets given object as the only active object on canvas
           * @param {fabric.Object} object Object to set as an active one
           * @param {Event} [e] Event (passed along when firing "object:selected")
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          setActiveObject: function(object, e2) {
            var currentActives = this.getActiveObjects();
            this._setActiveObject(object, e2);
            this._fireSelectionEvents(currentActives, e2);
            return this;
          },
          /**
           * This is a private method for now.
           * This is supposed to be equivalent to setActiveObject but without firing
           * any event. There is commitment to have this stay this way.
           * This is the functional part of setActiveObject.
           * @private
           * @param {Object} object to set as active
           * @param {Event} [e] Event (passed along when firing "object:selected")
           * @return {Boolean} true if the selection happened
           */
          _setActiveObject: function(object, e2) {
            if (this._activeObject === object) {
              return false;
            }
            if (!this._discardActiveObject(e2, object)) {
              return false;
            }
            if (object.onSelect({ e: e2 })) {
              return false;
            }
            this._activeObject = object;
            return true;
          },
          /**
           * This is a private method for now.
           * This is supposed to be equivalent to discardActiveObject but without firing
           * any events. There is commitment to have this stay this way.
           * This is the functional part of discardActiveObject.
           * @param {Event} [e] Event (passed along when firing "object:deselected")
           * @param {Object} object to set as active
           * @return {Boolean} true if the selection happened
           * @private
           */
          _discardActiveObject: function(e2, object) {
            var obj = this._activeObject;
            if (obj) {
              if (obj.onDeselect({ e: e2, object })) {
                return false;
              }
              this._activeObject = null;
            }
            return true;
          },
          /**
           * Discards currently active object and fire events. If the function is called by fabric
           * as a consequence of a mouse event, the event is passed as a parameter and
           * sent to the fire function for the custom events. When used as a method the
           * e param does not have any application.
           * @param {event} e
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          discardActiveObject: function(e2) {
            var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
            if (currentActives.length) {
              this.fire("before:selection:cleared", { target: activeObject, e: e2 });
            }
            this._discardActiveObject(e2);
            this._fireSelectionEvents(currentActives, e2);
            return this;
          },
          /**
           * Clears a canvas element and removes all event listeners
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          dispose: function() {
            var wrapper = this.wrapperEl;
            this.removeListeners();
            wrapper.removeChild(this.upperCanvasEl);
            wrapper.removeChild(this.lowerCanvasEl);
            this.contextCache = null;
            this.contextTop = null;
            ["upperCanvasEl", "cacheCanvasEl"].forEach((function(element) {
              fabric$1.util.cleanUpJsdomNode(this[element]);
              this[element] = void 0;
            }).bind(this));
            if (wrapper.parentNode) {
              wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
            }
            delete this.wrapperEl;
            fabric$1.StaticCanvas.prototype.dispose.call(this);
            return this;
          },
          /**
           * Clears all contexts (background, main, top) of an instance
           * @return {fabric.Canvas} thisArg
           * @chainable
           */
          clear: function() {
            this.discardActiveObject();
            this.clearContext(this.contextTop);
            return this.callSuper("clear");
          },
          /**
           * Draws objects' controls (borders/controls)
           * @param {CanvasRenderingContext2D} ctx Context to render controls on
           */
          drawControls: function(ctx) {
            var activeObject = this._activeObject;
            if (activeObject) {
              activeObject._renderControls(ctx);
            }
          },
          /**
           * @private
           */
          _toObject: function(instance, methodName, propertiesToInclude) {
            var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper("_toObject", instance, methodName, propertiesToInclude);
            this._unwindGroupTransformOnObject(instance, originalProperties);
            return object;
          },
          /**
           * Realises an object's group transformation on it
           * @private
           * @param {fabric.Object} [instance] the object to transform (gets mutated)
           * @returns the original values of instance which were changed
           */
          _realizeGroupTransformOnObject: function(instance) {
            if (instance.group && instance.group.type === "activeSelection" && this._activeObject === instance.group) {
              var layoutProps = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"];
              var originalValues = {};
              layoutProps.forEach(function(prop2) {
                originalValues[prop2] = instance[prop2];
              });
              fabric$1.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());
              return originalValues;
            } else {
              return null;
            }
          },
          /**
           * Restores the changed properties of instance
           * @private
           * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
           * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
           */
          _unwindGroupTransformOnObject: function(instance, originalValues) {
            if (originalValues) {
              instance.set(originalValues);
            }
          },
          /**
           * @private
           */
          _setSVGObject: function(markup, instance, reviver) {
            var originalProperties = this._realizeGroupTransformOnObject(instance);
            this.callSuper("_setSVGObject", markup, instance, reviver);
            this._unwindGroupTransformOnObject(instance, originalProperties);
          },
          setViewportTransform: function(vpt) {
            if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
              this._activeObject.clearContextTop();
            }
            fabric$1.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
          }
        }
      );
      for (var prop in fabric$1.StaticCanvas) {
        if (prop !== "prototype") {
          fabric$1.Canvas[prop] = fabric$1.StaticCanvas[prop];
        }
      }
    })();
    (function() {
      var addListener = fabric$1.util.addListener, removeListener = fabric$1.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = { passive: false };
      function checkClick(e2, value) {
        return e2.button && e2.button === value - 1;
      }
      fabric$1.util.object.extend(
        fabric$1.Canvas.prototype,
        /** @lends fabric.Canvas.prototype */
        {
          /**
           * Contains the id of the touch event that owns the fabric transform
           * @type Number
           * @private
           */
          mainTouchId: null,
          /**
           * Adds mouse listeners to canvas
           * @private
           */
          _initEventListeners: function() {
            this.removeListeners();
            this._bindEvents();
            this.addOrRemove(addListener, "add");
          },
          /**
           * return an event prefix pointer or mouse.
           * @private
           */
          _getEventPrefix: function() {
            return this.enablePointerEvents ? "pointer" : "mouse";
          },
          addOrRemove: function(functor, eventjsFunctor) {
            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
            functor(fabric$1.window, "resize", this._onResize);
            functor(canvasElement, eventTypePrefix + "down", this._onMouseDown);
            functor(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
            functor(canvasElement, eventTypePrefix + "out", this._onMouseOut);
            functor(canvasElement, eventTypePrefix + "enter", this._onMouseEnter);
            functor(canvasElement, "wheel", this._onMouseWheel);
            functor(canvasElement, "contextmenu", this._onContextMenu);
            functor(canvasElement, "dblclick", this._onDoubleClick);
            functor(canvasElement, "dragover", this._onDragOver);
            functor(canvasElement, "dragenter", this._onDragEnter);
            functor(canvasElement, "dragleave", this._onDragLeave);
            functor(canvasElement, "drop", this._onDrop);
            if (!this.enablePointerEvents) {
              functor(canvasElement, "touchstart", this._onTouchStart, addEventOptions);
            }
            if (typeof eventjs !== "undefined" && eventjsFunctor in eventjs) {
              eventjs[eventjsFunctor](canvasElement, "gesture", this._onGesture);
              eventjs[eventjsFunctor](canvasElement, "drag", this._onDrag);
              eventjs[eventjsFunctor](canvasElement, "orientation", this._onOrientationChange);
              eventjs[eventjsFunctor](canvasElement, "shake", this._onShake);
              eventjs[eventjsFunctor](canvasElement, "longpress", this._onLongPress);
            }
          },
          /**
           * Removes all event listeners
           */
          removeListeners: function() {
            this.addOrRemove(removeListener, "remove");
            var eventTypePrefix = this._getEventPrefix();
            removeListener(fabric$1.document, eventTypePrefix + "up", this._onMouseUp);
            removeListener(fabric$1.document, "touchend", this._onTouchEnd, addEventOptions);
            removeListener(fabric$1.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
            removeListener(fabric$1.document, "touchmove", this._onMouseMove, addEventOptions);
          },
          /**
           * @private
           */
          _bindEvents: function() {
            if (this.eventsBound) {
              return;
            }
            this._onMouseDown = this._onMouseDown.bind(this);
            this._onTouchStart = this._onTouchStart.bind(this);
            this._onMouseMove = this._onMouseMove.bind(this);
            this._onMouseUp = this._onMouseUp.bind(this);
            this._onTouchEnd = this._onTouchEnd.bind(this);
            this._onResize = this._onResize.bind(this);
            this._onGesture = this._onGesture.bind(this);
            this._onDrag = this._onDrag.bind(this);
            this._onShake = this._onShake.bind(this);
            this._onLongPress = this._onLongPress.bind(this);
            this._onOrientationChange = this._onOrientationChange.bind(this);
            this._onMouseWheel = this._onMouseWheel.bind(this);
            this._onMouseOut = this._onMouseOut.bind(this);
            this._onMouseEnter = this._onMouseEnter.bind(this);
            this._onContextMenu = this._onContextMenu.bind(this);
            this._onDoubleClick = this._onDoubleClick.bind(this);
            this._onDragOver = this._onDragOver.bind(this);
            this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter");
            this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave");
            this._onDrop = this._onDrop.bind(this);
            this.eventsBound = true;
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on Event.js gesture
           * @param {Event} [self] Inner Event object
           */
          _onGesture: function(e2, self2) {
            this.__onTransformGesture && this.__onTransformGesture(e2, self2);
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on Event.js drag
           * @param {Event} [self] Inner Event object
           */
          _onDrag: function(e2, self2) {
            this.__onDrag && this.__onDrag(e2, self2);
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on wheel event
           */
          _onMouseWheel: function(e2) {
            this.__onMouseWheel(e2);
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onMouseOut: function(e2) {
            var target = this._hoveredTarget;
            this.fire("mouse:out", { target, e: e2 });
            this._hoveredTarget = null;
            target && target.fire("mouseout", { e: e2 });
            var _this = this;
            this._hoveredTargets.forEach(function(_target) {
              _this.fire("mouse:out", { target, e: e2 });
              _target && target.fire("mouseout", { e: e2 });
            });
            this._hoveredTargets = [];
          },
          /**
           * @private
           * @param {Event} e Event object fired on mouseenter
           */
          _onMouseEnter: function(e2) {
            if (!this._currentTransform && !this.findTarget(e2)) {
              this.fire("mouse:over", { target: null, e: e2 });
              this._hoveredTarget = null;
              this._hoveredTargets = [];
            }
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on Event.js orientation change
           * @param {Event} [self] Inner Event object
           */
          _onOrientationChange: function(e2, self2) {
            this.__onOrientationChange && this.__onOrientationChange(e2, self2);
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on Event.js shake
           * @param {Event} [self] Inner Event object
           */
          _onShake: function(e2, self2) {
            this.__onShake && this.__onShake(e2, self2);
          },
          /**
           * @private
           * @param {Event} [e] Event object fired on Event.js shake
           * @param {Event} [self] Inner Event object
           */
          _onLongPress: function(e2, self2) {
            this.__onLongPress && this.__onLongPress(e2, self2);
          },
          /**
           * prevent default to allow drop event to be fired
           * @private
           * @param {Event} [e] Event object fired on Event.js shake
           */
          _onDragOver: function(e2) {
            e2.preventDefault();
            var target = this._simpleEventHandler("dragover", e2);
            this._fireEnterLeaveEvents(target, e2);
          },
          /**
           * `drop:before` is a an event that allow you to schedule logic
           * before the `drop` event. Prefer `drop` event always, but if you need
           * to run some drop-disabling logic on an event, since there is no way
           * to handle event handlers ordering, use `drop:before`
           * @param {Event} e
           */
          _onDrop: function(e2) {
            this._simpleEventHandler("drop:before", e2);
            return this._simpleEventHandler("drop", e2);
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onContextMenu: function(e2) {
            if (this.stopContextMenu) {
              e2.stopPropagation();
              e2.preventDefault();
            }
            return false;
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onDoubleClick: function(e2) {
            this._cacheTransformEventData(e2);
            this._handleEvent(e2, "dblclick");
            this._resetTransformEventData(e2);
          },
          /**
           * Return a the id of an event.
           * returns either the pointerId or the identifier or 0 for the mouse event
           * @private
           * @param {Event} evt Event object
           */
          getPointerId: function(evt) {
            var changedTouches = evt.changedTouches;
            if (changedTouches) {
              return changedTouches[0] && changedTouches[0].identifier;
            }
            if (this.enablePointerEvents) {
              return evt.pointerId;
            }
            return -1;
          },
          /**
           * Determines if an event has the id of the event that is considered main
           * @private
           * @param {evt} event Event object
           */
          _isMainEvent: function(evt) {
            if (evt.isPrimary === true) {
              return true;
            }
            if (evt.isPrimary === false) {
              return false;
            }
            if (evt.type === "touchend" && evt.touches.length === 0) {
              return true;
            }
            if (evt.changedTouches) {
              return evt.changedTouches[0].identifier === this.mainTouchId;
            }
            return true;
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onTouchStart: function(e2) {
            e2.preventDefault();
            if (this.mainTouchId === null) {
              this.mainTouchId = this.getPointerId(e2);
            }
            this.__onMouseDown(e2);
            this._resetTransformEventData();
            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
            addListener(fabric$1.document, "touchend", this._onTouchEnd, addEventOptions);
            addListener(fabric$1.document, "touchmove", this._onMouseMove, addEventOptions);
            removeListener(canvasElement, eventTypePrefix + "down", this._onMouseDown);
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onMouseDown: function(e2) {
            this.__onMouseDown(e2);
            this._resetTransformEventData();
            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
            removeListener(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
            addListener(fabric$1.document, eventTypePrefix + "up", this._onMouseUp);
            addListener(fabric$1.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onTouchEnd: function(e2) {
            if (e2.touches.length > 0) {
              return;
            }
            this.__onMouseUp(e2);
            this._resetTransformEventData();
            this.mainTouchId = null;
            var eventTypePrefix = this._getEventPrefix();
            removeListener(fabric$1.document, "touchend", this._onTouchEnd, addEventOptions);
            removeListener(fabric$1.document, "touchmove", this._onMouseMove, addEventOptions);
            var _this = this;
            if (this._willAddMouseDown) {
              clearTimeout(this._willAddMouseDown);
            }
            this._willAddMouseDown = setTimeout(function() {
              addListener(_this.upperCanvasEl, eventTypePrefix + "down", _this._onMouseDown);
              _this._willAddMouseDown = 0;
            }, 400);
          },
          /**
           * @private
           * @param {Event} e Event object fired on mouseup
           */
          _onMouseUp: function(e2) {
            this.__onMouseUp(e2);
            this._resetTransformEventData();
            var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
            if (this._isMainEvent(e2)) {
              removeListener(fabric$1.document, eventTypePrefix + "up", this._onMouseUp);
              removeListener(fabric$1.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
              addListener(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
            }
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousemove
           */
          _onMouseMove: function(e2) {
            !this.allowTouchScrolling && e2.preventDefault && e2.preventDefault();
            this.__onMouseMove(e2);
          },
          /**
           * @private
           */
          _onResize: function() {
            this.calcOffset();
          },
          /**
           * Decides whether the canvas should be redrawn in mouseup and mousedown events.
           * @private
           * @param {Object} target
           */
          _shouldRender: function(target) {
            var activeObject = this._activeObject;
            if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {
              return true;
            } else if (activeObject && activeObject.isEditing) {
              return false;
            }
            return false;
          },
          /**
           * Method that defines the actions when mouse is released on canvas.
           * The method resets the currentTransform parameters, store the image corner
           * position in the image object and render the canvas on top.
           * @private
           * @param {Event} e Event object fired on mouseup
           */
          __onMouseUp: function(e2) {
            var target, transform2 = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;
            this._cacheTransformEventData(e2);
            target = this._target;
            this._handleEvent(e2, "up:before");
            if (checkClick(e2, RIGHT_CLICK)) {
              if (this.fireRightClick) {
                this._handleEvent(e2, "up", RIGHT_CLICK, isClick);
              }
              return;
            }
            if (checkClick(e2, MIDDLE_CLICK)) {
              if (this.fireMiddleClick) {
                this._handleEvent(e2, "up", MIDDLE_CLICK, isClick);
              }
              this._resetTransformEventData();
              return;
            }
            if (this.isDrawingMode && this._isCurrentlyDrawing) {
              this._onMouseUpInDrawingMode(e2);
              return;
            }
            if (!this._isMainEvent(e2)) {
              return;
            }
            if (transform2) {
              this._finalizeCurrentTransform(e2);
              shouldRender = transform2.actionPerformed;
            }
            if (!isClick) {
              var targetWasActive = target === this._activeObject;
              this._maybeGroupObjects(e2);
              if (!shouldRender) {
                shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;
              }
            }
            var corner, pointer;
            if (target) {
              corner = target._findTargetCorner(
                this.getPointer(e2, true),
                fabric$1.util.isTouchEvent(e2)
              );
              if (target.selectable && target !== this._activeObject && target.activeOn === "up") {
                this.setActiveObject(target, e2);
                shouldRender = true;
              } else {
                var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e2, target, control);
                if (mouseUpHandler) {
                  pointer = this.getPointer(e2);
                  mouseUpHandler(e2, transform2, pointer.x, pointer.y);
                }
              }
              target.isMoving = false;
            }
            if (transform2 && (transform2.target !== target || transform2.corner !== corner)) {
              var originalControl = transform2.target && transform2.target.controls[transform2.corner], originalMouseUpHandler = originalControl && originalControl.getMouseUpHandler(e2, target, control);
              pointer = pointer || this.getPointer(e2);
              originalMouseUpHandler && originalMouseUpHandler(e2, transform2, pointer.x, pointer.y);
            }
            this._setCursorFromEvent(e2, target);
            this._handleEvent(e2, "up", LEFT_CLICK, isClick);
            this._groupSelector = null;
            this._currentTransform = null;
            target && (target.__corner = 0);
            if (shouldRender) {
              this.requestRenderAll();
            } else if (!isClick) {
              this.renderTop();
            }
          },
          /**
           * @private
           * Handle event firing for target and subtargets
           * @param {Event} e event from mouse
           * @param {String} eventType event to fire (up, down or move)
           * @return {Fabric.Object} target return the the target found, for internal reasons.
           */
          _simpleEventHandler: function(eventType, e2) {
            var target = this.findTarget(e2), targets = this.targets, options = {
              e: e2,
              target,
              subTargets: targets
            };
            this.fire(eventType, options);
            target && target.fire(eventType, options);
            if (!targets) {
              return target;
            }
            for (var i2 = 0; i2 < targets.length; i2++) {
              targets[i2].fire(eventType, options);
            }
            return target;
          },
          /**
           * @private
           * Handle event firing for target and subtargets
           * @param {Event} e event from mouse
           * @param {String} eventType event to fire (up, down or move)
           * @param {fabric.Object} targetObj receiving event
           * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
           * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
           */
          _handleEvent: function(e2, eventType, button, isClick) {
            var target = this._target, targets = this.targets || [], options = {
              e: e2,
              target,
              subTargets: targets,
              button: button || LEFT_CLICK,
              isClick: isClick || false,
              pointer: this._pointer,
              absolutePointer: this._absolutePointer,
              transform: this._currentTransform
            };
            if (eventType === "up") {
              options.currentTarget = this.findTarget(e2);
              options.currentSubTargets = this.targets;
            }
            this.fire("mouse:" + eventType, options);
            target && target.fire("mouse" + eventType, options);
            for (var i2 = 0; i2 < targets.length; i2++) {
              targets[i2].fire("mouse" + eventType, options);
            }
          },
          /**
           * @private
           * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
           */
          _finalizeCurrentTransform: function(e2) {
            var transform2 = this._currentTransform, target = transform2.target, options = {
              e: e2,
              target,
              transform: transform2,
              action: transform2.action
            };
            if (target._scaling) {
              target._scaling = false;
            }
            target.setCoords();
            if (transform2.actionPerformed || this.stateful && target.hasStateChanged()) {
              this._fire("modified", options);
            }
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          _onMouseDownInDrawingMode: function(e2) {
            this._isCurrentlyDrawing = true;
            if (this.getActiveObject()) {
              this.discardActiveObject(e2).requestRenderAll();
            }
            var pointer = this.getPointer(e2);
            this.freeDrawingBrush.onMouseDown(pointer, { e: e2, pointer });
            this._handleEvent(e2, "down");
          },
          /**
           * @private
           * @param {Event} e Event object fired on mousemove
           */
          _onMouseMoveInDrawingMode: function(e2) {
            if (this._isCurrentlyDrawing) {
              var pointer = this.getPointer(e2);
              this.freeDrawingBrush.onMouseMove(pointer, { e: e2, pointer });
            }
            this.setCursor(this.freeDrawingCursor);
            this._handleEvent(e2, "move");
          },
          /**
           * @private
           * @param {Event} e Event object fired on mouseup
           */
          _onMouseUpInDrawingMode: function(e2) {
            var pointer = this.getPointer(e2);
            this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e2, pointer });
            this._handleEvent(e2, "up");
          },
          /**
           * Method that defines the actions when mouse is clicked on canvas.
           * The method inits the currentTransform parameters and renders all the
           * canvas so the current image can be placed on the top canvas and the rest
           * in on the container one.
           * @private
           * @param {Event} e Event object fired on mousedown
           */
          __onMouseDown: function(e2) {
            this._cacheTransformEventData(e2);
            this._handleEvent(e2, "down:before");
            var target = this._target;
            if (checkClick(e2, RIGHT_CLICK)) {
              if (this.fireRightClick) {
                this._handleEvent(e2, "down", RIGHT_CLICK);
              }
              return;
            }
            if (checkClick(e2, MIDDLE_CLICK)) {
              if (this.fireMiddleClick) {
                this._handleEvent(e2, "down", MIDDLE_CLICK);
              }
              return;
            }
            if (this.isDrawingMode) {
              this._onMouseDownInDrawingMode(e2);
              return;
            }
            if (!this._isMainEvent(e2)) {
              return;
            }
            if (this._currentTransform) {
              return;
            }
            var pointer = this._pointer;
            this._previousPointer = pointer;
            var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e2, target);
            if (this._shouldClearSelection(e2, target)) {
              this.discardActiveObject(e2);
            } else if (shouldGroup) {
              this._handleGrouping(e2, target);
              target = this._activeObject;
            }
            if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {
              this._groupSelector = {
                ex: this._absolutePointer.x,
                ey: this._absolutePointer.y,
                top: 0,
                left: 0
              };
            }
            if (target) {
              var alreadySelected = target === this._activeObject;
              if (target.selectable && target.activeOn === "down") {
                this.setActiveObject(target, e2);
              }
              var corner = target._findTargetCorner(
                this.getPointer(e2, true),
                fabric$1.util.isTouchEvent(e2)
              );
              target.__corner = corner;
              if (target === this._activeObject && (corner || !shouldGroup)) {
                this._setupCurrentTransform(e2, target, alreadySelected);
                var control = target.controls[corner], pointer = this.getPointer(e2), mouseDownHandler = control && control.getMouseDownHandler(e2, target, control);
                if (mouseDownHandler) {
                  mouseDownHandler(e2, this._currentTransform, pointer.x, pointer.y);
                }
              }
            }
            this._handleEvent(e2, "down");
            (shouldRender || shouldGroup) && this.requestRenderAll();
          },
          /**
           * reset cache form common information needed during event processing
           * @private
           */
          _resetTransformEventData: function() {
            this._target = null;
            this._pointer = null;
            this._absolutePointer = null;
          },
          /**
           * Cache common information needed during event processing
           * @private
           * @param {Event} e Event object fired on event
           */
          _cacheTransformEventData: function(e2) {
            this._resetTransformEventData();
            this._pointer = this.getPointer(e2, true);
            this._absolutePointer = this.restorePointerVpt(this._pointer);
            this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e2) || null;
          },
          /**
           * @private
           */
          _beforeTransform: function(e2) {
            var t3 = this._currentTransform;
            this.stateful && t3.target.saveState();
            this.fire("before:transform", {
              e: e2,
              transform: t3
            });
          },
          /**
           * Method that defines the actions when mouse is hovering the canvas.
           * The currentTransform parameter will define whether the user is rotating/scaling/translating
           * an image or neither of them (only hovering). A group selection is also possible and would cancel
           * all any other type of action.
           * In case of an image transformation only the top canvas will be rendered.
           * @private
           * @param {Event} e Event object fired on mousemove
           */
          __onMouseMove: function(e2) {
            this._handleEvent(e2, "move:before");
            this._cacheTransformEventData(e2);
            var target, pointer;
            if (this.isDrawingMode) {
              this._onMouseMoveInDrawingMode(e2);
              return;
            }
            if (!this._isMainEvent(e2)) {
              return;
            }
            var groupSelector = this._groupSelector;
            if (groupSelector) {
              pointer = this._absolutePointer;
              groupSelector.left = pointer.x - groupSelector.ex;
              groupSelector.top = pointer.y - groupSelector.ey;
              this.renderTop();
            } else if (!this._currentTransform) {
              target = this.findTarget(e2) || null;
              this._setCursorFromEvent(e2, target);
              this._fireOverOutEvents(target, e2);
            } else {
              this._transformObject(e2);
            }
            this._handleEvent(e2, "move");
            this._resetTransformEventData();
          },
          /**
           * Manage the mouseout, mouseover events for the fabric object on the canvas
           * @param {Fabric.Object} target the target where the target from the mousemove event
           * @param {Event} e Event object fired on mousemove
           * @private
           */
          _fireOverOutEvents: function(target, e2) {
            var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);
            this.fireSyntheticInOutEvents(target, e2, {
              oldTarget: _hoveredTarget,
              evtOut: "mouseout",
              canvasEvtOut: "mouse:out",
              evtIn: "mouseover",
              canvasEvtIn: "mouse:over"
            });
            for (var i2 = 0; i2 < length; i2++) {
              this.fireSyntheticInOutEvents(targets[i2], e2, {
                oldTarget: _hoveredTargets[i2],
                evtOut: "mouseout",
                evtIn: "mouseover"
              });
            }
            this._hoveredTarget = target;
            this._hoveredTargets = this.targets.concat();
          },
          /**
           * Manage the dragEnter, dragLeave events for the fabric objects on the canvas
           * @param {Fabric.Object} target the target where the target from the onDrag event
           * @param {Event} e Event object fired on ondrag
           * @private
           */
          _fireEnterLeaveEvents: function(target, e2) {
            var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);
            this.fireSyntheticInOutEvents(target, e2, {
              oldTarget: _draggedoverTarget,
              evtOut: "dragleave",
              evtIn: "dragenter"
            });
            for (var i2 = 0; i2 < length; i2++) {
              this.fireSyntheticInOutEvents(targets[i2], e2, {
                oldTarget: _hoveredTargets[i2],
                evtOut: "dragleave",
                evtIn: "dragenter"
              });
            }
            this._draggedoverTarget = target;
          },
          /**
           * Manage the synthetic in/out events for the fabric objects on the canvas
           * @param {Fabric.Object} target the target where the target from the supported events
           * @param {Event} e Event object fired
           * @param {Object} config configuration for the function to work
           * @param {String} config.targetName property on the canvas where the old target is stored
           * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out
           * @param {String} config.evtOut name of the event to fire for out
           * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in
           * @param {String} config.evtIn name of the event to fire for in
           * @private
           */
          fireSyntheticInOutEvents: function(target, e2, config) {
            var inOpt, outOpt, oldTarget = config.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config.canvasEvtIn, canvasEvtOut = config.canvasEvtOut;
            if (targetChanged) {
              inOpt = { e: e2, target, previousTarget: oldTarget };
              outOpt = { e: e2, target: oldTarget, nextTarget: target };
            }
            inFires = target && targetChanged;
            outFires = oldTarget && targetChanged;
            if (outFires) {
              canvasEvtOut && this.fire(canvasEvtOut, outOpt);
              oldTarget.fire(config.evtOut, outOpt);
            }
            if (inFires) {
              canvasEvtIn && this.fire(canvasEvtIn, inOpt);
              target.fire(config.evtIn, inOpt);
            }
          },
          /**
           * Method that defines actions when an Event Mouse Wheel
           * @param {Event} e Event object fired on mouseup
           */
          __onMouseWheel: function(e2) {
            this._cacheTransformEventData(e2);
            this._handleEvent(e2, "wheel");
            this._resetTransformEventData();
          },
          /**
           * @private
           * @param {Event} e Event fired on mousemove
           */
          _transformObject: function(e2) {
            var pointer = this.getPointer(e2), transform2 = this._currentTransform;
            transform2.reset = false;
            transform2.shiftKey = e2.shiftKey;
            transform2.altKey = e2[this.centeredKey];
            this._performTransformAction(e2, transform2, pointer);
            transform2.actionPerformed && this.requestRenderAll();
          },
          /**
           * @private
           */
          _performTransformAction: function(e2, transform2, pointer) {
            var x2 = pointer.x, y2 = pointer.y, action = transform2.action, actionPerformed = false, actionHandler = transform2.actionHandler;
            if (actionHandler) {
              actionPerformed = actionHandler(e2, transform2, x2, y2);
            }
            if (action === "drag" && actionPerformed) {
              transform2.target.isMoving = true;
              this.setCursor(transform2.target.moveCursor || this.moveCursor);
            }
            transform2.actionPerformed = transform2.actionPerformed || actionPerformed;
          },
          /**
           * @private
           */
          _fire: fabric$1.controlsUtils.fireEvent,
          /**
           * Sets the cursor depending on where the canvas is being hovered.
           * Note: very buggy in Opera
           * @param {Event} e Event object
           * @param {Object} target Object that the mouse is hovering, if so.
           */
          _setCursorFromEvent: function(e2, target) {
            if (!target) {
              this.setCursor(this.defaultCursor);
              return false;
            }
            var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e2, true));
            if (!corner) {
              if (target.subTargetCheck) {
                this.targets.concat().reverse().map(function(_target) {
                  hoverCursor = _target.hoverCursor || hoverCursor;
                });
              }
              this.setCursor(hoverCursor);
            } else {
              this.setCursor(this.getCornerCursor(corner, target, e2));
            }
          },
          /**
           * @private
           */
          getCornerCursor: function(corner, target, e2) {
            var control = target.controls[corner];
            return control.cursorStyleHandler(e2, control, target);
          }
        }
      );
    })();
    (function() {
      var min = Math.min, max = Math.max;
      fabric$1.util.object.extend(
        fabric$1.Canvas.prototype,
        /** @lends fabric.Canvas.prototype */
        {
          /**
           * @private
           * @param {Event} e Event object
           * @param {fabric.Object} target
           * @return {Boolean}
           */
          _shouldGroup: function(e2, target) {
            var activeObject = this._activeObject;
            return activeObject && this._isSelectionKeyPressed(e2) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === "activeSelection") && !target.onSelect({ e: e2 });
          },
          /**
           * @private
           * @param {Event} e Event object
           * @param {fabric.Object} target
           */
          _handleGrouping: function(e2, target) {
            var activeObject = this._activeObject;
            if (activeObject.__corner) {
              return;
            }
            if (target === activeObject) {
              target = this.findTarget(e2, true);
              if (!target || !target.selectable) {
                return;
              }
            }
            if (activeObject && activeObject.type === "activeSelection") {
              this._updateActiveSelection(target, e2);
            } else {
              this._createActiveSelection(target, e2);
            }
          },
          /**
           * @private
           */
          _updateActiveSelection: function(target, e2) {
            var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);
            if (activeSelection.contains(target)) {
              activeSelection.removeWithUpdate(target);
              this._hoveredTarget = target;
              this._hoveredTargets = this.targets.concat();
              if (activeSelection.size() === 1) {
                this._setActiveObject(activeSelection.item(0), e2);
              }
            } else {
              activeSelection.addWithUpdate(target);
              this._hoveredTarget = activeSelection;
              this._hoveredTargets = this.targets.concat();
            }
            this._fireSelectionEvents(currentActiveObjects, e2);
          },
          /**
           * @private
           */
          _createActiveSelection: function(target, e2) {
            var currentActives = this.getActiveObjects(), group = this._createGroup(target);
            this._hoveredTarget = group;
            this._setActiveObject(group, e2);
            this._fireSelectionEvents(currentActives, e2);
          },
          /**
           * @private
           * @param {Object} target
           */
          _createGroup: function(target) {
            var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [this._activeObject, target] : [target, this._activeObject];
            this._activeObject.isEditing && this._activeObject.exitEditing();
            return new fabric$1.ActiveSelection(groupObjects, {
              canvas: this
            });
          },
          /**
           * @private
           * @param {Event} e mouse event
           */
          _groupSelectedObjects: function(e2) {
            var group = this._collectObjects(e2), aGroup;
            if (group.length === 1) {
              this.setActiveObject(group[0], e2);
            } else if (group.length > 1) {
              aGroup = new fabric$1.ActiveSelection(group.reverse(), {
                canvas: this
              });
              this.setActiveObject(aGroup, e2);
            }
          },
          /**
           * @private
           */
          _collectObjects: function(e2) {
            var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric$1.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric$1.Point(max(x1, x2), max(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;
            for (var i2 = this._objects.length; i2--; ) {
              currentObject = this._objects[i2];
              if (!currentObject || !currentObject.selectable || !currentObject.visible) {
                continue;
              }
              if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {
                group.push(currentObject);
                if (isClick) {
                  break;
                }
              }
            }
            if (group.length > 1) {
              group = group.filter(function(object) {
                return !object.onSelect({ e: e2 });
              });
            }
            return group;
          },
          /**
           * @private
           */
          _maybeGroupObjects: function(e2) {
            if (this.selection && this._groupSelector) {
              this._groupSelectedObjects(e2);
            }
            this.setCursor(this.defaultCursor);
            this._groupSelector = null;
          }
        }
      );
    })();
    (function() {
      fabric$1.util.object.extend(
        fabric$1.StaticCanvas.prototype,
        /** @lends fabric.StaticCanvas.prototype */
        {
          /**
           * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
           * @param {Object} [options] Options object
           * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
           * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
           * @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent
           * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
           * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
           * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
           * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
           * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0
           * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
           * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
           * @example <caption>Generate jpeg dataURL with lower quality</caption>
           * var dataURL = canvas.toDataURL({
           *   format: 'jpeg',
           *   quality: 0.8
           * });
           * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
           * var dataURL = canvas.toDataURL({
           *   format: 'png',
           *   left: 100,
           *   top: 100,
           *   width: 200,
           *   height: 200
           * });
           * @example <caption>Generate double scaled png dataURL</caption>
           * var dataURL = canvas.toDataURL({
           *   format: 'png',
           *   multiplier: 2
           * });
           */
          toDataURL: function(options) {
            options || (options = {});
            var format = options.format || "png", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);
            return fabric$1.util.toDataURL(canvasEl, format, quality);
          },
          /**
           * Create a new HTMLCanvas element painted with the current canvas content.
           * No need to resize the actual one or repaint it.
           * Will transfer object ownership to a new canvas, paint it, and set everything back.
           * This is an intermediary step used to get to a dataUrl but also it is useful to
           * create quick image copies of a canvas without passing for the dataUrl string
           * @param {Number} [multiplier] a zoom factor.
           * @param {Object} [cropping] Cropping informations
           * @param {Number} [cropping.left] Cropping left offset.
           * @param {Number} [cropping.top] Cropping top offset.
           * @param {Number} [cropping.width] Cropping width.
           * @param {Number} [cropping.height] Cropping height.
           */
          toCanvasElement: function(multiplier, cropping) {
            multiplier = multiplier || 1;
            cropping = cropping || {};
            var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [newZoom, 0, 0, newZoom, translateX, translateY], originalRetina = this.enableRetinaScaling, canvasEl = fabric$1.util.createCanvasElement(), originalContextTop = this.contextTop;
            canvasEl.width = scaledWidth;
            canvasEl.height = scaledHeight;
            this.contextTop = null;
            this.enableRetinaScaling = false;
            this.interactive = false;
            this.viewportTransform = newVp;
            this.width = scaledWidth;
            this.height = scaledHeight;
            this.calcViewportBoundaries();
            this.renderCanvas(canvasEl.getContext("2d"), this._objects);
            this.viewportTransform = vp;
            this.width = originalWidth;
            this.height = originalHeight;
            this.calcViewportBoundaries();
            this.interactive = originalInteractive;
            this.enableRetinaScaling = originalRetina;
            this.contextTop = originalContextTop;
            return canvasEl;
          }
        }
      );
    })();
    fabric$1.util.object.extend(
      fabric$1.StaticCanvas.prototype,
      /** @lends fabric.StaticCanvas.prototype */
      {
        /**
         * Populates canvas with data from the specified JSON.
         * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
         * @param {String|Object} json JSON string or object
         * @param {Function} callback Callback, invoked when json is parsed
         *                            and corresponding objects (e.g: {@link fabric.Image})
         *                            are initialized
         * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
         * @return {fabric.Canvas} instance
         * @chainable
         * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
         * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
         * @example <caption>loadFromJSON</caption>
         * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
         * @example <caption>loadFromJSON with reviver</caption>
         * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
         *   // `o` = json object
         *   // `object` = fabric.Object instance
         *   // ... do some stuff ...
         * });
         */
        loadFromJSON: function(json, callback, reviver) {
          if (!json) {
            return;
          }
          var serialized = typeof json === "string" ? JSON.parse(json) : fabric$1.util.object.clone(json);
          var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;
          this.renderOnAddRemove = false;
          delete serialized.clipPath;
          this._enlivenObjects(serialized.objects, function(enlivenedObjects) {
            _this.clear();
            _this._setBgOverlay(serialized, function() {
              if (clipPath) {
                _this._enlivenObjects([clipPath], function(enlivenedCanvasClip) {
                  _this.clipPath = enlivenedCanvasClip[0];
                  _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
                });
              } else {
                _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
              }
            });
          }, reviver);
          return this;
        },
        /**
         * @private
         * @param {Object} serialized Object with background and overlay information
         * @param {Array} restored canvas objects
         * @param {Function} cached renderOnAddRemove callback
         * @param {Function} callback Invoked after all background and overlay images/patterns loaded
         */
        __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
          var _this = this;
          enlivenedObjects.forEach(function(obj, index2) {
            _this.insertAt(obj, index2);
          });
          this.renderOnAddRemove = renderOnAddRemove;
          delete serialized.objects;
          delete serialized.backgroundImage;
          delete serialized.overlayImage;
          delete serialized.background;
          delete serialized.overlay;
          this._setOptions(serialized);
          this.renderAll();
          callback && callback();
        },
        /**
         * @private
         * @param {Object} serialized Object with background and overlay information
         * @param {Function} callback Invoked after all background and overlay images/patterns loaded
         */
        _setBgOverlay: function(serialized, callback) {
          var loaded = {
            backgroundColor: false,
            overlayColor: false,
            backgroundImage: false,
            overlayImage: false
          };
          if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
            callback && callback();
            return;
          }
          var cbIfLoaded = function() {
            if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
              callback && callback();
            }
          };
          this.__setBgOverlay("backgroundImage", serialized.backgroundImage, loaded, cbIfLoaded);
          this.__setBgOverlay("overlayImage", serialized.overlayImage, loaded, cbIfLoaded);
          this.__setBgOverlay("backgroundColor", serialized.background, loaded, cbIfLoaded);
          this.__setBgOverlay("overlayColor", serialized.overlay, loaded, cbIfLoaded);
        },
        /**
         * @private
         * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
         * @param {(Object|String)} value Value to set
         * @param {Object} loaded Set loaded property to true if property is set
         * @param {Object} callback Callback function to invoke after property is set
         */
        __setBgOverlay: function(property, value, loaded, callback) {
          var _this = this;
          if (!value) {
            loaded[property] = true;
            callback && callback();
            return;
          }
          if (property === "backgroundImage" || property === "overlayImage") {
            fabric$1.util.enlivenObjects([value], function(enlivedObject) {
              _this[property] = enlivedObject[0];
              loaded[property] = true;
              callback && callback();
            });
          } else {
            this["set" + fabric$1.util.string.capitalize(property, true)](value, function() {
              loaded[property] = true;
              callback && callback();
            });
          }
        },
        /**
         * @private
         * @param {Array} objects
         * @param {Function} callback
         * @param {Function} [reviver]
         */
        _enlivenObjects: function(objects, callback, reviver) {
          if (!objects || objects.length === 0) {
            callback && callback([]);
            return;
          }
          fabric$1.util.enlivenObjects(objects, function(enlivenedObjects) {
            callback && callback(enlivenedObjects);
          }, null, reviver);
        },
        /**
         * @private
         * @param {String} format
         * @param {Function} callback
         */
        _toDataURL: function(format, callback) {
          this.clone(function(clone2) {
            callback(clone2.toDataURL(format));
          });
        },
        /**
         * @private
         * @param {String} format
         * @param {Number} multiplier
         * @param {Function} callback
         */
        _toDataURLWithMultiplier: function(format, multiplier, callback) {
          this.clone(function(clone2) {
            callback(clone2.toDataURLWithMultiplier(format, multiplier));
          });
        },
        /**
         * Clones canvas instance
         * @param {Object} [callback] Receives cloned instance as a first argument
         * @param {Array} [properties] Array of properties to include in the cloned canvas and children
         */
        clone: function(callback, properties) {
          var data = JSON.stringify(this.toJSON(properties));
          this.cloneWithoutData(function(clone2) {
            clone2.loadFromJSON(data, function() {
              callback && callback(clone2);
            });
          });
        },
        /**
         * Clones canvas instance without cloning existing data.
         * This essentially copies canvas dimensions, clipping properties, etc.
         * but leaves data empty (so that you can populate it with your own)
         * @param {Object} [callback] Receives cloned instance as a first argument
         */
        cloneWithoutData: function(callback) {
          var el = fabric$1.util.createCanvasElement();
          el.width = this.width;
          el.height = this.height;
          var clone2 = new fabric$1.Canvas(el);
          if (this.backgroundImage) {
            clone2.setBackgroundImage(this.backgroundImage.src, function() {
              clone2.renderAll();
              callback && callback(clone2);
            });
            clone2.backgroundImageOpacity = this.backgroundImageOpacity;
            clone2.backgroundImageStretch = this.backgroundImageStretch;
          } else {
            callback && callback(clone2);
          }
        }
      }
    );
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, toFixed = fabric2.util.toFixed, capitalize2 = fabric2.util.string.capitalize, degreesToRadians = fabric2.util.degreesToRadians, objectCaching = !fabric2.isLikelyNode, ALIASING_LIMIT = 2;
      if (fabric2.Object) {
        return;
      }
      fabric2.Object = fabric2.util.createClass(
        fabric2.CommonMethods,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Type of an object (rect, circle, path, etc.).
           * Note that this property is meant to be read-only and not meant to be modified.
           * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
           * @type String
           * @default
           */
          type: "object",
          /**
           * Horizontal origin of transformation of an object (one of "left", "right", "center")
           * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
           * @type String
           * @default
           */
          originX: "left",
          /**
           * Vertical origin of transformation of an object (one of "top", "bottom", "center")
           * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
           * @type String
           * @default
           */
          originY: "top",
          /**
           * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
           * @type Number
           * @default
           */
          top: 0,
          /**
           * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
           * @type Number
           * @default
           */
          left: 0,
          /**
           * Object width
           * @type Number
           * @default
           */
          width: 0,
          /**
           * Object height
           * @type Number
           * @default
           */
          height: 0,
          /**
           * Object scale factor (horizontal)
           * @type Number
           * @default
           */
          scaleX: 1,
          /**
           * Object scale factor (vertical)
           * @type Number
           * @default
           */
          scaleY: 1,
          /**
           * When true, an object is rendered as flipped horizontally
           * @type Boolean
           * @default
           */
          flipX: false,
          /**
           * When true, an object is rendered as flipped vertically
           * @type Boolean
           * @default
           */
          flipY: false,
          /**
           * Opacity of an object
           * @type Number
           * @default
           */
          opacity: 1,
          /**
           * Angle of rotation of an object (in degrees)
           * @type Number
           * @default
           */
          angle: 0,
          /**
           * Angle of skew on x axes of an object (in degrees)
           * @type Number
           * @default
           */
          skewX: 0,
          /**
           * Angle of skew on y axes of an object (in degrees)
           * @type Number
           * @default
           */
          skewY: 0,
          /**
           * Size of object's controlling corners (in pixels)
           * @type Number
           * @default
           */
          cornerSize: 13,
          /**
           * Size of object's controlling corners when touch interaction is detected
           * @type Number
           * @default
           */
          touchCornerSize: 24,
          /**
           * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
           * @type Boolean
           * @default
           */
          transparentCorners: true,
          /**
           * Default cursor value used when hovering over this object on canvas
           * @type String
           * @default
           */
          hoverCursor: null,
          /**
           * Default cursor value used when moving this object on canvas
           * @type String
           * @default
           */
          moveCursor: null,
          /**
           * Padding between object and its controlling borders (in pixels)
           * @type Number
           * @default
           */
          padding: 0,
          /**
           * Color of controlling borders of an object (when it's active)
           * @type String
           * @default
           */
          borderColor: "rgb(178,204,255)",
          /**
           * Array specifying dash pattern of an object's borders (hasBorder must be true)
           * @since 1.6.2
           * @type Array
           */
          borderDashArray: null,
          /**
           * Color of controlling corners of an object (when it's active)
           * @type String
           * @default
           */
          cornerColor: "rgb(178,204,255)",
          /**
           * Color of controlling corners of an object (when it's active and transparentCorners false)
           * @since 1.6.2
           * @type String
           * @default
           */
          cornerStrokeColor: null,
          /**
           * Specify style of control, 'rect' or 'circle'
           * @since 1.6.2
           * @type String
           */
          cornerStyle: "rect",
          /**
           * Array specifying dash pattern of an object's control (hasBorder must be true)
           * @since 1.6.2
           * @type Array
           */
          cornerDashArray: null,
          /**
           * When true, this object will use center point as the origin of transformation
           * when being scaled via the controls.
           * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
           * @since 1.3.4
           * @type Boolean
           * @default
           */
          centeredScaling: false,
          /**
           * When true, this object will use center point as the origin of transformation
           * when being rotated via the controls.
           * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
           * @since 1.3.4
           * @type Boolean
           * @default
           */
          centeredRotation: true,
          /**
           * Color of object's fill
           * takes css colors https://www.w3.org/TR/css-color-3/
           * @type String
           * @default
           */
          fill: "rgb(0,0,0)",
          /**
           * Fill rule used to fill an object
           * accepted values are nonzero, evenodd
           * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
           * @type String
           * @default
           */
          fillRule: "nonzero",
          /**
           * Composite rule used for canvas globalCompositeOperation
           * @type String
           * @default
           */
          globalCompositeOperation: "source-over",
          /**
           * Background color of an object.
           * takes css colors https://www.w3.org/TR/css-color-3/
           * @type String
           * @default
           */
          backgroundColor: "",
          /**
           * Selection Background color of an object. colored layer behind the object when it is active.
           * does not mix good with globalCompositeOperation methods.
           * @type String
           * @default
           */
          selectionBackgroundColor: "",
          /**
           * When defined, an object is rendered via stroke and this property specifies its color
           * takes css colors https://www.w3.org/TR/css-color-3/
           * @type String
           * @default
           */
          stroke: null,
          /**
           * Width of a stroke used to render this object
           * @type Number
           * @default
           */
          strokeWidth: 1,
          /**
           * Array specifying dash pattern of an object's stroke (stroke must be defined)
           * @type Array
           */
          strokeDashArray: null,
          /**
           * Line offset of an object's stroke
           * @type Number
           * @default
           */
          strokeDashOffset: 0,
          /**
           * Line endings style of an object's stroke (one of "butt", "round", "square")
           * @type String
           * @default
           */
          strokeLineCap: "butt",
          /**
           * Corner style of an object's stroke (one of "bevel", "round", "miter")
           * @type String
           * @default
           */
          strokeLineJoin: "miter",
          /**
           * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
           * @type Number
           * @default
           */
          strokeMiterLimit: 4,
          /**
           * Shadow object representing shadow of this shape
           * @type fabric.Shadow
           * @default
           */
          shadow: null,
          /**
           * Opacity of object's controlling borders when object is active and moving
           * @type Number
           * @default
           */
          borderOpacityWhenMoving: 0.4,
          /**
           * Scale factor of object's controlling borders
           * bigger number will make a thicker border
           * border is 1, so this is basically a border thickness
           * since there is no way to change the border itself.
           * @type Number
           * @default
           */
          borderScaleFactor: 1,
          /**
           * Minimum allowed scale value of an object
           * @type Number
           * @default
           */
          minScaleLimit: 0,
          /**
           * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
           * But events still fire on it.
           * @type Boolean
           * @default
           */
          selectable: true,
          /**
           * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
           * @type Boolean
           * @default
           */
          evented: true,
          /**
           * When set to `false`, an object is not rendered on canvas
           * @type Boolean
           * @default
           */
          visible: true,
          /**
           * When set to `false`, object's controls are not displayed and can not be used to manipulate object
           * @type Boolean
           * @default
           */
          hasControls: true,
          /**
           * When set to `false`, object's controlling borders are not rendered
           * @type Boolean
           * @default
           */
          hasBorders: true,
          /**
           * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
           * @type Boolean
           * @default
           */
          perPixelTargetFind: false,
          /**
           * When `false`, default object's values are not included in its serialization
           * @type Boolean
           * @default
           */
          includeDefaultValues: true,
          /**
           * When `true`, object horizontal movement is locked
           * @type Boolean
           * @default
           */
          lockMovementX: false,
          /**
           * When `true`, object vertical movement is locked
           * @type Boolean
           * @default
           */
          lockMovementY: false,
          /**
           * When `true`, object rotation is locked
           * @type Boolean
           * @default
           */
          lockRotation: false,
          /**
           * When `true`, object horizontal scaling is locked
           * @type Boolean
           * @default
           */
          lockScalingX: false,
          /**
           * When `true`, object vertical scaling is locked
           * @type Boolean
           * @default
           */
          lockScalingY: false,
          /**
           * When `true`, object horizontal skewing is locked
           * @type Boolean
           * @default
           */
          lockSkewingX: false,
          /**
           * When `true`, object vertical skewing is locked
           * @type Boolean
           * @default
           */
          lockSkewingY: false,
          /**
           * When `true`, object cannot be flipped by scaling into negative values
           * @type Boolean
           * @default
           */
          lockScalingFlip: false,
          /**
           * When `true`, object is not exported in OBJECT/JSON
           * @since 1.6.3
           * @type Boolean
           * @default
           */
          excludeFromExport: false,
          /**
           * When `true`, object is cached on an additional canvas.
           * When `false`, object is not cached unless necessary ( clipPath )
           * default to true
           * @since 1.7.0
           * @type Boolean
           * @default true
           */
          objectCaching,
          /**
           * When `true`, object properties are checked for cache invalidation. In some particular
           * situation you may want this to be disabled ( spray brush, very big, groups)
           * or if your application does not allow you to modify properties for groups child you want
           * to disable it for groups.
           * default to false
           * since 1.7.0
           * @type Boolean
           * @default false
           */
          statefullCache: false,
          /**
           * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
           * too much and will be redrawn with correct details at the end of scaling.
           * this setting is performance and application dependant.
           * default to true
           * since 1.7.0
           * @type Boolean
           * @default true
           */
          noScaleCache: true,
          /**
           * When `false`, the stoke width will scale with the object.
           * When `true`, the stroke will always match the exact pixel size entered for stroke width.
           * this Property does not work on Text classes or drawing call that uses strokeText,fillText methods
           * default to false
           * @since 2.6.0
           * @type Boolean
           * @default false
           * @type Boolean
           * @default false
           */
          strokeUniform: false,
          /**
           * When set to `true`, object's cache will be rerendered next render call.
           * since 1.7.0
           * @type Boolean
           * @default true
           */
          dirty: true,
          /**
           * keeps the value of the last hovered corner during mouse move.
           * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
           * It should be private, but there is no harm in using it as
           * a read-only property.
           * @type number|string|any
           * @default 0
           */
          __corner: 0,
          /**
           * Determines if the fill or the stroke is drawn first (one of "fill" or "stroke")
           * @type String
           * @default
           */
          paintFirst: "fill",
          /**
           * When 'down', object is set to active on mousedown/touchstart
           * When 'up', object is set to active on mouseup/touchend
           * Experimental. Let's see if this breaks anything before supporting officially
           * @private
           * since 4.4.0
           * @type String
           * @default 'down'
           */
          activeOn: "down",
          /**
           * List of properties to consider when checking if state
           * of an object is changed (fabric.Object#hasStateChanged)
           * as well as for history (undo/redo) purposes
           * @type Array
           */
          stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),
          /**
           * List of properties to consider when checking if cache needs refresh
           * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
           * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
           * and refreshed at the next render
           * @type Array
           */
          cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),
          /**
           * List of properties to consider for animating colors.
           * @type Array
           */
          colorProperties: "fill stroke backgroundColor".split(" "),
          /**
           * a fabricObject that, without stroke define a clipping area with their shape. filled in black
           * the clipPath object gets used when the object has rendered, and the context is placed in the center
           * of the object cacheCanvas.
           * If you want 0,0 of a clipPath to align with an object center, use clipPath.originX/Y to 'center'
           * @type fabric.Object
           */
          clipPath: void 0,
          /**
           * Meaningful ONLY when the object is used as clipPath.
           * if true, the clipPath will make the object clip to the outside of the clipPath
           * since 2.4.0
           * @type boolean
           * @default false
           */
          inverted: false,
          /**
           * Meaningful ONLY when the object is used as clipPath.
           * if true, the clipPath will have its top and left relative to canvas, and will
           * not be influenced by the object transform. This will make the clipPath relative
           * to the canvas, but clipping just a particular object.
           * WARNING this is beta, this feature may change or be renamed.
           * since 2.4.0
           * @type boolean
           * @default false
           */
          absolutePositioned: false,
          /**
           * Constructor
           * @param {Object} [options] Options object
           */
          initialize: function(options) {
            if (options) {
              this.setOptions(options);
            }
          },
          /**
           * Create a the canvas used to keep the cached copy of the object
           * @private
           */
          _createCacheCanvas: function() {
            this._cacheProperties = {};
            this._cacheCanvas = fabric2.util.createCanvasElement();
            this._cacheContext = this._cacheCanvas.getContext("2d");
            this._updateCacheCanvas();
            this.dirty = true;
          },
          /**
           * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
           * and each side do not cross fabric.cacheSideLimit
           * those numbers are configurable so that you can get as much detail as you want
           * making bargain with performances.
           * @param {Object} dims
           * @param {Object} dims.width width of canvas
           * @param {Object} dims.height height of canvas
           * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
           * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
           * @return {Object}.width width of canvas
           * @return {Object}.height height of canvas
           * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
           * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
           */
          _limitCacheSize: function(dims) {
            var perfLimitSizeTotal = fabric2.perfLimitSizeTotal, width = dims.width, height = dims.height, max = fabric2.maxCacheSideLimit, min = fabric2.minCacheSideLimit;
            if (width <= max && height <= max && width * height <= perfLimitSizeTotal) {
              if (width < min) {
                dims.width = min;
              }
              if (height < min) {
                dims.height = min;
              }
              return dims;
            }
            var ar = width / height, limitedDims = fabric2.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric2.util.capValue, x2 = capValue(min, limitedDims.x, max), y2 = capValue(min, limitedDims.y, max);
            if (width > x2) {
              dims.zoomX /= width / x2;
              dims.width = x2;
              dims.capped = true;
            }
            if (height > y2) {
              dims.zoomY /= height / y2;
              dims.height = y2;
              dims.capped = true;
            }
            return dims;
          },
          /**
           * Return the dimension and the zoom level needed to create a cache canvas
           * big enough to host the object to be cached.
           * @private
           * @return {Object}.x width of object to be cached
           * @return {Object}.y height of object to be cached
           * @return {Object}.width width of canvas
           * @return {Object}.height height of canvas
           * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
           * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
           */
          _getCacheCanvasDimensions: function() {
            var objectScale = this.getTotalObjectScaling(), dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;
            return {
              // for sure this ALIASING_LIMIT is slightly creating problem
              // in situation in which the cache canvas gets an upper limit
              // also objectScale contains already scaleX and scaleY
              width: neededX + ALIASING_LIMIT,
              height: neededY + ALIASING_LIMIT,
              zoomX: objectScale.scaleX,
              zoomY: objectScale.scaleY,
              x: neededX,
              y: neededY
            };
          },
          /**
           * Update width and height of the canvas for cache
           * returns true or false if canvas needed resize.
           * @private
           * @return {Boolean} true if the canvas has been resized
           */
          _updateCacheCanvas: function() {
            var targetCanvas = this.canvas;
            if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
              var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;
              if (this === target && action.slice && action.slice(0, 5) === "scale") {
                return false;
              }
            }
            var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric2.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
            if (dimensionsChanged) {
              var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;
              shouldResizeCanvas = sizeGrowing || sizeShrinking;
              if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
                additionalWidth = width * 0.1;
                additionalHeight = height * 0.1;
              }
            }
            if (this instanceof fabric2.Text && this.path) {
              shouldRedraw = true;
              shouldResizeCanvas = true;
              additionalWidth += this.getHeightOfLine(0) * this.zoomX;
              additionalHeight += this.getHeightOfLine(0) * this.zoomY;
            }
            if (shouldRedraw) {
              if (shouldResizeCanvas) {
                canvas.width = Math.ceil(width + additionalWidth);
                canvas.height = Math.ceil(height + additionalHeight);
              } else {
                this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
                this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
              }
              drawingWidth = dims.x / 2;
              drawingHeight = dims.y / 2;
              this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
              this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
              this.cacheWidth = width;
              this.cacheHeight = height;
              this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
              this._cacheContext.scale(zoomX, zoomY);
              this.zoomX = zoomX;
              this.zoomY = zoomY;
              return true;
            }
            return false;
          },
          /**
           * Sets object's properties from options
           * @param {Object} [options] Options object
           */
          setOptions: function(options) {
            this._setOptions(options);
            this._initGradient(options.fill, "fill");
            this._initGradient(options.stroke, "stroke");
            this._initPattern(options.fill, "fill");
            this._initPattern(options.stroke, "stroke");
          },
          /**
           * Transforms context when rendering an object
           * @param {CanvasRenderingContext2D} ctx Context
           */
          transform: function(ctx) {
            var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;
            var m2 = this.calcTransformMatrix(!needFullTransform);
            ctx.transform(m2[0], m2[1], m2[2], m2[3], m2[4], m2[5]);
          },
          /**
           * Returns an object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            var NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS, object = {
              type: this.type,
              version: fabric2.version,
              originX: this.originX,
              originY: this.originY,
              left: toFixed(this.left, NUM_FRACTION_DIGITS),
              top: toFixed(this.top, NUM_FRACTION_DIGITS),
              width: toFixed(this.width, NUM_FRACTION_DIGITS),
              height: toFixed(this.height, NUM_FRACTION_DIGITS),
              fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,
              stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,
              strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
              strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
              strokeLineCap: this.strokeLineCap,
              strokeDashOffset: this.strokeDashOffset,
              strokeLineJoin: this.strokeLineJoin,
              strokeUniform: this.strokeUniform,
              strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
              scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),
              scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),
              angle: toFixed(this.angle, NUM_FRACTION_DIGITS),
              flipX: this.flipX,
              flipY: this.flipY,
              opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),
              shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,
              visible: this.visible,
              backgroundColor: this.backgroundColor,
              fillRule: this.fillRule,
              paintFirst: this.paintFirst,
              globalCompositeOperation: this.globalCompositeOperation,
              skewX: toFixed(this.skewX, NUM_FRACTION_DIGITS),
              skewY: toFixed(this.skewY, NUM_FRACTION_DIGITS)
            };
            if (this.clipPath && !this.clipPath.excludeFromExport) {
              object.clipPath = this.clipPath.toObject(propertiesToInclude);
              object.clipPath.inverted = this.clipPath.inverted;
              object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
            }
            fabric2.util.populateWithProperties(this, object, propertiesToInclude);
            if (!this.includeDefaultValues) {
              object = this._removeDefaultValues(object);
            }
            return object;
          },
          /**
           * Returns (dataless) object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of an instance
           */
          toDatalessObject: function(propertiesToInclude) {
            return this.toObject(propertiesToInclude);
          },
          /**
           * @private
           * @param {Object} object
           */
          _removeDefaultValues: function(object) {
            var prototype2 = fabric2.util.getKlass(object.type).prototype, stateProperties = prototype2.stateProperties;
            stateProperties.forEach(function(prop) {
              if (prop === "left" || prop === "top") {
                return;
              }
              if (object[prop] === prototype2[prop]) {
                delete object[prop];
              }
              if (Array.isArray(object[prop]) && Array.isArray(prototype2[prop]) && object[prop].length === 0 && prototype2[prop].length === 0) {
                delete object[prop];
              }
            });
            return object;
          },
          /**
           * Returns a string representation of an instance
           * @return {String}
           */
          toString: function() {
            return "#<fabric." + capitalize2(this.type) + ">";
          },
          /**
           * Return the object scale factor counting also the group scaling
           * @return {Object} object with scaleX and scaleY properties
           */
          getObjectScaling: function() {
            if (!this.group) {
              return {
                scaleX: this.scaleX,
                scaleY: this.scaleY
              };
            }
            var options = fabric2.util.qrDecompose(this.calcTransformMatrix());
            return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
          },
          /**
           * Return the object scale factor counting also the group scaling, zoom and retina
           * @return {Object} object with scaleX and scaleY properties
           */
          getTotalObjectScaling: function() {
            var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
            if (this.canvas) {
              var zoom = this.canvas.getZoom();
              var retina = this.canvas.getRetinaScaling();
              scaleX *= zoom * retina;
              scaleY *= zoom * retina;
            }
            return { scaleX, scaleY };
          },
          /**
           * Return the object opacity counting also the group property
           * @return {Number}
           */
          getObjectOpacity: function() {
            var opacity2 = this.opacity;
            if (this.group) {
              opacity2 *= this.group.getObjectOpacity();
            }
            return opacity2;
          },
          /**
           * @private
           * @param {String} key
           * @param {*} value
           * @return {fabric.Object} thisArg
           */
          _set: function(key, value) {
            var shouldConstrainValue = key === "scaleX" || key === "scaleY", isChanged = this[key] !== value, groupNeedsUpdate = false;
            if (shouldConstrainValue) {
              value = this._constrainScale(value);
            }
            if (key === "scaleX" && value < 0) {
              this.flipX = !this.flipX;
              value *= -1;
            } else if (key === "scaleY" && value < 0) {
              this.flipY = !this.flipY;
              value *= -1;
            } else if (key === "shadow" && value && !(value instanceof fabric2.Shadow)) {
              value = new fabric2.Shadow(value);
            } else if (key === "dirty" && this.group) {
              this.group.set("dirty", value);
            }
            this[key] = value;
            if (isChanged) {
              groupNeedsUpdate = this.group && this.group.isOnACache();
              if (this.cacheProperties.indexOf(key) > -1) {
                this.dirty = true;
                groupNeedsUpdate && this.group.set("dirty", true);
              } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
                this.group.set("dirty", true);
              }
            }
            return this;
          },
          /**
           * This callback function is called by the parent group of an object every
           * time a non-delegated property changes on the group. It is passed the key
           * and value as parameters. Not adding in this function's signature to avoid
           * Travis build error about unused variables.
           */
          setOnGroup: function() {
          },
          /**
           * Retrieves viewportTransform from Object's canvas if possible
           * @method getViewportTransform
           * @memberOf fabric.Object.prototype
           * @return {Array}
           */
          getViewportTransform: function() {
            if (this.canvas && this.canvas.viewportTransform) {
              return this.canvas.viewportTransform;
            }
            return fabric2.iMatrix.concat();
          },
          /*
           * @private
           * return if the object would be visible in rendering
           * @memberOf fabric.Object.prototype
           * @return {Boolean}
           */
          isNotVisible: function() {
            return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
          },
          /**
           * Renders an object on a specified context
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          render: function(ctx) {
            if (this.isNotVisible()) {
              return;
            }
            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
              return;
            }
            ctx.save();
            this._setupCompositeOperation(ctx);
            this.drawSelectionBackground(ctx);
            this.transform(ctx);
            this._setOpacity(ctx);
            this._setShadow(ctx, this);
            if (this.shouldCache()) {
              this.renderCache();
              this.drawCacheOnCanvas(ctx);
            } else {
              this._removeCacheCanvas();
              this.dirty = false;
              this.drawObject(ctx);
              if (this.objectCaching && this.statefullCache) {
                this.saveState({ propertySet: "cacheProperties" });
              }
            }
            ctx.restore();
          },
          renderCache: function(options) {
            options = options || {};
            if (!this._cacheCanvas || !this._cacheContext) {
              this._createCacheCanvas();
            }
            if (this.isCacheDirty()) {
              this.statefullCache && this.saveState({ propertySet: "cacheProperties" });
              this.drawObject(this._cacheContext, options.forClipping);
              this.dirty = false;
            }
          },
          /**
           * Remove cacheCanvas and its dimensions from the objects
           */
          _removeCacheCanvas: function() {
            this._cacheCanvas = null;
            this._cacheContext = null;
            this.cacheWidth = 0;
            this.cacheHeight = 0;
          },
          /**
           * return true if the object will draw a stroke
           * Does not consider text styles. This is just a shortcut used at rendering time
           * We want it to be an approximation and be fast.
           * wrote to avoid extra caching, it has to return true when stroke happens,
           * can guess when it will not happen at 100% chance, does not matter if it misses
           * some use case where the stroke is invisible.
           * @since 3.0.0
           * @returns Boolean
           */
          hasStroke: function() {
            return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
          },
          /**
           * return true if the object will draw a fill
           * Does not consider text styles. This is just a shortcut used at rendering time
           * We want it to be an approximation and be fast.
           * wrote to avoid extra caching, it has to return true when fill happens,
           * can guess when it will not happen at 100% chance, does not matter if it misses
           * some use case where the fill is invisible.
           * @since 3.0.0
           * @returns Boolean
           */
          hasFill: function() {
            return this.fill && this.fill !== "transparent";
          },
          /**
           * When set to `true`, force the object to have its own cache, even if it is inside a group
           * it may be needed when your object behave in a particular way on the cache and always needs
           * its own isolated canvas to render correctly.
           * Created to be overridden
           * since 1.7.12
           * @returns Boolean
           */
          needsItsOwnCache: function() {
            if (this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow === "object") {
              return true;
            }
            if (this.clipPath) {
              return true;
            }
            return false;
          },
          /**
           * Decide if the object should cache or not. Create its own cache level
           * objectCaching is a global flag, wins over everything
           * needsItsOwnCache should be used when the object drawing method requires
           * a cache step. None of the fabric classes requires it.
           * Generally you do not cache objects in groups because the group outside is cached.
           * Read as: cache if is needed, or if the feature is enabled but we are not already caching.
           * @return {Boolean}
           */
          shouldCache: function() {
            this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());
            return this.ownCaching;
          },
          /**
           * Check if this object or a child object will cast a shadow
           * used by Group.shouldCache to know if child has a shadow recursively
           * @return {Boolean}
           */
          willDrawShadow: function() {
            return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
          },
          /**
           * Execute the drawing operation for an object clipPath
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {fabric.Object} clipPath
           */
          drawClipPathOnCache: function(ctx, clipPath) {
            ctx.save();
            if (clipPath.inverted) {
              ctx.globalCompositeOperation = "destination-out";
            } else {
              ctx.globalCompositeOperation = "destination-in";
            }
            if (clipPath.absolutePositioned) {
              var m2 = fabric2.util.invertTransform(this.calcTransformMatrix());
              ctx.transform(m2[0], m2[1], m2[2], m2[3], m2[4], m2[5]);
            }
            clipPath.transform(ctx);
            ctx.scale(1 / clipPath.zoomX, 1 / clipPath.zoomY);
            ctx.drawImage(clipPath._cacheCanvas, -clipPath.cacheTranslationX, -clipPath.cacheTranslationY);
            ctx.restore();
          },
          /**
           * Execute the drawing operation for an object on a specified context
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          drawObject: function(ctx, forClipping) {
            var originalFill = this.fill, originalStroke = this.stroke;
            if (forClipping) {
              this.fill = "black";
              this.stroke = "";
              this._setClippingProperties(ctx);
            } else {
              this._renderBackground(ctx);
            }
            this._render(ctx);
            this._drawClipPath(ctx, this.clipPath);
            this.fill = originalFill;
            this.stroke = originalStroke;
          },
          /**
           * Prepare clipPath state and cache and draw it on instance's cache
           * @param {CanvasRenderingContext2D} ctx
           * @param {fabric.Object} clipPath
           */
          _drawClipPath: function(ctx, clipPath) {
            if (!clipPath) {
              return;
            }
            clipPath.canvas = this.canvas;
            clipPath.shouldCache();
            clipPath._transformDone = true;
            clipPath.renderCache({ forClipping: true });
            this.drawClipPathOnCache(ctx, clipPath);
          },
          /**
           * Paint the cached copy of the object on the target context.
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          drawCacheOnCanvas: function(ctx) {
            ctx.scale(1 / this.zoomX, 1 / this.zoomY);
            ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
          },
          /**
           * Check if cache is dirty
           * @param {Boolean} skipCanvas skip canvas checks because this object is painted
           * on parent canvas.
           */
          isCacheDirty: function(skipCanvas) {
            if (this.isNotVisible()) {
              return false;
            }
            if (this._cacheCanvas && this._cacheContext && !skipCanvas && this._updateCacheCanvas()) {
              return true;
            } else {
              if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
                if (this._cacheCanvas && this._cacheContext && !skipCanvas) {
                  var width = this.cacheWidth / this.zoomX;
                  var height = this.cacheHeight / this.zoomY;
                  this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
                }
                return true;
              }
            }
            return false;
          },
          /**
           * Draws a background for the object big as its untransformed dimensions
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderBackground: function(ctx) {
            if (!this.backgroundColor) {
              return;
            }
            var dim = this._getNonTransformedDimensions();
            ctx.fillStyle = this.backgroundColor;
            ctx.fillRect(
              -dim.x / 2,
              -dim.y / 2,
              dim.x,
              dim.y
            );
            this._removeShadow(ctx);
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _setOpacity: function(ctx) {
            if (this.group && !this.group._transformDone) {
              ctx.globalAlpha = this.getObjectOpacity();
            } else {
              ctx.globalAlpha *= this.opacity;
            }
          },
          _setStrokeStyles: function(ctx, decl) {
            var stroke = decl.stroke;
            if (stroke) {
              ctx.lineWidth = decl.strokeWidth;
              ctx.lineCap = decl.strokeLineCap;
              ctx.lineDashOffset = decl.strokeDashOffset;
              ctx.lineJoin = decl.strokeLineJoin;
              ctx.miterLimit = decl.strokeMiterLimit;
              if (stroke.toLive) {
                if (stroke.gradientUnits === "percentage" || stroke.gradientTransform || stroke.patternTransform) {
                  this._applyPatternForTransformedGradient(ctx, stroke);
                } else {
                  ctx.strokeStyle = stroke.toLive(ctx, this);
                  this._applyPatternGradientTransform(ctx, stroke);
                }
              } else {
                ctx.strokeStyle = decl.stroke;
              }
            }
          },
          _setFillStyles: function(ctx, decl) {
            var fill2 = decl.fill;
            if (fill2) {
              if (fill2.toLive) {
                ctx.fillStyle = fill2.toLive(ctx, this);
                this._applyPatternGradientTransform(ctx, decl.fill);
              } else {
                ctx.fillStyle = fill2;
              }
            }
          },
          _setClippingProperties: function(ctx) {
            ctx.globalAlpha = 1;
            ctx.strokeStyle = "transparent";
            ctx.fillStyle = "#000000";
          },
          /**
           * @private
           * Sets line dash
           * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
           * @param {Array} dashArray array representing dashes
           */
          _setLineDash: function(ctx, dashArray) {
            if (!dashArray || dashArray.length === 0) {
              return;
            }
            if (1 & dashArray.length) {
              dashArray.push.apply(dashArray, dashArray);
            }
            ctx.setLineDash(dashArray);
          },
          /**
           * Renders controls and borders for the object
           * the context here is not transformed
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Object} [styleOverride] properties to override the object style
           */
          _renderControls: function(ctx, styleOverride) {
            var vpt = this.getViewportTransform(), matrix2 = this.calcTransformMatrix(), options, drawBorders, drawControls;
            styleOverride = styleOverride || {};
            drawBorders = typeof styleOverride.hasBorders !== "undefined" ? styleOverride.hasBorders : this.hasBorders;
            drawControls = typeof styleOverride.hasControls !== "undefined" ? styleOverride.hasControls : this.hasControls;
            matrix2 = fabric2.util.multiplyTransformMatrices(vpt, matrix2);
            options = fabric2.util.qrDecompose(matrix2);
            ctx.save();
            ctx.translate(options.translateX, options.translateY);
            ctx.lineWidth = 1 * this.borderScaleFactor;
            if (!this.group) {
              ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
            }
            if (this.flipX) {
              options.angle -= 180;
            }
            ctx.rotate(degreesToRadians(this.group ? options.angle : this.angle));
            if (styleOverride.forActiveSelection || this.group) {
              drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
            } else {
              drawBorders && this.drawBorders(ctx, styleOverride);
            }
            drawControls && this.drawControls(ctx, styleOverride);
            ctx.restore();
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _setShadow: function(ctx) {
            if (!this.shadow) {
              return;
            }
            var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;
            if (shadow.nonScaling) {
              scaling = { scaleX: 1, scaleY: 1 };
            } else {
              scaling = this.getObjectScaling();
            }
            if (canvas && canvas._isRetinaScaling()) {
              multX *= fabric2.devicePixelRatio;
              multY *= fabric2.devicePixelRatio;
            }
            ctx.shadowColor = shadow.color;
            ctx.shadowBlur = shadow.blur * fabric2.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
            ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
            ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _removeShadow: function(ctx) {
            if (!this.shadow) {
              return;
            }
            ctx.shadowColor = "";
            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Object} filler fabric.Pattern or fabric.Gradient
           * @return {Object} offset.offsetX offset for text rendering
           * @return {Object} offset.offsetY offset for text rendering
           */
          _applyPatternGradientTransform: function(ctx, filler) {
            if (!filler || !filler.toLive) {
              return { offsetX: 0, offsetY: 0 };
            }
            var t3 = filler.gradientTransform || filler.patternTransform;
            var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;
            if (filler.gradientUnits === "percentage") {
              ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
            } else {
              ctx.transform(1, 0, 0, 1, offsetX, offsetY);
            }
            if (t3) {
              ctx.transform(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]);
            }
            return { offsetX, offsetY };
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderPaintInOrder: function(ctx) {
            if (this.paintFirst === "stroke") {
              this._renderStroke(ctx);
              this._renderFill(ctx);
            } else {
              this._renderFill(ctx);
              this._renderStroke(ctx);
            }
          },
          /**
           * @private
           * function that actually render something on the context.
           * empty here to allow Obects to work on tests to benchmark fabric functionalites
           * not related to rendering
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function() {
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderFill: function(ctx) {
            if (!this.fill) {
              return;
            }
            ctx.save();
            this._setFillStyles(ctx, this);
            if (this.fillRule === "evenodd") {
              ctx.fill("evenodd");
            } else {
              ctx.fill();
            }
            ctx.restore();
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderStroke: function(ctx) {
            if (!this.stroke || this.strokeWidth === 0) {
              return;
            }
            if (this.shadow && !this.shadow.affectStroke) {
              this._removeShadow(ctx);
            }
            ctx.save();
            if (this.strokeUniform && this.group) {
              var scaling = this.getObjectScaling();
              ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
            } else if (this.strokeUniform) {
              ctx.scale(1 / this.scaleX, 1 / this.scaleY);
            }
            this._setLineDash(ctx, this.strokeDashArray);
            this._setStrokeStyles(ctx, this);
            ctx.stroke();
            ctx.restore();
          },
          /**
           * This function try to patch the missing gradientTransform on canvas gradients.
           * transforming a context to transform the gradient, is going to transform the stroke too.
           * we want to transform the gradient but not the stroke operation, so we create
           * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
           * this method has drwabacks: is slow, is in low resolution, needs a patch for when the size
           * is limited.
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {fabric.Gradient} filler a fabric gradient instance
           */
          _applyPatternForTransformedGradient: function(ctx, filler) {
            var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric2.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
            pCanvas.width = width;
            pCanvas.height = height;
            pCtx = pCanvas.getContext("2d");
            pCtx.beginPath();
            pCtx.moveTo(0, 0);
            pCtx.lineTo(width, 0);
            pCtx.lineTo(width, height);
            pCtx.lineTo(0, height);
            pCtx.closePath();
            pCtx.translate(width / 2, height / 2);
            pCtx.scale(
              dims.zoomX / this.scaleX / retinaScaling,
              dims.zoomY / this.scaleY / retinaScaling
            );
            this._applyPatternGradientTransform(pCtx, filler);
            pCtx.fillStyle = filler.toLive(ctx);
            pCtx.fill();
            ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
            ctx.scale(
              retinaScaling * this.scaleX / dims.zoomX,
              retinaScaling * this.scaleY / dims.zoomY
            );
            ctx.strokeStyle = pCtx.createPattern(pCanvas, "no-repeat");
          },
          /**
           * This function is an helper for svg import. it returns the center of the object in the svg
           * untransformed coordinates
           * @private
           * @return {Object} center point from element coordinates
           */
          _findCenterFromElement: function() {
            return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
          },
          /**
           * This function is an helper for svg import. it decompose the transformMatrix
           * and assign properties to object.
           * untransformed coordinates
           * @private
           * @chainable
           */
          _assignTransformMatrixProps: function() {
            if (this.transformMatrix) {
              var options = fabric2.util.qrDecompose(this.transformMatrix);
              this.flipX = false;
              this.flipY = false;
              this.set("scaleX", options.scaleX);
              this.set("scaleY", options.scaleY);
              this.angle = options.angle;
              this.skewX = options.skewX;
              this.skewY = 0;
            }
          },
          /**
           * This function is an helper for svg import. it removes the transform matrix
           * and set to object properties that fabricjs can handle
           * @private
           * @param {Object} preserveAspectRatioOptions
           * @return {thisArg}
           */
          _removeTransformMatrix: function(preserveAspectRatioOptions) {
            var center = this._findCenterFromElement();
            if (this.transformMatrix) {
              this._assignTransformMatrixProps();
              center = fabric2.util.transformPoint(center, this.transformMatrix);
            }
            this.transformMatrix = null;
            if (preserveAspectRatioOptions) {
              this.scaleX *= preserveAspectRatioOptions.scaleX;
              this.scaleY *= preserveAspectRatioOptions.scaleY;
              this.cropX = preserveAspectRatioOptions.cropX;
              this.cropY = preserveAspectRatioOptions.cropY;
              center.x += preserveAspectRatioOptions.offsetLeft;
              center.y += preserveAspectRatioOptions.offsetTop;
              this.width = preserveAspectRatioOptions.width;
              this.height = preserveAspectRatioOptions.height;
            }
            this.setPositionByOrigin(center, "center", "center");
          },
          /**
           * Clones an instance, using a callback method will work for every object.
           * @param {Function} callback Callback is invoked with a clone as a first argument
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           */
          clone: function(callback, propertiesToInclude) {
            var objectForm = this.toObject(propertiesToInclude);
            if (this.constructor.fromObject) {
              this.constructor.fromObject(objectForm, callback);
            } else {
              fabric2.Object._fromObject("Object", objectForm, callback);
            }
          },
          /**
           * Creates an instance of fabric.Image out of an object
           * makes use of toCanvasElement.
           * Once this method was based on toDataUrl and loadImage, so it also had a quality
           * and format option. toCanvasElement is faster and produce no loss of quality.
           * If you need to get a real Jpeg or Png from an object, using toDataURL is the right way to do it.
           * toCanvasElement and then toBlob from the obtained canvas is also a good option.
           * This method is sync now, but still support the callback because we did not want to break.
           * When fabricJS 5.0 will be planned, this will probably be changed to not have a callback.
           * @param {Function} callback callback, invoked with an instance as a first argument
           * @param {Object} [options] for clone as image, passed to toDataURL
           * @param {Number} [options.multiplier=1] Multiplier to scale by
           * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
           * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
           * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
           * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
           * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
           * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
           * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
           * @return {fabric.Object} thisArg
           */
          cloneAsImage: function(callback, options) {
            var canvasEl = this.toCanvasElement(options);
            if (callback) {
              callback(new fabric2.Image(canvasEl));
            }
            return this;
          },
          /**
           * Converts an object into a HTMLCanvas element
           * @param {Object} options Options object
           * @param {Number} [options.multiplier=1] Multiplier to scale by
           * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
           * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
           * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
           * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
           * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
           * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
           * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
           * @return {HTMLCanvasElement} Returns DOM element <canvas> with the fabric.Object
           */
          toCanvasElement: function(options) {
            options || (options = {});
            var utils2 = fabric2.util, origParams = utils2.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric2.devicePixelRatio : 1);
            delete this.group;
            if (options.withoutTransform) {
              utils2.resetObjectTransform(this);
            }
            if (options.withoutShadow) {
              this.shadow = null;
            }
            var el = fabric2.util.createCanvasElement(), boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = { x: 0, y: 0 }, shadowBlur, width, height;
            if (shadow) {
              shadowBlur = shadow.blur;
              if (shadow.nonScaling) {
                scaling = { scaleX: 1, scaleY: 1 };
              } else {
                scaling = this.getObjectScaling();
              }
              shadowOffset.x = 2 * Math.round(abs(shadow.offsetX) + shadowBlur) * abs(scaling.scaleX);
              shadowOffset.y = 2 * Math.round(abs(shadow.offsetY) + shadowBlur) * abs(scaling.scaleY);
            }
            width = boundingRect.width + shadowOffset.x;
            height = boundingRect.height + shadowOffset.y;
            el.width = Math.ceil(width);
            el.height = Math.ceil(height);
            var canvas = new fabric2.StaticCanvas(el, {
              enableRetinaScaling: false,
              renderOnAddRemove: false,
              skipOffscreen: false
            });
            if (options.format === "jpeg") {
              canvas.backgroundColor = "#fff";
            }
            this.setPositionByOrigin(new fabric2.Point(canvas.width / 2, canvas.height / 2), "center", "center");
            var originalCanvas = this.canvas;
            canvas.add(this);
            var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
            this.shadow = originalShadow;
            this.set("canvas", originalCanvas);
            if (originalGroup) {
              this.group = originalGroup;
            }
            this.set(origParams).setCoords();
            canvas._objects = [];
            canvas.dispose();
            canvas = null;
            return canvasEl;
          },
          /**
           * Converts an object into a data-url-like string
           * @param {Object} options Options object
           * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
           * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
           * @param {Number} [options.multiplier=1] Multiplier to scale by
           * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
           * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
           * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
           * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
           * @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 1.6.4
           * @param {Boolean} [options.withoutTransform] Remove current object transform ( no scale , no angle, no flip, no skew ). Introduced in 2.3.4
           * @param {Boolean} [options.withoutShadow] Remove current object shadow. Introduced in 2.4.2
           * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
           */
          toDataURL: function(options) {
            options || (options = {});
            return fabric2.util.toDataURL(this.toCanvasElement(options), options.format || "png", options.quality || 1);
          },
          /**
           * Returns true if specified type is identical to the type of an instance
           * @param {String} type Type to check against
           * @return {Boolean}
           */
          isType: function(type) {
            return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === type;
          },
          /**
           * Returns complexity of an instance
           * @return {Number} complexity of this instance (is 1 unless subclassed)
           */
          complexity: function() {
            return 1;
          },
          /**
           * Returns a JSON representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} JSON
           */
          toJSON: function(propertiesToInclude) {
            return this.toObject(propertiesToInclude);
          },
          /**
           * Sets "angle" of an instance with centered rotation
           * @param {Number} angle Angle value (in degrees)
           * @return {fabric.Object} thisArg
           * @chainable
           */
          rotate: function(angle2) {
            var shouldCenterOrigin = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation;
            if (shouldCenterOrigin) {
              this._setOriginToCenter();
            }
            this.set("angle", angle2);
            if (shouldCenterOrigin) {
              this._resetOrigin();
            }
            return this;
          },
          /**
           * Centers object horizontally on canvas to which it was added last.
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          centerH: function() {
            this.canvas && this.canvas.centerObjectH(this);
            return this;
          },
          /**
           * Centers object horizontally on current viewport of canvas to which it was added last.
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          viewportCenterH: function() {
            this.canvas && this.canvas.viewportCenterObjectH(this);
            return this;
          },
          /**
           * Centers object vertically on canvas to which it was added last.
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          centerV: function() {
            this.canvas && this.canvas.centerObjectV(this);
            return this;
          },
          /**
           * Centers object vertically on current viewport of canvas to which it was added last.
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          viewportCenterV: function() {
            this.canvas && this.canvas.viewportCenterObjectV(this);
            return this;
          },
          /**
           * Centers object vertically and horizontally on canvas to which is was added last
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          center: function() {
            this.canvas && this.canvas.centerObject(this);
            return this;
          },
          /**
           * Centers object on current viewport of canvas to which it was added last.
           * You might need to call `setCoords` on an object after centering, to update controls area.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          viewportCenter: function() {
            this.canvas && this.canvas.viewportCenterObject(this);
            return this;
          },
          /**
           * Returns coordinates of a pointer relative to an object
           * @param {Event} e Event to operate upon
           * @param {Object} [pointer] Pointer to operate upon (instead of event)
           * @return {Object} Coordinates of a pointer (x, y)
           */
          getLocalPointer: function(e2, pointer) {
            pointer = pointer || this.canvas.getPointer(e2);
            var pClicked = new fabric2.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();
            if (this.angle) {
              pClicked = fabric2.util.rotatePoint(
                pClicked,
                objectLeftTop,
                degreesToRadians(-this.angle)
              );
            }
            return {
              x: pClicked.x - objectLeftTop.x,
              y: pClicked.y - objectLeftTop.y
            };
          },
          /**
           * Sets canvas globalCompositeOperation for specific object
           * custom composition operation for the particular object can be specified using globalCompositeOperation property
           * @param {CanvasRenderingContext2D} ctx Rendering canvas context
           */
          _setupCompositeOperation: function(ctx) {
            if (this.globalCompositeOperation) {
              ctx.globalCompositeOperation = this.globalCompositeOperation;
            }
          },
          /**
           * cancel instance's running animations
           * override if necessary to dispose artifacts such as `clipPath`
           */
          dispose: function() {
            if (fabric2.runningAnimations) {
              fabric2.runningAnimations.cancelByTarget(this);
            }
          }
        }
      );
      fabric2.util.createAccessors && fabric2.util.createAccessors(fabric2.Object);
      extend2(fabric2.Object.prototype, fabric2.Observable);
      fabric2.Object.NUM_FRACTION_DIGITS = 2;
      fabric2.Object.ENLIVEN_PROPS = ["clipPath"];
      fabric2.Object._fromObject = function(className, object, callback, extraParam) {
        var klass = fabric2[className];
        object = clone2(object, true);
        fabric2.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
          if (typeof patterns[0] !== "undefined") {
            object.fill = patterns[0];
          }
          if (typeof patterns[1] !== "undefined") {
            object.stroke = patterns[1];
          }
          fabric2.util.enlivenObjectEnlivables(object, object, function() {
            var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
            callback && callback(instance);
          });
        });
      };
      fabric2.Object.__uid = 0;
    })(exports);
    (function() {
      var degreesToRadians = fabric$1.util.degreesToRadians, originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      }, originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };
      fabric$1.util.object.extend(
        fabric$1.Object.prototype,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Translates the coordinates from a set of origin to another (based on the object's dimensions)
           * @param {fabric.Point} point The point which corresponds to the originX and originY params
           * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
           * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
           * @return {fabric.Point}
           */
          translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
            var x2 = point.x, y2 = point.y, offsetX, offsetY, dim;
            if (typeof fromOriginX === "string") {
              fromOriginX = originXOffset[fromOriginX];
            } else {
              fromOriginX -= 0.5;
            }
            if (typeof toOriginX === "string") {
              toOriginX = originXOffset[toOriginX];
            } else {
              toOriginX -= 0.5;
            }
            offsetX = toOriginX - fromOriginX;
            if (typeof fromOriginY === "string") {
              fromOriginY = originYOffset[fromOriginY];
            } else {
              fromOriginY -= 0.5;
            }
            if (typeof toOriginY === "string") {
              toOriginY = originYOffset[toOriginY];
            } else {
              toOriginY -= 0.5;
            }
            offsetY = toOriginY - fromOriginY;
            if (offsetX || offsetY) {
              dim = this._getTransformedDimensions();
              x2 = point.x + offsetX * dim.x;
              y2 = point.y + offsetY * dim.y;
            }
            return new fabric$1.Point(x2, y2);
          },
          /**
           * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
           * @param {fabric.Point} point The point which corresponds to the originX and originY params
           * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
           * @return {fabric.Point}
           */
          translateToCenterPoint: function(point, originX, originY) {
            var p2 = this.translateToGivenOrigin(point, originX, originY, "center", "center");
            if (this.angle) {
              return fabric$1.util.rotatePoint(p2, point, degreesToRadians(this.angle));
            }
            return p2;
          },
          /**
           * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
           * @param {fabric.Point} center The point which corresponds to center of the object
           * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
           * @return {fabric.Point}
           */
          translateToOriginPoint: function(center, originX, originY) {
            var p2 = this.translateToGivenOrigin(center, "center", "center", originX, originY);
            if (this.angle) {
              return fabric$1.util.rotatePoint(p2, center, degreesToRadians(this.angle));
            }
            return p2;
          },
          /**
           * Returns the real center coordinates of the object
           * @return {fabric.Point}
           */
          getCenterPoint: function() {
            var leftTop = new fabric$1.Point(this.left, this.top);
            return this.translateToCenterPoint(leftTop, this.originX, this.originY);
          },
          /**
           * Returns the coordinates of the object based on center coordinates
           * @param {fabric.Point} point The point which corresponds to the originX and originY params
           * @return {fabric.Point}
           */
          // getOriginPoint: function(center) {
          //   return this.translateToOriginPoint(center, this.originX, this.originY);
          // },
          /**
           * Returns the coordinates of the object as if it has a different origin
           * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
           * @return {fabric.Point}
           */
          getPointByOrigin: function(originX, originY) {
            var center = this.getCenterPoint();
            return this.translateToOriginPoint(center, originX, originY);
          },
          /**
           * Returns the point in local coordinates
           * @param {fabric.Point} point The point relative to the global coordinate system
           * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
           * @return {fabric.Point}
           */
          toLocalPoint: function(point, originX, originY) {
            var center = this.getCenterPoint(), p2, p22;
            if (typeof originX !== "undefined" && typeof originY !== "undefined") {
              p2 = this.translateToGivenOrigin(center, "center", "center", originX, originY);
            } else {
              p2 = new fabric$1.Point(this.left, this.top);
            }
            p22 = new fabric$1.Point(point.x, point.y);
            if (this.angle) {
              p22 = fabric$1.util.rotatePoint(p22, center, -degreesToRadians(this.angle));
            }
            return p22.subtractEquals(p2);
          },
          /**
           * Returns the point in global coordinates
           * @param {fabric.Point} The point relative to the local coordinate system
           * @return {fabric.Point}
           */
          // toGlobalPoint: function(point) {
          //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
          // },
          /**
           * Sets the position of the object taking into consideration the object's origin
           * @param {fabric.Point} pos The new position of the object
           * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
           * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
           * @return {void}
           */
          setPositionByOrigin: function(pos, originX, originY) {
            var center = this.translateToCenterPoint(pos, originX, originY), position2 = this.translateToOriginPoint(center, this.originX, this.originY);
            this.set("left", position2.x);
            this.set("top", position2.y);
          },
          /**
           * @param {String} to One of 'left', 'center', 'right'
           */
          adjustPosition: function(to) {
            var angle2 = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric$1.util.cos(angle2) * hypotFull, yFull = fabric$1.util.sin(angle2) * hypotFull, offsetFrom, offsetTo;
            if (typeof this.originX === "string") {
              offsetFrom = originXOffset[this.originX];
            } else {
              offsetFrom = this.originX - 0.5;
            }
            if (typeof to === "string") {
              offsetTo = originXOffset[to];
            } else {
              offsetTo = to - 0.5;
            }
            this.left += xFull * (offsetTo - offsetFrom);
            this.top += yFull * (offsetTo - offsetFrom);
            this.setCoords();
            this.originX = to;
          },
          /**
           * Sets the origin/position of the object to it's center point
           * @private
           * @return {void}
           */
          _setOriginToCenter: function() {
            this._originalOriginX = this.originX;
            this._originalOriginY = this.originY;
            var center = this.getCenterPoint();
            this.originX = "center";
            this.originY = "center";
            this.left = center.x;
            this.top = center.y;
          },
          /**
           * Resets the origin/position of the object to it's original origin
           * @private
           * @return {void}
           */
          _resetOrigin: function() {
            var originPoint = this.translateToOriginPoint(
              this.getCenterPoint(),
              this._originalOriginX,
              this._originalOriginY
            );
            this.originX = this._originalOriginX;
            this.originY = this._originalOriginY;
            this.left = originPoint.x;
            this.top = originPoint.y;
            this._originalOriginX = null;
            this._originalOriginY = null;
          },
          /**
           * @private
           */
          _getLeftTopCoords: function() {
            return this.translateToOriginPoint(this.getCenterPoint(), "left", "top");
          }
        }
      );
    })();
    (function() {
      function arrayFromCoords(coords) {
        return [
          new fabric$1.Point(coords.tl.x, coords.tl.y),
          new fabric$1.Point(coords.tr.x, coords.tr.y),
          new fabric$1.Point(coords.br.x, coords.br.y),
          new fabric$1.Point(coords.bl.x, coords.bl.y)
        ];
      }
      var util = fabric$1.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;
      util.object.extend(
        fabric$1.Object.prototype,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Describe object's corner position in canvas element coordinates.
           * properties are depending on control keys and padding the main controls.
           * each property is an object with x, y and corner.
           * The `corner` property contains in a similar manner the 4 points of the
           * interactive area of the corner.
           * The coordinates depends from the controls positionHandler and are used
           * to draw and locate controls
           * @memberOf fabric.Object.prototype
           */
          oCoords: null,
          /**
           * Describe object's corner position in canvas object absolute coordinates
           * properties are tl,tr,bl,br and describe the four main corner.
           * each property is an object with x, y, instance of Fabric.Point.
           * The coordinates depends from this properties: width, height, scaleX, scaleY
           * skewX, skewY, angle, strokeWidth, top, left.
           * Those coordinates are useful to understand where an object is. They get updated
           * with oCoords but they do not need to be updated when zoom or panning change.
           * The coordinates get updated with @method setCoords.
           * You can calculate them without updating with @method calcACoords();
           * @memberOf fabric.Object.prototype
           */
          aCoords: null,
          /**
           * Describe object's corner position in canvas element coordinates.
           * includes padding. Used of object detection.
           * set and refreshed with setCoords.
           * @memberOf fabric.Object.prototype
           */
          lineCoords: null,
          /**
           * storage for object transform matrix
           */
          ownMatrixCache: null,
          /**
           * storage for object full transform matrix
           */
          matrixCache: null,
          /**
           * custom controls interface
           * controls are added by default_controls.js
           */
          controls: {},
          /**
           * return correct set of coordinates for intersection
           * this will return either aCoords or lineCoords.
           * @param {Boolean} absolute will return aCoords if true or lineCoords
           * @return {Object} {tl, tr, br, bl} points
           */
          _getCoords: function(absolute, calculate) {
            if (calculate) {
              return absolute ? this.calcACoords() : this.calcLineCoords();
            }
            if (!this.aCoords || !this.lineCoords) {
              this.setCoords(true);
            }
            return absolute ? this.aCoords : this.lineCoords;
          },
          /**
           * return correct set of coordinates for intersection
           * this will return either aCoords or lineCoords.
           * The coords are returned in an array.
           * @return {Array} [tl, tr, br, bl] of points
           */
          getCoords: function(absolute, calculate) {
            return arrayFromCoords(this._getCoords(absolute, calculate));
          },
          /**
           * Checks if object intersects with an area formed by 2 points
           * @param {Object} pointTL top-left point of area
           * @param {Object} pointBR bottom-right point of area
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if object intersects with an area formed by 2 points
           */
          intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
            var coords = this.getCoords(absolute, calculate), intersection = fabric$1.Intersection.intersectPolygonRectangle(
              coords,
              pointTL,
              pointBR
            );
            return intersection.status === "Intersection";
          },
          /**
           * Checks if object intersects with another object
           * @param {Object} other Object to test
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if object intersects with another object
           */
          intersectsWithObject: function(other, absolute, calculate) {
            var intersection = fabric$1.Intersection.intersectPolygonPolygon(
              this.getCoords(absolute, calculate),
              other.getCoords(absolute, calculate)
            );
            return intersection.status === "Intersection" || other.isContainedWithinObject(this, absolute, calculate) || this.isContainedWithinObject(other, absolute, calculate);
          },
          /**
           * Checks if object is fully contained within area of another object
           * @param {Object} other Object to test
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if object is fully contained within area of another object
           */
          isContainedWithinObject: function(other, absolute, calculate) {
            var points = this.getCoords(absolute, calculate), otherCoords = absolute ? other.aCoords : other.lineCoords, i2 = 0, lines = other._getImageLines(otherCoords);
            for (; i2 < 4; i2++) {
              if (!other.containsPoint(points[i2], lines)) {
                return false;
              }
            }
            return true;
          },
          /**
           * Checks if object is fully contained within area formed by 2 points
           * @param {Object} pointTL top-left point of area
           * @param {Object} pointBR bottom-right point of area
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if object is fully contained within area formed by 2 points
           */
          isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
            var boundingRect = this.getBoundingRect(absolute, calculate);
            return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;
          },
          /**
           * Checks if point is inside the object
           * @param {fabric.Point} point Point to check against
           * @param {Object} [lines] object returned from @method _getImageLines
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if point is inside the object
           */
          containsPoint: function(point, lines, absolute, calculate) {
            var coords = this._getCoords(absolute, calculate), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);
            return xPoints !== 0 && xPoints % 2 === 1;
          },
          /**
           * Checks if object is contained within the canvas with current viewportTransform
           * the check is done stopping at first point that appears on screen
           * @param {Boolean} [calculate] use coordinates of current position instead of .aCoords
           * @return {Boolean} true if object is fully or partially contained within canvas
           */
          isOnScreen: function(calculate) {
            if (!this.canvas) {
              return false;
            }
            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
            var points = this.getCoords(true, calculate);
            if (points.some(function(point) {
              return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;
            })) {
              return true;
            }
            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
              return true;
            }
            return this._containsCenterOfCanvas(pointTL, pointBR, calculate);
          },
          /**
           * Checks if the object contains the midpoint between canvas extremities
           * Does not make sense outside the context of isOnScreen and isPartiallyOnScreen
           * @private
           * @param {Fabric.Point} pointTL Top Left point
           * @param {Fabric.Point} pointBR Top Right point
           * @param {Boolean} calculate use coordinates of current position instead of .oCoords
           * @return {Boolean} true if the object contains the point
           */
          _containsCenterOfCanvas: function(pointTL, pointBR, calculate) {
            var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
            if (this.containsPoint(centerPoint, null, true, calculate)) {
              return true;
            }
            return false;
          },
          /**
           * Checks if object is partially contained within the canvas with current viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
           * @return {Boolean} true if object is partially contained within canvas
           */
          isPartiallyOnScreen: function(calculate) {
            if (!this.canvas) {
              return false;
            }
            var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
            if (this.intersectsWithRect(pointTL, pointBR, true, calculate)) {
              return true;
            }
            var allPointsAreOutside = this.getCoords(true, calculate).every(function(point) {
              return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);
            });
            return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate);
          },
          /**
           * Method that returns an object with the object edges in it, given the coordinates of the corners
           * @private
           * @param {Object} oCoords Coordinates of the object corners
           */
          _getImageLines: function(oCoords) {
            var lines = {
              topline: {
                o: oCoords.tl,
                d: oCoords.tr
              },
              rightline: {
                o: oCoords.tr,
                d: oCoords.br
              },
              bottomline: {
                o: oCoords.br,
                d: oCoords.bl
              },
              leftline: {
                o: oCoords.bl,
                d: oCoords.tl
              }
            };
            return lines;
          },
          /**
           * Helper method to determine how many cross points are between the 4 object edges
           * and the horizontal line determined by a point on canvas
           * @private
           * @param {fabric.Point} point Point to check
           * @param {Object} lines Coordinates of the object being evaluated
           */
          // remove yi, not used but left code here just in case.
          _findCrossPoints: function(point, lines) {
            var b1, b2, a1, a2, xi, xcount = 0, iLine;
            for (var lineKey in lines) {
              iLine = lines[lineKey];
              if (iLine.o.y < point.y && iLine.d.y < point.y) {
                continue;
              }
              if (iLine.o.y >= point.y && iLine.d.y >= point.y) {
                continue;
              }
              if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {
                xi = iLine.o.x;
              } else {
                b1 = 0;
                b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
                a1 = point.y - b1 * point.x;
                a2 = iLine.o.y - b2 * iLine.o.x;
                xi = -(a1 - a2) / (b1 - b2);
              }
              if (xi >= point.x) {
                xcount += 1;
              }
              if (xcount === 2) {
                break;
              }
            }
            return xcount;
          },
          /**
           * Returns coordinates of object's bounding rectangle (left, top, width, height)
           * the box is intended as aligned to axis of canvas.
           * @param {Boolean} [absolute] use coordinates without viewportTransform
           * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords / .aCoords
           * @return {Object} Object with left, top, width, height properties
           */
          getBoundingRect: function(absolute, calculate) {
            var coords = this.getCoords(absolute, calculate);
            return util.makeBoundingBoxFromPoints(coords);
          },
          /**
           * Returns width of an object's bounding box counting transformations
           * before 2.0 it was named getWidth();
           * @return {Number} width value
           */
          getScaledWidth: function() {
            return this._getTransformedDimensions().x;
          },
          /**
           * Returns height of an object bounding box counting transformations
           * before 2.0 it was named getHeight();
           * @return {Number} height value
           */
          getScaledHeight: function() {
            return this._getTransformedDimensions().y;
          },
          /**
           * Makes sure the scale is valid and modifies it if necessary
           * @private
           * @param {Number} value
           * @return {Number}
           */
          _constrainScale: function(value) {
            if (Math.abs(value) < this.minScaleLimit) {
              if (value < 0) {
                return -this.minScaleLimit;
              } else {
                return this.minScaleLimit;
              }
            } else if (value === 0) {
              return 1e-4;
            }
            return value;
          },
          /**
           * Scales an object (equally by x and y)
           * @param {Number} value Scale factor
           * @return {fabric.Object} thisArg
           * @chainable
           */
          scale: function(value) {
            this._set("scaleX", value);
            this._set("scaleY", value);
            return this.setCoords();
          },
          /**
           * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
           * @param {Number} value New width value
           * @param {Boolean} absolute ignore viewport
           * @return {fabric.Object} thisArg
           * @chainable
           */
          scaleToWidth: function(value, absolute) {
            var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
            return this.scale(value / this.width / boundingRectFactor);
          },
          /**
           * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
           * @param {Number} value New height value
           * @param {Boolean} absolute ignore viewport
           * @return {fabric.Object} thisArg
           * @chainable
           */
          scaleToHeight: function(value, absolute) {
            var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
            return this.scale(value / this.height / boundingRectFactor);
          },
          calcLineCoords: function() {
            var vpt = this.getViewportTransform(), padding = this.padding, angle2 = degreesToRadians(this.angle), cos = util.cos(angle2), sin = util.sin(angle2), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();
            var lineCoords = {
              tl: transformPoint(aCoords.tl, vpt),
              tr: transformPoint(aCoords.tr, vpt),
              bl: transformPoint(aCoords.bl, vpt),
              br: transformPoint(aCoords.br, vpt)
            };
            if (padding) {
              lineCoords.tl.x -= cosPMinusSinP;
              lineCoords.tl.y -= cosPSinP;
              lineCoords.tr.x += cosPSinP;
              lineCoords.tr.y -= cosPMinusSinP;
              lineCoords.bl.x -= cosPSinP;
              lineCoords.bl.y += cosPMinusSinP;
              lineCoords.br.x += cosPMinusSinP;
              lineCoords.br.y += cosPSinP;
            }
            return lineCoords;
          },
          calcOCoords: function() {
            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]), dim = this._calculateCurrentDimensions(), coords = {};
            this.forEachControl(function(control, key, fabricObject) {
              coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
            });
            return coords;
          },
          calcACoords: function() {
            var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w2 = dim.x / 2, h2 = dim.y / 2;
            return {
              // corners
              tl: transformPoint({ x: -w2, y: -h2 }, finalMatrix),
              tr: transformPoint({ x: w2, y: -h2 }, finalMatrix),
              bl: transformPoint({ x: -w2, y: h2 }, finalMatrix),
              br: transformPoint({ x: w2, y: h2 }, finalMatrix)
            };
          },
          /**
           * Sets corner and controls position coordinates based on current angle, width and height, left and top.
           * oCoords are used to find the corners
           * aCoords are used to quickly find an object on the canvas
           * lineCoords are used to quickly find object during pointer events.
           * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}
           *
           * @param {Boolean} [skipCorners] skip calculation of oCoords.
           * @return {fabric.Object} thisArg
           * @chainable
           */
          setCoords: function(skipCorners) {
            this.aCoords = this.calcACoords();
            this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
            if (skipCorners) {
              return this;
            }
            this.oCoords = this.calcOCoords();
            this._setCornerCoords && this._setCornerCoords();
            return this;
          },
          /**
           * calculate rotation matrix of an object
           * @return {Array} rotation matrix for the object
           */
          _calcRotateMatrix: function() {
            return util.calcRotateMatrix(this);
          },
          /**
           * calculate the translation matrix for an object transform
           * @return {Array} rotation matrix for the object
           */
          _calcTranslateMatrix: function() {
            var center = this.getCenterPoint();
            return [1, 0, 0, 1, center.x, center.y];
          },
          transformMatrixKey: function(skipGroup) {
            var sep = "_", prefix = "";
            if (!skipGroup && this.group) {
              prefix = this.group.transformMatrixKey(skipGroup) + sep;
            }
            return prefix + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
          },
          /**
           * calculate transform matrix that represents the current transformations from the
           * object's properties.
           * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations
           * There are some situation in which this is useful to avoid the fake rotation.
           * @return {Array} transform matrix for the object
           */
          calcTransformMatrix: function(skipGroup) {
            var matrix2 = this.calcOwnMatrix();
            if (skipGroup || !this.group) {
              return matrix2;
            }
            var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
            if (cache.key === key) {
              return cache.value;
            }
            if (this.group) {
              matrix2 = multiplyMatrices(this.group.calcTransformMatrix(false), matrix2);
            }
            cache.key = key;
            cache.value = matrix2;
            return matrix2;
          },
          /**
           * calculate transform matrix that represents the current transformations from the
           * object's properties, this matrix does not include the group transformation
           * @return {Array} transform matrix for the object
           */
          calcOwnMatrix: function() {
            var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
            if (cache.key === key) {
              return cache.value;
            }
            var tMatrix = this._calcTranslateMatrix(), options = {
              angle: this.angle,
              translateX: tMatrix[4],
              translateY: tMatrix[5],
              scaleX: this.scaleX,
              scaleY: this.scaleY,
              skewX: this.skewX,
              skewY: this.skewY,
              flipX: this.flipX,
              flipY: this.flipY
            };
            cache.key = key;
            cache.value = util.composeMatrix(options);
            return cache.value;
          },
          /*
           * Calculate object dimensions from its properties
           * @private
           * @return {Object} .x width dimension
           * @return {Object} .y height dimension
           */
          _getNonTransformedDimensions: function() {
            var strokeWidth = this.strokeWidth, w2 = this.width + strokeWidth, h2 = this.height + strokeWidth;
            return { x: w2, y: h2 };
          },
          /*
           * Calculate object bounding box dimensions from its properties scale, skew.
           * @param {Number} skewX, a value to override current skewX
           * @param {Number} skewY, a value to override current skewY
           * @private
           * @return {Object} .x width dimension
           * @return {Object} .y height dimension
           */
          _getTransformedDimensions: function(skewX, skewY) {
            if (typeof skewX === "undefined") {
              skewX = this.skewX;
            }
            if (typeof skewY === "undefined") {
              skewY = this.skewY;
            }
            var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;
            if (this.strokeUniform) {
              dimX = this.width;
              dimY = this.height;
            } else {
              dimensions = this._getNonTransformedDimensions();
              dimX = dimensions.x;
              dimY = dimensions.y;
            }
            if (noSkew) {
              return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
            }
            var bbox = util.sizeAfterTransform(dimX, dimY, {
              scaleX: this.scaleX,
              scaleY: this.scaleY,
              skewX,
              skewY
            });
            return this._finalizeDimensions(bbox.x, bbox.y);
          },
          /*
           * Calculate object bounding box dimensions from its properties scale, skew.
           * @param Number width width of the bbox
           * @param Number height height of the bbox
           * @private
           * @return {Object} .x finalized width dimension
           * @return {Object} .y finalized height dimension
           */
          _finalizeDimensions: function(width, height) {
            return this.strokeUniform ? { x: width + this.strokeWidth, y: height + this.strokeWidth } : { x: width, y: height };
          },
          /*
           * Calculate object dimensions for controls box, including padding and canvas zoom.
           * and active selection
           * private
           */
          _calculateCurrentDimensions: function() {
            var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p2 = transformPoint(dim, vpt, true);
            return p2.scalarAdd(2 * this.padding);
          }
        }
      );
    })();
    fabric$1.util.object.extend(
      fabric$1.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Moves an object to the bottom of the stack of drawn objects
         * @return {fabric.Object} thisArg
         * @chainable
         */
        sendToBack: function() {
          if (this.group) {
            fabric$1.StaticCanvas.prototype.sendToBack.call(this.group, this);
          } else if (this.canvas) {
            this.canvas.sendToBack(this);
          }
          return this;
        },
        /**
         * Moves an object to the top of the stack of drawn objects
         * @return {fabric.Object} thisArg
         * @chainable
         */
        bringToFront: function() {
          if (this.group) {
            fabric$1.StaticCanvas.prototype.bringToFront.call(this.group, this);
          } else if (this.canvas) {
            this.canvas.bringToFront(this);
          }
          return this;
        },
        /**
         * Moves an object down in stack of drawn objects
         * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
         * @return {fabric.Object} thisArg
         * @chainable
         */
        sendBackwards: function(intersecting) {
          if (this.group) {
            fabric$1.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
          } else if (this.canvas) {
            this.canvas.sendBackwards(this, intersecting);
          }
          return this;
        },
        /**
         * Moves an object up in stack of drawn objects
         * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
         * @return {fabric.Object} thisArg
         * @chainable
         */
        bringForward: function(intersecting) {
          if (this.group) {
            fabric$1.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
          } else if (this.canvas) {
            this.canvas.bringForward(this, intersecting);
          }
          return this;
        },
        /**
         * Moves an object to specified level in stack of drawn objects
         * @param {Number} index New position of object
         * @return {fabric.Object} thisArg
         * @chainable
         */
        moveTo: function(index2) {
          if (this.group && this.group.type !== "activeSelection") {
            fabric$1.StaticCanvas.prototype.moveTo.call(this.group, this, index2);
          } else if (this.canvas) {
            this.canvas.moveTo(this, index2);
          }
          return this;
        }
      }
    );
    (function() {
      function getSvgColorString(prop, value) {
        if (!value) {
          return prop + ": none; ";
        } else if (value.toLive) {
          return prop + ": url(#SVGID_" + value.id + "); ";
        } else {
          var color2 = new fabric$1.Color(value), str = prop + ": " + color2.toRgb() + "; ", opacity2 = color2.getAlpha();
          if (opacity2 !== 1) {
            str += prop + "-opacity: " + opacity2.toString() + "; ";
          }
          return str;
        }
      }
      var toFixed = fabric$1.util.toFixed;
      fabric$1.util.object.extend(
        fabric$1.Object.prototype,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Returns styles-string for svg-export
           * @param {Boolean} skipShadow a boolean to skip shadow filter output
           * @return {String}
           */
          getSvgStyles: function(skipShadow) {
            var fillRule = this.fillRule ? this.fillRule : "nonzero", strokeWidth = this.strokeWidth ? this.strokeWidth : "0", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : "0", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : "butt", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : "miter", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : "4", opacity2 = typeof this.opacity !== "undefined" ? this.opacity : "1", visibility2 = this.visible ? "" : " visibility: hidden;", filter2 = skipShadow ? "" : this.getSvgFilter(), fill2 = getSvgColorString("fill", this.fill), stroke = getSvgColorString("stroke", this.stroke);
            return [
              stroke,
              "stroke-width: ",
              strokeWidth,
              "; ",
              "stroke-dasharray: ",
              strokeDashArray,
              "; ",
              "stroke-linecap: ",
              strokeLineCap,
              "; ",
              "stroke-dashoffset: ",
              strokeDashOffset,
              "; ",
              "stroke-linejoin: ",
              strokeLineJoin,
              "; ",
              "stroke-miterlimit: ",
              strokeMiterLimit,
              "; ",
              fill2,
              "fill-rule: ",
              fillRule,
              "; ",
              "opacity: ",
              opacity2,
              ";",
              filter2,
              visibility2
            ].join("");
          },
          /**
           * Returns styles-string for svg-export
           * @param {Object} style the object from which to retrieve style properties
           * @param {Boolean} useWhiteSpace a boolean to include an additional attribute in the style.
           * @return {String}
           */
          getSvgSpanStyles: function(style, useWhiteSpace) {
            var term = "; ";
            var fontFamily2 = style.fontFamily ? "font-family: " + (style.fontFamily.indexOf("'") === -1 && style.fontFamily.indexOf('"') === -1 ? "'" + style.fontFamily + "'" : style.fontFamily) + term : "";
            var strokeWidth = style.strokeWidth ? "stroke-width: " + style.strokeWidth + term : "", fontFamily2 = fontFamily2, fontSize2 = style.fontSize ? "font-size: " + style.fontSize + "px" + term : "", fontStyle2 = style.fontStyle ? "font-style: " + style.fontStyle + term : "", fontWeight2 = style.fontWeight ? "font-weight: " + style.fontWeight + term : "", fill2 = style.fill ? getSvgColorString("fill", style.fill) : "", stroke = style.stroke ? getSvgColorString("stroke", style.stroke) : "", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? "baseline-shift: " + -style.deltaY + "; " : "";
            if (textDecoration) {
              textDecoration = "text-decoration: " + textDecoration + term;
            }
            return [
              stroke,
              strokeWidth,
              fontFamily2,
              fontSize2,
              fontStyle2,
              fontWeight2,
              textDecoration,
              fill2,
              deltaY,
              useWhiteSpace ? "white-space: pre; " : ""
            ].join("");
          },
          /**
           * Returns text-decoration property for svg-export
           * @param {Object} style the object from which to retrieve style properties
           * @return {String}
           */
          getSvgTextDecoration: function(style) {
            return ["overline", "underline", "line-through"].filter(function(decoration) {
              return style[decoration.replace("-", "")];
            }).join(" ");
          },
          /**
           * Returns filter for svg shadow
           * @return {String}
           */
          getSvgFilter: function() {
            return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "";
          },
          /**
           * Returns id attribute for svg output
           * @return {String}
           */
          getSvgCommons: function() {
            return [
              this.id ? 'id="' + this.id + '" ' : "",
              this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""
            ].join("");
          },
          /**
           * Returns transform-string for svg-export
           * @param {Boolean} use the full transform or the single object one.
           * @return {String}
           */
          getSvgTransform: function(full, additionalTransform) {
            var transform2 = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform="' + fabric$1.util.matrixToSVG(transform2);
            return svgTransform + (additionalTransform || "") + '" ';
          },
          _setSVGBg: function(textBgRects) {
            if (this.backgroundColor) {
              var NUM_FRACTION_DIGITS = fabric$1.Object.NUM_FRACTION_DIGITS;
              textBgRects.push(
                "		<rect ",
                this._getFillAttributes(this.backgroundColor),
                ' x="',
                toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
                '" y="',
                toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
                '" width="',
                toFixed(this.width, NUM_FRACTION_DIGITS),
                '" height="',
                toFixed(this.height, NUM_FRACTION_DIGITS),
                '"></rect>\n'
              );
            }
          },
          /**
           * Returns svg representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toSVG: function(reviver) {
            return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver });
          },
          /**
           * Returns svg clipPath representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toClipPathSVG: function(reviver) {
            return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver });
          },
          /**
           * @private
           */
          _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
            options = options || {};
            var reviver = options.reviver, additionalTransform = options.additionalTransform || "", commonPieces = [
              this.getSvgTransform(true, additionalTransform),
              this.getSvgCommons()
            ].join(""), index2 = objectMarkup.indexOf("COMMON_PARTS");
            objectMarkup[index2] = commonPieces;
            return reviver ? reviver(objectMarkup.join("")) : objectMarkup.join("");
          },
          /**
           * @private
           */
          _createBaseSVGMarkup: function(objectMarkup, options) {
            options = options || {};
            var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? "" : 'style="' + this.getSvgStyles() + '" ', shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill2 = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, index2 = objectMarkup.indexOf("COMMON_PARTS"), additionalTransform = options.additionalTransform;
            if (clipPath) {
              clipPath.clipPathId = "CLIPPATH_" + fabric$1.Object.__uid++;
              clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' + clipPath.toClipPathSVG(reviver) + "</clipPath>\n";
            }
            if (absoluteClipPath) {
              markup.push(
                "<g ",
                shadowInfo,
                this.getSvgCommons(),
                " >\n"
              );
            }
            markup.push(
              "<g ",
              this.getSvgTransform(false),
              !absoluteClipPath ? shadowInfo + this.getSvgCommons() : "",
              " >\n"
            );
            commonPieces = [
              styleInfo,
              vectorEffect,
              noStyle ? "" : this.addPaintOrder(),
              " ",
              additionalTransform ? 'transform="' + additionalTransform + '" ' : ""
            ].join("");
            objectMarkup[index2] = commonPieces;
            if (fill2 && fill2.toLive) {
              markup.push(fill2.toSVG(this));
            }
            if (stroke && stroke.toLive) {
              markup.push(stroke.toSVG(this));
            }
            if (shadow) {
              markup.push(shadow.toSVG(this));
            }
            if (clipPath) {
              markup.push(clipPathMarkup);
            }
            markup.push(objectMarkup.join(""));
            markup.push("</g>\n");
            absoluteClipPath && markup.push("</g>\n");
            return reviver ? reviver(markup.join("")) : markup.join("");
          },
          addPaintOrder: function() {
            return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "";
          }
        }
      );
    })();
    (function() {
      var extend2 = fabric$1.util.object.extend, originalSet = "stateProperties";
      function saveProps(origin2, destination, props) {
        var tmpObj = {}, deep = true;
        props.forEach(function(prop) {
          tmpObj[prop] = origin2[prop];
        });
        extend2(origin2[destination], tmpObj, deep);
      }
      function _isEqual(origValue, currentValue, firstPass) {
        if (origValue === currentValue) {
          return true;
        } else if (Array.isArray(origValue)) {
          if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
            return false;
          }
          for (var i2 = 0, len = origValue.length; i2 < len; i2++) {
            if (!_isEqual(origValue[i2], currentValue[i2])) {
              return false;
            }
          }
          return true;
        } else if (origValue && typeof origValue === "object") {
          var keys2 = Object.keys(origValue), key;
          if (!currentValue || typeof currentValue !== "object" || !firstPass && keys2.length !== Object.keys(currentValue).length) {
            return false;
          }
          for (var i2 = 0, len = keys2.length; i2 < len; i2++) {
            key = keys2[i2];
            if (key === "canvas" || key === "group") {
              continue;
            }
            if (!_isEqual(origValue[key], currentValue[key])) {
              return false;
            }
          }
          return true;
        }
      }
      fabric$1.util.object.extend(
        fabric$1.Object.prototype,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Returns true if object state (one of its state properties) was changed
           * @param {String} [propertySet] optional name for the set of property we want to save
           * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
           */
          hasStateChanged: function(propertySet) {
            propertySet = propertySet || originalSet;
            var dashedPropertySet = "_" + propertySet;
            if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
              return true;
            }
            return !_isEqual(this[dashedPropertySet], this, true);
          },
          /**
           * Saves state of an object
           * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
           * @return {fabric.Object} thisArg
           */
          saveState: function(options) {
            var propertySet = options && options.propertySet || originalSet, destination = "_" + propertySet;
            if (!this[destination]) {
              return this.setupState(options);
            }
            saveProps(this, destination, this[propertySet]);
            if (options && options.stateProperties) {
              saveProps(this, destination, options.stateProperties);
            }
            return this;
          },
          /**
           * Setups state of an object
           * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
           * @return {fabric.Object} thisArg
           */
          setupState: function(options) {
            options = options || {};
            var propertySet = options.propertySet || originalSet;
            options.propertySet = propertySet;
            this["_" + propertySet] = {};
            this.saveState(options);
            return this;
          }
        }
      );
    })();
    (function() {
      var degreesToRadians = fabric$1.util.degreesToRadians;
      fabric$1.util.object.extend(
        fabric$1.Object.prototype,
        /** @lends fabric.Object.prototype */
        {
          /**
           * Determines which corner has been clicked
           * @private
           * @param {Object} pointer The pointer indicating the mouse position
           * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
           */
          _findTargetCorner: function(pointer, forTouch) {
            if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
              return false;
            }
            var ex = pointer.x, ey = pointer.y, xPoints, lines, keys2 = Object.keys(this.oCoords), j2 = keys2.length - 1, i2;
            this.__corner = 0;
            for (; j2 >= 0; j2--) {
              i2 = keys2[j2];
              if (!this.isControlVisible(i2)) {
                continue;
              }
              lines = this._getImageLines(forTouch ? this.oCoords[i2].touchCorner : this.oCoords[i2].corner);
              xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
              if (xPoints !== 0 && xPoints % 2 === 1) {
                this.__corner = i2;
                return i2;
              }
            }
            return false;
          },
          /**
           * Calls a function for each control. The function gets called,
           * with the control, the object that is calling the iterator and the control's key
           * @param {Function} fn function to iterate over the controls over
           */
          forEachControl: function(fn) {
            for (var i2 in this.controls) {
              fn(this.controls[i2], i2, this);
            }
          },
          /**
           * Sets the coordinates of the draggable boxes in the corners of
           * the image used to scale/rotate it.
           * note: if we would switch to ROUND corner area, all of this would disappear.
           * everything would resolve to a single point and a pythagorean theorem for the distance
           * @private
           */
          _setCornerCoords: function() {
            var coords = this.oCoords;
            for (var control in coords) {
              var controlObject = this.controls[control];
              coords[control].corner = controlObject.calcCornerCoords(
                this.angle,
                this.cornerSize,
                coords[control].x,
                coords[control].y,
                false
              );
              coords[control].touchCorner = controlObject.calcCornerCoords(
                this.angle,
                this.touchCornerSize,
                coords[control].x,
                coords[control].y,
                true
              );
            }
          },
          /**
           * Draws a colored layer behind the object, inside its selection borders.
           * Requires public options: padding, selectionBackgroundColor
           * this function is called when the context is transformed
           * has checks to be skipped when the object is on a staticCanvas
           * @param {CanvasRenderingContext2D} ctx Context to draw on
           * @return {fabric.Object} thisArg
           * @chainable
           */
          drawSelectionBackground: function(ctx) {
            if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {
              return this;
            }
            ctx.save();
            var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;
            ctx.translate(center.x, center.y);
            ctx.scale(1 / vpt[0], 1 / vpt[3]);
            ctx.rotate(degreesToRadians(this.angle));
            ctx.fillStyle = this.selectionBackgroundColor;
            ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
            ctx.restore();
            return this;
          },
          /**
           * Draws borders of an object's bounding box.
           * Requires public properties: width, height
           * Requires public options: padding, borderColor
           * @param {CanvasRenderingContext2D} ctx Context to draw on
           * @param {Object} styleOverride object to override the object style
           * @return {fabric.Object} thisArg
           * @chainable
           */
          drawBorders: function(ctx, styleOverride) {
            styleOverride = styleOverride || {};
            var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== "undefined" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;
            ctx.save();
            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
            ctx.strokeRect(
              -width / 2,
              -height / 2,
              width,
              height
            );
            if (hasControls) {
              ctx.beginPath();
              this.forEachControl(function(control, key, fabricObject) {
                if (control.withConnection && control.getVisibility(fabricObject, key)) {
                  shouldStroke = true;
                  ctx.moveTo(control.x * width, control.y * height);
                  ctx.lineTo(
                    control.x * width + control.offsetX,
                    control.y * height + control.offsetY
                  );
                }
              });
              if (shouldStroke) {
                ctx.stroke();
              }
            }
            ctx.restore();
            return this;
          },
          /**
           * Draws borders of an object's bounding box when it is inside a group.
           * Requires public properties: width, height
           * Requires public options: padding, borderColor
           * @param {CanvasRenderingContext2D} ctx Context to draw on
           * @param {object} options object representing current object parameters
           * @param {Object} styleOverride object to override the object style
           * @return {fabric.Object} thisArg
           * @chainable
           */
          drawBordersInGroup: function(ctx, options, styleOverride) {
            styleOverride = styleOverride || {};
            var bbox = fabric$1.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
            ctx.save();
            this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
            ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
            ctx.strokeRect(
              -width / 2,
              -height / 2,
              width,
              height
            );
            ctx.restore();
            return this;
          },
          /**
           * Draws corners of an object's bounding box.
           * Requires public properties: width, height
           * Requires public options: cornerSize, padding
           * @param {CanvasRenderingContext2D} ctx Context to draw on
           * @param {Object} styleOverride object to override the object style
           * @return {fabric.Object} thisArg
           * @chainable
           */
          drawControls: function(ctx, styleOverride) {
            styleOverride = styleOverride || {};
            ctx.save();
            var retinaScaling = this.canvas.getRetinaScaling(), matrix2, p2;
            ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);
            ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
            if (!this.transparentCorners) {
              ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
            }
            this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);
            this.setCoords();
            if (this.group) {
              matrix2 = this.group.calcTransformMatrix();
            }
            this.forEachControl(function(control, key, fabricObject) {
              p2 = fabricObject.oCoords[key];
              if (control.getVisibility(fabricObject, key)) {
                if (matrix2) {
                  p2 = fabric$1.util.transformPoint(p2, matrix2);
                }
                control.render(ctx, p2.x, p2.y, styleOverride, fabricObject);
              }
            });
            ctx.restore();
            return this;
          },
          /**
           * Returns true if the specified control is visible, false otherwise.
           * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
           * @returns {Boolean} true if the specified control is visible, false otherwise
           */
          isControlVisible: function(controlKey) {
            return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
          },
          /**
           * Sets the visibility of the specified control.
           * @param {String} controlKey The key of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
           * @param {Boolean} visible true to set the specified control visible, false otherwise
           * @return {fabric.Object} thisArg
           * @chainable
           */
          setControlVisible: function(controlKey, visible) {
            if (!this._controlsVisibility) {
              this._controlsVisibility = {};
            }
            this._controlsVisibility[controlKey] = visible;
            return this;
          },
          /**
           * Sets the visibility state of object controls.
           * @param {Object} [options] Options object
           * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
           * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
           * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
           * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
           * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
           * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
           * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
           * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
           * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
           * @return {fabric.Object} thisArg
           * @chainable
           */
          setControlsVisibility: function(options) {
            options || (options = {});
            for (var p2 in options) {
              this.setControlVisible(p2, options[p2]);
            }
            return this;
          },
          /**
           * This callback function is called every time _discardActiveObject or _setActiveObject
           * try to to deselect this object. If the function returns true, the process is cancelled
           * @param {Object} [options] options sent from the upper functions
           * @param {Event} [options.e] event if the process is generated by an event
           */
          onDeselect: function() {
          },
          /**
           * This callback function is called every time _discardActiveObject or _setActiveObject
           * try to to select this object. If the function returns true, the process is cancelled
           * @param {Object} [options] options sent from the upper functions
           * @param {Event} [options.e] event if the process is generated by an event
           */
          onSelect: function() {
          }
        }
      );
    })();
    fabric$1.util.object.extend(
      fabric$1.StaticCanvas.prototype,
      /** @lends fabric.StaticCanvas.prototype */
      {
        /**
         * Animation duration (in ms) for fx* methods
         * @type Number
         * @default
         */
        FX_DURATION: 500,
        /**
         * Centers object horizontally with animation.
         * @param {fabric.Object} object Object to center
         * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
         * @param {Function} [callbacks.onComplete] Invoked on completion
         * @param {Function} [callbacks.onChange] Invoked on every step of animation
         * @return {fabric.AnimationContext} context
         */
        fxCenterObjectH: function(object, callbacks) {
          callbacks = callbacks || {};
          var empty2 = function() {
          }, onComplete = callbacks.onComplete || empty2, onChange = callbacks.onChange || empty2, _this = this;
          return fabric$1.util.animate({
            target: this,
            startValue: object.left,
            endValue: this.getCenterPoint().x,
            duration: this.FX_DURATION,
            onChange: function(value) {
              object.set("left", value);
              _this.requestRenderAll();
              onChange();
            },
            onComplete: function() {
              object.setCoords();
              onComplete();
            }
          });
        },
        /**
         * Centers object vertically with animation.
         * @param {fabric.Object} object Object to center
         * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
         * @param {Function} [callbacks.onComplete] Invoked on completion
         * @param {Function} [callbacks.onChange] Invoked on every step of animation
         * @return {fabric.AnimationContext} context
         */
        fxCenterObjectV: function(object, callbacks) {
          callbacks = callbacks || {};
          var empty2 = function() {
          }, onComplete = callbacks.onComplete || empty2, onChange = callbacks.onChange || empty2, _this = this;
          return fabric$1.util.animate({
            target: this,
            startValue: object.top,
            endValue: this.getCenterPoint().y,
            duration: this.FX_DURATION,
            onChange: function(value) {
              object.set("top", value);
              _this.requestRenderAll();
              onChange();
            },
            onComplete: function() {
              object.setCoords();
              onComplete();
            }
          });
        },
        /**
         * Same as `fabric.Canvas#remove` but animated
         * @param {fabric.Object} object Object to remove
         * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
         * @param {Function} [callbacks.onComplete] Invoked on completion
         * @param {Function} [callbacks.onChange] Invoked on every step of animation
         * @return {fabric.AnimationContext} context
         */
        fxRemove: function(object, callbacks) {
          callbacks = callbacks || {};
          var empty2 = function() {
          }, onComplete = callbacks.onComplete || empty2, onChange = callbacks.onChange || empty2, _this = this;
          return fabric$1.util.animate({
            target: this,
            startValue: object.opacity,
            endValue: 0,
            duration: this.FX_DURATION,
            onChange: function(value) {
              object.set("opacity", value);
              _this.requestRenderAll();
              onChange();
            },
            onComplete: function() {
              _this.remove(object);
              onComplete();
            }
          });
        }
      }
    );
    fabric$1.util.object.extend(
      fabric$1.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * Animates object's properties
         * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
         * @param {Number|Object} value Value to animate property to (if string was given first) or options object
         * @return {fabric.Object} thisArg
         * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
         * @return {fabric.AnimationContext | fabric.AnimationContext[]} animation context (or an array if passed multiple properties)
         *
         * As object â multiple properties
         *
         * object.animate({ left: ..., top: ... });
         * object.animate({ left: ..., top: ... }, { duration: ... });
         *
         * As string â one property
         *
         * object.animate('left', ...);
         * object.animate('left', { duration: ... });
         *
         */
        animate: function() {
          if (arguments[0] && typeof arguments[0] === "object") {
            var propsToAnimate = [], prop, skipCallbacks, out = [];
            for (prop in arguments[0]) {
              propsToAnimate.push(prop);
            }
            for (var i2 = 0, len = propsToAnimate.length; i2 < len; i2++) {
              prop = propsToAnimate[i2];
              skipCallbacks = i2 !== len - 1;
              out.push(this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks));
            }
            return out;
          } else {
            return this._animate.apply(this, arguments);
          }
        },
        /**
         * @private
         * @param {String} property Property to animate
         * @param {String} to Value to animate to
         * @param {Object} [options] Options object
         * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
         */
        _animate: function(property, to, options, skipCallbacks) {
          var _this = this, propPair;
          to = to.toString();
          if (!options) {
            options = {};
          } else {
            options = fabric$1.util.object.clone(options);
          }
          if (~property.indexOf(".")) {
            propPair = property.split(".");
          }
          var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;
          var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);
          if (!("from" in options)) {
            options.from = currentValue;
          }
          if (!propIsColor) {
            if (~to.indexOf("=")) {
              to = currentValue + parseFloat(to.replace("=", ""));
            } else {
              to = parseFloat(to);
            }
          }
          var _options = {
            target: this,
            startValue: options.from,
            endValue: to,
            byValue: options.by,
            easing: options.easing,
            duration: options.duration,
            abort: options.abort && function(value, valueProgress, timeProgress) {
              return options.abort.call(_this, value, valueProgress, timeProgress);
            },
            onChange: function(value, valueProgress, timeProgress) {
              if (propPair) {
                _this[propPair[0]][propPair[1]] = value;
              } else {
                _this.set(property, value);
              }
              if (skipCallbacks) {
                return;
              }
              options.onChange && options.onChange(value, valueProgress, timeProgress);
            },
            onComplete: function(value, valueProgress, timeProgress) {
              if (skipCallbacks) {
                return;
              }
              _this.setCoords();
              options.onComplete && options.onComplete(value, valueProgress, timeProgress);
            }
          };
          if (propIsColor) {
            return fabric$1.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
          } else {
            return fabric$1.util.animate(_options);
          }
        }
      }
    );
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 };
      if (fabric2.Line) {
        fabric2.warn("fabric.Line is already defined");
        return;
      }
      fabric2.Line = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Line.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "line",
          /**
           * x value or first line edge
           * @type Number
           * @default
           */
          x1: 0,
          /**
           * y value or first line edge
           * @type Number
           * @default
           */
          y1: 0,
          /**
           * x value or second line edge
           * @type Number
           * @default
           */
          x2: 0,
          /**
           * y value or second line edge
           * @type Number
           * @default
           */
          y2: 0,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"),
          /**
           * Constructor
           * @param {Array} [points] Array of points
           * @param {Object} [options] Options object
           * @return {fabric.Line} thisArg
           */
          initialize: function(points, options) {
            if (!points) {
              points = [0, 0, 0, 0];
            }
            this.callSuper("initialize", options);
            this.set("x1", points[0]);
            this.set("y1", points[1]);
            this.set("x2", points[2]);
            this.set("y2", points[3]);
            this._setWidthHeight(options);
          },
          /**
           * @private
           * @param {Object} [options] Options
           */
          _setWidthHeight: function(options) {
            options || (options = {});
            this.width = Math.abs(this.x2 - this.x1);
            this.height = Math.abs(this.y2 - this.y1);
            this.left = "left" in options ? options.left : this._getLeftToOriginX();
            this.top = "top" in options ? options.top : this._getTopToOriginY();
          },
          /**
           * @private
           * @param {String} key
           * @param {*} value
           */
          _set: function(key, value) {
            this.callSuper("_set", key, value);
            if (typeof coordProps[key] !== "undefined") {
              this._setWidthHeight();
            }
            return this;
          },
          /**
           * @private
           * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
           */
          _getLeftToOriginX: makeEdgeToOriginGetter(
            {
              // property names
              origin: "originX",
              axis1: "x1",
              axis2: "x2",
              dimension: "width"
            },
            {
              // possible values of origin
              nearest: "left",
              center: "center",
              farthest: "right"
            }
          ),
          /**
           * @private
           * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
           */
          _getTopToOriginY: makeEdgeToOriginGetter(
            {
              // property names
              origin: "originY",
              axis1: "y1",
              axis2: "y2",
              dimension: "height"
            },
            {
              // possible values of origin
              nearest: "top",
              center: "center",
              farthest: "bottom"
            }
          ),
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            ctx.beginPath();
            var p2 = this.calcLinePoints();
            ctx.moveTo(p2.x1, p2.y1);
            ctx.lineTo(p2.x2, p2.y2);
            ctx.lineWidth = this.strokeWidth;
            var origStrokeStyle = ctx.strokeStyle;
            ctx.strokeStyle = this.stroke || ctx.fillStyle;
            this.stroke && this._renderStroke(ctx);
            ctx.strokeStyle = origStrokeStyle;
          },
          /**
           * This function is an helper for svg import. it returns the center of the object in the svg
           * untransformed coordinates
           * @private
           * @return {Object} center point from element coordinates
           */
          _findCenterFromElement: function() {
            return {
              x: (this.x1 + this.x2) / 2,
              y: (this.y1 + this.y2) / 2
            };
          },
          /**
           * Returns object representation of an instance
           * @method toObject
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return extend2(this.callSuper("toObject", propertiesToInclude), this.calcLinePoints());
          },
          /*
           * Calculate object dimensions from its properties
           * @private
           */
          _getNonTransformedDimensions: function() {
            var dim = this.callSuper("_getNonTransformedDimensions");
            if (this.strokeLineCap === "butt") {
              if (this.width === 0) {
                dim.y -= this.strokeWidth;
              }
              if (this.height === 0) {
                dim.x -= this.strokeWidth;
              }
            }
            return dim;
          },
          /**
           * Recalculates line points given width and height
           * @private
           */
          calcLinePoints: function() {
            var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;
            return {
              x1,
              x2,
              y1,
              y2
            };
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var p2 = this.calcLinePoints();
            return [
              "<line ",
              "COMMON_PARTS",
              'x1="',
              p2.x1,
              '" y1="',
              p2.y1,
              '" x2="',
              p2.x2,
              '" y2="',
              p2.y2,
              '" />\n'
            ];
          }
          /* _TO_SVG_END_ */
        }
      );
      fabric2.Line.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" "));
      fabric2.Line.fromElement = function(element, callback, options) {
        options = options || {};
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Line.ATTRIBUTE_NAMES), points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
        callback(new fabric2.Line(points, extend2(parsedAttributes, options)));
      };
      fabric2.Line.fromObject = function(object, callback) {
        function _callback(instance) {
          delete instance.points;
          callback && callback(instance);
        }
        var options = clone2(object, true);
        options.points = [object.x1, object.y1, object.x2, object.y2];
        fabric2.Object._fromObject("Line", options, _callback, "points");
      };
      function makeEdgeToOriginGetter(propertyNames, originValues) {
        var origin2 = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;
        return function() {
          switch (this.get(origin2)) {
            case nearest:
              return Math.min(this.get(axis1), this.get(axis2));
            case center:
              return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);
            case farthest:
              return Math.max(this.get(axis1), this.get(axis2));
          }
        };
      }
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), degreesToRadians = fabric2.util.degreesToRadians;
      if (fabric2.Circle) {
        fabric2.warn("fabric.Circle is already defined.");
        return;
      }
      fabric2.Circle = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Circle.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "circle",
          /**
           * Radius of this circle
           * @type Number
           * @default
           */
          radius: 0,
          /**
           * degrees of start of the circle.
           * probably will change to degrees in next major version
           * @type Number 0 - 359
           * @default 0
           */
          startAngle: 0,
          /**
           * End angle of the circle
           * probably will change to degrees in next major version
           * @type Number 1 - 360
           * @default 360
           */
          endAngle: 360,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"),
          /**
           * @private
           * @param {String} key
           * @param {*} value
           * @return {fabric.Circle} thisArg
           */
          _set: function(key, value) {
            this.callSuper("_set", key, value);
            if (key === "radius") {
              this.setRadius(value);
            }
            return this;
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(propertiesToInclude));
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var svgString, x2 = 0, y2 = 0, angle2 = (this.endAngle - this.startAngle) % 360;
            if (angle2 === 0) {
              svgString = [
                "<circle ",
                "COMMON_PARTS",
                'cx="' + x2 + '" cy="' + y2 + '" ',
                'r="',
                this.radius,
                '" />\n'
              ];
            } else {
              var start = degreesToRadians(this.startAngle), end = degreesToRadians(this.endAngle), radius = this.radius, startX = fabric2.util.cos(start) * radius, startY = fabric2.util.sin(start) * radius, endX = fabric2.util.cos(end) * radius, endY = fabric2.util.sin(end) * radius, largeFlag = angle2 > 180 ? "1" : "0";
              svgString = [
                '<path d="M ' + startX + " " + startY,
                " A " + radius + " " + radius,
                " 0 ",
                +largeFlag + " 1",
                " " + endX + " " + endY,
                '" ',
                "COMMON_PARTS",
                " />\n"
              ];
            }
            return svgString;
          },
          /* _TO_SVG_END_ */
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx context to render on
           */
          _render: function(ctx) {
            ctx.beginPath();
            ctx.arc(
              0,
              0,
              this.radius,
              degreesToRadians(this.startAngle),
              degreesToRadians(this.endAngle),
              false
            );
            this._renderPaintInOrder(ctx);
          },
          /**
           * Returns horizontal radius of an object (according to how an object is scaled)
           * @return {Number}
           */
          getRadiusX: function() {
            return this.get("radius") * this.get("scaleX");
          },
          /**
           * Returns vertical radius of an object (according to how an object is scaled)
           * @return {Number}
           */
          getRadiusY: function() {
            return this.get("radius") * this.get("scaleY");
          },
          /**
           * Sets radius of an object (and updates width accordingly)
           * @return {fabric.Circle} thisArg
           */
          setRadius: function(value) {
            this.radius = value;
            return this.set("width", value * 2).set("height", value * 2);
          }
        }
      );
      fabric2.Circle.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("cx cy r".split(" "));
      fabric2.Circle.fromElement = function(element, callback) {
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Circle.ATTRIBUTE_NAMES);
        if (!isValidRadius(parsedAttributes)) {
          throw new Error("value of `r` attribute is required and can not be negative");
        }
        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
        callback(new fabric2.Circle(parsedAttributes));
      };
      function isValidRadius(attributes) {
        return "radius" in attributes && attributes.radius >= 0;
      }
      fabric2.Circle.fromObject = function(object, callback) {
        fabric2.Object._fromObject("Circle", object, callback);
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      if (fabric2.Triangle) {
        fabric2.warn("fabric.Triangle is already defined");
        return;
      }
      fabric2.Triangle = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Triangle.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "triangle",
          /**
           * Width is set to 100 to compensate the old initialize code that was setting it to 100
           * @type Number
           * @default
           */
          width: 100,
          /**
           * Height is set to 100 to compensate the old initialize code that was setting it to 100
           * @type Number
           * @default
           */
          height: 100,
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            var widthBy2 = this.width / 2, heightBy2 = this.height / 2;
            ctx.beginPath();
            ctx.moveTo(-widthBy2, heightBy2);
            ctx.lineTo(0, -heightBy2);
            ctx.lineTo(widthBy2, heightBy2);
            ctx.closePath();
            this._renderPaintInOrder(ctx);
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [
              -widthBy2 + " " + heightBy2,
              "0 " + -heightBy2,
              widthBy2 + " " + heightBy2
            ].join(",");
            return [
              "<polygon ",
              "COMMON_PARTS",
              'points="',
              points,
              '" />'
            ];
          }
          /* _TO_SVG_END_ */
        }
      );
      fabric2.Triangle.fromObject = function(object, callback) {
        return fabric2.Object._fromObject("Triangle", object, callback);
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), piBy2 = Math.PI * 2;
      if (fabric2.Ellipse) {
        fabric2.warn("fabric.Ellipse is already defined.");
        return;
      }
      fabric2.Ellipse = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Ellipse.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "ellipse",
          /**
           * Horizontal radius
           * @type Number
           * @default
           */
          rx: 0,
          /**
           * Vertical radius
           * @type Number
           * @default
           */
          ry: 0,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("rx", "ry"),
          /**
           * Constructor
           * @param {Object} [options] Options object
           * @return {fabric.Ellipse} thisArg
           */
          initialize: function(options) {
            this.callSuper("initialize", options);
            this.set("rx", options && options.rx || 0);
            this.set("ry", options && options.ry || 0);
          },
          /**
           * @private
           * @param {String} key
           * @param {*} value
           * @return {fabric.Ellipse} thisArg
           */
          _set: function(key, value) {
            this.callSuper("_set", key, value);
            switch (key) {
              case "rx":
                this.rx = value;
                this.set("width", value * 2);
                break;
              case "ry":
                this.ry = value;
                this.set("height", value * 2);
                break;
            }
            return this;
          },
          /**
           * Returns horizontal radius of an object (according to how an object is scaled)
           * @return {Number}
           */
          getRx: function() {
            return this.get("rx") * this.get("scaleX");
          },
          /**
           * Returns Vertical radius of an object (according to how an object is scaled)
           * @return {Number}
           */
          getRy: function() {
            return this.get("ry") * this.get("scaleY");
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return this.callSuper("toObject", ["rx", "ry"].concat(propertiesToInclude));
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            return [
              "<ellipse ",
              "COMMON_PARTS",
              'cx="0" cy="0" ',
              'rx="',
              this.rx,
              '" ry="',
              this.ry,
              '" />\n'
            ];
          },
          /* _TO_SVG_END_ */
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx context to render on
           */
          _render: function(ctx) {
            ctx.beginPath();
            ctx.save();
            ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
            ctx.arc(
              0,
              0,
              this.rx,
              0,
              piBy2,
              false
            );
            ctx.restore();
            this._renderPaintInOrder(ctx);
          }
        }
      );
      fabric2.Ellipse.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" "));
      fabric2.Ellipse.fromElement = function(element, callback) {
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Ellipse.ATTRIBUTE_NAMES);
        parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
        parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
        callback(new fabric2.Ellipse(parsedAttributes));
      };
      fabric2.Ellipse.fromObject = function(object, callback) {
        fabric2.Object._fromObject("Ellipse", object, callback);
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend;
      if (fabric2.Rect) {
        fabric2.warn("fabric.Rect is already defined");
        return;
      }
      fabric2.Rect = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Rect.prototype */
        {
          /**
           * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
           * as well as for history (undo/redo) purposes
           * @type Array
           */
          stateProperties: fabric2.Object.prototype.stateProperties.concat("rx", "ry"),
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "rect",
          /**
           * Horizontal border radius
           * @type Number
           * @default
           */
          rx: 0,
          /**
           * Vertical border radius
           * @type Number
           * @default
           */
          ry: 0,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("rx", "ry"),
          /**
           * Constructor
           * @param {Object} [options] Options object
           * @return {Object} thisArg
           */
          initialize: function(options) {
            this.callSuper("initialize", options);
            this._initRxRy();
          },
          /**
           * Initializes rx/ry attributes
           * @private
           */
          _initRxRy: function() {
            if (this.rx && !this.ry) {
              this.ry = this.rx;
            } else if (this.ry && !this.rx) {
              this.rx = this.ry;
            }
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w2 = this.width, h2 = this.height, x2 = -this.width / 2, y2 = -this.height / 2, isRounded = rx !== 0 || ry !== 0, k2 = 1 - 0.5522847498;
            ctx.beginPath();
            ctx.moveTo(x2 + rx, y2);
            ctx.lineTo(x2 + w2 - rx, y2);
            isRounded && ctx.bezierCurveTo(x2 + w2 - k2 * rx, y2, x2 + w2, y2 + k2 * ry, x2 + w2, y2 + ry);
            ctx.lineTo(x2 + w2, y2 + h2 - ry);
            isRounded && ctx.bezierCurveTo(x2 + w2, y2 + h2 - k2 * ry, x2 + w2 - k2 * rx, y2 + h2, x2 + w2 - rx, y2 + h2);
            ctx.lineTo(x2 + rx, y2 + h2);
            isRounded && ctx.bezierCurveTo(x2 + k2 * rx, y2 + h2, x2, y2 + h2 - k2 * ry, x2, y2 + h2 - ry);
            ctx.lineTo(x2, y2 + ry);
            isRounded && ctx.bezierCurveTo(x2, y2 + k2 * ry, x2 + k2 * rx, y2, x2 + rx, y2);
            ctx.closePath();
            this._renderPaintInOrder(ctx);
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return this.callSuper("toObject", ["rx", "ry"].concat(propertiesToInclude));
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var x2 = -this.width / 2, y2 = -this.height / 2;
            return [
              "<rect ",
              "COMMON_PARTS",
              'x="',
              x2,
              '" y="',
              y2,
              '" rx="',
              this.rx,
              '" ry="',
              this.ry,
              '" width="',
              this.width,
              '" height="',
              this.height,
              '" />\n'
            ];
          }
          /* _TO_SVG_END_ */
        }
      );
      fabric2.Rect.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" "));
      fabric2.Rect.fromElement = function(element, callback, options) {
        if (!element) {
          return callback(null);
        }
        options = options || {};
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Rect.ATTRIBUTE_NAMES);
        parsedAttributes.left = parsedAttributes.left || 0;
        parsedAttributes.top = parsedAttributes.top || 0;
        parsedAttributes.height = parsedAttributes.height || 0;
        parsedAttributes.width = parsedAttributes.width || 0;
        var rect = new fabric2.Rect(extend2(options ? fabric2.util.object.clone(options) : {}, parsedAttributes));
        rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
        callback(rect);
      };
      fabric2.Rect.fromObject = function(object, callback) {
        return fabric2.Object._fromObject("Rect", object, callback);
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, min = fabric2.util.array.min, max = fabric2.util.array.max, toFixed = fabric2.util.toFixed, projectStrokeOnPoints = fabric2.util.projectStrokeOnPoints;
      if (fabric2.Polyline) {
        fabric2.warn("fabric.Polyline is already defined");
        return;
      }
      fabric2.Polyline = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Polyline.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "polyline",
          /**
           * Points array
           * @type Array
           * @default
           */
          points: null,
          /**
           * WARNING: Feature in progress
           * Calculate the exact bounding box taking in account strokeWidth on acute angles
           * this will be turned to true by default on fabric 6.0
           * maybe will be left in as an optimization since calculations may be slow
           * @deprecated
           * @type Boolean
           * @default false
           */
          exactBoundingBox: false,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("points"),
          /**
           * Constructor
           * @param {Array} points Array of points (where each point is an object with x and y)
           * @param {Object} [options] Options object
           * @return {fabric.Polyline} thisArg
           * @example
           * var poly = new fabric.Polyline([
           *     { x: 10, y: 10 },
           *     { x: 50, y: 30 },
           *     { x: 40, y: 70 },
           *     { x: 60, y: 50 },
           *     { x: 100, y: 150 },
           *     { x: 40, y: 100 }
           *   ], {
           *   stroke: 'red',
           *   left: 100,
           *   top: 100
           * });
           */
          initialize: function(points, options) {
            options = options || {};
            this.points = points || [];
            this.callSuper("initialize", options);
            this._setPositionDimensions(options);
          },
          /**
           * @private
           */
          _projectStrokeOnPoints: function() {
            return projectStrokeOnPoints(this.points, this, true);
          },
          _setPositionDimensions: function(options) {
            var calcDim = this._calcDimensions(options), correctLeftTop, correctSize = this.exactBoundingBox ? this.strokeWidth : 0;
            this.width = calcDim.width - correctSize;
            this.height = calcDim.height - correctSize;
            if (!options.fromSVG) {
              correctLeftTop = this.translateToGivenOrigin(
                {
                  // this looks bad, but is one way to keep it optional for now.
                  x: calcDim.left - this.strokeWidth / 2 + correctSize / 2,
                  y: calcDim.top - this.strokeWidth / 2 + correctSize / 2
                },
                "left",
                "top",
                this.originX,
                this.originY
              );
            }
            if (typeof options.left === "undefined") {
              this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
            }
            if (typeof options.top === "undefined") {
              this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
            }
            this.pathOffset = {
              x: calcDim.left + this.width / 2 + correctSize / 2,
              y: calcDim.top + this.height / 2 + correctSize / 2
            };
          },
          /**
           * Calculate the polygon min and max point from points array,
           * returning an object with left, top, width, height to measure the
           * polygon size
           * @return {Object} object.left X coordinate of the polygon leftmost point
           * @return {Object} object.top Y coordinate of the polygon topmost point
           * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
           * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
           * @private
           */
          _calcDimensions: function() {
            var points = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, minX = min(points, "x") || 0, minY = min(points, "y") || 0, maxX = max(points, "x") || 0, maxY = max(points, "y") || 0, width = maxX - minX, height = maxY - minY;
            return {
              left: minX,
              top: minY,
              width,
              height
            };
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return extend2(this.callSuper("toObject", propertiesToInclude), {
              points: this.points.concat()
            });
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS;
            for (var i2 = 0, len = this.points.length; i2 < len; i2++) {
              points.push(
                toFixed(this.points[i2].x - diffX, NUM_FRACTION_DIGITS),
                ",",
                toFixed(this.points[i2].y - diffY, NUM_FRACTION_DIGITS),
                " "
              );
            }
            return [
              "<" + this.type + " ",
              "COMMON_PARTS",
              'points="',
              points.join(""),
              '" />\n'
            ];
          },
          /* _TO_SVG_END_ */
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          commonRender: function(ctx) {
            var point, len = this.points.length, x2 = this.pathOffset.x, y2 = this.pathOffset.y;
            if (!len || isNaN(this.points[len - 1].y)) {
              return false;
            }
            ctx.beginPath();
            ctx.moveTo(this.points[0].x - x2, this.points[0].y - y2);
            for (var i2 = 0; i2 < len; i2++) {
              point = this.points[i2];
              ctx.lineTo(point.x - x2, point.y - y2);
            }
            return true;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            if (!this.commonRender(ctx)) {
              return;
            }
            this._renderPaintInOrder(ctx);
          },
          /**
           * Returns complexity of an instance
           * @return {Number} complexity of this instance
           */
          complexity: function() {
            return this.get("points").length;
          }
        }
      );
      fabric2.Polyline.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat();
      fabric2.Polyline.fromElementGenerator = function(_class) {
        return function(element, callback, options) {
          if (!element) {
            return callback(null);
          }
          options || (options = {});
          var points = fabric2.parsePointsAttribute(element.getAttribute("points")), parsedAttributes = fabric2.parseAttributes(element, fabric2[_class].ATTRIBUTE_NAMES);
          parsedAttributes.fromSVG = true;
          callback(new fabric2[_class](points, extend2(parsedAttributes, options)));
        };
      };
      fabric2.Polyline.fromElement = fabric2.Polyline.fromElementGenerator("Polyline");
      fabric2.Polyline.fromObject = function(object, callback) {
        return fabric2.Object._fromObject("Polyline", object, callback, "points");
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), projectStrokeOnPoints = fabric2.util.projectStrokeOnPoints;
      if (fabric2.Polygon) {
        fabric2.warn("fabric.Polygon is already defined");
        return;
      }
      fabric2.Polygon = fabric2.util.createClass(
        fabric2.Polyline,
        /** @lends fabric.Polygon.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "polygon",
          /**
           * @private
           */
          _projectStrokeOnPoints: function() {
            return projectStrokeOnPoints(this.points, this);
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            if (!this.commonRender(ctx)) {
              return;
            }
            ctx.closePath();
            this._renderPaintInOrder(ctx);
          }
        }
      );
      fabric2.Polygon.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat();
      fabric2.Polygon.fromElement = fabric2.Polyline.fromElementGenerator("Polygon");
      fabric2.Polygon.fromObject = function(object, callback) {
        fabric2.Object._fromObject("Polygon", object, callback, "points");
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), min = fabric2.util.array.min, max = fabric2.util.array.max, extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, toFixed = fabric2.util.toFixed;
      if (fabric2.Path) {
        fabric2.warn("fabric.Path is already defined");
        return;
      }
      fabric2.Path = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Path.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "path",
          /**
           * Array of path points
           * @type Array
           * @default
           */
          path: null,
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat("path", "fillRule"),
          stateProperties: fabric2.Object.prototype.stateProperties.concat("path"),
          /**
           * Constructor
           * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
           * @param {Object} [options] Options object
           * @return {fabric.Path} thisArg
           */
          initialize: function(path2, options) {
            options = clone2(options || {});
            delete options.path;
            this.callSuper("initialize", options);
            this._setPath(path2 || [], options);
          },
          /**
          * @private
          * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
          * @param {Object} [options] Options object
          */
          _setPath: function(path2, options) {
            this.path = fabric2.util.makePathSimpler(
              Array.isArray(path2) ? path2 : fabric2.util.parsePath(path2)
            );
            fabric2.Polyline.prototype._setPositionDimensions.call(this, options || {});
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx context to render path on
           */
          _renderPathCommands: function(ctx) {
            var current, subpathStartX = 0, subpathStartY = 0, x2 = 0, y2 = 0, controlX = 0, controlY = 0, l2 = -this.pathOffset.x, t3 = -this.pathOffset.y;
            ctx.beginPath();
            for (var i2 = 0, len = this.path.length; i2 < len; ++i2) {
              current = this.path[i2];
              switch (current[0]) {
                // first letter
                case "L":
                  x2 = current[1];
                  y2 = current[2];
                  ctx.lineTo(x2 + l2, y2 + t3);
                  break;
                case "M":
                  x2 = current[1];
                  y2 = current[2];
                  subpathStartX = x2;
                  subpathStartY = y2;
                  ctx.moveTo(x2 + l2, y2 + t3);
                  break;
                case "C":
                  x2 = current[5];
                  y2 = current[6];
                  controlX = current[3];
                  controlY = current[4];
                  ctx.bezierCurveTo(
                    current[1] + l2,
                    current[2] + t3,
                    controlX + l2,
                    controlY + t3,
                    x2 + l2,
                    y2 + t3
                  );
                  break;
                case "Q":
                  ctx.quadraticCurveTo(
                    current[1] + l2,
                    current[2] + t3,
                    current[3] + l2,
                    current[4] + t3
                  );
                  x2 = current[3];
                  y2 = current[4];
                  controlX = current[1];
                  controlY = current[2];
                  break;
                case "z":
                case "Z":
                  x2 = subpathStartX;
                  y2 = subpathStartY;
                  ctx.closePath();
                  break;
              }
            }
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx context to render path on
           */
          _render: function(ctx) {
            this._renderPathCommands(ctx);
            this._renderPaintInOrder(ctx);
          },
          /**
           * Returns string representation of an instance
           * @return {String} string representation of an instance
           */
          toString: function() {
            return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>";
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            return extend2(this.callSuper("toObject", propertiesToInclude), {
              path: this.path.map(function(item) {
                return item.slice();
              })
            });
          },
          /**
           * Returns dataless object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toDatalessObject: function(propertiesToInclude) {
            var o2 = this.toObject(["sourcePath"].concat(propertiesToInclude));
            if (o2.sourcePath) {
              delete o2.path;
            }
            return o2;
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var path2 = fabric2.util.joinPath(this.path);
            return [
              "<path ",
              "COMMON_PARTS",
              'd="',
              path2,
              '" stroke-linecap="round" ',
              "/>\n"
            ];
          },
          _getOffsetTransform: function() {
            var digits = fabric2.Object.NUM_FRACTION_DIGITS;
            return " translate(" + toFixed(-this.pathOffset.x, digits) + ", " + toFixed(-this.pathOffset.y, digits) + ")";
          },
          /**
           * Returns svg clipPath representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toClipPathSVG: function(reviver) {
            var additionalTransform = this._getOffsetTransform();
            return "	" + this._createBaseClipPathSVGMarkup(
              this._toSVG(),
              { reviver, additionalTransform }
            );
          },
          /**
           * Returns svg representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toSVG: function(reviver) {
            var additionalTransform = this._getOffsetTransform();
            return this._createBaseSVGMarkup(this._toSVG(), { reviver, additionalTransform });
          },
          /* _TO_SVG_END_ */
          /**
           * Returns number representation of an instance complexity
           * @return {Number} complexity of this instance
           */
          complexity: function() {
            return this.path.length;
          },
          /**
           * @private
           */
          _calcDimensions: function() {
            var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x2 = 0, y2 = 0, bounds;
            for (var i2 = 0, len = this.path.length; i2 < len; ++i2) {
              current = this.path[i2];
              switch (current[0]) {
                // first letter
                case "L":
                  x2 = current[1];
                  y2 = current[2];
                  bounds = [];
                  break;
                case "M":
                  x2 = current[1];
                  y2 = current[2];
                  subpathStartX = x2;
                  subpathStartY = y2;
                  bounds = [];
                  break;
                case "C":
                  bounds = fabric2.util.getBoundsOfCurve(
                    x2,
                    y2,
                    current[1],
                    current[2],
                    current[3],
                    current[4],
                    current[5],
                    current[6]
                  );
                  x2 = current[5];
                  y2 = current[6];
                  break;
                case "Q":
                  bounds = fabric2.util.getBoundsOfCurve(
                    x2,
                    y2,
                    current[1],
                    current[2],
                    current[1],
                    current[2],
                    current[3],
                    current[4]
                  );
                  x2 = current[3];
                  y2 = current[4];
                  break;
                case "z":
                case "Z":
                  x2 = subpathStartX;
                  y2 = subpathStartY;
                  break;
              }
              bounds.forEach(function(point) {
                aX.push(point.x);
                aY.push(point.y);
              });
              aX.push(x2);
              aY.push(y2);
            }
            var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max(aX) || 0, maxY = max(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;
            return {
              left: minX,
              top: minY,
              width: deltaX,
              height: deltaY
            };
          }
        }
      );
      fabric2.Path.fromObject = function(object, callback) {
        if (typeof object.sourcePath === "string") {
          var pathUrl = object.sourcePath;
          fabric2.loadSVGFromURL(pathUrl, function(elements2) {
            var path2 = elements2[0];
            path2.setOptions(object);
            if (object.clipPath) {
              fabric2.util.enlivenObjects([object.clipPath], function(elivenedObjects) {
                path2.clipPath = elivenedObjects[0];
                callback && callback(path2);
              });
            } else {
              callback && callback(path2);
            }
          });
        } else {
          fabric2.Object._fromObject("Path", object, callback, "path");
        }
      };
      fabric2.Path.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat(["d"]);
      fabric2.Path.fromElement = function(element, callback, options) {
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Path.ATTRIBUTE_NAMES);
        parsedAttributes.fromSVG = true;
        callback(new fabric2.Path(parsedAttributes.d, extend2(parsedAttributes, options)));
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), min = fabric2.util.array.min, max = fabric2.util.array.max;
      if (fabric2.Group) {
        return;
      }
      fabric2.Group = fabric2.util.createClass(
        fabric2.Object,
        fabric2.Collection,
        /** @lends fabric.Group.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "group",
          /**
           * Width of stroke
           * @type Number
           * @default
           */
          strokeWidth: 0,
          /**
           * Indicates if click, mouseover, mouseout events & hoverCursor should also check for subtargets
           * @type Boolean
           * @default
           */
          subTargetCheck: false,
          /**
           * Groups are container, do not render anything on theyr own, ence no cache properties
           * @type Array
           * @default
           */
          cacheProperties: [],
          /**
           * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
           * available setting this boolean to true.
           * @type Boolean
           * @since 2.0.0
           * @default
           */
          useSetOnGroup: false,
          /**
           * Constructor
           * @param {Object} objects Group objects
           * @param {Object} [options] Options object
           * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
           * @return {Object} thisArg
           */
          initialize: function(objects, options, isAlreadyGrouped) {
            options = options || {};
            this._objects = [];
            isAlreadyGrouped && this.callSuper("initialize", options);
            this._objects = objects || [];
            for (var i2 = this._objects.length; i2--; ) {
              this._objects[i2].group = this;
            }
            if (!isAlreadyGrouped) {
              var center = options && options.centerPoint;
              if (options.originX !== void 0) {
                this.originX = options.originX;
              }
              if (options.originY !== void 0) {
                this.originY = options.originY;
              }
              center || this._calcBounds();
              this._updateObjectsCoords(center);
              delete options.centerPoint;
              this.callSuper("initialize", options);
            } else {
              this._updateObjectsACoords();
            }
            this.setCoords();
          },
          /**
           * @private
           */
          _updateObjectsACoords: function() {
            var skipControls = true;
            for (var i2 = this._objects.length; i2--; ) {
              this._objects[i2].setCoords(skipControls);
            }
          },
          /**
           * @private
           * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
           */
          _updateObjectsCoords: function(center) {
            var center = center || this.getCenterPoint();
            for (var i2 = this._objects.length; i2--; ) {
              this._updateObjectCoords(this._objects[i2], center);
            }
          },
          /**
           * @private
           * @param {Object} object
           * @param {fabric.Point} center, current center of group.
           */
          _updateObjectCoords: function(object, center) {
            var objectLeft = object.left, objectTop = object.top, skipControls = true;
            object.set({
              left: objectLeft - center.x,
              top: objectTop - center.y
            });
            object.group = this;
            object.setCoords(skipControls);
          },
          /**
           * Returns string represenation of a group
           * @return {String}
           */
          toString: function() {
            return "#<fabric.Group: (" + this.complexity() + ")>";
          },
          /**
           * Adds an object to a group; Then recalculates group's dimension, position.
           * @param {Object} object
           * @return {fabric.Group} thisArg
           * @chainable
           */
          addWithUpdate: function(object) {
            var nested = !!this.group;
            this._restoreObjectsState();
            fabric2.util.resetObjectTransform(this);
            if (object) {
              if (nested) {
                fabric2.util.removeTransformFromObject(object, this.group.calcTransformMatrix());
              }
              this._objects.push(object);
              object.group = this;
              object._set("canvas", this.canvas);
            }
            this._calcBounds();
            this._updateObjectsCoords();
            this.dirty = true;
            if (nested) {
              this.group.addWithUpdate();
            } else {
              this.setCoords();
            }
            return this;
          },
          /**
           * Removes an object from a group; Then recalculates group's dimension, position.
           * @param {Object} object
           * @return {fabric.Group} thisArg
           * @chainable
           */
          removeWithUpdate: function(object) {
            this._restoreObjectsState();
            fabric2.util.resetObjectTransform(this);
            this.remove(object);
            this._calcBounds();
            this._updateObjectsCoords();
            this.setCoords();
            this.dirty = true;
            return this;
          },
          /**
           * @private
           */
          _onObjectAdded: function(object) {
            this.dirty = true;
            object.group = this;
            object._set("canvas", this.canvas);
          },
          /**
           * @private
           */
          _onObjectRemoved: function(object) {
            this.dirty = true;
            delete object.group;
          },
          /**
           * @private
           */
          _set: function(key, value) {
            var i2 = this._objects.length;
            if (this.useSetOnGroup) {
              while (i2--) {
                this._objects[i2].setOnGroup(key, value);
              }
            }
            if (key === "canvas") {
              while (i2--) {
                this._objects[i2]._set(key, value);
              }
            }
            fabric2.Object.prototype._set.call(this, key, value);
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            var _includeDefaultValues = this.includeDefaultValues;
            var objsToObject = this._objects.filter(function(obj2) {
              return !obj2.excludeFromExport;
            }).map(function(obj2) {
              var originalDefaults = obj2.includeDefaultValues;
              obj2.includeDefaultValues = _includeDefaultValues;
              var _obj = obj2.toObject(propertiesToInclude);
              obj2.includeDefaultValues = originalDefaults;
              return _obj;
            });
            var obj = fabric2.Object.prototype.toObject.call(this, propertiesToInclude);
            obj.objects = objsToObject;
            return obj;
          },
          /**
           * Returns object representation of an instance, in dataless mode.
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} object representation of an instance
           */
          toDatalessObject: function(propertiesToInclude) {
            var objsToObject, sourcePath = this.sourcePath;
            if (sourcePath) {
              objsToObject = sourcePath;
            } else {
              var _includeDefaultValues = this.includeDefaultValues;
              objsToObject = this._objects.map(function(obj2) {
                var originalDefaults = obj2.includeDefaultValues;
                obj2.includeDefaultValues = _includeDefaultValues;
                var _obj = obj2.toDatalessObject(propertiesToInclude);
                obj2.includeDefaultValues = originalDefaults;
                return _obj;
              });
            }
            var obj = fabric2.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
            obj.objects = objsToObject;
            return obj;
          },
          /**
           * Renders instance on a given context
           * @param {CanvasRenderingContext2D} ctx context to render instance on
           */
          render: function(ctx) {
            this._transformDone = true;
            this.callSuper("render", ctx);
            this._transformDone = false;
          },
          /**
           * Decide if the object should cache or not. Create its own cache level
           * needsItsOwnCache should be used when the object drawing method requires
           * a cache step. None of the fabric classes requires it.
           * Generally you do not cache objects in groups because the group is already cached.
           * @return {Boolean}
           */
          shouldCache: function() {
            var ownCache = fabric2.Object.prototype.shouldCache.call(this);
            if (ownCache) {
              for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
                if (this._objects[i2].willDrawShadow()) {
                  this.ownCaching = false;
                  return false;
                }
              }
            }
            return ownCache;
          },
          /**
           * Check if this object or a child object will cast a shadow
           * @return {Boolean}
           */
          willDrawShadow: function() {
            if (fabric2.Object.prototype.willDrawShadow.call(this)) {
              return true;
            }
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              if (this._objects[i2].willDrawShadow()) {
                return true;
              }
            }
            return false;
          },
          /**
           * Check if this group or its parent group are caching, recursively up
           * @return {Boolean}
           */
          isOnACache: function() {
            return this.ownCaching || this.group && this.group.isOnACache();
          },
          /**
           * Execute the drawing operation for an object on a specified context
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          drawObject: function(ctx) {
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              this._objects[i2].render(ctx);
            }
            this._drawClipPath(ctx, this.clipPath);
          },
          /**
           * Check if cache is dirty
           */
          isCacheDirty: function(skipCanvas) {
            if (this.callSuper("isCacheDirty", skipCanvas)) {
              return true;
            }
            if (!this.statefullCache) {
              return false;
            }
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              if (this._objects[i2].isCacheDirty(true)) {
                if (this._cacheCanvas) {
                  var x2 = this.cacheWidth / this.zoomX, y2 = this.cacheHeight / this.zoomY;
                  this._cacheContext.clearRect(-x2 / 2, -y2 / 2, x2, y2);
                }
                return true;
              }
            }
            return false;
          },
          /**
           * Restores original state of each of group objects (original state is that which was before group was created).
           * if the nested boolean is true, the original state will be restored just for the
           * first group and not for all the group chain
           * @private
           * @param {Boolean} nested tell the function to restore object state up to the parent group and not more
           * @return {fabric.Group} thisArg
           * @chainable
           */
          _restoreObjectsState: function() {
            var groupMatrix = this.calcOwnMatrix();
            this._objects.forEach(function(object) {
              fabric2.util.addTransformToObject(object, groupMatrix);
              delete object.group;
              object.setCoords();
            });
            return this;
          },
          /**
           * Destroys a group (restoring state of its objects)
           * @return {fabric.Group} thisArg
           * @chainable
           */
          destroy: function() {
            this._objects.forEach(function(object) {
              object.set("dirty", true);
            });
            return this._restoreObjectsState();
          },
          dispose: function() {
            this.callSuper("dispose");
            this.forEachObject(function(object) {
              object.dispose && object.dispose();
            });
            this._objects = [];
          },
          /**
           * make a group an active selection, remove the group from canvas
           * the group has to be on canvas for this to work.
           * @return {fabric.ActiveSelection} thisArg
           * @chainable
           */
          toActiveSelection: function() {
            if (!this.canvas) {
              return;
            }
            var objects = this._objects, canvas = this.canvas;
            this._objects = [];
            var options = this.toObject();
            delete options.objects;
            var activeSelection = new fabric2.ActiveSelection([]);
            activeSelection.set(options);
            activeSelection.type = "activeSelection";
            canvas.remove(this);
            objects.forEach(function(object) {
              object.group = activeSelection;
              object.dirty = true;
              canvas.add(object);
            });
            activeSelection.canvas = canvas;
            activeSelection._objects = objects;
            canvas._activeObject = activeSelection;
            activeSelection.setCoords();
            return activeSelection;
          },
          /**
           * Destroys a group (restoring state of its objects)
           * @return {fabric.Group} thisArg
           * @chainable
           */
          ungroupOnCanvas: function() {
            return this._restoreObjectsState();
          },
          /**
           * Sets coordinates of all objects inside group
           * @return {fabric.Group} thisArg
           * @chainable
           */
          setObjectsCoords: function() {
            var skipControls = true;
            this.forEachObject(function(object) {
              object.setCoords(skipControls);
            });
            return this;
          },
          /**
           * @private
           */
          _calcBounds: function(onlyWidthHeight) {
            var aX = [], aY = [], o2, prop, coords, props = ["tr", "br", "bl", "tl"], i2 = 0, iLen = this._objects.length, j2, jLen = props.length;
            for (; i2 < iLen; ++i2) {
              o2 = this._objects[i2];
              coords = o2.calcACoords();
              for (j2 = 0; j2 < jLen; j2++) {
                prop = props[j2];
                aX.push(coords[prop].x);
                aY.push(coords[prop].y);
              }
              o2.aCoords = coords;
            }
            this._getBounds(aX, aY, onlyWidthHeight);
          },
          /**
           * @private
           */
          _getBounds: function(aX, aY, onlyWidthHeight) {
            var minXY = new fabric2.Point(min(aX), min(aY)), maxXY = new fabric2.Point(max(aX), max(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;
            this.width = width;
            this.height = height;
            if (!onlyWidthHeight) {
              this.setPositionByOrigin({ x: left, y: top }, "left", "top");
            }
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          _toSVG: function(reviver) {
            var svgString = ["<g ", "COMMON_PARTS", " >\n"];
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              svgString.push("		", this._objects[i2].toSVG(reviver));
            }
            svgString.push("</g>\n");
            return svgString;
          },
          /**
           * Returns styles-string for svg-export, specific version for group
           * @return {String}
           */
          getSvgStyles: function() {
            var opacity2 = typeof this.opacity !== "undefined" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", visibility2 = this.visible ? "" : " visibility: hidden;";
            return [
              opacity2,
              this.getSvgFilter(),
              visibility2
            ].join("");
          },
          /**
           * Returns svg clipPath representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toClipPathSVG: function(reviver) {
            var svgString = [];
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              svgString.push("	", this._objects[i2].toClipPathSVG(reviver));
            }
            return this._createBaseClipPathSVGMarkup(svgString, { reviver });
          }
          /* _TO_SVG_END_ */
        }
      );
      fabric2.Group.fromObject = function(object, callback) {
        var objects = object.objects, options = fabric2.util.object.clone(object, true);
        delete options.objects;
        if (typeof objects === "string") {
          fabric2.loadSVGFromURL(objects, function(elements2) {
            var group = fabric2.util.groupSVGElements(elements2, object, objects);
            var clipPath = options.clipPath;
            delete options.clipPath;
            group.set(options);
            if (clipPath) {
              fabric2.util.enlivenObjects([clipPath], function(elivenedObjects) {
                group.clipPath = elivenedObjects[0];
                callback && callback(group);
              });
            } else {
              callback && callback(group);
            }
          });
          return;
        }
        fabric2.util.enlivenObjects(objects, function(enlivenedObjects) {
          fabric2.util.enlivenObjectEnlivables(object, options, function() {
            callback && callback(new fabric2.Group(enlivenedObjects, options, true));
          });
        });
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      if (fabric2.ActiveSelection) {
        return;
      }
      fabric2.ActiveSelection = fabric2.util.createClass(
        fabric2.Group,
        /** @lends fabric.ActiveSelection.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "activeSelection",
          /**
           * Constructor
           * @param {Object} objects ActiveSelection objects
           * @param {Object} [options] Options object
           * @return {Object} thisArg
           */
          initialize: function(objects, options) {
            options = options || {};
            this._objects = objects || [];
            for (var i2 = this._objects.length; i2--; ) {
              this._objects[i2].group = this;
            }
            if (options.originX) {
              this.originX = options.originX;
            }
            if (options.originY) {
              this.originY = options.originY;
            }
            this._calcBounds();
            this._updateObjectsCoords();
            fabric2.Object.prototype.initialize.call(this, options);
            this.setCoords();
          },
          /**
           * Change te activeSelection to a normal group,
           * High level function that automatically adds it to canvas as
           * active object. no events fired.
           * @since 2.0.0
           * @return {fabric.Group}
           */
          toGroup: function() {
            var objects = this._objects.concat();
            this._objects = [];
            var options = fabric2.Object.prototype.toObject.call(this);
            var newGroup = new fabric2.Group([]);
            delete options.type;
            newGroup.set(options);
            objects.forEach(function(object) {
              object.canvas.remove(object);
              object.group = newGroup;
            });
            newGroup._objects = objects;
            if (!this.canvas) {
              return newGroup;
            }
            var canvas = this.canvas;
            canvas.add(newGroup);
            canvas._activeObject = newGroup;
            newGroup.setCoords();
            return newGroup;
          },
          /**
           * If returns true, deselection is cancelled.
           * @since 2.0.0
           * @return {Boolean} [cancel]
           */
          onDeselect: function() {
            this.destroy();
            return false;
          },
          /**
           * Returns string representation of a group
           * @return {String}
           */
          toString: function() {
            return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
          },
          /**
           * Decide if the object should cache or not. Create its own cache level
           * objectCaching is a global flag, wins over everything
           * needsItsOwnCache should be used when the object drawing method requires
           * a cache step. None of the fabric classes requires it.
           * Generally you do not cache objects in groups because the group outside is cached.
           * @return {Boolean}
           */
          shouldCache: function() {
            return false;
          },
          /**
           * Check if this group or its parent group are caching, recursively up
           * @return {Boolean}
           */
          isOnACache: function() {
            return false;
          },
          /**
           * Renders controls and borders for the object
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Object} [styleOverride] properties to override the object style
           * @param {Object} [childrenOverride] properties to override the children overrides
           */
          _renderControls: function(ctx, styleOverride, childrenOverride) {
            ctx.save();
            ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
            this.callSuper("_renderControls", ctx, styleOverride);
            childrenOverride = childrenOverride || {};
            if (typeof childrenOverride.hasControls === "undefined") {
              childrenOverride.hasControls = false;
            }
            childrenOverride.forActiveSelection = true;
            for (var i2 = 0, len = this._objects.length; i2 < len; i2++) {
              this._objects[i2]._renderControls(ctx, childrenOverride);
            }
            ctx.restore();
          }
        }
      );
      fabric2.ActiveSelection.fromObject = function(object, callback) {
        fabric2.util.enlivenObjects(object.objects, function(enlivenedObjects) {
          delete object.objects;
          callback && callback(new fabric2.ActiveSelection(enlivenedObjects, object, true));
        });
      };
    })(exports);
    (function(global2) {
      var extend2 = fabric$1.util.object.extend;
      if (!global2.fabric) {
        global2.fabric = {};
      }
      if (global2.fabric.Image) {
        fabric$1.warn("fabric.Image is already defined.");
        return;
      }
      fabric$1.Image = fabric$1.util.createClass(
        fabric$1.Object,
        /** @lends fabric.Image.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "image",
          /**
           * Width of a stroke.
           * For image quality a stroke multiple of 2 gives better results.
           * @type Number
           * @default
           */
          strokeWidth: 0,
          /**
           * When calling {@link fabric.Image.getSrc}, return value from element src with `element.getAttribute('src')`.
           * This allows for relative urls as image src.
           * @since 2.7.0
           * @type Boolean
           * @default
           */
          srcFromAttribute: false,
          /**
           * private
           * contains last value of scaleX to detect
           * if the Image got resized after the last Render
           * @type Number
           */
          _lastScaleX: 1,
          /**
           * private
           * contains last value of scaleY to detect
           * if the Image got resized after the last Render
           * @type Number
           */
          _lastScaleY: 1,
          /**
           * private
           * contains last value of scaling applied by the apply filter chain
           * @type Number
           */
          _filterScalingX: 1,
          /**
           * private
           * contains last value of scaling applied by the apply filter chain
           * @type Number
           */
          _filterScalingY: 1,
          /**
           * minimum scale factor under which any resizeFilter is triggered to resize the image
           * 0 will disable the automatic resize. 1 will trigger automatically always.
           * number bigger than 1 are not implemented yet.
           * @type Number
           */
          minimumScaleTrigger: 0.5,
          /**
           * List of properties to consider when checking if
           * state of an object is changed ({@link fabric.Object#hasStateChanged})
           * as well as for history (undo/redo) purposes
           * @type Array
           */
          stateProperties: fabric$1.Object.prototype.stateProperties.concat("cropX", "cropY"),
          /**
           * List of properties to consider when checking if cache needs refresh
           * Those properties are checked by statefullCache ON ( or lazy mode if we want ) or from single
           * calls to Object.set(key, value). If the key is in this list, the object is marked as dirty
           * and refreshed at the next render
           * @type Array
           */
          cacheProperties: fabric$1.Object.prototype.cacheProperties.concat("cropX", "cropY"),
          /**
           * key used to retrieve the texture representing this image
           * @since 2.0.0
           * @type String
           * @default
           */
          cacheKey: "",
          /**
           * Image crop in pixels from original image size.
           * @since 2.0.0
           * @type Number
           * @default
           */
          cropX: 0,
          /**
           * Image crop in pixels from original image size.
           * @since 2.0.0
           * @type Number
           * @default
           */
          cropY: 0,
          /**
           * Indicates whether this canvas will use image smoothing when painting this image.
           * Also influence if the cacheCanvas for this image uses imageSmoothing
           * @since 4.0.0-beta.11
           * @type Boolean
           * @default
           */
          imageSmoothing: true,
          /**
           * Constructor
           * Image can be initialized with any canvas drawable or a string.
           * The string should be a url and will be loaded as an image.
           * Canvas and Image element work out of the box, while videos require extra code to work.
           * Please check video element events for seeking.
           * @param {HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | String} element Image element
           * @param {Object} [options] Options object
           * @param {function} [callback] callback function to call after eventual filters applied.
           * @return {fabric.Image} thisArg
           */
          initialize: function(element, options) {
            options || (options = {});
            this.filters = [];
            this.cacheKey = "texture" + fabric$1.Object.__uid++;
            this.callSuper("initialize", options);
            this._initElement(element, options);
          },
          /**
           * Returns image element which this instance if based on
           * @return {HTMLImageElement} Image element
           */
          getElement: function() {
            return this._element || {};
          },
          /**
           * Sets image element for this instance to a specified one.
           * If filters defined they are applied to new image.
           * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
           * @param {HTMLImageElement} element
           * @param {Object} [options] Options object
           * @return {fabric.Image} thisArg
           * @chainable
           */
          setElement: function(element, options) {
            this.removeTexture(this.cacheKey);
            this.removeTexture(this.cacheKey + "_filtered");
            this._element = element;
            this._originalElement = element;
            this._initConfig(options);
            if (this.filters.length !== 0) {
              this.applyFilters();
            }
            if (this.resizeFilter) {
              this.applyResizeFilters();
            }
            return this;
          },
          /**
           * Delete a single texture if in webgl mode
           */
          removeTexture: function(key) {
            var backend = fabric$1.filterBackend;
            if (backend && backend.evictCachesForKey) {
              backend.evictCachesForKey(key);
            }
          },
          /**
           * Delete textures, reference to elements and eventually JSDOM cleanup
           */
          dispose: function() {
            this.callSuper("dispose");
            this.removeTexture(this.cacheKey);
            this.removeTexture(this.cacheKey + "_filtered");
            this._cacheContext = void 0;
            ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((function(element) {
              fabric$1.util.cleanUpJsdomNode(this[element]);
              this[element] = void 0;
            }).bind(this));
          },
          /**
           * Get the crossOrigin value (of the corresponding image element)
           */
          getCrossOrigin: function() {
            return this._originalElement && (this._originalElement.crossOrigin || null);
          },
          /**
           * Returns original size of an image
           * @return {Object} Object with "width" and "height" properties
           */
          getOriginalSize: function() {
            var element = this.getElement();
            return {
              width: element.naturalWidth || element.width,
              height: element.naturalHeight || element.height
            };
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _stroke: function(ctx) {
            if (!this.stroke || this.strokeWidth === 0) {
              return;
            }
            var w2 = this.width / 2, h2 = this.height / 2;
            ctx.beginPath();
            ctx.moveTo(-w2, -h2);
            ctx.lineTo(w2, -h2);
            ctx.lineTo(w2, h2);
            ctx.lineTo(-w2, h2);
            ctx.lineTo(-w2, -h2);
            ctx.closePath();
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            var filters = [];
            this.filters.forEach(function(filterObj) {
              if (filterObj) {
                filters.push(filterObj.toObject());
              }
            });
            var object = extend2(
              this.callSuper(
                "toObject",
                ["cropX", "cropY"].concat(propertiesToInclude)
              ),
              {
                src: this.getSrc(),
                crossOrigin: this.getCrossOrigin(),
                filters
              }
            );
            if (this.resizeFilter) {
              object.resizeFilter = this.resizeFilter.toObject();
            }
            return object;
          },
          /**
           * Returns true if an image has crop applied, inspecting values of cropX,cropY,width,height.
           * @return {Boolean}
           */
          hasCrop: function() {
            return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
          },
          /* _TO_SVG_START_ */
          /**
           * Returns svg representation of an instance
           * @return {Array} an array of strings with the specific svg representation
           * of the instance
           */
          _toSVG: function() {
            var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x2 = -this.width / 2, y2 = -this.height / 2, clipPath = "", imageRendering = "";
            if (!element) {
              return [];
            }
            if (this.hasCrop()) {
              var clipPathId = fabric$1.Object.__uid++;
              svgString.push(
                '<clipPath id="imageCrop_' + clipPathId + '">\n',
                '	<rect x="' + x2 + '" y="' + y2 + '" width="' + this.width + '" height="' + this.height + '" />\n',
                "</clipPath>\n"
              );
              clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
            }
            if (!this.imageSmoothing) {
              imageRendering = '" image-rendering="optimizeSpeed';
            }
            imageMarkup.push(
              "	<image ",
              "COMMON_PARTS",
              'xlink:href="',
              this.getSvgSrc(true),
              '" x="',
              x2 - this.cropX,
              '" y="',
              y2 - this.cropY,
              // we're essentially moving origin of transformation from top/left corner to the center of the shape
              // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
              // so that object's center aligns with container's left/top
              '" width="',
              element.width || element.naturalWidth,
              '" height="',
              element.height || element.height,
              imageRendering,
              '"',
              clipPath,
              "></image>\n"
            );
            if (this.stroke || this.strokeDashArray) {
              var origFill = this.fill;
              this.fill = null;
              strokeSvg = [
                "	<rect ",
                'x="',
                x2,
                '" y="',
                y2,
                '" width="',
                this.width,
                '" height="',
                this.height,
                '" style="',
                this.getSvgStyles(),
                '"/>\n'
              ];
              this.fill = origFill;
            }
            if (this.paintFirst !== "fill") {
              svgString = svgString.concat(strokeSvg, imageMarkup);
            } else {
              svgString = svgString.concat(imageMarkup, strokeSvg);
            }
            return svgString;
          },
          /* _TO_SVG_END_ */
          /**
           * Returns source of an image
           * @param {Boolean} filtered indicates if the src is needed for svg
           * @return {String} Source of an image
           */
          getSrc: function(filtered) {
            var element = filtered ? this._element : this._originalElement;
            if (element) {
              if (element.toDataURL) {
                return element.toDataURL();
              }
              if (this.srcFromAttribute) {
                return element.getAttribute("src");
              } else {
                return element.src;
              }
            } else {
              return this.src || "";
            }
          },
          /**
           * Sets source of an image
           * @param {String} src Source string (URL)
           * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
           * @param {Object} [options] Options object
           * @param {String} [options.crossOrigin] crossOrigin value (one of "", "anonymous", "use-credentials")
           * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
           * @return {fabric.Image} thisArg
           * @chainable
           */
          setSrc: function(src, callback, options) {
            fabric$1.util.loadImage(src, function(img, isError) {
              this.setElement(img, options);
              this._setWidthHeight();
              callback && callback(this, isError);
            }, this, options && options.crossOrigin);
            return this;
          },
          /**
           * Returns string representation of an instance
           * @return {String} String representation of an instance
           */
          toString: function() {
            return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
          },
          applyResizeFilters: function() {
            var filter2 = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;
            if (this.group) {
              this.set("dirty", true);
            }
            if (!filter2 || scaleX > minimumScale && scaleY > minimumScale) {
              this._element = elementToFilter;
              this._filterScalingX = 1;
              this._filterScalingY = 1;
              this._lastScaleX = scaleX;
              this._lastScaleY = scaleY;
              return;
            }
            if (!fabric$1.filterBackend) {
              fabric$1.filterBackend = fabric$1.initFilterBackend();
            }
            var canvasEl = fabric$1.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
            canvasEl.width = sourceWidth;
            canvasEl.height = sourceHeight;
            this._element = canvasEl;
            this._lastScaleX = filter2.scaleX = scaleX;
            this._lastScaleY = filter2.scaleY = scaleY;
            fabric$1.filterBackend.applyFilters(
              [filter2],
              elementToFilter,
              sourceWidth,
              sourceHeight,
              this._element,
              cacheKey
            );
            this._filterScalingX = canvasEl.width / this._originalElement.width;
            this._filterScalingY = canvasEl.height / this._originalElement.height;
          },
          /**
           * Applies filters assigned to this image (from "filters" array) or from filter param
           * @method applyFilters
           * @param {Array} filters to be applied
           * @param {Boolean} forResizing specify if the filter operation is a resize operation
           * @return {thisArg} return the fabric.Image object
           * @chainable
           */
          applyFilters: function(filters) {
            filters = filters || this.filters || [];
            filters = filters.filter(function(filter2) {
              return filter2 && !filter2.isNeutralState();
            });
            this.set("dirty", true);
            this.removeTexture(this.cacheKey + "_filtered");
            if (filters.length === 0) {
              this._element = this._originalElement;
              this._filteredEl = null;
              this._filterScalingX = 1;
              this._filterScalingY = 1;
              return this;
            }
            var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;
            if (this._element === this._originalElement) {
              var canvasEl = fabric$1.util.createCanvasElement();
              canvasEl.width = sourceWidth;
              canvasEl.height = sourceHeight;
              this._element = canvasEl;
              this._filteredEl = canvasEl;
            } else {
              this._element = this._filteredEl;
              this._filteredEl.getContext("2d").clearRect(0, 0, sourceWidth, sourceHeight);
              this._lastScaleX = 1;
              this._lastScaleY = 1;
            }
            if (!fabric$1.filterBackend) {
              fabric$1.filterBackend = fabric$1.initFilterBackend();
            }
            fabric$1.filterBackend.applyFilters(
              filters,
              this._originalElement,
              sourceWidth,
              sourceHeight,
              this._element,
              this.cacheKey
            );
            if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {
              this._filterScalingX = this._element.width / this._originalElement.width;
              this._filterScalingY = this._element.height / this._originalElement.height;
            }
            return this;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            fabric$1.util.setImageSmoothing(ctx, this.imageSmoothing);
            if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
              this.applyResizeFilters();
            }
            this._stroke(ctx);
            this._renderPaintInOrder(ctx);
          },
          /**
           * Paint the cached copy of the object on the target context.
           * it will set the imageSmoothing for the draw operation
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          drawCacheOnCanvas: function(ctx) {
            fabric$1.util.setImageSmoothing(ctx, this.imageSmoothing);
            fabric$1.Object.prototype.drawCacheOnCanvas.call(this, ctx);
          },
          /**
           * Decide if the object should cache or not. Create its own cache level
           * needsItsOwnCache should be used when the object drawing method requires
           * a cache step. None of the fabric classes requires it.
           * Generally you do not cache objects in groups because the group outside is cached.
           * This is the special image version where we would like to avoid caching where possible.
           * Essentially images do not benefit from caching. They may require caching, and in that
           * case we do it. Also caching an image usually ends in a loss of details.
           * A full performance audit should be done.
           * @return {Boolean}
           */
          shouldCache: function() {
            return this.needsItsOwnCache();
          },
          _renderFill: function(ctx) {
            var elementToDraw = this._element;
            if (!elementToDraw) {
              return;
            }
            var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w2 = this.width, h2 = this.height, min = Math.min, max = Math.max, cropX = max(this.cropX, 0), cropY = max(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, sW = min(w2 * scaleX, elWidth - sX), sH = min(h2 * scaleY, elHeight - sY), x2 = -w2 / 2, y2 = -h2 / 2, maxDestW = min(w2, elWidth / scaleX - cropX), maxDestH = min(h2, elHeight / scaleY - cropY);
            elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x2, y2, maxDestW, maxDestH);
          },
          /**
           * needed to check if image needs resize
           * @private
           */
          _needsResize: function() {
            var scale = this.getTotalObjectScaling();
            return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;
          },
          /**
           * @private
           */
          _resetWidthHeight: function() {
            this.set(this.getOriginalSize());
          },
          /**
           * The Image class's initialization method. This method is automatically
           * called by the constructor.
           * @private
           * @param {HTMLImageElement|String} element The element representing the image
           * @param {Object} [options] Options object
           */
          _initElement: function(element, options) {
            this.setElement(fabric$1.util.getById(element), options);
            fabric$1.util.addClass(this.getElement(), fabric$1.Image.CSS_CANVAS);
          },
          /**
           * @private
           * @param {Object} [options] Options object
           */
          _initConfig: function(options) {
            options || (options = {});
            this.setOptions(options);
            this._setWidthHeight(options);
          },
          /**
           * @private
           * @param {Array} filters to be initialized
           * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
           */
          _initFilters: function(filters, callback) {
            if (filters && filters.length) {
              fabric$1.util.enlivenObjects(filters, function(enlivenedObjects) {
                callback && callback(enlivenedObjects);
              }, "fabric.Image.filters");
            } else {
              callback && callback();
            }
          },
          /**
           * @private
           * Set the width and the height of the image object, using the element or the
           * options.
           * @param {Object} [options] Object with width/height properties
           */
          _setWidthHeight: function(options) {
            options || (options = {});
            var el = this.getElement();
            this.width = options.width || el.naturalWidth || el.width || 0;
            this.height = options.height || el.naturalHeight || el.height || 0;
          },
          /**
           * Calculate offset for center and scale factor for the image in order to respect
           * the preserveAspectRatio attribute
           * @private
           * @return {Object}
           */
          parsePreserveAspectRatioAttribute: function() {
            var pAR = fabric$1.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
            if (pAR && (pAR.alignX !== "none" || pAR.alignY !== "none")) {
              if (pAR.meetOrSlice === "meet") {
                scaleX = scaleY = fabric$1.util.findScaleToFit(this._element, parsedAttributes);
                offset = (pWidth - rWidth * scaleX) / 2;
                if (pAR.alignX === "Min") {
                  offsetLeft = -offset;
                }
                if (pAR.alignX === "Max") {
                  offsetLeft = offset;
                }
                offset = (pHeight - rHeight * scaleY) / 2;
                if (pAR.alignY === "Min") {
                  offsetTop = -offset;
                }
                if (pAR.alignY === "Max") {
                  offsetTop = offset;
                }
              }
              if (pAR.meetOrSlice === "slice") {
                scaleX = scaleY = fabric$1.util.findScaleToCover(this._element, parsedAttributes);
                offset = rWidth - pWidth / scaleX;
                if (pAR.alignX === "Mid") {
                  cropX = offset / 2;
                }
                if (pAR.alignX === "Max") {
                  cropX = offset;
                }
                offset = rHeight - pHeight / scaleY;
                if (pAR.alignY === "Mid") {
                  cropY = offset / 2;
                }
                if (pAR.alignY === "Max") {
                  cropY = offset;
                }
                rWidth = pWidth / scaleX;
                rHeight = pHeight / scaleY;
              }
            } else {
              scaleX = pWidth / rWidth;
              scaleY = pHeight / rHeight;
            }
            return {
              width: rWidth,
              height: rHeight,
              scaleX,
              scaleY,
              offsetLeft,
              offsetTop,
              cropX,
              cropY
            };
          }
        }
      );
      fabric$1.Image.CSS_CANVAS = "canvas-img";
      fabric$1.Image.prototype.getSvgSrc = fabric$1.Image.prototype.getSrc;
      fabric$1.Image.fromObject = function(_object, callback) {
        var object = fabric$1.util.object.clone(_object);
        fabric$1.util.loadImage(object.src, function(img, isError) {
          if (isError) {
            callback && callback(null, true);
            return;
          }
          fabric$1.Image.prototype._initFilters.call(object, object.filters, function(filters) {
            object.filters = filters || [];
            fabric$1.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
              object.resizeFilter = resizeFilters[0];
              fabric$1.util.enlivenObjectEnlivables(object, object, function() {
                var image2 = new fabric$1.Image(img, object);
                callback(image2, false);
              });
            });
          });
        }, null, object.crossOrigin);
      };
      fabric$1.Image.fromURL = function(url, callback, imgOptions) {
        fabric$1.util.loadImage(url, function(img, isError) {
          callback && callback(new fabric$1.Image(img, imgOptions), isError);
        }, null, imgOptions && imgOptions.crossOrigin);
      };
      fabric$1.Image.ATTRIBUTE_NAMES = fabric$1.SHARED_ATTRIBUTES.concat(
        "x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")
      );
      fabric$1.Image.fromElement = function(element, callback, options) {
        var parsedAttributes = fabric$1.parseAttributes(element, fabric$1.Image.ATTRIBUTE_NAMES);
        fabric$1.Image.fromURL(
          parsedAttributes["xlink:href"],
          callback,
          extend2(options ? fabric$1.util.object.clone(options) : {}, parsedAttributes)
        );
      };
    })(exports);
    fabric$1.util.object.extend(
      fabric$1.Object.prototype,
      /** @lends fabric.Object.prototype */
      {
        /**
         * @private
         * @return {Number} angle value
         */
        _getAngleValueForStraighten: function() {
          var angle2 = this.angle % 360;
          if (angle2 > 0) {
            return Math.round((angle2 - 1) / 90) * 90;
          }
          return Math.round(angle2 / 90) * 90;
        },
        /**
         * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
         * @return {fabric.Object} thisArg
         * @chainable
         */
        straighten: function() {
          return this.rotate(this._getAngleValueForStraighten());
        },
        /**
         * Same as {@link fabric.Object.prototype.straighten} but with animation
         * @param {Object} callbacks Object with callback functions
         * @param {Function} [callbacks.onComplete] Invoked on completion
         * @param {Function} [callbacks.onChange] Invoked on every step of animation
         * @return {fabric.Object} thisArg
         */
        fxStraighten: function(callbacks) {
          callbacks = callbacks || {};
          var empty2 = function() {
          }, onComplete = callbacks.onComplete || empty2, onChange = callbacks.onChange || empty2, _this = this;
          return fabric$1.util.animate({
            target: this,
            startValue: this.get("angle"),
            endValue: this._getAngleValueForStraighten(),
            duration: this.FX_DURATION,
            onChange: function(value) {
              _this.rotate(value);
              onChange();
            },
            onComplete: function() {
              _this.setCoords();
              onComplete();
            }
          });
        }
      }
    );
    fabric$1.util.object.extend(
      fabric$1.StaticCanvas.prototype,
      /** @lends fabric.StaticCanvas.prototype */
      {
        /**
         * Straightens object, then rerenders canvas
         * @param {fabric.Object} object Object to straighten
         * @return {fabric.Canvas} thisArg
         * @chainable
         */
        straightenObject: function(object) {
          object.straighten();
          this.requestRenderAll();
          return this;
        },
        /**
         * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
         * @param {fabric.Object} object Object to straighten
         * @return {fabric.Canvas} thisArg
         */
        fxStraightenObject: function(object) {
          return object.fxStraighten({
            onChange: this.requestRenderAllBound
          });
        }
      }
    );
    (function() {
      function testPrecision(gl, precision) {
        var fragmentSource = "precision " + precision + " float;\nvoid main(){}";
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSource);
        gl.compileShader(fragmentShader);
        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          return false;
        }
        return true;
      }
      fabric$1.isWebglSupported = function(tileSize) {
        if (fabric$1.isLikelyNode) {
          return false;
        }
        tileSize = tileSize || fabric$1.WebglFilterBackend.prototype.tileSize;
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        var isSupported = false;
        if (gl) {
          fabric$1.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
          isSupported = fabric$1.maxTextureSize >= tileSize;
          var precisions = ["highp", "mediump", "lowp"];
          for (var i2 = 0; i2 < 3; i2++) {
            if (testPrecision(gl, precisions[i2])) {
              fabric$1.webGlPrecision = precisions[i2];
              break;
            }
          }
        }
        this.isSupported = isSupported;
        return isSupported;
      };
      fabric$1.WebglFilterBackend = WebglFilterBackend;
      function WebglFilterBackend(options) {
        if (options && options.tileSize) {
          this.tileSize = options.tileSize;
        }
        this.setupGLContext(this.tileSize, this.tileSize);
        this.captureGPUInfo();
      }
      WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */
      {
        tileSize: 2048,
        /**
         * Experimental. This object is a sort of repository of help layers used to avoid
         * of recreating them during frequent filtering. If you are previewing a filter with
         * a slider you probably do not want to create help layers every filter step.
         * in this object there will be appended some canvases, created once, resized sometimes
         * cleared never. Clearing is left to the developer.
         **/
        resources: {},
        /**
         * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
         */
        setupGLContext: function(width, height) {
          this.dispose();
          this.createWebGLCanvas(width, height);
          this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
          this.chooseFastestCopyGLTo2DMethod(width, height);
        },
        /**
         * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
         * putImageData is faster than drawImage for that specific operation.
         */
        chooseFastestCopyGLTo2DMethod: function(width, height) {
          var canMeasurePerf = typeof window.performance !== "undefined", canUseImageData;
          try {
            new ImageData(1, 1);
            canUseImageData = true;
          } catch (e2) {
            canUseImageData = false;
          }
          var canUseArrayBuffer = typeof ArrayBuffer !== "undefined";
          var canUseUint8Clamped = typeof Uint8ClampedArray !== "undefined";
          if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
            return;
          }
          var targetCanvas = fabric$1.util.createCanvasElement();
          var imageBuffer = new ArrayBuffer(width * height * 4);
          if (fabric$1.forceGLPutImageData) {
            this.imageBuffer = imageBuffer;
            this.copyGLTo2D = copyGLTo2DPutImageData;
            return;
          }
          var testContext = {
            imageBuffer,
            destinationWidth: width,
            destinationHeight: height,
            targetCanvas
          };
          var startTime, drawImageTime, putImageDataTime;
          targetCanvas.width = width;
          targetCanvas.height = height;
          startTime = window.performance.now();
          copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
          drawImageTime = window.performance.now() - startTime;
          startTime = window.performance.now();
          copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
          putImageDataTime = window.performance.now() - startTime;
          if (drawImageTime > putImageDataTime) {
            this.imageBuffer = imageBuffer;
            this.copyGLTo2D = copyGLTo2DPutImageData;
          } else {
            this.copyGLTo2D = copyGLTo2DDrawImage;
          }
        },
        /**
         * Create a canvas element and associated WebGL context and attaches them as
         * class properties to the GLFilterBackend class.
         */
        createWebGLCanvas: function(width, height) {
          var canvas = fabric$1.util.createCanvasElement();
          canvas.width = width;
          canvas.height = height;
          var glOptions = {
            alpha: true,
            premultipliedAlpha: false,
            depth: false,
            stencil: false,
            antialias: false
          }, gl = canvas.getContext("webgl", glOptions);
          if (!gl) {
            gl = canvas.getContext("experimental-webgl", glOptions);
          }
          if (!gl) {
            return;
          }
          gl.clearColor(0, 0, 0, 0);
          this.canvas = canvas;
          this.gl = gl;
        },
        /**
         * Attempts to apply the requested filters to the source provided, drawing the filtered output
         * to the provided target canvas.
         *
         * @param {Array} filters The filters to apply.
         * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
         * @param {Number} width The width of the source input.
         * @param {Number} height The height of the source input.
         * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
         * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
         * omitted, caching will be skipped.
         */
        applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
          var gl = this.gl;
          var cachedTexture;
          if (cacheKey) {
            cachedTexture = this.getCachedTexture(cacheKey, source);
          }
          var pipelineState = {
            originalWidth: source.width || source.originalWidth,
            originalHeight: source.height || source.originalHeight,
            sourceWidth: width,
            sourceHeight: height,
            destinationWidth: width,
            destinationHeight: height,
            context: gl,
            sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
            targetTexture: this.createTexture(gl, width, height),
            originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source),
            passes: filters.length,
            webgl: true,
            aPosition: this.aPosition,
            programCache: this.programCache,
            pass: 0,
            filterBackend: this,
            targetCanvas
          };
          var tempFbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
          filters.forEach(function(filter2) {
            filter2 && filter2.applyTo(pipelineState);
          });
          resizeCanvasIfNeeded(pipelineState);
          this.copyGLTo2D(gl, pipelineState);
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.deleteTexture(pipelineState.sourceTexture);
          gl.deleteTexture(pipelineState.targetTexture);
          gl.deleteFramebuffer(tempFbo);
          targetCanvas.getContext("2d").setTransform(1, 0, 0, 1, 0, 0);
          return pipelineState;
        },
        /**
         * Detach event listeners, remove references, and clean up caches.
         */
        dispose: function() {
          if (this.canvas) {
            this.canvas = null;
            this.gl = null;
          }
          this.clearWebGLCaches();
        },
        /**
         * Wipe out WebGL-related caches.
         */
        clearWebGLCaches: function() {
          this.programCache = {};
          this.textureCache = {};
        },
        /**
         * Create a WebGL texture object.
         *
         * Accepts specific dimensions to initialize the texture to or a source image.
         *
         * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
         * @param {Number} width The width to initialize the texture at.
         * @param {Number} height The height to initialize the texture.
         * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
         * @param {Number} filterType gl.NEAREST or gl.LINEAR usually, webgl numeri constants
         * @returns {WebGLTexture}
         */
        createTexture: function(gl, width, height, textureImageSource, filterType) {
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterType || gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterType || gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          if (textureImageSource) {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          return texture;
        },
        /**
         * Can be optionally used to get a texture from the cache array
         *
         * If an existing texture is not found, a new texture is created and cached.
         *
         * @param {String} uniqueId A cache key to use to find an existing texture.
         * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
         * texture cache entry if one does not already exist.
         */
        getCachedTexture: function(uniqueId, textureImageSource) {
          if (this.textureCache[uniqueId]) {
            return this.textureCache[uniqueId];
          } else {
            var texture = this.createTexture(
              this.gl,
              textureImageSource.width,
              textureImageSource.height,
              textureImageSource
            );
            this.textureCache[uniqueId] = texture;
            return texture;
          }
        },
        /**
         * Clear out cached resources related to a source image that has been
         * filtered previously.
         *
         * @param {String} cacheKey The cache key provided when the source image was filtered.
         */
        evictCachesForKey: function(cacheKey) {
          if (this.textureCache[cacheKey]) {
            this.gl.deleteTexture(this.textureCache[cacheKey]);
            delete this.textureCache[cacheKey];
          }
        },
        copyGLTo2D: copyGLTo2DDrawImage,
        /**
         * Attempt to extract GPU information strings from a WebGL context.
         *
         * Useful information when debugging or blacklisting specific GPUs.
         *
         * @returns {Object} A GPU info object with renderer and vendor strings.
         */
        captureGPUInfo: function() {
          if (this.gpuInfo) {
            return this.gpuInfo;
          }
          var gl = this.gl, gpuInfo = { renderer: "", vendor: "" };
          if (!gl) {
            return gpuInfo;
          }
          var ext = gl.getExtension("WEBGL_debug_renderer_info");
          if (ext) {
            var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
            var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
            if (renderer) {
              gpuInfo.renderer = renderer.toLowerCase();
            }
            if (vendor) {
              gpuInfo.vendor = vendor.toLowerCase();
            }
          }
          this.gpuInfo = gpuInfo;
          return gpuInfo;
        }
      };
    })();
    function resizeCanvasIfNeeded(pipelineState) {
      var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;
      if (width !== dWidth || height !== dHeight) {
        targetCanvas.width = dWidth;
        targetCanvas.height = dHeight;
      }
    }
    function copyGLTo2DDrawImage(gl, pipelineState) {
      var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext("2d");
      ctx.translate(0, targetCanvas.height);
      ctx.scale(1, -1);
      var sourceY = glCanvas.height - targetCanvas.height;
      ctx.drawImage(
        glCanvas,
        0,
        sourceY,
        targetCanvas.width,
        targetCanvas.height,
        0,
        0,
        targetCanvas.width,
        targetCanvas.height
      );
    }
    function copyGLTo2DPutImageData(gl, pipelineState) {
      var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext("2d"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;
      var u82 = new Uint8Array(this.imageBuffer, 0, numBytes);
      var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);
      gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u82);
      var imgData = new ImageData(u8Clamped, dWidth, dHeight);
      ctx.putImageData(imgData, 0, 0);
    }
    (function() {
      var noop2 = function() {
      };
      fabric$1.Canvas2dFilterBackend = Canvas2dFilterBackend;
      function Canvas2dFilterBackend() {
      }
      Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */
      {
        evictCachesForKey: noop2,
        dispose: noop2,
        clearWebGLCaches: noop2,
        /**
         * Experimental. This object is a sort of repository of help layers used to avoid
         * of recreating them during frequent filtering. If you are previewing a filter with
         * a slider you probably do not want to create help layers every filter step.
         * in this object there will be appended some canvases, created once, resized sometimes
         * cleared never. Clearing is left to the developer.
         **/
        resources: {},
        /**
         * Apply a set of filters against a source image and draw the filtered output
         * to the provided destination canvas.
         *
         * @param {EnhancedFilter} filters The filter to apply.
         * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
         * @param {Number} sourceWidth The width of the source input.
         * @param {Number} sourceHeight The height of the source input.
         * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
         */
        applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
          var ctx = targetCanvas.getContext("2d");
          ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
          var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
          var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
          var pipelineState = {
            sourceWidth,
            sourceHeight,
            imageData,
            originalEl: sourceElement,
            originalImageData,
            canvasEl: targetCanvas,
            ctx,
            filterBackend: this
          };
          filters.forEach(function(filter2) {
            filter2.applyTo(pipelineState);
          });
          if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
            targetCanvas.width = pipelineState.imageData.width;
            targetCanvas.height = pipelineState.imageData.height;
          }
          ctx.putImageData(pipelineState.imageData, 0, 0);
          return pipelineState;
        }
      };
    })();
    fabric$1.Image = fabric$1.Image || {};
    fabric$1.Image.filters = fabric$1.Image.filters || {};
    fabric$1.Image.filters.BaseFilter = fabric$1.util.createClass(
      /** @lends fabric.Image.filters.BaseFilter.prototype */
      {
        /**
         * Filter type
         * @param {String} type
         * @default
         */
        type: "BaseFilter",
        /**
         * Array of attributes to send with buffers. do not modify
         * @private
         */
        vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
        fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}",
        /**
         * Constructor
         * @param {Object} [options] Options object
         */
        initialize: function(options) {
          if (options) {
            this.setOptions(options);
          }
        },
        /**
         * Sets filter's properties from options
         * @param {Object} [options] Options object
         */
        setOptions: function(options) {
          for (var prop in options) {
            this[prop] = options[prop];
          }
        },
        /**
         * Compile this filter's shader program.
         *
         * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
         * @param {String} fragmentSource fragmentShader source for compilation
         * @param {String} vertexSource vertexShader source for compilation
         */
        createProgram: function(gl, fragmentSource, vertexSource) {
          fragmentSource = fragmentSource || this.fragmentSource;
          vertexSource = vertexSource || this.vertexSource;
          if (fabric$1.webGlPrecision !== "highp") {
            fragmentSource = fragmentSource.replace(
              /precision highp float/g,
              "precision " + fabric$1.webGlPrecision + " float"
            );
          }
          var vertexShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertexShader, vertexSource);
          gl.compileShader(vertexShader);
          if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
            throw new Error(
              // eslint-disable-next-line prefer-template
              "Vertex shader compile error for " + this.type + ": " + gl.getShaderInfoLog(vertexShader)
            );
          }
          var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragmentShader, fragmentSource);
          gl.compileShader(fragmentShader);
          if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
            throw new Error(
              // eslint-disable-next-line prefer-template
              "Fragment shader compile error for " + this.type + ": " + gl.getShaderInfoLog(fragmentShader)
            );
          }
          var program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(
              // eslint-disable-next-line prefer-template
              'Shader link error for "${this.type}" ' + gl.getProgramInfoLog(program)
            );
          }
          var attributeLocations = this.getAttributeLocations(gl, program);
          var uniformLocations = this.getUniformLocations(gl, program) || {};
          uniformLocations.uStepW = gl.getUniformLocation(program, "uStepW");
          uniformLocations.uStepH = gl.getUniformLocation(program, "uStepH");
          return {
            program,
            attributeLocations,
            uniformLocations
          };
        },
        /**
         * Return a map of attribute names to WebGLAttributeLocation objects.
         *
         * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
         * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
         * @returns {Object} A map of attribute names to attribute locations.
         */
        getAttributeLocations: function(gl, program) {
          return {
            aPosition: gl.getAttribLocation(program, "aPosition")
          };
        },
        /**
         * Return a map of uniform names to WebGLUniformLocation objects.
         *
         * Intended to be overridden by subclasses.
         *
         * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
         * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
         * @returns {Object} A map of uniform names to uniform locations.
         */
        getUniformLocations: function() {
          return {};
        },
        /**
         * Send attribute data from this filter to its shader program on the GPU.
         *
         * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
         * @param {Object} attributeLocations A map of shader attribute names to their locations.
         */
        sendAttributeData: function(gl, attributeLocations, aPositionData) {
          var attributeLocation = attributeLocations.aPosition;
          var buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.enableVertexAttribArray(attributeLocation);
          gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
          gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
        },
        _setupFrameBuffer: function(options) {
          var gl = options.context, width, height;
          if (options.passes > 1) {
            width = options.destinationWidth;
            height = options.destinationHeight;
            if (options.sourceWidth !== width || options.sourceHeight !== height) {
              gl.deleteTexture(options.targetTexture);
              options.targetTexture = options.filterBackend.createTexture(gl, width, height);
            }
            gl.framebufferTexture2D(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0,
              gl.TEXTURE_2D,
              options.targetTexture,
              0
            );
          } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.finish();
          }
        },
        _swapTextures: function(options) {
          options.passes--;
          options.pass++;
          var temp = options.targetTexture;
          options.targetTexture = options.sourceTexture;
          options.sourceTexture = temp;
        },
        /**
         * Generic isNeutral implementation for one parameter based filters.
         * Used only in image applyFilters to discard filters that will not have an effect
         * on the image
         * Other filters may need their own version ( ColorMatrix, HueRotation, gamma, ComposedFilter )
         * @param {Object} options
         **/
        isNeutralState: function() {
          var main = this.mainParameter, _class = fabric$1.Image.filters[this.type].prototype;
          if (main) {
            if (Array.isArray(_class[main])) {
              for (var i2 = _class[main].length; i2--; ) {
                if (this[main][i2] !== _class[main][i2]) {
                  return false;
                }
              }
              return true;
            } else {
              return _class[main] === this[main];
            }
          } else {
            return false;
          }
        },
        /**
         * Apply this filter to the input image data provided.
         *
         * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
         *
         * @param {Object} options
         * @param {Number} options.passes The number of filters remaining to be executed
         * @param {Boolean} options.webgl Whether to use webgl to render the filter.
         * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
         * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        applyTo: function(options) {
          if (options.webgl) {
            this._setupFrameBuffer(options);
            this.applyToWebGL(options);
            this._swapTextures(options);
          } else {
            this.applyTo2d(options);
          }
        },
        /**
         * Retrieves the cached shader.
         * @param {Object} options
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        retrieveShader: function(options) {
          if (!options.programCache.hasOwnProperty(this.type)) {
            options.programCache[this.type] = this.createProgram(options.context);
          }
          return options.programCache[this.type];
        },
        /**
         * Apply this filter using webgl.
         *
         * @param {Object} options
         * @param {Number} options.passes The number of filters remaining to be executed
         * @param {Boolean} options.webgl Whether to use webgl to render the filter.
         * @param {WebGLTexture} options.originalTexture The texture of the original input image.
         * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
         * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
         * @param {WebGLRenderingContext} options.context The GL context used for rendering.
         * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
         */
        applyToWebGL: function(options) {
          var gl = options.context;
          var shader = this.retrieveShader(options);
          if (options.pass === 0 && options.originalTexture) {
            gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
          } else {
            gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
          }
          gl.useProgram(shader.program);
          this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);
          gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
          gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);
          this.sendUniformData(gl, shader.uniformLocations);
          gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        },
        bindAdditionalTexture: function(gl, texture, textureUnit) {
          gl.activeTexture(textureUnit);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.activeTexture(gl.TEXTURE0);
        },
        unbindAdditionalTexture: function(gl, textureUnit) {
          gl.activeTexture(textureUnit);
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.activeTexture(gl.TEXTURE0);
        },
        getMainParameter: function() {
          return this[this.mainParameter];
        },
        setMainParameter: function(value) {
          this[this.mainParameter] = value;
        },
        /**
         * Send uniform data from this filter to its shader program on the GPU.
         *
         * Intended to be overridden by subclasses.
         *
         * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
         * @param {Object} uniformLocations A map of shader uniform names to their locations.
         */
        sendUniformData: function() {
        },
        /**
         * If needed by a 2d filter, this functions can create an helper canvas to be used
         * remember that options.targetCanvas is available for use till end of chain.
         */
        createHelpLayer: function(options) {
          if (!options.helpLayer) {
            var helpLayer = document.createElement("canvas");
            helpLayer.width = options.sourceWidth;
            helpLayer.height = options.sourceHeight;
            options.helpLayer = helpLayer;
          }
        },
        /**
         * Returns object representation of an instance
         * @return {Object} Object representation of an instance
         */
        toObject: function() {
          var object = { type: this.type }, mainP = this.mainParameter;
          if (mainP) {
            object[mainP] = this[mainP];
          }
          return object;
        },
        /**
         * Returns a JSON representation of an instance
         * @return {Object} JSON
         */
        toJSON: function() {
          return this.toObject();
        }
      }
    );
    fabric$1.Image.filters.BaseFilter.fromObject = function(object, callback) {
      var filter2 = new fabric$1.Image.filters[object.type](object);
      callback && callback(filter2);
      return filter2;
    };
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.ColorMatrix = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.ColorMatrix.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "ColorMatrix",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}",
          /**
           * Colormatrix for pixels.
           * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
           * outside the -1, 1 range.
           * 0.0039215686 is the part of 1 that get translated to 1 in 2d
           * @param {Array} matrix array of 20 numbers.
           * @default
           */
          matrix: [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0
          ],
          mainParameter: "matrix",
          /**
           * Lock the colormatrix on the color part, skipping alpha, mainly for non webgl scenario
           * to save some calculation
           * @type Boolean
           * @default true
           */
          colorsOnly: true,
          /**
           * Constructor
           * @param {Object} [options] Options object
           */
          initialize: function(options) {
            this.callSuper("initialize", options);
            this.matrix = this.matrix.slice(0);
          },
          /**
           * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8Array to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, iLen = data.length, m2 = this.matrix, r2, g2, b2, a2, i2, colorsOnly = this.colorsOnly;
            for (i2 = 0; i2 < iLen; i2 += 4) {
              r2 = data[i2];
              g2 = data[i2 + 1];
              b2 = data[i2 + 2];
              if (colorsOnly) {
                data[i2] = r2 * m2[0] + g2 * m2[1] + b2 * m2[2] + m2[4] * 255;
                data[i2 + 1] = r2 * m2[5] + g2 * m2[6] + b2 * m2[7] + m2[9] * 255;
                data[i2 + 2] = r2 * m2[10] + g2 * m2[11] + b2 * m2[12] + m2[14] * 255;
              } else {
                a2 = data[i2 + 3];
                data[i2] = r2 * m2[0] + g2 * m2[1] + b2 * m2[2] + a2 * m2[3] + m2[4] * 255;
                data[i2 + 1] = r2 * m2[5] + g2 * m2[6] + b2 * m2[7] + a2 * m2[8] + m2[9] * 255;
                data[i2 + 2] = r2 * m2[10] + g2 * m2[11] + b2 * m2[12] + a2 * m2[13] + m2[14] * 255;
                data[i2 + 3] = r2 * m2[15] + g2 * m2[16] + b2 * m2[17] + a2 * m2[18] + m2[19] * 255;
              }
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uColorMatrix: gl.getUniformLocation(program, "uColorMatrix"),
              uConstants: gl.getUniformLocation(program, "uConstants")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var m2 = this.matrix, matrix2 = [
              m2[0],
              m2[1],
              m2[2],
              m2[3],
              m2[5],
              m2[6],
              m2[7],
              m2[8],
              m2[10],
              m2[11],
              m2[12],
              m2[13],
              m2[15],
              m2[16],
              m2[17],
              m2[18]
            ], constants = [m2[4], m2[9], m2[14], m2[19]];
            gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix2);
            gl.uniform4fv(uniformLocations.uConstants, constants);
          }
        }
      );
      fabric2.Image.filters.ColorMatrix.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Brightness = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Brightness.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Brightness",
          /**
           * Fragment source for the brightness program
           */
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}",
          /**
           * Brightness value, from -1 to 1.
           * translated to -255 to 255 for 2d
           * 0.0039215686 is the part of 1 that get translated to 1 in 2d
           * @param {Number} brightness
           * @default
           */
          brightness: 0,
          /**
           * Describe the property that is the filter parameter
           * @param {String} m
           * @default
           */
          mainParameter: "brightness",
          /**
          * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
          *
          * @param {Object} options
          * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
          */
          applyTo2d: function(options) {
            if (this.brightness === 0) {
              return;
            }
            var imageData = options.imageData, data = imageData.data, i2, len = data.length, brightness = Math.round(this.brightness * 255);
            for (i2 = 0; i2 < len; i2 += 4) {
              data[i2] = data[i2] + brightness;
              data[i2 + 1] = data[i2 + 1] + brightness;
              data[i2 + 2] = data[i2 + 2] + brightness;
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uBrightness: gl.getUniformLocation(program, "uBrightness")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uBrightness, this.brightness);
          }
        }
      );
      fabric2.Image.filters.Brightness.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Convolute = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Convolute.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Convolute",
          /*
           * Opaque value (true/false)
           */
          opaque: false,
          /*
           * matrix for the filter, max 9x9
           */
          matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],
          /**
           * Fragment source for the brightness program
           */
          fragmentSource: {
            Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
            Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
            Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
            Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
            Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
            Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
            Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
            Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}"
          },
          /**
           * Constructor
           * @memberOf fabric.Image.filters.Convolute.prototype
           * @param {Object} [options] Options object
           * @param {Boolean} [options.opaque=false] Opaque value (true/false)
           * @param {Array} [options.matrix] Filter matrix
           */
          /**
          * Retrieves the cached shader.
          * @param {Object} options
          * @param {WebGLRenderingContext} options.context The GL context used for rendering.
          * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
          */
          retrieveShader: function(options) {
            var size = Math.sqrt(this.matrix.length);
            var cacheKey = this.type + "_" + size + "_" + (this.opaque ? 1 : 0);
            var shaderSource = this.fragmentSource[cacheKey];
            if (!options.programCache.hasOwnProperty(cacheKey)) {
              options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
            }
            return options.programCache[cacheKey];
          },
          /**
           * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, alphaFac = this.opaque ? 1 : 0, r2, g2, b2, a2, dstOff, scx, scy, srcOff, wt2, x2, y2, cx, cy;
            for (y2 = 0; y2 < sh; y2++) {
              for (x2 = 0; x2 < sw; x2++) {
                dstOff = (y2 * sw + x2) * 4;
                r2 = 0;
                g2 = 0;
                b2 = 0;
                a2 = 0;
                for (cy = 0; cy < side; cy++) {
                  for (cx = 0; cx < side; cx++) {
                    scy = y2 + cy - halfSide;
                    scx = x2 + cx - halfSide;
                    if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                      continue;
                    }
                    srcOff = (scy * sw + scx) * 4;
                    wt2 = weights[cy * side + cx];
                    r2 += data[srcOff] * wt2;
                    g2 += data[srcOff + 1] * wt2;
                    b2 += data[srcOff + 2] * wt2;
                    if (!alphaFac) {
                      a2 += data[srcOff + 3] * wt2;
                    }
                  }
                }
                dst[dstOff] = r2;
                dst[dstOff + 1] = g2;
                dst[dstOff + 2] = b2;
                if (!alphaFac) {
                  dst[dstOff + 3] = a2;
                } else {
                  dst[dstOff + 3] = data[dstOff + 3];
                }
              }
            }
            options.imageData = output;
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uMatrix: gl.getUniformLocation(program, "uMatrix"),
              uOpaque: gl.getUniformLocation(program, "uOpaque"),
              uHalfSize: gl.getUniformLocation(program, "uHalfSize"),
              uSize: gl.getUniformLocation(program, "uSize")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return extend2(this.callSuper("toObject"), {
              opaque: this.opaque,
              matrix: this.matrix
            });
          }
        }
      );
      fabric2.Image.filters.Convolute.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Grayscale = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Grayscale.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Grayscale",
          fragmentSource: {
            average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}",
            lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}",
            luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}"
          },
          /**
           * Grayscale mode, between 'average', 'lightness', 'luminosity'
           * @param {String} type
           * @default
           */
          mode: "average",
          mainParameter: "mode",
          /**
           * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8Array to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, i2, len = data.length, value, mode = this.mode;
            for (i2 = 0; i2 < len; i2 += 4) {
              if (mode === "average") {
                value = (data[i2] + data[i2 + 1] + data[i2 + 2]) / 3;
              } else if (mode === "lightness") {
                value = (Math.min(data[i2], data[i2 + 1], data[i2 + 2]) + Math.max(data[i2], data[i2 + 1], data[i2 + 2])) / 2;
              } else if (mode === "luminosity") {
                value = 0.21 * data[i2] + 0.72 * data[i2 + 1] + 0.07 * data[i2 + 2];
              }
              data[i2] = value;
              data[i2 + 1] = value;
              data[i2 + 2] = value;
            }
          },
          /**
           * Retrieves the cached shader.
           * @param {Object} options
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          retrieveShader: function(options) {
            var cacheKey = this.type + "_" + this.mode;
            if (!options.programCache.hasOwnProperty(cacheKey)) {
              var shaderSource = this.fragmentSource[this.mode];
              options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
            }
            return options.programCache[cacheKey];
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uMode: gl.getUniformLocation(program, "uMode")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var mode = 1;
            gl.uniform1i(uniformLocations.uMode, mode);
          },
          /**
           * Grayscale filter isNeutralState implementation
           * The filter is never neutral
           * on the image
           **/
          isNeutralState: function() {
            return false;
          }
        }
      );
      fabric2.Image.filters.Grayscale.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Invert = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Invert.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Invert",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}",
          /**
           * Filter invert. if false, does nothing
           * @param {Boolean} invert
           * @default
           */
          invert: true,
          mainParameter: "invert",
          /**
           * Apply the Invert operation to a Uint8Array representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8Array to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, i2, len = data.length;
            for (i2 = 0; i2 < len; i2 += 4) {
              data[i2] = 255 - data[i2];
              data[i2 + 1] = 255 - data[i2 + 1];
              data[i2 + 2] = 255 - data[i2 + 2];
            }
          },
          /**
           * Invert filter isNeutralState implementation
           * Used only in image applyFilters to discard filters that will not have an effect
           * on the image
           * @param {Object} options
           **/
          isNeutralState: function() {
            return !this.invert;
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uInvert: gl.getUniformLocation(program, "uInvert")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1i(uniformLocations.uInvert, this.invert);
          }
        }
      );
      fabric2.Image.filters.Invert.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Noise = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Noise.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Noise",
          /**
           * Fragment source for the noise program
           */
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}",
          /**
           * Describe the property that is the filter parameter
           * @param {String} m
           * @default
           */
          mainParameter: "noise",
          /**
           * Noise value, from
           * @param {Number} noise
           * @default
           */
          noise: 0,
          /**
           * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            if (this.noise === 0) {
              return;
            }
            var imageData = options.imageData, data = imageData.data, i2, len = data.length, noise = this.noise, rand;
            for (i2 = 0, len = data.length; i2 < len; i2 += 4) {
              rand = (0.5 - Math.random()) * noise;
              data[i2] += rand;
              data[i2 + 1] += rand;
              data[i2 + 2] += rand;
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uNoise: gl.getUniformLocation(program, "uNoise"),
              uSeed: gl.getUniformLocation(program, "uSeed")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
            gl.uniform1f(uniformLocations.uSeed, Math.random());
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return extend2(this.callSuper("toObject"), {
              noise: this.noise
            });
          }
        }
      );
      fabric2.Image.filters.Noise.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Pixelate = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Pixelate.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Pixelate",
          blocksize: 4,
          mainParameter: "blocksize",
          /**
           * Fragment source for the Pixelate program
           */
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}",
          /**
           * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index2, i2, j2, r2, g2, b2, a2, _i, _j, _iLen, _jLen;
            for (i2 = 0; i2 < iLen; i2 += this.blocksize) {
              for (j2 = 0; j2 < jLen; j2 += this.blocksize) {
                index2 = i2 * 4 * jLen + j2 * 4;
                r2 = data[index2];
                g2 = data[index2 + 1];
                b2 = data[index2 + 2];
                a2 = data[index2 + 3];
                _iLen = Math.min(i2 + this.blocksize, iLen);
                _jLen = Math.min(j2 + this.blocksize, jLen);
                for (_i = i2; _i < _iLen; _i++) {
                  for (_j = j2; _j < _jLen; _j++) {
                    index2 = _i * 4 * jLen + _j * 4;
                    data[index2] = r2;
                    data[index2 + 1] = g2;
                    data[index2 + 2] = b2;
                    data[index2 + 3] = a2;
                  }
                }
              }
            }
          },
          /**
           * Indicate when the filter is not gonna apply changes to the image
           **/
          isNeutralState: function() {
            return this.blocksize === 1;
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uBlocksize: gl.getUniformLocation(program, "uBlocksize"),
              uStepW: gl.getUniformLocation(program, "uStepW"),
              uStepH: gl.getUniformLocation(program, "uStepH")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
          }
        }
      );
      fabric2.Image.filters.Pixelate.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.RemoveColor = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.RemoveColor.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "RemoveColor",
          /**
           * Color to remove, in any format understood by fabric.Color.
           * @param {String} type
           * @default
           */
          color: "#FFFFFF",
          /**
           * Fragment source for the brightness program
           */
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}",
          /**
           * distance to actual color, as value up or down from each r,g,b
           * between 0 and 1
           **/
          distance: 0.02,
          /**
           * For color to remove inside distance, use alpha channel for a smoother deletion
           * NOT IMPLEMENTED YET
           **/
          useAlpha: false,
          /**
           * Constructor
           * @memberOf fabric.Image.filters.RemoveWhite.prototype
           * @param {Object} [options] Options object
           * @param {Number} [options.color=#RRGGBB] Threshold value
           * @param {Number} [options.distance=10] Distance value
           */
          /**
           * Applies filter to canvas element
           * @param {Object} canvasEl Canvas element to apply filter to
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, i2, distance2 = this.distance * 255, r2, g2, b2, source = new fabric2.Color(this.color).getSource(), lowC = [
              source[0] - distance2,
              source[1] - distance2,
              source[2] - distance2
            ], highC = [
              source[0] + distance2,
              source[1] + distance2,
              source[2] + distance2
            ];
            for (i2 = 0; i2 < data.length; i2 += 4) {
              r2 = data[i2];
              g2 = data[i2 + 1];
              b2 = data[i2 + 2];
              if (r2 > lowC[0] && g2 > lowC[1] && b2 > lowC[2] && r2 < highC[0] && g2 < highC[1] && b2 < highC[2]) {
                data[i2 + 3] = 0;
              }
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uLow: gl.getUniformLocation(program, "uLow"),
              uHigh: gl.getUniformLocation(program, "uHigh")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var source = new fabric2.Color(this.color).getSource(), distance2 = parseFloat(this.distance), lowC = [
              0 + source[0] / 255 - distance2,
              0 + source[1] / 255 - distance2,
              0 + source[2] / 255 - distance2,
              1
            ], highC = [
              source[0] / 255 + distance2,
              source[1] / 255 + distance2,
              source[2] / 255 + distance2,
              1
            ];
            gl.uniform4fv(uniformLocations.uLow, lowC);
            gl.uniform4fv(uniformLocations.uHigh, highC);
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return extend2(this.callSuper("toObject"), {
              color: this.color,
              distance: this.distance
            });
          }
        }
      );
      fabric2.Image.filters.RemoveColor.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      var matrices = {
        Brownie: [
          0.5997,
          0.34553,
          -0.27082,
          0,
          0.186,
          -0.0377,
          0.86095,
          0.15059,
          0,
          -0.1449,
          0.24113,
          -0.07441,
          0.44972,
          0,
          -0.02965,
          0,
          0,
          0,
          1,
          0
        ],
        Vintage: [
          0.62793,
          0.32021,
          -0.03965,
          0,
          0.03784,
          0.02578,
          0.64411,
          0.03259,
          0,
          0.02926,
          0.0466,
          -0.08512,
          0.52416,
          0,
          0.02023,
          0,
          0,
          0,
          1,
          0
        ],
        Kodachrome: [
          1.12855,
          -0.39673,
          -0.03992,
          0,
          0.24991,
          -0.16404,
          1.08352,
          -0.05498,
          0,
          0.09698,
          -0.16786,
          -0.56034,
          1.60148,
          0,
          0.13972,
          0,
          0,
          0,
          1,
          0
        ],
        Technicolor: [
          1.91252,
          -0.85453,
          -0.09155,
          0,
          0.04624,
          -0.30878,
          1.76589,
          -0.10601,
          0,
          -0.27589,
          -0.2311,
          -0.75018,
          1.84759,
          0,
          0.12137,
          0,
          0,
          0,
          1,
          0
        ],
        Polaroid: [
          1.438,
          -0.062,
          -0.062,
          0,
          0,
          -0.122,
          1.378,
          -0.122,
          0,
          0,
          -0.016,
          -0.016,
          1.483,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        Sepia: [
          0.393,
          0.769,
          0.189,
          0,
          0,
          0.349,
          0.686,
          0.168,
          0,
          0,
          0.272,
          0.534,
          0.131,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ],
        BlackWhite: [
          1.5,
          1.5,
          1.5,
          0,
          -1,
          1.5,
          1.5,
          1.5,
          0,
          -1,
          1.5,
          1.5,
          1.5,
          0,
          -1,
          0,
          0,
          0,
          1,
          0
        ]
      };
      for (var key in matrices) {
        filters[key] = createClass(
          filters.ColorMatrix,
          /** @lends fabric.Image.filters.Sepia.prototype */
          {
            /**
             * Filter type
             * @param {String} type
             * @default
             */
            type: key,
            /**
             * Colormatrix for the effect
             * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
             * outside the -1, 1 range.
             * @param {Array} matrix array of 20 numbers.
             * @default
             */
            matrix: matrices[key],
            /**
             * Lock the matrix export for this kind of static, parameter less filters.
             */
            mainParameter: false,
            /**
             * Lock the colormatrix on the color part, skipping alpha
             */
            colorsOnly: true
          }
        );
        fabric2.Image.filters[key].fromObject = fabric2.Image.filters.BaseFilter.fromObject;
      }
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.BlendColor = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Blend.prototype */
        {
          type: "BlendColor",
          /**
           * Color to make the blend operation with. default to a reddish color since black or white
           * gives always strong result.
           * @type String
           * @default
           **/
          color: "#F95C63",
          /**
           * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
           * darken, lighten, overlay, exclusion, tint.
           * @type String
           * @default
           **/
          mode: "multiply",
          /**
           * alpha value. represent the strength of the blend color operation.
           * @type Number
           * @default
           **/
          alpha: 1,
          /**
           * Fragment source for the Multiply program
           */
          fragmentSource: {
            multiply: "gl_FragColor.rgb *= uColor.rgb;\n",
            screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",
            add: "gl_FragColor.rgb += uColor.rgb;\n",
            diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",
            subtract: "gl_FragColor.rgb -= uColor.rgb;\n",
            lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",
            darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",
            exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",
            overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n",
            tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n"
          },
          /**
           * build the fragment source for the filters, joining the common part with
           * the specific one.
           * @param {String} mode the mode of the filter, a key of this.fragmentSource
           * @return {String} the source to be compiled
           * @private
           */
          buildSource: function(mode) {
            return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[mode] + "}\n}";
          },
          /**
           * Retrieves the cached shader.
           * @param {Object} options
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          retrieveShader: function(options) {
            var cacheKey = this.type + "_" + this.mode, shaderSource;
            if (!options.programCache.hasOwnProperty(cacheKey)) {
              shaderSource = this.buildSource(this.mode);
              options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
            }
            return options.programCache[cacheKey];
          },
          /**
           * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r2, g2, b2, source, alpha1 = 1 - this.alpha;
            source = new fabric2.Color(this.color).getSource();
            tr = source[0] * this.alpha;
            tg = source[1] * this.alpha;
            tb = source[2] * this.alpha;
            for (var i2 = 0; i2 < iLen; i2 += 4) {
              r2 = data[i2];
              g2 = data[i2 + 1];
              b2 = data[i2 + 2];
              switch (this.mode) {
                case "multiply":
                  data[i2] = r2 * tr / 255;
                  data[i2 + 1] = g2 * tg / 255;
                  data[i2 + 2] = b2 * tb / 255;
                  break;
                case "screen":
                  data[i2] = 255 - (255 - r2) * (255 - tr) / 255;
                  data[i2 + 1] = 255 - (255 - g2) * (255 - tg) / 255;
                  data[i2 + 2] = 255 - (255 - b2) * (255 - tb) / 255;
                  break;
                case "add":
                  data[i2] = r2 + tr;
                  data[i2 + 1] = g2 + tg;
                  data[i2 + 2] = b2 + tb;
                  break;
                case "diff":
                case "difference":
                  data[i2] = Math.abs(r2 - tr);
                  data[i2 + 1] = Math.abs(g2 - tg);
                  data[i2 + 2] = Math.abs(b2 - tb);
                  break;
                case "subtract":
                  data[i2] = r2 - tr;
                  data[i2 + 1] = g2 - tg;
                  data[i2 + 2] = b2 - tb;
                  break;
                case "darken":
                  data[i2] = Math.min(r2, tr);
                  data[i2 + 1] = Math.min(g2, tg);
                  data[i2 + 2] = Math.min(b2, tb);
                  break;
                case "lighten":
                  data[i2] = Math.max(r2, tr);
                  data[i2 + 1] = Math.max(g2, tg);
                  data[i2 + 2] = Math.max(b2, tb);
                  break;
                case "overlay":
                  data[i2] = tr < 128 ? 2 * r2 * tr / 255 : 255 - 2 * (255 - r2) * (255 - tr) / 255;
                  data[i2 + 1] = tg < 128 ? 2 * g2 * tg / 255 : 255 - 2 * (255 - g2) * (255 - tg) / 255;
                  data[i2 + 2] = tb < 128 ? 2 * b2 * tb / 255 : 255 - 2 * (255 - b2) * (255 - tb) / 255;
                  break;
                case "exclusion":
                  data[i2] = tr + r2 - 2 * tr * r2 / 255;
                  data[i2 + 1] = tg + g2 - 2 * tg * g2 / 255;
                  data[i2 + 2] = tb + b2 - 2 * tb * b2 / 255;
                  break;
                case "tint":
                  data[i2] = tr + r2 * alpha1;
                  data[i2 + 1] = tg + g2 * alpha1;
                  data[i2 + 2] = tb + b2 * alpha1;
              }
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uColor: gl.getUniformLocation(program, "uColor")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var source = new fabric2.Color(this.color).getSource();
            source[0] = this.alpha * source[0] / 255;
            source[1] = this.alpha * source[1] / 255;
            source[2] = this.alpha * source[2] / 255;
            source[3] = this.alpha;
            gl.uniform4fv(uniformLocations.uColor, source);
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return {
              type: this.type,
              color: this.color,
              mode: this.mode,
              alpha: this.alpha
            };
          }
        }
      );
      fabric2.Image.filters.BlendColor.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.BlendImage = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.BlendImage.prototype */
        {
          type: "BlendImage",
          /**
           * Color to make the blend operation with. default to a reddish color since black or white
           * gives always strong result.
           **/
          image: null,
          /**
           * Blend mode for the filter (one of "multiply", "mask")
           * @type String
           * @default
           **/
          mode: "multiply",
          /**
           * alpha value. represent the strength of the blend image operation.
           * not implemented.
           **/
          alpha: 1,
          vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
          /**
           * Fragment source for the Multiply program
           */
          fragmentSource: {
            multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}",
            mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}"
          },
          /**
           * Retrieves the cached shader.
           * @param {Object} options
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          retrieveShader: function(options) {
            var cacheKey = this.type + "_" + this.mode;
            var shaderSource = this.fragmentSource[this.mode];
            if (!options.programCache.hasOwnProperty(cacheKey)) {
              options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
            }
            return options.programCache[cacheKey];
          },
          applyToWebGL: function(options) {
            var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);
            this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
            this.callSuper("applyToWebGL", options);
            this.unbindAdditionalTexture(gl, gl.TEXTURE1);
          },
          createTexture: function(backend, image2) {
            return backend.getCachedTexture(image2.cacheKey, image2._element);
          },
          /**
           * Calculate a transformMatrix to adapt the image to blend over
           * @param {Object} options
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          calculateMatrix: function() {
            var image2 = this.image, width = image2._element.width, height = image2._element.height;
            return [
              1 / image2.scaleX,
              0,
              0,
              0,
              1 / image2.scaleY,
              0,
              -image2.left / width,
              -image2.top / height,
              1
            ];
          },
          /**
           * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r2, g2, b2, a2, canvas1, context, image2 = this.image, blendData;
            if (!resources.blendImage) {
              resources.blendImage = fabric2.util.createCanvasElement();
            }
            canvas1 = resources.blendImage;
            context = canvas1.getContext("2d");
            if (canvas1.width !== width || canvas1.height !== height) {
              canvas1.width = width;
              canvas1.height = height;
            } else {
              context.clearRect(0, 0, width, height);
            }
            context.setTransform(image2.scaleX, 0, 0, image2.scaleY, image2.left, image2.top);
            context.drawImage(image2._element, 0, 0, width, height);
            blendData = context.getImageData(0, 0, width, height).data;
            for (var i2 = 0; i2 < iLen; i2 += 4) {
              r2 = data[i2];
              g2 = data[i2 + 1];
              b2 = data[i2 + 2];
              a2 = data[i2 + 3];
              tr = blendData[i2];
              tg = blendData[i2 + 1];
              tb = blendData[i2 + 2];
              ta = blendData[i2 + 3];
              switch (this.mode) {
                case "multiply":
                  data[i2] = r2 * tr / 255;
                  data[i2 + 1] = g2 * tg / 255;
                  data[i2 + 2] = b2 * tb / 255;
                  data[i2 + 3] = a2 * ta / 255;
                  break;
                case "mask":
                  data[i2 + 3] = ta;
                  break;
              }
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uTransformMatrix: gl.getUniformLocation(program, "uTransformMatrix"),
              uImage: gl.getUniformLocation(program, "uImage")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var matrix2 = this.calculateMatrix();
            gl.uniform1i(uniformLocations.uImage, 1);
            gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix2);
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return {
              type: this.type,
              image: this.image && this.image.toObject(),
              mode: this.mode,
              alpha: this.alpha
            };
          }
        }
      );
      fabric2.Image.filters.BlendImage.fromObject = function(object, callback) {
        fabric2.Image.fromObject(object.image, function(image2) {
          var options = fabric2.util.object.clone(object);
          options.image = image2;
          callback(new fabric2.Image.filters.BlendImage(options));
        });
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Resize = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Resize.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Resize",
          /**
           * Resize type
           * for webgl resizeType is just lanczos, for canvas2d can be:
           * bilinear, hermite, sliceHack, lanczos.
           * @param {String} resizeType
           * @default
           */
          resizeType: "hermite",
          /**
           * Scale factor for resizing, x axis
           * @param {Number} scaleX
           * @default
           */
          scaleX: 1,
          /**
           * Scale factor for resizing, y axis
           * @param {Number} scaleY
           * @default
           */
          scaleY: 1,
          /**
           * LanczosLobes parameter for lanczos filter, valid for resizeType lanczos
           * @param {Number} lanczosLobes
           * @default
           */
          lanczosLobes: 3,
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uDelta: gl.getUniformLocation(program, "uDelta"),
              uTaps: gl.getUniformLocation(program, "uTaps")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
            gl.uniform1fv(uniformLocations.uTaps, this.taps);
          },
          /**
           * Retrieves the cached shader.
           * @param {Object} options
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          retrieveShader: function(options) {
            var filterWindow = this.getFilterWindow(), cacheKey = this.type + "_" + filterWindow;
            if (!options.programCache.hasOwnProperty(cacheKey)) {
              var fragmentShader = this.generateShader(filterWindow);
              options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
            }
            return options.programCache[cacheKey];
          },
          getFilterWindow: function() {
            var scale = this.tempScale;
            return Math.ceil(this.lanczosLobes / scale);
          },
          getTaps: function() {
            var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
            for (var i2 = 1; i2 <= filterWindow; i2++) {
              taps[i2 - 1] = lobeFunction(i2 * scale);
            }
            return taps;
          },
          /**
           * Generate vertex and shader sources from the necessary steps numbers
           * @param {Number} filterWindow
           */
          generateShader: function(filterWindow) {
            var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;
            for (var i2 = 1; i2 <= filterWindow; i2++) {
              offsets[i2 - 1] = i2 + ".0 * uDelta";
            }
            fragmentShader += "uniform float uTaps[" + filterWindow + "];\n";
            fragmentShader += "void main() {\n";
            fragmentShader += "  vec4 color = texture2D(uTexture, vTexCoord);\n";
            fragmentShader += "  float sum = 1.0;\n";
            offsets.forEach(function(offset, i3) {
              fragmentShader += "  color += texture2D(uTexture, vTexCoord + " + offset + ") * uTaps[" + i3 + "];\n";
              fragmentShader += "  color += texture2D(uTexture, vTexCoord - " + offset + ") * uTaps[" + i3 + "];\n";
              fragmentShader += "  sum += 2.0 * uTaps[" + i3 + "];\n";
            });
            fragmentShader += "  gl_FragColor = color / sum;\n";
            fragmentShader += "}";
            return fragmentShader;
          },
          fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n",
          /**
           * Apply the resize filter to the image
           * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
           *
           * @param {Object} options
           * @param {Number} options.passes The number of filters remaining to be executed
           * @param {Boolean} options.webgl Whether to use webgl to render the filter.
           * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
           * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          applyTo: function(options) {
            if (options.webgl) {
              options.passes++;
              this.width = options.sourceWidth;
              this.horizontal = true;
              this.dW = Math.round(this.width * this.scaleX);
              this.dH = options.sourceHeight;
              this.tempScale = this.dW / this.width;
              this.taps = this.getTaps();
              options.destinationWidth = this.dW;
              this._setupFrameBuffer(options);
              this.applyToWebGL(options);
              this._swapTextures(options);
              options.sourceWidth = options.destinationWidth;
              this.height = options.sourceHeight;
              this.horizontal = false;
              this.dH = Math.round(this.height * this.scaleY);
              this.tempScale = this.dH / this.height;
              this.taps = this.getTaps();
              options.destinationHeight = this.dH;
              this._setupFrameBuffer(options);
              this.applyToWebGL(options);
              this._swapTextures(options);
              options.sourceHeight = options.destinationHeight;
            } else {
              this.applyTo2d(options);
            }
          },
          isNeutralState: function() {
            return this.scaleX === 1 && this.scaleY === 1;
          },
          lanczosCreate: function(lobes) {
            return function(x2) {
              if (x2 >= lobes || x2 <= -lobes) {
                return 0;
              }
              if (x2 < 11920929e-14 && x2 > -11920929e-14) {
                return 1;
              }
              x2 *= Math.PI;
              var xx = x2 / lobes;
              return sin(x2) / x2 * sin(xx) / xx;
            };
          },
          /**
           * Applies filter to canvas element
           * @memberOf fabric.Image.filters.Resize.prototype
           * @param {Object} canvasEl Canvas element to apply filter to
           * @param {Number} scaleX
           * @param {Number} scaleY
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;
            this.rcpScaleX = 1 / scaleX;
            this.rcpScaleY = 1 / scaleY;
            var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;
            if (this.resizeType === "sliceHack") {
              newData = this.sliceByTwo(options, oW, oH, dW, dH);
            } else if (this.resizeType === "hermite") {
              newData = this.hermiteFastResize(options, oW, oH, dW, dH);
            } else if (this.resizeType === "bilinear") {
              newData = this.bilinearFiltering(options, oW, oH, dW, dH);
            } else if (this.resizeType === "lanczos") {
              newData = this.lanczosResize(options, oW, oH, dW, dH);
            }
            options.imageData = newData;
          },
          /**
           * Filter sliceByTwo
           * @param {Object} canvasEl Canvas element to apply filter to
           * @param {Number} oW Original Width
           * @param {Number} oH Original Height
           * @param {Number} dW Destination Width
           * @param {Number} dH Destination Height
           * @returns {ImageData}
           */
          sliceByTwo: function(options, oW, oH, dW, dH) {
            var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric2.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
            if (!resources.sliceByTwo) {
              resources.sliceByTwo = document.createElement("canvas");
            }
            tmpCanvas = resources.sliceByTwo;
            if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
              tmpCanvas.width = oW * 1.5;
              tmpCanvas.height = oH;
            }
            ctx = tmpCanvas.getContext("2d");
            ctx.clearRect(0, 0, oW * 1.5, oH);
            ctx.putImageData(imageData, 0, 0);
            dW = floor(dW);
            dH = floor(dH);
            while (!doneW || !doneH) {
              oW = stepW;
              oH = stepH;
              if (dW < floor(stepW * mult)) {
                stepW = floor(stepW * mult);
              } else {
                stepW = dW;
                doneW = true;
              }
              if (dH < floor(stepH * mult)) {
                stepH = floor(stepH * mult);
              } else {
                stepH = dH;
                doneH = true;
              }
              ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
              sX = dX;
              sY = dY;
              dY += stepH;
            }
            return ctx.getImageData(sX, sY, dW, dH);
          },
          /**
           * Filter lanczosResize
           * @param {Object} canvasEl Canvas element to apply filter to
           * @param {Number} oW Original Width
           * @param {Number} oH Original Height
           * @param {Number} dW Destination Width
           * @param {Number} dH Destination Height
           * @returns {ImageData}
           */
          lanczosResize: function(options, oW, oH, dW, dH) {
            function process2(u2) {
              var v2, i2, weight, idx, a2, red, green, blue, alpha, fX, fY;
              center.x = (u2 + 0.5) * ratioX;
              icenter.x = floor(center.x);
              for (v2 = 0; v2 < dH; v2++) {
                center.y = (v2 + 0.5) * ratioY;
                icenter.y = floor(center.y);
                a2 = 0;
                red = 0;
                green = 0;
                blue = 0;
                alpha = 0;
                for (i2 = icenter.x - range2X; i2 <= icenter.x + range2X; i2++) {
                  if (i2 < 0 || i2 >= oW) {
                    continue;
                  }
                  fX = floor(1e3 * abs(i2 - center.x));
                  if (!cacheLanc[fX]) {
                    cacheLanc[fX] = {};
                  }
                  for (var j2 = icenter.y - range2Y; j2 <= icenter.y + range2Y; j2++) {
                    if (j2 < 0 || j2 >= oH) {
                      continue;
                    }
                    fY = floor(1e3 * abs(j2 - center.y));
                    if (!cacheLanc[fX][fY]) {
                      cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1e3);
                    }
                    weight = cacheLanc[fX][fY];
                    if (weight > 0) {
                      idx = (j2 * oW + i2) * 4;
                      a2 += weight;
                      red += weight * srcData[idx];
                      green += weight * srcData[idx + 1];
                      blue += weight * srcData[idx + 2];
                      alpha += weight * srcData[idx + 3];
                    }
                  }
                }
                idx = (v2 * dW + u2) * 4;
                destData[idx] = red / a2;
                destData[idx + 1] = green / a2;
                destData[idx + 2] = blue / a2;
                destData[idx + 3] = alpha / a2;
              }
              if (++u2 < dW) {
                return process2(u2);
              } else {
                return destImg;
              }
            }
            var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};
            return process2(0);
          },
          /**
           * bilinearFiltering
           * @param {Object} canvasEl Canvas element to apply filter to
           * @param {Number} oW Original Width
           * @param {Number} oH Original Height
           * @param {Number} dW Destination Width
           * @param {Number} dH Destination Height
           * @returns {ImageData}
           */
          bilinearFiltering: function(options, oW, oH, dW, dH) {
            var a2, b2, c2, d2, x2, y2, i2, j2, xDiff, yDiff, chnl, color2, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;
            for (i2 = 0; i2 < dH; i2++) {
              for (j2 = 0; j2 < dW; j2++) {
                x2 = floor(ratioX * j2);
                y2 = floor(ratioY * i2);
                xDiff = ratioX * j2 - x2;
                yDiff = ratioY * i2 - y2;
                origPix = 4 * (y2 * oW + x2);
                for (chnl = 0; chnl < 4; chnl++) {
                  a2 = pixels[origPix + chnl];
                  b2 = pixels[origPix + 4 + chnl];
                  c2 = pixels[origPix + w4 + chnl];
                  d2 = pixels[origPix + w4 + 4 + chnl];
                  color2 = a2 * (1 - xDiff) * (1 - yDiff) + b2 * xDiff * (1 - yDiff) + c2 * yDiff * (1 - xDiff) + d2 * xDiff * yDiff;
                  destPixels[offset++] = color2;
                }
              }
            }
            return destImage;
          },
          /**
           * hermiteFastResize
           * @param {Object} canvasEl Canvas element to apply filter to
           * @param {Number} oW Original Width
           * @param {Number} oH Original Height
           * @param {Number} dW Destination Width
           * @param {Number} dH Destination Height
           * @returns {ImageData}
           */
          hermiteFastResize: function(options, oW, oH, dW, dH) {
            var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
            for (var j2 = 0; j2 < dH; j2++) {
              for (var i2 = 0; i2 < dW; i2++) {
                var x2 = (i2 + j2 * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j2 + 0.5) * ratioH;
                for (var yy = floor(j2 * ratioH); yy < (j2 + 1) * ratioH; yy++) {
                  var dy = abs(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i2 + 0.5) * ratioW, w0 = dy * dy;
                  for (var xx = floor(i2 * ratioW); xx < (i2 + 1) * ratioW; xx++) {
                    var dx = abs(centerX - (xx + 0.5)) / ratioWHalf, w2 = sqrt(w0 + dx * dx);
                    if (w2 > 1 && w2 < -1) {
                      continue;
                    }
                    weight = 2 * w2 * w2 * w2 - 3 * w2 * w2 + 1;
                    if (weight > 0) {
                      dx = 4 * (xx + yy * oW);
                      gxA += weight * data[dx + 3];
                      weightsAlpha += weight;
                      if (data[dx + 3] < 255) {
                        weight = weight * data[dx + 3] / 250;
                      }
                      gxR += weight * data[dx];
                      gxG += weight * data[dx + 1];
                      gxB += weight * data[dx + 2];
                      weights += weight;
                    }
                  }
                }
                data2[x2] = gxR / weights;
                data2[x2 + 1] = gxG / weights;
                data2[x2 + 2] = gxB / weights;
                data2[x2 + 3] = gxA / weightsAlpha;
              }
            }
            return img2;
          },
          /**
           * Returns object representation of an instance
           * @return {Object} Object representation of an instance
           */
          toObject: function() {
            return {
              type: this.type,
              scaleX: this.scaleX,
              scaleY: this.scaleY,
              resizeType: this.resizeType,
              lanczosLobes: this.lanczosLobes
            };
          }
        }
      );
      fabric2.Image.filters.Resize.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Contrast = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Contrast.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Contrast",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}",
          /**
           * contrast value, range from -1 to 1.
           * @param {Number} contrast
           * @default 0
           */
          contrast: 0,
          mainParameter: "contrast",
          /**
           * Constructor
           * @memberOf fabric.Image.filters.Contrast.prototype
           * @param {Object} [options] Options object
           * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
           */
          /**
            * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
            *
            * @param {Object} options
            * @param {ImageData} options.imageData The Uint8Array to be filtered.
            */
          applyTo2d: function(options) {
            if (this.contrast === 0) {
              return;
            }
            var imageData = options.imageData, i2, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));
            for (i2 = 0; i2 < len; i2 += 4) {
              data[i2] = contrastF * (data[i2] - 128) + 128;
              data[i2 + 1] = contrastF * (data[i2 + 1] - 128) + 128;
              data[i2 + 2] = contrastF * (data[i2 + 2] - 128) + 128;
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uContrast: gl.getUniformLocation(program, "uContrast")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uContrast, this.contrast);
          }
        }
      );
      fabric2.Image.filters.Contrast.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Saturation = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Saturation.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Saturation",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}",
          /**
           * Saturation value, from -1 to 1.
           * Increases/decreases the color saturation.
           * A value of 0 has no effect.
           * 
           * @param {Number} saturation
           * @default
           */
          saturation: 0,
          mainParameter: "saturation",
          /**
           * Constructor
           * @memberOf fabric.Image.filters.Saturate.prototype
           * @param {Object} [options] Options object
           * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
           */
          /**
           * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            if (this.saturation === 0) {
              return;
            }
            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i2, max;
            for (i2 = 0; i2 < len; i2 += 4) {
              max = Math.max(data[i2], data[i2 + 1], data[i2 + 2]);
              data[i2] += max !== data[i2] ? (max - data[i2]) * adjust : 0;
              data[i2 + 1] += max !== data[i2 + 1] ? (max - data[i2 + 1]) * adjust : 0;
              data[i2 + 2] += max !== data[i2 + 2] ? (max - data[i2 + 2]) * adjust : 0;
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uSaturation: gl.getUniformLocation(program, "uSaturation")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
          }
        }
      );
      fabric2.Image.filters.Saturation.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Vibrance = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Vibrance.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Vibrance",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uVibrance;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat max = max(color.r, max(color.g, color.b));\nfloat avg = (color.r + color.g + color.b) / 3.0;\nfloat amt = (abs(max - avg) * 2.0) * uVibrance;\ncolor.r += max != color.r ? (max - color.r) * amt : 0.00;\ncolor.g += max != color.g ? (max - color.g) * amt : 0.00;\ncolor.b += max != color.b ? (max - color.b) * amt : 0.00;\ngl_FragColor = color;\n}",
          /**
           * Vibrance value, from -1 to 1.
           * Increases/decreases the saturation of more muted colors with less effect on saturated colors.
           * A value of 0 has no effect.
           * 
           * @param {Number} vibrance
           * @default
           */
          vibrance: 0,
          mainParameter: "vibrance",
          /**
           * Constructor
           * @memberOf fabric.Image.filters.Vibrance.prototype
           * @param {Object} [options] Options object
           * @param {Number} [options.vibrance=0] Vibrance value for the image (between -1 and 1)
           */
          /**
           * Apply the Vibrance operation to a Uint8ClampedArray representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
           */
          applyTo2d: function(options) {
            if (this.vibrance === 0) {
              return;
            }
            var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i2, max, avg, amt;
            for (i2 = 0; i2 < len; i2 += 4) {
              max = Math.max(data[i2], data[i2 + 1], data[i2 + 2]);
              avg = (data[i2] + data[i2 + 1] + data[i2 + 2]) / 3;
              amt = Math.abs(max - avg) * 2 / 255 * adjust;
              data[i2] += max !== data[i2] ? (max - data[i2]) * amt : 0;
              data[i2 + 1] += max !== data[i2 + 1] ? (max - data[i2 + 1]) * amt : 0;
              data[i2 + 2] += max !== data[i2 + 2] ? (max - data[i2 + 2]) * amt : 0;
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uVibrance: gl.getUniformLocation(program, "uVibrance")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);
          }
        }
      );
      fabric2.Image.filters.Vibrance.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Blur = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Blur.prototype */
        {
          type: "Blur",
          /*
          'gl_FragColor = vec4(0.0);',
          'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
          'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
          'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
          'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
          'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
          'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
          'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
          'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
          'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
          'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
          'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
          'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
          'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
          'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
          'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
          */
          /* eslint-disable max-len */
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}",
          /* eslint-enable max-len */
          /**
           * blur value, in percentage of image dimensions.
           * specific to keep the image blur constant at different resolutions
           * range between 0 and 1.
           * @type Number
           * @default
           */
          blur: 0,
          mainParameter: "blur",
          applyTo: function(options) {
            if (options.webgl) {
              this.aspectRatio = options.sourceWidth / options.sourceHeight;
              options.passes++;
              this._setupFrameBuffer(options);
              this.horizontal = true;
              this.applyToWebGL(options);
              this._swapTextures(options);
              this._setupFrameBuffer(options);
              this.horizontal = false;
              this.applyToWebGL(options);
              this._swapTextures(options);
            } else {
              this.applyTo2d(options);
            }
          },
          applyTo2d: function(options) {
            options.imageData = this.simpleBlur(options);
          },
          simpleBlur: function(options) {
            var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;
            if (!resources.blurLayer1) {
              resources.blurLayer1 = fabric2.util.createCanvasElement();
              resources.blurLayer2 = fabric2.util.createCanvasElement();
            }
            canvas1 = resources.blurLayer1;
            canvas2 = resources.blurLayer2;
            if (canvas1.width !== width || canvas1.height !== height) {
              canvas2.width = canvas1.width = width;
              canvas2.height = canvas1.height = height;
            }
            var ctx1 = canvas1.getContext("2d"), ctx2 = canvas2.getContext("2d"), nSamples = 15, random, percent, j2, i2, blur = this.blur * 0.06 * 0.5;
            ctx1.putImageData(options.imageData, 0, 0);
            ctx2.clearRect(0, 0, width, height);
            for (i2 = -nSamples; i2 <= nSamples; i2++) {
              random = (Math.random() - 0.5) / 4;
              percent = i2 / nSamples;
              j2 = blur * percent * width + random;
              ctx2.globalAlpha = 1 - Math.abs(percent);
              ctx2.drawImage(canvas1, j2, random);
              ctx1.drawImage(canvas2, 0, 0);
              ctx2.globalAlpha = 1;
              ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            }
            for (i2 = -nSamples; i2 <= nSamples; i2++) {
              random = (Math.random() - 0.5) / 4;
              percent = i2 / nSamples;
              j2 = blur * percent * height + random;
              ctx2.globalAlpha = 1 - Math.abs(percent);
              ctx2.drawImage(canvas1, random, j2);
              ctx1.drawImage(canvas2, 0, 0);
              ctx2.globalAlpha = 1;
              ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
            }
            options.ctx.drawImage(canvas1, 0, 0);
            var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
            ctx1.globalAlpha = 1;
            ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
            return newImageData;
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              delta: gl.getUniformLocation(program, "uDelta")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            var delta = this.chooseRightDelta();
            gl.uniform2fv(uniformLocations.delta, delta);
          },
          /**
           * choose right value of image percentage to blur with
           * @returns {Array} a numeric array with delta values
           */
          chooseRightDelta: function() {
            var blurScale = 1, delta = [0, 0], blur;
            if (this.horizontal) {
              if (this.aspectRatio > 1) {
                blurScale = 1 / this.aspectRatio;
              }
            } else {
              if (this.aspectRatio < 1) {
                blurScale = this.aspectRatio;
              }
            }
            blur = blurScale * this.blur * 0.12;
            if (this.horizontal) {
              delta[0] = blur;
            } else {
              delta[1] = blur;
            }
            return delta;
          }
        }
      );
      filters.Blur.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Gamma = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Gamma.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "Gamma",
          fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}",
          /**
           * Gamma array value, from 0.01 to 2.2.
           * @param {Array} gamma
           * @default
           */
          gamma: [1, 1, 1],
          /**
           * Describe the property that is the filter parameter
           * @param {String} m
           * @default
           */
          mainParameter: "gamma",
          /**
           * Constructor
           * @param {Object} [options] Options object
           */
          initialize: function(options) {
            this.gamma = [1, 1, 1];
            filters.BaseFilter.prototype.initialize.call(this, options);
          },
          /**
           * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
           *
           * @param {Object} options
           * @param {ImageData} options.imageData The Uint8Array to be filtered.
           */
          applyTo2d: function(options) {
            var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i2;
            if (!this.rVals) {
              this.rVals = new Uint8Array(256);
              this.gVals = new Uint8Array(256);
              this.bVals = new Uint8Array(256);
            }
            for (i2 = 0, len = 256; i2 < len; i2++) {
              this.rVals[i2] = Math.pow(i2 / 255, rInv) * 255;
              this.gVals[i2] = Math.pow(i2 / 255, gInv) * 255;
              this.bVals[i2] = Math.pow(i2 / 255, bInv) * 255;
            }
            for (i2 = 0, len = data.length; i2 < len; i2 += 4) {
              data[i2] = this.rVals[data[i2]];
              data[i2 + 1] = this.gVals[data[i2 + 1]];
              data[i2 + 2] = this.bVals[data[i2 + 2]];
            }
          },
          /**
           * Return WebGL uniform locations for this filter's shader.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {WebGLShaderProgram} program This filter's compiled shader program.
           */
          getUniformLocations: function(gl, program) {
            return {
              uGamma: gl.getUniformLocation(program, "uGamma")
            };
          },
          /**
           * Send data from this filter to its shader program's uniforms.
           *
           * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
           * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
           */
          sendUniformData: function(gl, uniformLocations) {
            gl.uniform3fv(uniformLocations.uGamma, this.gamma);
          }
        }
      );
      fabric2.Image.filters.Gamma.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.Composed = createClass(
        filters.BaseFilter,
        /** @lends fabric.Image.filters.Composed.prototype */
        {
          type: "Composed",
          /**
           * A non sparse array of filters to apply
           */
          subFilters: [],
          /**
           * Constructor
           * @param {Object} [options] Options object
           */
          initialize: function(options) {
            this.callSuper("initialize", options);
            this.subFilters = this.subFilters.slice(0);
          },
          /**
           * Apply this container's filters to the input image provided.
           *
           * @param {Object} options
           * @param {Number} options.passes The number of filters remaining to be applied.
           */
          applyTo: function(options) {
            options.passes += this.subFilters.length - 1;
            this.subFilters.forEach(function(filter2) {
              filter2.applyTo(options);
            });
          },
          /**
           * Serialize this filter into JSON.
           *
           * @returns {Object} A JSON representation of this filter.
           */
          toObject: function() {
            return fabric2.util.object.extend(this.callSuper("toObject"), {
              subFilters: this.subFilters.map(function(filter2) {
                return filter2.toObject();
              })
            });
          },
          isNeutralState: function() {
            return !this.subFilters.some(function(filter2) {
              return !filter2.isNeutralState();
            });
          }
        }
      );
      fabric2.Image.filters.Composed.fromObject = function(object, callback) {
        var filters2 = object.subFilters || [], subFilters = filters2.map(function(filter2) {
          return new fabric2.Image.filters[filter2.type](filter2);
        }), instance = new fabric2.Image.filters.Composed({ subFilters });
        callback && callback(instance);
        return instance;
      };
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
      filters.HueRotation = createClass(
        filters.ColorMatrix,
        /** @lends fabric.Image.filters.HueRotation.prototype */
        {
          /**
           * Filter type
           * @param {String} type
           * @default
           */
          type: "HueRotation",
          /**
           * HueRotation value, from -1 to 1.
           * the unit is radians
           * @param {Number} myParameter
           * @default
           */
          rotation: 0,
          /**
           * Describe the property that is the filter parameter
           * @param {String} m
           * @default
           */
          mainParameter: "rotation",
          calculateMatrix: function() {
            var rad = this.rotation * Math.PI, cos = fabric2.util.cos(rad), sin = fabric2.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
            this.matrix = [
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              1,
              0
            ];
            this.matrix[0] = cos + OneMinusCos / 3;
            this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
            this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
            this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
            this.matrix[6] = cos + aThird * OneMinusCos;
            this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
            this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
            this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
            this.matrix[12] = cos + aThird * OneMinusCos;
          },
          /**
           * HueRotation isNeutralState implementation
           * Used only in image applyFilters to discard filters that will not have an effect
           * on the image
           * @param {Object} options
           **/
          isNeutralState: function(options) {
            this.calculateMatrix();
            return filters.BaseFilter.prototype.isNeutralState.call(this, options);
          },
          /**
           * Apply this filter to the input image data provided.
           *
           * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
           *
           * @param {Object} options
           * @param {Number} options.passes The number of filters remaining to be executed
           * @param {Boolean} options.webgl Whether to use webgl to render the filter.
           * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
           * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
           * @param {WebGLRenderingContext} options.context The GL context used for rendering.
           * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
           */
          applyTo: function(options) {
            this.calculateMatrix();
            filters.BaseFilter.prototype.applyTo.call(this, options);
          }
        }
      );
      fabric2.Image.filters.HueRotation.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
    })(exports);
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {}), clone2 = fabric2.util.object.clone;
      if (fabric2.Text) {
        fabric2.warn("fabric.Text is already defined");
        return;
      }
      var additionalProps = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" ");
      fabric2.Text = fabric2.util.createClass(
        fabric2.Object,
        /** @lends fabric.Text.prototype */
        {
          /**
           * Properties which when set cause object to change dimensions
           * @type Array
           * @private
           */
          _dimensionAffectingProps: [
            "fontSize",
            "fontWeight",
            "fontFamily",
            "fontStyle",
            "lineHeight",
            "text",
            "charSpacing",
            "textAlign",
            "styles",
            "path",
            "pathStartOffset",
            "pathSide",
            "pathAlign"
          ],
          /**
           * @private
           */
          _reNewline: /\r?\n/,
          /**
           * Use this regular expression to filter for whitespaces that is not a new line.
           * Mostly used when text is 'justify' aligned.
           * @private
           */
          _reSpacesAndTabs: /[ \t\r]/g,
          /**
           * Use this regular expression to filter for whitespace that is not a new line.
           * Mostly used when text is 'justify' aligned.
           * @private
           */
          _reSpaceAndTab: /[ \t\r]/,
          /**
           * Use this regular expression to filter consecutive groups of non spaces.
           * Mostly used when text is 'justify' aligned.
           * @private
           */
          _reWords: /\S+/g,
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "text",
          /**
           * Font size (in pixels)
           * @type Number
           * @default
           */
          fontSize: 40,
          /**
           * Font weight (e.g. bold, normal, 400, 600, 800)
           * @type {(Number|String)}
           * @default
           */
          fontWeight: "normal",
          /**
           * Font family
           * @type String
           * @default
           */
          fontFamily: "Times New Roman",
          /**
           * Text decoration underline.
           * @type Boolean
           * @default
           */
          underline: false,
          /**
           * Text decoration overline.
           * @type Boolean
           * @default
           */
          overline: false,
          /**
           * Text decoration linethrough.
           * @type Boolean
           * @default
           */
          linethrough: false,
          /**
           * Text alignment. Possible values: "left", "center", "right", "justify",
           * "justify-left", "justify-center" or "justify-right".
           * @type String
           * @default
           */
          textAlign: "left",
          /**
           * Font style . Possible values: "", "normal", "italic" or "oblique".
           * @type String
           * @default
           */
          fontStyle: "normal",
          /**
           * Line height
           * @type Number
           * @default
           */
          lineHeight: 1.16,
          /**
           * Superscript schema object (minimum overlap)
           * @type {Object}
           * @default
           */
          superscript: {
            size: 0.6,
            // fontSize factor
            baseline: -0.35
            // baseline-shift factor (upwards)
          },
          /**
           * Subscript schema object (minimum overlap)
           * @type {Object}
           * @default
           */
          subscript: {
            size: 0.6,
            // fontSize factor
            baseline: 0.11
            // baseline-shift factor (downwards)
          },
          /**
           * Background color of text lines
           * @type String
           * @default
           */
          textBackgroundColor: "",
          /**
           * List of properties to consider when checking if
           * state of an object is changed ({@link fabric.Object#hasStateChanged})
           * as well as for history (undo/redo) purposes
           * @type Array
           */
          stateProperties: fabric2.Object.prototype.stateProperties.concat(additionalProps),
          /**
           * List of properties to consider when checking if cache needs refresh
           * @type Array
           */
          cacheProperties: fabric2.Object.prototype.cacheProperties.concat(additionalProps),
          /**
           * When defined, an object is rendered via stroke and this property specifies its color.
           * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
           * @type String
           * @default
           */
          stroke: null,
          /**
           * Shadow object representing shadow of this shape.
           * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
           * @type fabric.Shadow
           * @default
           */
          shadow: null,
          /**
           * fabric.Path that the text should follow.
           * since 4.6.0 the path will be drawn automatically.
           * if you want to make the path visible, give it a stroke and strokeWidth or fill value
           * if you want it to be hidden, assign visible = false to the path.
           * This feature is in BETA, and SVG import/export is not yet supported.
           * @type fabric.Path
           * @example
           * var textPath = new fabric.Text('Text on a path', {
           *     top: 150,
           *     left: 150,
           *     textAlign: 'center',
           *     charSpacing: -50,
           *     path: new fabric.Path('M 0 0 C 50 -100 150 -100 200 0', {
           *         strokeWidth: 1,
           *         visible: false
           *     }),
           *     pathSide: 'left',
           *     pathStartOffset: 0
           * });
           * @default
           */
          path: null,
          /**
           * Offset amount for text path starting position
           * Only used when text has a path
           * @type Number
           * @default
           */
          pathStartOffset: 0,
          /**
           * Which side of the path the text should be drawn on.
           * Only used when text has a path
           * @type {String} 'left|right'
           * @default
           */
          pathSide: "left",
          /**
           * How text is aligned to the path. This property determines
           * the perpendicular position of each character relative to the path.
           * (one of "baseline", "center", "ascender", "descender")
           * This feature is in BETA, and its behavior may change
           * @type String
           * @default
           */
          pathAlign: "baseline",
          /**
           * @private
           */
          _fontSizeFraction: 0.222,
          /**
           * @private
           */
          offsets: {
            underline: 0.1,
            linethrough: -0.315,
            overline: -0.88
          },
          /**
           * Text Line proportion to font Size (in pixels)
           * @type Number
           * @default
           */
          _fontSizeMult: 1.13,
          /**
           * additional space between characters
           * expressed in thousands of em unit
           * @type Number
           * @default
           */
          charSpacing: 0,
          /**
           * Object containing character styles - top-level properties -> line numbers,
           * 2nd-level properties - character numbers
           * @type Object
           * @default
           */
          styles: null,
          /**
           * Reference to a context to measure text char or couple of chars
           * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
           * once created it will be referenced on fabric._measuringContext to avoid creating a canvas for every
           * text object created.
           * @type {CanvasRenderingContext2D}
           * @default
           */
          _measuringContext: null,
          /**
           * Baseline shift, styles only, keep at 0 for the main text object
           * @type {Number}
           * @default
           */
          deltaY: 0,
          /**
           * WARNING: EXPERIMENTAL. NOT SUPPORTED YET
           * determine the direction of the text.
           * This has to be set manually together with textAlign and originX for proper
           * experience.
           * some interesting link for the future
           * https://www.w3.org/International/questions/qa-bidi-unicode-controls
           * @since 4.5.0
           * @type {String} 'ltr|rtl'
           * @default
           */
          direction: "ltr",
          /**
           * Array of properties that define a style unit (of 'styles').
           * @type {Array}
           * @default
           */
          _styleProperties: [
            "stroke",
            "strokeWidth",
            "fill",
            "fontFamily",
            "fontSize",
            "fontWeight",
            "fontStyle",
            "underline",
            "overline",
            "linethrough",
            "deltaY",
            "textBackgroundColor"
          ],
          /**
           * contains characters bounding boxes
           */
          __charBounds: [],
          /**
           * use this size when measuring text. To avoid IE11 rounding errors
           * @type {Number}
           * @default
           * @readonly
           * @private
           */
          CACHE_FONT_SIZE: 400,
          /**
           * contains the min text width to avoid getting 0
           * @type {Number}
           * @default
           */
          MIN_TEXT_WIDTH: 2,
          /**
           * Constructor
           * @param {String} text Text string
           * @param {Object} [options] Options object
           * @return {fabric.Text} thisArg
           */
          initialize: function(text2, options) {
            this.styles = options ? options.styles || {} : {};
            this.text = text2;
            this.__skipDimension = true;
            this.callSuper("initialize", options);
            if (this.path) {
              this.setPathInfo();
            }
            this.__skipDimension = false;
            this.initDimensions();
            this.setCoords();
            this.setupState({ propertySet: "_dimensionAffectingProps" });
          },
          /**
           * If text has a path, it will add the extra information needed
           * for path and text calculations
           * @return {fabric.Text} thisArg
           */
          setPathInfo: function() {
            var path2 = this.path;
            if (path2) {
              path2.segmentsInfo = fabric2.util.getPathSegmentsInfo(path2.path);
            }
          },
          /**
           * Return a context for measurement of text string.
           * if created it gets stored for reuse
           * this is for internal use, please do not use it
           * @private
           * @param {String} text Text string
           * @param {Object} [options] Options object
           * @return {fabric.Text} thisArg
           */
          getMeasuringContext: function() {
            if (!fabric2._measuringContext) {
              fabric2._measuringContext = this.canvas && this.canvas.contextCache || fabric2.util.createCanvasElement().getContext("2d");
            }
            return fabric2._measuringContext;
          },
          /**
           * @private
           * Divides text into lines of text and lines of graphemes.
           */
          _splitText: function() {
            var newLines = this._splitTextIntoLines(this.text);
            this.textLines = newLines.lines;
            this._textLines = newLines.graphemeLines;
            this._unwrappedTextLines = newLines._unwrappedLines;
            this._text = newLines.graphemeText;
            return newLines;
          },
          /**
           * Initialize or update text dimensions.
           * Updates this.width and this.height with the proper values.
           * Does not return dimensions.
           */
          initDimensions: function() {
            if (this.__skipDimension) {
              return;
            }
            this._splitText();
            this._clearCache();
            if (this.path) {
              this.width = this.path.width;
              this.height = this.path.height;
            } else {
              this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
              this.height = this.calcTextHeight();
            }
            if (this.textAlign.indexOf("justify") !== -1) {
              this.enlargeSpaces();
            }
            this.saveState({ propertySet: "_dimensionAffectingProps" });
          },
          /**
           * Enlarge space boxes and shift the others
           */
          enlargeSpaces: function() {
            var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              if (this.textAlign !== "justify" && (i2 === len - 1 || this.isEndOfWrapping(i2))) {
                continue;
              }
              accumulatedSpace = 0;
              line = this._textLines[i2];
              currentLineWidth = this.getLineWidth(i2);
              if (currentLineWidth < this.width && (spaces = this.textLines[i2].match(this._reSpacesAndTabs))) {
                numberOfSpaces = spaces.length;
                diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
                for (var j2 = 0, jlen = line.length; j2 <= jlen; j2++) {
                  charBound = this.__charBounds[i2][j2];
                  if (this._reSpaceAndTab.test(line[j2])) {
                    charBound.width += diffSpace;
                    charBound.kernedWidth += diffSpace;
                    charBound.left += accumulatedSpace;
                    accumulatedSpace += diffSpace;
                  } else {
                    charBound.left += accumulatedSpace;
                  }
                }
              }
            }
          },
          /**
           * Detect if the text line is ended with an hard break
           * text and itext do not have wrapping, return false
           * @return {Boolean}
           */
          isEndOfWrapping: function(lineIndex) {
            return lineIndex === this._textLines.length - 1;
          },
          /**
           * Detect if a line has a linebreak and so we need to account for it when moving
           * and counting style.
           * It return always for text and Itext.
           * @return Number
           */
          missingNewlineOffset: function() {
            return 1;
          },
          /**
           * Returns string representation of an instance
           * @return {String} String representation of text object
           */
          toString: function() {
            return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
          },
          /**
           * Return the dimension and the zoom level needed to create a cache canvas
           * big enough to host the object to be cached.
           * @private
           * @param {Object} dim.x width of object to be cached
           * @param {Object} dim.y height of object to be cached
           * @return {Object}.width width of canvas
           * @return {Object}.height height of canvas
           * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
           * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
           */
          _getCacheCanvasDimensions: function() {
            var dims = this.callSuper("_getCacheCanvasDimensions");
            var fontSize2 = this.fontSize;
            dims.width += fontSize2 * dims.zoomX;
            dims.height += fontSize2 * dims.zoomY;
            return dims;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            var path2 = this.path;
            path2 && !path2.isNotVisible() && path2._render(ctx);
            this._setTextStyles(ctx);
            this._renderTextLinesBackground(ctx);
            this._renderTextDecoration(ctx, "underline");
            this._renderText(ctx);
            this._renderTextDecoration(ctx, "overline");
            this._renderTextDecoration(ctx, "linethrough");
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderText: function(ctx) {
            if (this.paintFirst === "stroke") {
              this._renderTextStroke(ctx);
              this._renderTextFill(ctx);
            } else {
              this._renderTextFill(ctx);
              this._renderTextStroke(ctx);
            }
          },
          /**
           * Set the font parameter of the context with the object properties or with charStyle
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Object} [charStyle] object with font style properties
           * @param {String} [charStyle.fontFamily] Font Family
           * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
           * @param {String} [charStyle.fontWeight] Font weight
           * @param {String} [charStyle.fontStyle] Font style (italic|normal)
           */
          _setTextStyles: function(ctx, charStyle, forMeasuring) {
            ctx.textBaseline = "alphabetical";
            if (this.path) {
              switch (this.pathAlign) {
                case "center":
                  ctx.textBaseline = "middle";
                  break;
                case "ascender":
                  ctx.textBaseline = "top";
                  break;
                case "descender":
                  ctx.textBaseline = "bottom";
                  break;
              }
            }
            ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
          },
          /**
           * calculate and return the text Width measuring each line.
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @return {Number} Maximum width of fabric.Text object
           */
          calcTextWidth: function() {
            var maxWidth = this.getLineWidth(0);
            for (var i2 = 1, len = this._textLines.length; i2 < len; i2++) {
              var currentLineWidth = this.getLineWidth(i2);
              if (currentLineWidth > maxWidth) {
                maxWidth = currentLineWidth;
              }
            }
            return maxWidth;
          },
          /**
           * @private
           * @param {String} method Method name ("fillText" or "strokeText")
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {String} line Text to render
           * @param {Number} left Left position of text
           * @param {Number} top Top position of text
           * @param {Number} lineIndex Index of a line in a text
           */
          _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
            this._renderChars(method, ctx, line, left, top, lineIndex);
          },
          /**
           * Renders the text background for lines, taking care of style
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderTextLinesBackground: function(ctx) {
            if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) {
              return;
            }
            var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path2 = this.path, drawStart;
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              heightOfLine = this.getHeightOfLine(i2);
              if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", i2)) {
                lineTopOffset += heightOfLine;
                continue;
              }
              line = this._textLines[i2];
              lineLeftOffset = this._getLineLeftOffset(i2);
              boxWidth = 0;
              boxStart = 0;
              lastColor = this.getValueOfPropertyAt(i2, 0, "textBackgroundColor");
              for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                charBox = this.__charBounds[i2][j2];
                currentColor = this.getValueOfPropertyAt(i2, j2, "textBackgroundColor");
                if (path2) {
                  ctx.save();
                  ctx.translate(charBox.renderLeft, charBox.renderTop);
                  ctx.rotate(charBox.angle);
                  ctx.fillStyle = currentColor;
                  currentColor && ctx.fillRect(
                    -charBox.width / 2,
                    -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction),
                    charBox.width,
                    heightOfLine / this.lineHeight
                  );
                  ctx.restore();
                } else if (currentColor !== lastColor) {
                  drawStart = leftOffset + lineLeftOffset + boxStart;
                  if (this.direction === "rtl") {
                    drawStart = this.width - drawStart - boxWidth;
                  }
                  ctx.fillStyle = lastColor;
                  lastColor && ctx.fillRect(
                    drawStart,
                    lineTopOffset,
                    boxWidth,
                    heightOfLine / this.lineHeight
                  );
                  boxStart = charBox.left;
                  boxWidth = charBox.width;
                  lastColor = currentColor;
                } else {
                  boxWidth += charBox.kernedWidth;
                }
              }
              if (currentColor && !path2) {
                drawStart = leftOffset + lineLeftOffset + boxStart;
                if (this.direction === "rtl") {
                  drawStart = this.width - drawStart - boxWidth;
                }
                ctx.fillStyle = currentColor;
                ctx.fillRect(
                  drawStart,
                  lineTopOffset,
                  boxWidth,
                  heightOfLine / this.lineHeight
                );
              }
              lineTopOffset += heightOfLine;
            }
            ctx.fillStyle = originalFill;
            this._removeShadow(ctx);
          },
          /**
           * @private
           * @param {Object} decl style declaration for cache
           * @param {String} decl.fontFamily fontFamily
           * @param {String} decl.fontStyle fontStyle
           * @param {String} decl.fontWeight fontWeight
           * @return {Object} reference to cache
           */
          getFontCache: function(decl) {
            var fontFamily2 = decl.fontFamily.toLowerCase();
            if (!fabric2.charWidthsCache[fontFamily2]) {
              fabric2.charWidthsCache[fontFamily2] = {};
            }
            var cache = fabric2.charWidthsCache[fontFamily2], cacheProp = decl.fontStyle.toLowerCase() + "_" + (decl.fontWeight + "").toLowerCase();
            if (!cache[cacheProp]) {
              cache[cacheProp] = {};
            }
            return cache[cacheProp];
          },
          /**
           * measure and return the width of a single character.
           * possibly overridden to accommodate different measure logic or
           * to hook some external lib for character measurement
           * @private
           * @param {String} _char, char to be measured
           * @param {Object} charStyle style of char to be measured
           * @param {String} [previousChar] previous char
           * @param {Object} [prevCharStyle] style of previous char
           */
          _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
            var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;
            if (previousChar && fontCache[previousChar] !== void 0) {
              previousWidth = fontCache[previousChar];
            }
            if (fontCache[_char] !== void 0) {
              kernedWidth = width = fontCache[_char];
            }
            if (stylesAreEqual && fontCache[couple] !== void 0) {
              coupleWidth = fontCache[couple];
              kernedWidth = coupleWidth - previousWidth;
            }
            if (width === void 0 || previousWidth === void 0 || coupleWidth === void 0) {
              var ctx = this.getMeasuringContext();
              this._setTextStyles(ctx, charStyle, true);
            }
            if (width === void 0) {
              kernedWidth = width = ctx.measureText(_char).width;
              fontCache[_char] = width;
            }
            if (previousWidth === void 0 && stylesAreEqual && previousChar) {
              previousWidth = ctx.measureText(previousChar).width;
              fontCache[previousChar] = previousWidth;
            }
            if (stylesAreEqual && coupleWidth === void 0) {
              coupleWidth = ctx.measureText(couple).width;
              fontCache[couple] = coupleWidth;
              kernedWidth = coupleWidth - previousWidth;
            }
            return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
          },
          /**
           * Computes height of character at given position
           * @param {Number} line the line index number
           * @param {Number} _char the character index number
           * @return {Number} fontSize of the character
           */
          getHeightOfChar: function(line, _char) {
            return this.getValueOfPropertyAt(line, _char, "fontSize");
          },
          /**
           * measure a text line measuring all characters.
           * @param {Number} lineIndex line number
           * @return {Number} Line width
           */
          measureLine: function(lineIndex) {
            var lineInfo = this._measureLine(lineIndex);
            if (this.charSpacing !== 0) {
              lineInfo.width -= this._getWidthOfCharSpacing();
            }
            if (lineInfo.width < 0) {
              lineInfo.width = 0;
            }
            return lineInfo;
          },
          /**
           * measure every grapheme of a line, populating __charBounds
           * @param {Number} lineIndex
           * @return {Object} object.width total width of characters
           * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
           */
          _measureLine: function(lineIndex) {
            var width = 0, i2, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path2 = this.path, reverse = this.pathSide === "right";
            this.__charBounds[lineIndex] = lineBounds;
            for (i2 = 0; i2 < line.length; i2++) {
              grapheme = line[i2];
              graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i2, prevGrapheme);
              lineBounds[i2] = graphemeInfo;
              width += graphemeInfo.kernedWidth;
              prevGrapheme = grapheme;
            }
            lineBounds[i2] = {
              left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
              width: 0,
              kernedWidth: 0,
              height: this.fontSize
            };
            if (path2) {
              totalPathLength = path2.segmentsInfo[path2.segmentsInfo.length - 1].length;
              startingPoint = fabric2.util.getPointOnPath(path2.path, 0, path2.segmentsInfo);
              startingPoint.x += path2.pathOffset.x;
              startingPoint.y += path2.pathOffset.y;
              switch (this.textAlign) {
                case "left":
                  positionInPath = reverse ? totalPathLength - width : 0;
                  break;
                case "center":
                  positionInPath = (totalPathLength - width) / 2;
                  break;
                case "right":
                  positionInPath = reverse ? 0 : totalPathLength - width;
                  break;
              }
              positionInPath += this.pathStartOffset * (reverse ? -1 : 1);
              for (i2 = reverse ? line.length - 1 : 0; reverse ? i2 >= 0 : i2 < line.length; reverse ? i2-- : i2++) {
                graphemeInfo = lineBounds[i2];
                if (positionInPath > totalPathLength) {
                  positionInPath %= totalPathLength;
                } else if (positionInPath < 0) {
                  positionInPath += totalPathLength;
                }
                this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);
                positionInPath += graphemeInfo.kernedWidth;
              }
            }
            return { width, numOfSpaces };
          },
          /**
           * Calculate the angle  and the left,top position of the char that follow a path.
           * It appends it to graphemeInfo to be reused later at rendering
           * @private
           * @param {Number} positionInPath to be measured
           * @param {Object} graphemeInfo current grapheme box information
           * @param {Object} startingPoint position of the point
           */
          _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {
            var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path2 = this.path;
            var info = fabric2.util.getPointOnPath(path2.path, centerPosition, path2.segmentsInfo);
            graphemeInfo.renderLeft = info.x - startingPoint.x;
            graphemeInfo.renderTop = info.y - startingPoint.y;
            graphemeInfo.angle = info.angle + (this.pathSide === "right" ? Math.PI : 0);
          },
          /**
           * Measure and return the info of a single grapheme.
           * needs the the info of previous graphemes already filled
           * @private
           * @param {String} grapheme to be measured
           * @param {Number} lineIndex index of the line where the char is
           * @param {Number} charIndex position in the line
           * @param {String} [prevGrapheme] character preceding the one to be measured
           */
          _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
            var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;
            if (this.charSpacing !== 0) {
              charSpacing = this._getWidthOfCharSpacing();
              width += charSpacing;
              kernedWidth += charSpacing;
            }
            var box = {
              width,
              left: 0,
              height: style.fontSize,
              kernedWidth,
              deltaY: style.deltaY
            };
            if (charIndex > 0 && !skipLeft) {
              var previousBox = this.__charBounds[lineIndex][charIndex - 1];
              box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
            }
            return box;
          },
          /**
           * Calculate height of line at 'lineIndex'
           * @param {Number} lineIndex index of line to calculate
           * @return {Number}
           */
          getHeightOfLine: function(lineIndex) {
            if (this.__lineHeights[lineIndex]) {
              return this.__lineHeights[lineIndex];
            }
            var line = this._textLines[lineIndex], maxHeight = this.getHeightOfChar(lineIndex, 0);
            for (var i2 = 1, len = line.length; i2 < len; i2++) {
              maxHeight = Math.max(this.getHeightOfChar(lineIndex, i2), maxHeight);
            }
            return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
          },
          /**
           * Calculate text box height
           */
          calcTextHeight: function() {
            var lineHeight2, height = 0;
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              lineHeight2 = this.getHeightOfLine(i2);
              height += i2 === len - 1 ? lineHeight2 / this.lineHeight : lineHeight2;
            }
            return height;
          },
          /**
           * @private
           * @return {Number} Left offset
           */
          _getLeftOffset: function() {
            return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
          },
          /**
           * @private
           * @return {Number} Top offset
           */
          _getTopOffset: function() {
            return -this.height / 2;
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {String} method Method name ("fillText" or "strokeText")
           */
          _renderTextCommon: function(ctx, method) {
            ctx.save();
            var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              var heightOfLine = this.getHeightOfLine(i2), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i2);
              this._renderTextLine(
                method,
                ctx,
                this._textLines[i2],
                left + leftOffset,
                top + lineHeights + maxHeight,
                i2
              );
              lineHeights += heightOfLine;
            }
            ctx.restore();
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderTextFill: function(ctx) {
            if (!this.fill && !this.styleHas("fill")) {
              return;
            }
            this._renderTextCommon(ctx, "fillText");
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderTextStroke: function(ctx) {
            if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
              return;
            }
            if (this.shadow && !this.shadow.affectStroke) {
              this._removeShadow(ctx);
            }
            ctx.save();
            this._setLineDash(ctx, this.strokeDashArray);
            ctx.beginPath();
            this._renderTextCommon(ctx, "strokeText");
            ctx.closePath();
            ctx.restore();
          },
          /**
           * @private
           * @param {String} method fillText or strokeText.
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Array} line Content of the line, splitted in an array by grapheme
           * @param {Number} left
           * @param {Number} top
           * @param {Number} lineIndex
           */
          _renderChars: function(method, ctx, line, left, top, lineIndex) {
            var lineHeight2 = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf("justify") !== -1, actualStyle, nextStyle, charsToRender = "", charBox, boxWidth = 0, timeToRender, path2 = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path2, isLtr = this.direction === "ltr", sign = this.direction === "ltr" ? 1 : -1, drawingLeft, currentDirection = ctx.canvas.getAttribute("dir");
            ctx.save();
            if (currentDirection !== this.direction) {
              ctx.canvas.setAttribute("dir", isLtr ? "ltr" : "rtl");
              ctx.direction = isLtr ? "ltr" : "rtl";
              ctx.textAlign = isLtr ? "left" : "right";
            }
            top -= lineHeight2 * this._fontSizeFraction / this.lineHeight;
            if (shortCut) {
              this._renderChar(method, ctx, lineIndex, 0, line.join(""), left, top, lineHeight2);
              ctx.restore();
              return;
            }
            for (var i2 = 0, len = line.length - 1; i2 <= len; i2++) {
              timeToRender = i2 === len || this.charSpacing || path2;
              charsToRender += line[i2];
              charBox = this.__charBounds[lineIndex][i2];
              if (boxWidth === 0) {
                left += sign * (charBox.kernedWidth - charBox.width);
                boxWidth += charBox.width;
              } else {
                boxWidth += charBox.kernedWidth;
              }
              if (isJustify && !timeToRender) {
                if (this._reSpaceAndTab.test(line[i2])) {
                  timeToRender = true;
                }
              }
              if (!timeToRender) {
                actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i2);
                nextStyle = this.getCompleteStyleDeclaration(lineIndex, i2 + 1);
                timeToRender = fabric2.util.hasStyleChanged(actualStyle, nextStyle, false);
              }
              if (timeToRender) {
                if (path2) {
                  ctx.save();
                  ctx.translate(charBox.renderLeft, charBox.renderTop);
                  ctx.rotate(charBox.angle);
                  this._renderChar(method, ctx, lineIndex, i2, charsToRender, -boxWidth / 2, 0, lineHeight2);
                  ctx.restore();
                } else {
                  drawingLeft = left;
                  this._renderChar(method, ctx, lineIndex, i2, charsToRender, drawingLeft, top, lineHeight2);
                }
                charsToRender = "";
                actualStyle = nextStyle;
                left += sign * boxWidth;
                boxWidth = 0;
              }
            }
            ctx.restore();
          },
          /**
           * This function try to patch the missing gradientTransform on canvas gradients.
           * transforming a context to transform the gradient, is going to transform the stroke too.
           * we want to transform the gradient but not the stroke operation, so we create
           * a transformed gradient on a pattern and then we use the pattern instead of the gradient.
           * this method has drawbacks: is slow, is in low resolution, needs a patch for when the size
           * is limited.
           * @private
           * @param {fabric.Gradient} filler a fabric gradient instance
           * @return {CanvasPattern} a pattern to use as fill/stroke style
           */
          _applyPatternGradientTransformText: function(filler) {
            var pCanvas = fabric2.util.createCanvasElement(), pCtx, width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;
            pCanvas.width = width;
            pCanvas.height = height;
            pCtx = pCanvas.getContext("2d");
            pCtx.beginPath();
            pCtx.moveTo(0, 0);
            pCtx.lineTo(width, 0);
            pCtx.lineTo(width, height);
            pCtx.lineTo(0, height);
            pCtx.closePath();
            pCtx.translate(width / 2, height / 2);
            pCtx.fillStyle = filler.toLive(pCtx);
            this._applyPatternGradientTransform(pCtx, filler);
            pCtx.fill();
            return pCtx.createPattern(pCanvas, "no-repeat");
          },
          handleFiller: function(ctx, property, filler) {
            var offsetX, offsetY;
            if (filler.toLive) {
              if (filler.gradientUnits === "percentage" || filler.gradientTransform || filler.patternTransform) {
                offsetX = -this.width / 2;
                offsetY = -this.height / 2;
                ctx.translate(offsetX, offsetY);
                ctx[property] = this._applyPatternGradientTransformText(filler);
                return { offsetX, offsetY };
              } else {
                ctx[property] = filler.toLive(ctx, this);
                return this._applyPatternGradientTransform(ctx, filler);
              }
            } else {
              ctx[property] = filler;
            }
            return { offsetX: 0, offsetY: 0 };
          },
          _setStrokeStyles: function(ctx, decl) {
            ctx.lineWidth = decl.strokeWidth;
            ctx.lineCap = this.strokeLineCap;
            ctx.lineDashOffset = this.strokeDashOffset;
            ctx.lineJoin = this.strokeLineJoin;
            ctx.miterLimit = this.strokeMiterLimit;
            return this.handleFiller(ctx, "strokeStyle", decl.stroke);
          },
          _setFillStyles: function(ctx, decl) {
            return this.handleFiller(ctx, "fillStyle", decl.fill);
          },
          /**
           * @private
           * @param {String} method
           * @param {CanvasRenderingContext2D} ctx Context to render on
           * @param {Number} lineIndex
           * @param {Number} charIndex
           * @param {String} _char
           * @param {Number} left Left coordinate
           * @param {Number} top Top coordinate
           * @param {Number} lineHeight Height of the line
           */
          _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
            var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === "fillText" && fullDecl.fill, shouldStroke = method === "strokeText" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;
            if (!shouldStroke && !shouldFill) {
              return;
            }
            ctx.save();
            shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));
            shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));
            ctx.font = this._getFontDeclaration(fullDecl);
            if (decl && decl.textBackgroundColor) {
              this._removeShadow(ctx);
            }
            if (decl && decl.deltaY) {
              top += decl.deltaY;
            }
            shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);
            shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);
            ctx.restore();
          },
          /**
           * Turns the character into a 'superior figure' (i.e. 'superscript')
           * @param {Number} start selection start
           * @param {Number} end selection end
           * @returns {fabric.Text} thisArg
           * @chainable
           */
          setSuperscript: function(start, end) {
            return this._setScript(start, end, this.superscript);
          },
          /**
           * Turns the character into an 'inferior figure' (i.e. 'subscript')
           * @param {Number} start selection start
           * @param {Number} end selection end
           * @returns {fabric.Text} thisArg
           * @chainable
           */
          setSubscript: function(start, end) {
            return this._setScript(start, end, this.subscript);
          },
          /**
           * Applies 'schema' at given position
           * @private
           * @param {Number} start selection start
           * @param {Number} end selection end
           * @param {Number} schema
           * @returns {fabric.Text} thisArg
           * @chainable
           */
          _setScript: function(start, end, schema) {
            var loc = this.get2DCursorLocation(start, true), fontSize2 = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, "fontSize"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, "deltaY"), style = { fontSize: fontSize2 * schema.size, deltaY: dy + fontSize2 * schema.baseline };
            this.setSelectionStyles(style, start, end);
            return this;
          },
          /**
           * @private
           * @param {Number} lineIndex index text line
           * @return {Number} Line left offset
           */
          _getLineLeftOffset: function(lineIndex) {
            var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign2 = this.textAlign, direction2 = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);
            if (textAlign2 === "justify" || textAlign2 === "justify-center" && !isEndOfWrapping || textAlign2 === "justify-right" && !isEndOfWrapping || textAlign2 === "justify-left" && !isEndOfWrapping) {
              return 0;
            }
            if (textAlign2 === "center") {
              leftOffset = lineDiff / 2;
            }
            if (textAlign2 === "right") {
              leftOffset = lineDiff;
            }
            if (textAlign2 === "justify-center") {
              leftOffset = lineDiff / 2;
            }
            if (textAlign2 === "justify-right") {
              leftOffset = lineDiff;
            }
            if (direction2 === "rtl") {
              leftOffset -= lineDiff;
            }
            return leftOffset;
          },
          /**
           * @private
           */
          _clearCache: function() {
            this.__lineWidths = [];
            this.__lineHeights = [];
            this.__charBounds = [];
          },
          /**
           * @private
           */
          _shouldClearDimensionCache: function() {
            var shouldClear = this._forceClearCache;
            shouldClear || (shouldClear = this.hasStateChanged("_dimensionAffectingProps"));
            if (shouldClear) {
              this.dirty = true;
              this._forceClearCache = false;
            }
            return shouldClear;
          },
          /**
           * Measure a single line given its index. Used to calculate the initial
           * text bounding box. The values are calculated and stored in __lineWidths cache.
           * @private
           * @param {Number} lineIndex line number
           * @return {Number} Line width
           */
          getLineWidth: function(lineIndex) {
            if (this.__lineWidths[lineIndex] !== void 0) {
              return this.__lineWidths[lineIndex];
            }
            var lineInfo = this.measureLine(lineIndex);
            var width = lineInfo.width;
            this.__lineWidths[lineIndex] = width;
            return width;
          },
          _getWidthOfCharSpacing: function() {
            if (this.charSpacing !== 0) {
              return this.fontSize * this.charSpacing / 1e3;
            }
            return 0;
          },
          /**
           * Retrieves the value of property at given character position
           * @param {Number} lineIndex the line number
           * @param {Number} charIndex the character number
           * @param {String} property the property name
           * @returns the value of 'property'
           */
          getValueOfPropertyAt: function(lineIndex, charIndex, property) {
            var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
            if (charStyle && typeof charStyle[property] !== "undefined") {
              return charStyle[property];
            }
            return this[property];
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _renderTextDecoration: function(ctx, type) {
            if (!this[type] && !this.styleHas(type)) {
              return;
            }
            var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path2 = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              heightOfLine = this.getHeightOfLine(i2);
              if (!this[type] && !this.styleHas(type, i2)) {
                topOffset += heightOfLine;
                continue;
              }
              line = this._textLines[i2];
              maxHeight = heightOfLine / this.lineHeight;
              lineLeftOffset = this._getLineLeftOffset(i2);
              boxStart = 0;
              boxWidth = 0;
              lastDecoration = this.getValueOfPropertyAt(i2, 0, type);
              lastFill = this.getValueOfPropertyAt(i2, 0, "fill");
              top = topOffset + maxHeight * (1 - this._fontSizeFraction);
              size = this.getHeightOfChar(i2, 0);
              dy = this.getValueOfPropertyAt(i2, 0, "deltaY");
              for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                charBox = this.__charBounds[i2][j2];
                currentDecoration = this.getValueOfPropertyAt(i2, j2, type);
                currentFill = this.getValueOfPropertyAt(i2, j2, "fill");
                _size = this.getHeightOfChar(i2, j2);
                _dy = this.getValueOfPropertyAt(i2, j2, "deltaY");
                if (path2 && currentDecoration && currentFill) {
                  ctx.save();
                  ctx.fillStyle = lastFill;
                  ctx.translate(charBox.renderLeft, charBox.renderTop);
                  ctx.rotate(charBox.angle);
                  ctx.fillRect(
                    -charBox.kernedWidth / 2,
                    offsetY * _size + _dy,
                    charBox.kernedWidth,
                    this.fontSize / 15
                  );
                  ctx.restore();
                } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {
                  var drawStart = leftOffset + lineLeftOffset + boxStart;
                  if (this.direction === "rtl") {
                    drawStart = this.width - drawStart - boxWidth;
                  }
                  if (lastDecoration && lastFill) {
                    ctx.fillStyle = lastFill;
                    ctx.fillRect(
                      drawStart,
                      top + offsetY * size + dy,
                      boxWidth,
                      this.fontSize / 15
                    );
                  }
                  boxStart = charBox.left;
                  boxWidth = charBox.width;
                  lastDecoration = currentDecoration;
                  lastFill = currentFill;
                  size = _size;
                  dy = _dy;
                } else {
                  boxWidth += charBox.kernedWidth;
                }
              }
              var drawStart = leftOffset + lineLeftOffset + boxStart;
              if (this.direction === "rtl") {
                drawStart = this.width - drawStart - boxWidth;
              }
              ctx.fillStyle = currentFill;
              currentDecoration && currentFill && ctx.fillRect(
                drawStart,
                top + offsetY * size + dy,
                boxWidth - charSpacing,
                this.fontSize / 15
              );
              topOffset += heightOfLine;
            }
            this._removeShadow(ctx);
          },
          /**
           * return font declaration string for canvas context
           * @param {Object} [styleObject] object
           * @returns {String} font declaration formatted for canvas context.
           */
          _getFontDeclaration: function(styleObject, forMeasuring) {
            var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric2.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
            var fontFamily2 = family === void 0 || family.indexOf("'") > -1 || family.indexOf(",") > -1 || family.indexOf('"') > -1 || fontIsGeneric ? style.fontFamily : '"' + style.fontFamily + '"';
            return [
              // node-canvas needs "weight style", while browsers need "style weight"
              // verify if this can be fixed in JSDOM
              fabric2.isLikelyNode ? style.fontWeight : style.fontStyle,
              fabric2.isLikelyNode ? style.fontStyle : style.fontWeight,
              forMeasuring ? this.CACHE_FONT_SIZE + "px" : style.fontSize + "px",
              fontFamily2
            ].join(" ");
          },
          /**
           * Renders text instance on a specified context
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          render: function(ctx) {
            if (!this.visible) {
              return;
            }
            if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
              return;
            }
            if (this._shouldClearDimensionCache()) {
              this.initDimensions();
            }
            this.callSuper("render", ctx);
          },
          /**
           * Returns the text as an array of lines.
           * @param {String} text text to split
           * @returns {Array} Lines in the text
           */
          _splitTextIntoLines: function(text2) {
            var lines = text2.split(this._reNewline), newLines = new Array(lines.length), newLine = ["\n"], newText = [];
            for (var i2 = 0; i2 < lines.length; i2++) {
              newLines[i2] = fabric2.util.string.graphemeSplit(lines[i2]);
              newText = newText.concat(newLines[i2], newLine);
            }
            newText.pop();
            return { _unwrappedLines: newLines, lines, graphemeText: newText, graphemeLines: newLines };
          },
          /**
           * Returns object representation of an instance
           * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
           * @return {Object} Object representation of an instance
           */
          toObject: function(propertiesToInclude) {
            var allProperties = additionalProps.concat(propertiesToInclude);
            var obj = this.callSuper("toObject", allProperties);
            obj.styles = fabric2.util.stylesToArray(this.styles, this.text);
            if (obj.path) {
              obj.path = this.path.toObject();
            }
            return obj;
          },
          /**
           * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
           * @param {String|Object} key Property name or object (if object, iterate over the object properties)
           * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
           * @return {fabric.Object} thisArg
           * @chainable
           */
          set: function(key, value) {
            this.callSuper("set", key, value);
            var needsDims = false;
            var isAddingPath = false;
            if (typeof key === "object") {
              for (var _key in key) {
                if (_key === "path") {
                  this.setPathInfo();
                }
                needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
                isAddingPath = isAddingPath || _key === "path";
              }
            } else {
              needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
              isAddingPath = key === "path";
            }
            if (isAddingPath) {
              this.setPathInfo();
            }
            if (needsDims) {
              this.initDimensions();
              this.setCoords();
            }
            return this;
          },
          /**
           * Returns complexity of an instance
           * @return {Number} complexity
           */
          complexity: function() {
            return 1;
          }
        }
      );
      fabric2.Text.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat(
        "x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")
      );
      fabric2.Text.DEFAULT_SVG_FONT_SIZE = 16;
      fabric2.Text.fromElement = function(element, callback, options) {
        if (!element) {
          return callback(null);
        }
        var parsedAttributes = fabric2.parseAttributes(element, fabric2.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || "left";
        options = fabric2.util.object.extend(options ? clone2(options) : {}, parsedAttributes);
        options.top = options.top || 0;
        options.left = options.left || 0;
        if (parsedAttributes.textDecoration) {
          var textDecoration = parsedAttributes.textDecoration;
          if (textDecoration.indexOf("underline") !== -1) {
            options.underline = true;
          }
          if (textDecoration.indexOf("overline") !== -1) {
            options.overline = true;
          }
          if (textDecoration.indexOf("line-through") !== -1) {
            options.linethrough = true;
          }
          delete options.textDecoration;
        }
        if ("dx" in parsedAttributes) {
          options.left += parsedAttributes.dx;
        }
        if ("dy" in parsedAttributes) {
          options.top += parsedAttributes.dy;
        }
        if (!("fontSize" in options)) {
          options.fontSize = fabric2.Text.DEFAULT_SVG_FONT_SIZE;
        }
        var textContent = "";
        if (!("textContent" in element)) {
          if ("firstChild" in element && element.firstChild !== null) {
            if ("data" in element.firstChild && element.firstChild.data !== null) {
              textContent = element.firstChild.data;
            }
          }
        } else {
          textContent = element.textContent;
        }
        textContent = textContent.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
        var originalStrokeWidth = options.strokeWidth;
        options.strokeWidth = 0;
        var text2 = new fabric2.Text(textContent, options), textHeightScaleFactor = text2.getScaledHeight() / text2.height, lineHeightDiff = (text2.height + text2.strokeWidth) * text2.lineHeight - text2.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text2.getScaledHeight() + scaledDiff, offX = 0;
        if (parsedAnchor === "center") {
          offX = text2.getScaledWidth() / 2;
        }
        if (parsedAnchor === "right") {
          offX = text2.getScaledWidth();
        }
        text2.set({
          left: text2.left - offX,
          top: text2.top - (textHeight - text2.fontSize * (0.07 + text2._fontSizeFraction)) / text2.lineHeight,
          strokeWidth: typeof originalStrokeWidth !== "undefined" ? originalStrokeWidth : 1
        });
        callback(text2);
      };
      fabric2.Text.fromObject = function(object, callback) {
        var objectCopy = clone2(object), path2 = object.path;
        delete objectCopy.path;
        return fabric2.Object._fromObject("Text", objectCopy, function(textInstance) {
          textInstance.styles = fabric2.util.stylesFromArray(object.styles, object.text);
          if (path2) {
            fabric2.Object._fromObject("Path", path2, function(pathInstance) {
              textInstance.set("path", pathInstance);
              callback(textInstance);
            }, "path");
          } else {
            callback(textInstance);
          }
        }, "text");
      };
      fabric2.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"];
      fabric2.util.createAccessors && fabric2.util.createAccessors(fabric2.Text);
    })(exports);
    (function() {
      fabric$1.util.object.extend(
        fabric$1.Text.prototype,
        /** @lends fabric.Text.prototype */
        {
          /**
           * Returns true if object has no styling or no styling in a line
           * @param {Number} lineIndex , lineIndex is on wrapped lines.
           * @return {Boolean}
           */
          isEmptyStyles: function(lineIndex) {
            if (!this.styles) {
              return true;
            }
            if (typeof lineIndex !== "undefined" && !this.styles[lineIndex]) {
              return true;
            }
            var obj = typeof lineIndex === "undefined" ? this.styles : { line: this.styles[lineIndex] };
            for (var p1 in obj) {
              for (var p2 in obj[p1]) {
                for (var p3 in obj[p1][p2]) {
                  return false;
                }
              }
            }
            return true;
          },
          /**
           * Returns true if object has a style property or has it ina specified line
           * This function is used to detect if a text will use a particular property or not.
           * @param {String} property to check for
           * @param {Number} lineIndex to check the style on
           * @return {Boolean}
           */
          styleHas: function(property, lineIndex) {
            if (!this.styles || !property || property === "") {
              return false;
            }
            if (typeof lineIndex !== "undefined" && !this.styles[lineIndex]) {
              return false;
            }
            var obj = typeof lineIndex === "undefined" ? this.styles : { 0: this.styles[lineIndex] };
            for (var p1 in obj) {
              for (var p2 in obj[p1]) {
                if (typeof obj[p1][p2][property] !== "undefined") {
                  return true;
                }
              }
            }
            return false;
          },
          /**
           * Check if characters in a text have a value for a property
           * whose value matches the textbox's value for that property.  If so,
           * the character-level property is deleted.  If the character
           * has no other properties, then it is also deleted.  Finally,
           * if the line containing that character has no other characters
           * then it also is deleted.
           *
           * @param {string} property The property to compare between characters and text.
           */
          cleanStyle: function(property) {
            if (!this.styles || !property || property === "") {
              return false;
            }
            var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
            for (var p1 in obj) {
              letterCount = 0;
              for (var p2 in obj[p1]) {
                var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);
                stylesCount++;
                if (stylePropertyHasBeenSet) {
                  if (!stylePropertyValue) {
                    stylePropertyValue = styleObject[property];
                  } else if (styleObject[property] !== stylePropertyValue) {
                    allStyleObjectPropertiesMatch = false;
                  }
                  if (styleObject[property] === this[property]) {
                    delete styleObject[property];
                  }
                } else {
                  allStyleObjectPropertiesMatch = false;
                }
                if (Object.keys(styleObject).length !== 0) {
                  letterCount++;
                } else {
                  delete obj[p1][p2];
                }
              }
              if (letterCount === 0) {
                delete obj[p1];
              }
            }
            for (var i2 = 0; i2 < this._textLines.length; i2++) {
              graphemeCount += this._textLines[i2].length;
            }
            if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
              this[property] = stylePropertyValue;
              this.removeStyle(property);
            }
          },
          /**
           * Remove a style property or properties from all individual character styles
           * in a text object.  Deletes the character style object if it contains no other style
           * props.  Deletes a line style object if it contains no other character styles.
           *
           * @param {String} props The property to remove from character styles.
           */
          removeStyle: function(property) {
            if (!this.styles || !property || property === "") {
              return;
            }
            var obj = this.styles, line, lineNum, charNum;
            for (lineNum in obj) {
              line = obj[lineNum];
              for (charNum in line) {
                delete line[charNum][property];
                if (Object.keys(line[charNum]).length === 0) {
                  delete line[charNum];
                }
              }
              if (Object.keys(line).length === 0) {
                delete obj[lineNum];
              }
            }
          },
          /**
           * @private
           */
          _extendStyles: function(index2, styles) {
            var loc = this.get2DCursorLocation(index2);
            if (!this._getLineStyle(loc.lineIndex)) {
              this._setLineStyle(loc.lineIndex);
            }
            if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
              this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
            }
            fabric$1.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
          },
          /**
           * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
           * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
           * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. useful to manage styles.
           */
          get2DCursorLocation: function(selectionStart, skipWrapping) {
            if (typeof selectionStart === "undefined") {
              selectionStart = this.selectionStart;
            }
            var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;
            for (var i2 = 0; i2 < len; i2++) {
              if (selectionStart <= lines[i2].length) {
                return {
                  lineIndex: i2,
                  charIndex: selectionStart
                };
              }
              selectionStart -= lines[i2].length + this.missingNewlineOffset(i2);
            }
            return {
              lineIndex: i2 - 1,
              charIndex: lines[i2 - 1].length < selectionStart ? lines[i2 - 1].length : selectionStart
            };
          },
          /**
           * Gets style of a current selection/cursor (at the start position)
           * if startIndex or endIndex are not provided, selectionStart or selectionEnd will be used.
           * @param {Number} [startIndex] Start index to get styles at
           * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
           * @param {Boolean} [complete] get full style or not
           * @return {Array} styles an array with one, zero or more Style objects
           */
          getSelectionStyles: function(startIndex, endIndex, complete) {
            if (typeof startIndex === "undefined") {
              startIndex = this.selectionStart || 0;
            }
            if (typeof endIndex === "undefined") {
              endIndex = this.selectionEnd || startIndex;
            }
            var styles = [];
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              styles.push(this.getStyleAtPosition(i2, complete));
            }
            return styles;
          },
          /**
           * Gets style of a current selection/cursor position
           * @param {Number} position  to get styles at
           * @param {Boolean} [complete] full style if true
           * @return {Object} style Style object at a specified index
           * @private
           */
          getStyleAtPosition: function(position2, complete) {
            var loc = this.get2DCursorLocation(position2), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
            return style || {};
          },
          /**
           * Sets style of a current selection, if no selection exist, do not set anything.
           * @param {Object} [styles] Styles object
           * @param {Number} [startIndex] Start index to get styles at
           * @param {Number} [endIndex] End index to get styles at, if not specified selectionEnd or startIndex + 1
           * @return {fabric.IText} thisArg
           * @chainable
           */
          setSelectionStyles: function(styles, startIndex, endIndex) {
            if (typeof startIndex === "undefined") {
              startIndex = this.selectionStart || 0;
            }
            if (typeof endIndex === "undefined") {
              endIndex = this.selectionEnd || startIndex;
            }
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              this._extendStyles(i2, styles);
            }
            this._forceClearCache = true;
            return this;
          },
          /**
           * get the reference, not a clone, of the style object for a given character
           * @param {Number} lineIndex
           * @param {Number} charIndex
           * @return {Object} style object
           */
          _getStyleDeclaration: function(lineIndex, charIndex) {
            var lineStyle = this.styles && this.styles[lineIndex];
            if (!lineStyle) {
              return null;
            }
            return lineStyle[charIndex];
          },
          /**
           * return a new object that contains all the style property for a character
           * the object returned is newly created
           * @param {Number} lineIndex of the line where the character is
           * @param {Number} charIndex position of the character on the line
           * @return {Object} style object
           */
          getCompleteStyleDeclaration: function(lineIndex, charIndex) {
            var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;
            for (var i2 = 0; i2 < this._styleProperties.length; i2++) {
              prop = this._styleProperties[i2];
              styleObject[prop] = typeof style[prop] === "undefined" ? this[prop] : style[prop];
            }
            return styleObject;
          },
          /**
           * @param {Number} lineIndex
           * @param {Number} charIndex
           * @param {Object} style
           * @private
           */
          _setStyleDeclaration: function(lineIndex, charIndex, style) {
            this.styles[lineIndex][charIndex] = style;
          },
          /**
           *
           * @param {Number} lineIndex
           * @param {Number} charIndex
           * @private
           */
          _deleteStyleDeclaration: function(lineIndex, charIndex) {
            delete this.styles[lineIndex][charIndex];
          },
          /**
           * @param {Number} lineIndex
           * @return {Boolean} if the line exists or not
           * @private
           */
          _getLineStyle: function(lineIndex) {
            return !!this.styles[lineIndex];
          },
          /**
           * Set the line style to an empty object so that is initialized
           * @param {Number} lineIndex
           * @private
           */
          _setLineStyle: function(lineIndex) {
            this.styles[lineIndex] = {};
          },
          /**
           * @param {Number} lineIndex
           * @private
           */
          _deleteLineStyle: function(lineIndex) {
            delete this.styles[lineIndex];
          }
        }
      );
    })();
    (function() {
      function parseDecoration(object) {
        if (object.textDecoration) {
          object.textDecoration.indexOf("underline") > -1 && (object.underline = true);
          object.textDecoration.indexOf("line-through") > -1 && (object.linethrough = true);
          object.textDecoration.indexOf("overline") > -1 && (object.overline = true);
          delete object.textDecoration;
        }
      }
      fabric$1.IText = fabric$1.util.createClass(
        fabric$1.Text,
        fabric$1.Observable,
        /** @lends fabric.IText.prototype */
        {
          /**
           * Type of an object
           * @type String
           * @default
           */
          type: "i-text",
          /**
           * Index where text selection starts (or where cursor is when there is no selection)
           * @type Number
           * @default
           */
          selectionStart: 0,
          /**
           * Index where text selection ends
           * @type Number
           * @default
           */
          selectionEnd: 0,
          /**
           * Color of text selection
           * @type String
           * @default
           */
          selectionColor: "rgba(17,119,255,0.3)",
          /**
           * Indicates whether text is in editing mode
           * @type Boolean
           * @default
           */
          isEditing: false,
          /**
           * Indicates whether a text can be edited
           * @type Boolean
           * @default
           */
          editable: true,
          /**
           * Border color of text object while it's in editing mode
           * @type String
           * @default
           */
          editingBorderColor: "rgba(102,153,255,0.25)",
          /**
           * Width of cursor (in px)
           * @type Number
           * @default
           */
          cursorWidth: 2,
          /**
           * Color of text cursor color in editing mode.
           * if not set (default) will take color from the text.
           * if set to a color value that fabric can understand, it will
           * be used instead of the color of the text at the current position.
           * @type String
           * @default
           */
          cursorColor: "",
          /**
           * Delay between cursor blink (in ms)
           * @type Number
           * @default
           */
          cursorDelay: 1e3,
          /**
           * Duration of cursor fadein (in ms)
           * @type Number
           * @default
           */
          cursorDuration: 600,
          /**
           * Indicates whether internal text char widths can be cached
           * @type Boolean
           * @default
           */
          caching: true,
          /**
           * DOM container to append the hiddenTextarea.
           * An alternative to attaching to the document.body.
           * Useful to reduce laggish redraw of the full document.body tree and
           * also with modals event capturing that won't let the textarea take focus.
           * @type HTMLElement
           * @default
           */
          hiddenTextareaContainer: null,
          /**
           * @private
           */
          _reSpace: /\s|\n/,
          /**
           * @private
           */
          _currentCursorOpacity: 0,
          /**
           * @private
           */
          _selectionDirection: null,
          /**
           * @private
           */
          _abortCursorAnimation: false,
          /**
           * @private
           */
          __widthOfSpace: [],
          /**
           * Helps determining when the text is in composition, so that the cursor
           * rendering is altered.
           */
          inCompositionMode: false,
          /**
           * Constructor
           * @param {String} text Text string
           * @param {Object} [options] Options object
           * @return {fabric.IText} thisArg
           */
          initialize: function(text2, options) {
            this.callSuper("initialize", text2, options);
            this.initBehavior();
          },
          /**
           * Sets selection start (left boundary of a selection)
           * @param {Number} index Index to set selection start to
           */
          setSelectionStart: function(index2) {
            index2 = Math.max(index2, 0);
            this._updateAndFire("selectionStart", index2);
          },
          /**
           * Sets selection end (right boundary of a selection)
           * @param {Number} index Index to set selection end to
           */
          setSelectionEnd: function(index2) {
            index2 = Math.min(index2, this.text.length);
            this._updateAndFire("selectionEnd", index2);
          },
          /**
           * @private
           * @param {String} property 'selectionStart' or 'selectionEnd'
           * @param {Number} index new position of property
           */
          _updateAndFire: function(property, index2) {
            if (this[property] !== index2) {
              this._fireSelectionChanged();
              this[property] = index2;
            }
            this._updateTextarea();
          },
          /**
           * Fires the even of selection changed
           * @private
           */
          _fireSelectionChanged: function() {
            this.fire("selection:changed");
            this.canvas && this.canvas.fire("text:selection:changed", { target: this });
          },
          /**
           * Initialize text dimensions. Render all text on given context
           * or on a offscreen canvas to get the text width with measureText.
           * Updates this.width and this.height with the proper values.
           * Does not return dimensions.
           * @private
           */
          initDimensions: function() {
            this.isEditing && this.initDelayedCursor();
            this.clearContextTop();
            this.callSuper("initDimensions");
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          render: function(ctx) {
            this.clearContextTop();
            this.callSuper("render", ctx);
            this.cursorOffsetCache = {};
            this.renderCursorOrSelection();
          },
          /**
           * @private
           * @param {CanvasRenderingContext2D} ctx Context to render on
           */
          _render: function(ctx) {
            this.callSuper("_render", ctx);
          },
          /**
           * Prepare and clean the contextTop
           */
          clearContextTop: function(skipRestore) {
            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
              return;
            }
            var ctx = this.canvas.contextTop, v2 = this.canvas.viewportTransform;
            ctx.save();
            ctx.transform(v2[0], v2[1], v2[2], v2[3], v2[4], v2[5]);
            this.transform(ctx);
            this._clearTextArea(ctx);
            skipRestore || ctx.restore();
          },
          /**
           * Renders cursor or selection (depending on what exists)
           * it does on the contextTop. If contextTop is not available, do nothing.
           */
          renderCursorOrSelection: function() {
            if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
              return;
            }
            var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;
            this.clearContextTop(true);
            if (this.selectionStart === this.selectionEnd) {
              this.renderCursor(boundaries, ctx);
            } else {
              this.renderSelection(boundaries, ctx);
            }
            ctx.restore();
          },
          _clearTextArea: function(ctx) {
            var width = this.width + 4, height = this.height + 4;
            ctx.clearRect(-width / 2, -height / 2, width, height);
          },
          /**
           * Returns cursor boundaries (left, top, leftOffset, topOffset)
           * @private
           * @param {Array} chars Array of characters
           * @param {String} typeOfBoundaries
           */
          _getCursorBoundaries: function(position2) {
            if (typeof position2 === "undefined") {
              position2 = this.selectionStart;
            }
            var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position2);
            return {
              left,
              top,
              leftOffset: offsets.left,
              topOffset: offsets.top
            };
          },
          /**
           * @private
           */
          _getCursorBoundariesOffsets: function(position2) {
            if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) {
              return this.cursorOffsetCache;
            }
            var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position2);
            charIndex = cursorPosition.charIndex;
            lineIndex = cursorPosition.lineIndex;
            for (var i2 = 0; i2 < lineIndex; i2++) {
              topOffset += this.getHeightOfLine(i2);
            }
            lineLeftOffset = this._getLineLeftOffset(lineIndex);
            var bound = this.__charBounds[lineIndex][charIndex];
            bound && (leftOffset = bound.left);
            if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
              leftOffset -= this._getWidthOfCharSpacing();
            }
            boundaries = {
              top: topOffset,
              left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)
            };
            if (this.direction === "rtl") {
              boundaries.left *= -1;
            }
            this.cursorOffsetCache = boundaries;
            return this.cursorOffsetCache;
          },
          /**
           * Renders cursor
           * @param {Object} boundaries
           * @param {CanvasRenderingContext2D} ctx transformed context to draw on
           */
          renderCursor: function(boundaries, ctx) {
            var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, "fontSize"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, "deltaY");
            topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);
            if (this.inCompositionMode) {
              this.renderSelection(boundaries, ctx);
            }
            ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, "fill");
            ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
            ctx.fillRect(
              boundaries.left + boundaries.leftOffset - cursorWidth / 2,
              topOffset + boundaries.top + dy,
              cursorWidth,
              charHeight
            );
          },
          /**
           * Renders text selection
           * @param {Object} boundaries Object with left/top/leftOffset/topOffset
           * @param {CanvasRenderingContext2D} ctx transformed context to draw on
           */
          renderSelection: function(boundaries, ctx) {
            var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf("justify") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;
            for (var i2 = startLine; i2 <= endLine; i2++) {
              var lineOffset = this._getLineLeftOffset(i2) || 0, lineHeight2 = this.getHeightOfLine(i2), realLineHeight = 0, boxStart = 0, boxEnd = 0;
              if (i2 === startLine) {
                boxStart = this.__charBounds[startLine][startChar].left;
              }
              if (i2 >= startLine && i2 < endLine) {
                boxEnd = isJustify && !this.isEndOfWrapping(i2) ? this.width : this.getLineWidth(i2) || 5;
              } else if (i2 === endLine) {
                if (endChar === 0) {
                  boxEnd = this.__charBounds[endLine][endChar].left;
                } else {
                  var charSpacing = this._getWidthOfCharSpacing();
                  boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;
                }
              }
              realLineHeight = lineHeight2;
              if (this.lineHeight < 1 || i2 === endLine && this.lineHeight > 1) {
                lineHeight2 /= this.lineHeight;
              }
              var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight2, extraTop = 0;
              if (this.inCompositionMode) {
                ctx.fillStyle = this.compositionColor || "black";
                drawHeight = 1;
                extraTop = lineHeight2;
              } else {
                ctx.fillStyle = this.selectionColor;
              }
              if (this.direction === "rtl") {
                drawStart = this.width - drawStart - drawWidth;
              }
              ctx.fillRect(
                drawStart,
                boundaries.top + boundaries.topOffset + extraTop,
                drawWidth,
                drawHeight
              );
              boundaries.topOffset += realLineHeight;
            }
          },
          /**
           * High level function to know the height of the cursor.
           * the currentChar is the one that precedes the cursor
           * Returns fontSize of char at the current cursor
           * Unused from the library, is for the end user
           * @return {Number} Character font size
           */
          getCurrentCharFontSize: function() {
            var cp = this._getCurrentCharIndex();
            return this.getValueOfPropertyAt(cp.l, cp.c, "fontSize");
          },
          /**
           * High level function to know the color of the cursor.
           * the currentChar is the one that precedes the cursor
           * Returns color (fill) of char at the current cursor
           * if the text object has a pattern or gradient for filler, it will return that.
           * Unused by the library, is for the end user
           * @return {String | fabric.Gradient | fabric.Pattern} Character color (fill)
           */
          getCurrentCharColor: function() {
            var cp = this._getCurrentCharIndex();
            return this.getValueOfPropertyAt(cp.l, cp.c, "fill");
          },
          /**
           * Returns the cursor position for the getCurrent.. functions
           * @private
           */
          _getCurrentCharIndex: function() {
            var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
            return { l: cursorPosition.lineIndex, c: charIndex };
          }
        }
      );
      fabric$1.IText.fromObject = function(object, callback) {
        var styles = fabric$1.util.stylesFromArray(object.styles, object.text);
        var objCopy = Object.assign({}, object, { styles });
        parseDecoration(objCopy);
        if (objCopy.styles) {
          for (var i2 in objCopy.styles) {
            for (var j2 in objCopy.styles[i2]) {
              parseDecoration(objCopy.styles[i2][j2]);
            }
          }
        }
        fabric$1.Object._fromObject("IText", objCopy, callback, "text");
      };
    })();
    (function() {
      var clone2 = fabric$1.util.object.clone;
      fabric$1.util.object.extend(
        fabric$1.IText.prototype,
        /** @lends fabric.IText.prototype */
        {
          /**
           * Initializes all the interactive behavior of IText
           */
          initBehavior: function() {
            this.initAddedHandler();
            this.initRemovedHandler();
            this.initCursorSelectionHandlers();
            this.initDoubleClickSimulation();
            this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
          },
          onDeselect: function() {
            this.isEditing && this.exitEditing();
            this.selected = false;
          },
          /**
           * Initializes "added" event handler
           */
          initAddedHandler: function() {
            var _this = this;
            this.on("added", function() {
              var canvas = _this.canvas;
              if (canvas) {
                if (!canvas._hasITextHandlers) {
                  canvas._hasITextHandlers = true;
                  _this._initCanvasHandlers(canvas);
                }
                canvas._iTextInstances = canvas._iTextInstances || [];
                canvas._iTextInstances.push(_this);
              }
            });
          },
          initRemovedHandler: function() {
            var _this = this;
            this.on("removed", function() {
              var canvas = _this.canvas;
              if (canvas) {
                canvas._iTextInstances = canvas._iTextInstances || [];
                fabric$1.util.removeFromArray(canvas._iTextInstances, _this);
                if (canvas._iTextInstances.length === 0) {
                  canvas._hasITextHandlers = false;
                  _this._removeCanvasHandlers(canvas);
                }
              }
            });
          },
          /**
           * register canvas event to manage exiting on other instances
           * @private
           */
          _initCanvasHandlers: function(canvas) {
            canvas._mouseUpITextHandler = function() {
              if (canvas._iTextInstances) {
                canvas._iTextInstances.forEach(function(obj) {
                  obj.__isMousedown = false;
                });
              }
            };
            canvas.on("mouse:up", canvas._mouseUpITextHandler);
          },
          /**
           * remove canvas event to manage exiting on other instances
           * @private
           */
          _removeCanvasHandlers: function(canvas) {
            canvas.off("mouse:up", canvas._mouseUpITextHandler);
          },
          /**
           * @private
           */
          _tick: function() {
            this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete");
          },
          /**
           * @private
           */
          _animateCursor: function(obj, targetOpacity, duration2, completeMethod) {
            var tickState;
            tickState = {
              isAborted: false,
              abort: function() {
                this.isAborted = true;
              }
            };
            obj.animate("_currentCursorOpacity", targetOpacity, {
              duration: duration2,
              onComplete: function() {
                if (!tickState.isAborted) {
                  obj[completeMethod]();
                }
              },
              onChange: function() {
                if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
                  obj.renderCursorOrSelection();
                }
              },
              abort: function() {
                return tickState.isAborted;
              }
            });
            return tickState;
          },
          /**
           * @private
           */
          _onTickComplete: function() {
            var _this = this;
            if (this._cursorTimeout1) {
              clearTimeout(this._cursorTimeout1);
            }
            this._cursorTimeout1 = setTimeout(function() {
              _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, "_tick");
            }, 100);
          },
          /**
           * Initializes delayed cursor
           */
          initDelayedCursor: function(restart) {
            var _this = this, delay = restart ? 0 : this.cursorDelay;
            this.abortCursorAnimation();
            this._currentCursorOpacity = 1;
            this._cursorTimeout2 = setTimeout(function() {
              _this._tick();
            }, delay);
          },
          /**
           * Aborts cursor animation and clears all timeouts
           */
          abortCursorAnimation: function() {
            var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;
            this._currentTickState && this._currentTickState.abort();
            this._currentTickCompleteState && this._currentTickCompleteState.abort();
            clearTimeout(this._cursorTimeout1);
            clearTimeout(this._cursorTimeout2);
            this._currentCursorOpacity = 0;
            if (shouldClear && canvas) {
              canvas.clearContext(canvas.contextTop || canvas.contextContainer);
            }
          },
          /**
           * Selects entire text
           * @return {fabric.IText} thisArg
           * @chainable
           */
          selectAll: function() {
            this.selectionStart = 0;
            this.selectionEnd = this._text.length;
            this._fireSelectionChanged();
            this._updateTextarea();
            return this;
          },
          /**
           * Returns selected text
           * @return {String}
           */
          getSelectedText: function() {
            return this._text.slice(this.selectionStart, this.selectionEnd).join("");
          },
          /**
           * Find new selection index representing start of current word according to current selection index
           * @param {Number} startFrom Current selection index
           * @return {Number} New selection index
           */
          findWordBoundaryLeft: function(startFrom) {
            var offset = 0, index2 = startFrom - 1;
            if (this._reSpace.test(this._text[index2])) {
              while (this._reSpace.test(this._text[index2])) {
                offset++;
                index2--;
              }
            }
            while (/\S/.test(this._text[index2]) && index2 > -1) {
              offset++;
              index2--;
            }
            return startFrom - offset;
          },
          /**
           * Find new selection index representing end of current word according to current selection index
           * @param {Number} startFrom Current selection index
           * @return {Number} New selection index
           */
          findWordBoundaryRight: function(startFrom) {
            var offset = 0, index2 = startFrom;
            if (this._reSpace.test(this._text[index2])) {
              while (this._reSpace.test(this._text[index2])) {
                offset++;
                index2++;
              }
            }
            while (/\S/.test(this._text[index2]) && index2 < this._text.length) {
              offset++;
              index2++;
            }
            return startFrom + offset;
          },
          /**
           * Find new selection index representing start of current line according to current selection index
           * @param {Number} startFrom Current selection index
           * @return {Number} New selection index
           */
          findLineBoundaryLeft: function(startFrom) {
            var offset = 0, index2 = startFrom - 1;
            while (!/\n/.test(this._text[index2]) && index2 > -1) {
              offset++;
              index2--;
            }
            return startFrom - offset;
          },
          /**
           * Find new selection index representing end of current line according to current selection index
           * @param {Number} startFrom Current selection index
           * @return {Number} New selection index
           */
          findLineBoundaryRight: function(startFrom) {
            var offset = 0, index2 = startFrom;
            while (!/\n/.test(this._text[index2]) && index2 < this._text.length) {
              offset++;
              index2++;
            }
            return startFrom + offset;
          },
          /**
           * Finds index corresponding to beginning or end of a word
           * @param {Number} selectionStart Index of a character
           * @param {Number} direction 1 or -1
           * @return {Number} Index of the beginning or end of a word
           */
          searchWordBoundary: function(selectionStart, direction2) {
            var text2 = this._text, index2 = this._reSpace.test(text2[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text2[index2], reNonWord = fabric$1.reNonWord;
            while (!reNonWord.test(_char) && index2 > 0 && index2 < text2.length) {
              index2 += direction2;
              _char = text2[index2];
            }
            if (reNonWord.test(_char)) {
              index2 += direction2 === 1 ? 0 : 1;
            }
            return index2;
          },
          /**
           * Selects a word based on the index
           * @param {Number} selectionStart Index of a character
           */
          selectWord: function(selectionStart) {
            selectionStart = selectionStart || this.selectionStart;
            var newSelectionStart = this.searchWordBoundary(selectionStart, -1), newSelectionEnd = this.searchWordBoundary(selectionStart, 1);
            this.selectionStart = newSelectionStart;
            this.selectionEnd = newSelectionEnd;
            this._fireSelectionChanged();
            this._updateTextarea();
            this.renderCursorOrSelection();
          },
          /**
           * Selects a line based on the index
           * @param {Number} selectionStart Index of a character
           * @return {fabric.IText} thisArg
           * @chainable
           */
          selectLine: function(selectionStart) {
            selectionStart = selectionStart || this.selectionStart;
            var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);
            this.selectionStart = newSelectionStart;
            this.selectionEnd = newSelectionEnd;
            this._fireSelectionChanged();
            this._updateTextarea();
            return this;
          },
          /**
           * Enters editing state
           * @return {fabric.IText} thisArg
           * @chainable
           */
          enterEditing: function(e2) {
            if (this.isEditing || !this.editable) {
              return;
            }
            if (this.canvas) {
              this.canvas.calcOffset();
              this.exitEditingOnOthers(this.canvas);
            }
            this.isEditing = true;
            this.initHiddenTextarea(e2);
            this.hiddenTextarea.focus();
            this.hiddenTextarea.value = this.text;
            this._updateTextarea();
            this._saveEditingProps();
            this._setEditingProps();
            this._textBeforeEdit = this.text;
            this._tick();
            this.fire("editing:entered");
            this._fireSelectionChanged();
            if (!this.canvas) {
              return this;
            }
            this.canvas.fire("text:editing:entered", { target: this });
            this.initMouseMoveHandler();
            this.canvas.requestRenderAll();
            return this;
          },
          exitEditingOnOthers: function(canvas) {
            if (canvas._iTextInstances) {
              canvas._iTextInstances.forEach(function(obj) {
                obj.selected = false;
                if (obj.isEditing) {
                  obj.exitEditing();
                }
              });
            }
          },
          /**
           * Initializes "mousemove" event handler
           */
          initMouseMoveHandler: function() {
            this.canvas.on("mouse:move", this.mouseMoveHandler);
          },
          /**
           * @private
           */
          mouseMoveHandler: function(options) {
            if (!this.__isMousedown || !this.isEditing) {
              return;
            }
            document.activeElement !== this.hiddenTextarea && this.hiddenTextarea.focus();
            var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;
            if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {
              return;
            }
            if (newSelectionStart > this.__selectionStartOnMouseDown) {
              this.selectionStart = this.__selectionStartOnMouseDown;
              this.selectionEnd = newSelectionStart;
            } else {
              this.selectionStart = newSelectionStart;
              this.selectionEnd = this.__selectionStartOnMouseDown;
            }
            if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
              this.restartCursorIfNeeded();
              this._fireSelectionChanged();
              this._updateTextarea();
              this.renderCursorOrSelection();
            }
          },
          /**
           * @private
           */
          _setEditingProps: function() {
            this.hoverCursor = "text";
            if (this.canvas) {
              this.canvas.defaultCursor = this.canvas.moveCursor = "text";
            }
            this.borderColor = this.editingBorderColor;
            this.hasControls = this.selectable = false;
            this.lockMovementX = this.lockMovementY = true;
          },
          /**
           * convert from textarea to grapheme indexes
           */
          fromStringToGraphemeSelection: function(start, end, text2) {
            var smallerTextStart = text2.slice(0, start), graphemeStart = fabric$1.util.string.graphemeSplit(smallerTextStart).length;
            if (start === end) {
              return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
            }
            var smallerTextEnd = text2.slice(start, end), graphemeEnd = fabric$1.util.string.graphemeSplit(smallerTextEnd).length;
            return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
          },
          /**
           * convert from fabric to textarea values
           */
          fromGraphemeToStringSelection: function(start, end, _text) {
            var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join("").length;
            if (start === end) {
              return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
            }
            var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join("").length;
            return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
          },
          /**
           * @private
           */
          _updateTextarea: function() {
            this.cursorOffsetCache = {};
            if (!this.hiddenTextarea) {
              return;
            }
            if (!this.inCompositionMode) {
              var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
              this.hiddenTextarea.selectionStart = newSelection.selectionStart;
              this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
            }
            this.updateTextareaPosition();
          },
          /**
           * @private
           */
          updateFromTextArea: function() {
            if (!this.hiddenTextarea) {
              return;
            }
            this.cursorOffsetCache = {};
            this.text = this.hiddenTextarea.value;
            if (this._shouldClearDimensionCache()) {
              this.initDimensions();
              this.setCoords();
            }
            var newSelection = this.fromStringToGraphemeSelection(
              this.hiddenTextarea.selectionStart,
              this.hiddenTextarea.selectionEnd,
              this.hiddenTextarea.value
            );
            this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
            if (!this.inCompositionMode) {
              this.selectionStart = newSelection.selectionStart;
            }
            this.updateTextareaPosition();
          },
          /**
           * @private
           */
          updateTextareaPosition: function() {
            if (this.selectionStart === this.selectionEnd) {
              var style = this._calcTextareaPosition();
              this.hiddenTextarea.style.left = style.left;
              this.hiddenTextarea.style.top = style.top;
            }
          },
          /**
           * @private
           * @return {Object} style contains style for hiddenTextarea
           */
          _calcTextareaPosition: function() {
            if (!this.canvas) {
              return { x: 1, y: 1 };
            }
            var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, "fontSize") * this.lineHeight, leftOffset = boundaries.leftOffset, m2 = this.calcTransformMatrix(), p2 = {
              x: boundaries.left + leftOffset,
              y: boundaries.top + boundaries.topOffset + charHeight
            }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;
            p2 = fabric$1.util.transformPoint(p2, m2);
            p2 = fabric$1.util.transformPoint(p2, this.canvas.viewportTransform);
            p2.x *= scaleX;
            p2.y *= scaleY;
            if (p2.x < 0) {
              p2.x = 0;
            }
            if (p2.x > maxWidth) {
              p2.x = maxWidth;
            }
            if (p2.y < 0) {
              p2.y = 0;
            }
            if (p2.y > maxHeight) {
              p2.y = maxHeight;
            }
            p2.x += this.canvas._offset.left;
            p2.y += this.canvas._offset.top;
            return { left: p2.x + "px", top: p2.y + "px", fontSize: charHeight + "px", charHeight };
          },
          /**
           * @private
           */
          _saveEditingProps: function() {
            this._savedProps = {
              hasControls: this.hasControls,
              borderColor: this.borderColor,
              lockMovementX: this.lockMovementX,
              lockMovementY: this.lockMovementY,
              hoverCursor: this.hoverCursor,
              selectable: this.selectable,
              defaultCursor: this.canvas && this.canvas.defaultCursor,
              moveCursor: this.canvas && this.canvas.moveCursor
            };
          },
          /**
           * @private
           */
          _restoreEditingProps: function() {
            if (!this._savedProps) {
              return;
            }
            this.hoverCursor = this._savedProps.hoverCursor;
            this.hasControls = this._savedProps.hasControls;
            this.borderColor = this._savedProps.borderColor;
            this.selectable = this._savedProps.selectable;
            this.lockMovementX = this._savedProps.lockMovementX;
            this.lockMovementY = this._savedProps.lockMovementY;
            if (this.canvas) {
              this.canvas.defaultCursor = this._savedProps.defaultCursor;
              this.canvas.moveCursor = this._savedProps.moveCursor;
            }
          },
          /**
           * Exits from editing state
           * @return {fabric.IText} thisArg
           * @chainable
           */
          exitEditing: function() {
            var isTextChanged = this._textBeforeEdit !== this.text;
            var hiddenTextarea = this.hiddenTextarea;
            this.selected = false;
            this.isEditing = false;
            this.selectionEnd = this.selectionStart;
            if (hiddenTextarea) {
              hiddenTextarea.blur && hiddenTextarea.blur();
              hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
            }
            this.hiddenTextarea = null;
            this.abortCursorAnimation();
            this._restoreEditingProps();
            this._currentCursorOpacity = 0;
            if (this._shouldClearDimensionCache()) {
              this.initDimensions();
              this.setCoords();
            }
            this.fire("editing:exited");
            isTextChanged && this.fire("modified");
            if (this.canvas) {
              this.canvas.off("mouse:move", this.mouseMoveHandler);
              this.canvas.fire("text:editing:exited", { target: this });
              isTextChanged && this.canvas.fire("object:modified", { target: this });
            }
            return this;
          },
          /**
           * @private
           */
          _removeExtraneousStyles: function() {
            for (var prop in this.styles) {
              if (!this._textLines[prop]) {
                delete this.styles[prop];
              }
            }
          },
          /**
           * remove and reflow a style block from start to end.
           * @param {Number} start linear start position for removal (included in removal)
           * @param {Number} end linear end position for removal ( excluded from removal )
           */
          removeStyleFromTo: function(start, end) {
            var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i2, styleObj;
            if (lineStart !== lineEnd) {
              if (this.styles[lineStart]) {
                for (i2 = charStart; i2 < this._unwrappedTextLines[lineStart].length; i2++) {
                  delete this.styles[lineStart][i2];
                }
              }
              if (this.styles[lineEnd]) {
                for (i2 = charEnd; i2 < this._unwrappedTextLines[lineEnd].length; i2++) {
                  styleObj = this.styles[lineEnd][i2];
                  if (styleObj) {
                    this.styles[lineStart] || (this.styles[lineStart] = {});
                    this.styles[lineStart][charStart + i2 - charEnd] = styleObj;
                  }
                }
              }
              for (i2 = lineStart + 1; i2 <= lineEnd; i2++) {
                delete this.styles[i2];
              }
              this.shiftLineStyles(lineEnd, lineStart - lineEnd);
            } else {
              if (this.styles[lineStart]) {
                styleObj = this.styles[lineStart];
                var diff = charEnd - charStart, numericChar, _char;
                for (i2 = charStart; i2 < charEnd; i2++) {
                  delete styleObj[i2];
                }
                for (_char in this.styles[lineStart]) {
                  numericChar = parseInt(_char, 10);
                  if (numericChar >= charEnd) {
                    styleObj[numericChar - diff] = styleObj[_char];
                    delete styleObj[_char];
                  }
                }
              }
            }
          },
          /**
           * Shifts line styles up or down
           * @param {Number} lineIndex Index of a line
           * @param {Number} offset Can any number?
           */
          shiftLineStyles: function(lineIndex, offset) {
            var clonedStyles = clone2(this.styles);
            for (var line in this.styles) {
              var numericLine = parseInt(line, 10);
              if (numericLine > lineIndex) {
                this.styles[numericLine + offset] = clonedStyles[numericLine];
                if (!clonedStyles[numericLine - offset]) {
                  delete this.styles[numericLine];
                }
              }
            }
          },
          restartCursorIfNeeded: function() {
            if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {
              this.initDelayedCursor();
            }
          },
          /**
           * Handle insertion of more consecutive style lines for when one or more
           * newlines gets added to the text. Since current style needs to be shifted
           * first we shift the current style of the number lines needed, then we add
           * new lines from the last to the first.
           * @param {Number} lineIndex Index of a line
           * @param {Number} charIndex Index of a char
           * @param {Number} qty number of lines to add
           * @param {Array} copiedStyle Array of objects styles
           */
          insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
            var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;
            qty || (qty = 1);
            this.shiftLineStyles(lineIndex, qty);
            if (this.styles[lineIndex]) {
              currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
            }
            for (var index2 in this.styles[lineIndex]) {
              var numIndex = parseInt(index2, 10);
              if (numIndex >= charIndex) {
                somethingAdded = true;
                newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index2];
                if (!(isEndOfLine && charIndex === 0)) {
                  delete this.styles[lineIndex][index2];
                }
              }
            }
            var styleCarriedOver = false;
            if (somethingAdded && !isEndOfLine) {
              this.styles[lineIndex + qty] = newLineStyles;
              styleCarriedOver = true;
            }
            if (styleCarriedOver) {
              qty--;
            }
            while (qty > 0) {
              if (copiedStyle && copiedStyle[qty - 1]) {
                this.styles[lineIndex + qty] = { 0: clone2(copiedStyle[qty - 1]) };
              } else if (currentCharStyle) {
                this.styles[lineIndex + qty] = { 0: clone2(currentCharStyle) };
              } else {
                delete this.styles[lineIndex + qty];
              }
              qty--;
            }
            this._forceClearCache = true;
          },
          /**
           * Inserts style object for a given line/char index
           * @param {Number} lineIndex Index of a line
           * @param {Number} charIndex Index of a char
           * @param {Number} quantity number Style object to insert, if given
           * @param {Array} copiedStyle array of style objects
           */
          insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
            if (!this.styles) {
              this.styles = {};
            }
            var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone2(currentLineStyles) : {};
            quantity || (quantity = 1);
            for (var index2 in currentLineStylesCloned) {
              var numericIndex = parseInt(index2, 10);
              if (numericIndex >= charIndex) {
                currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
                if (!currentLineStylesCloned[numericIndex - quantity]) {
                  delete currentLineStyles[numericIndex];
                }
              }
            }
            this._forceClearCache = true;
            if (copiedStyle) {
              while (quantity--) {
                if (!Object.keys(copiedStyle[quantity]).length) {
                  continue;
                }
                if (!this.styles[lineIndex]) {
                  this.styles[lineIndex] = {};
                }
                this.styles[lineIndex][charIndex + quantity] = clone2(copiedStyle[quantity]);
              }
              return;
            }
            if (!currentLineStyles) {
              return;
            }
            var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
            while (newStyle && quantity--) {
              this.styles[lineIndex][charIndex + quantity] = clone2(newStyle);
            }
          },
          /**
           * Inserts style object(s)
           * @param {Array} insertedText Characters at the location where style is inserted
           * @param {Number} start cursor index for inserting style
           * @param {Array} [copiedStyle] array of style objects to insert.
           */
          insertNewStyleBlock: function(insertedText, start, copiedStyle) {
            var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [0], linesLength = 0;
            for (var i2 = 0; i2 < insertedText.length; i2++) {
              if (insertedText[i2] === "\n") {
                linesLength++;
                addedLines[linesLength] = 0;
              } else {
                addedLines[linesLength]++;
              }
            }
            if (addedLines[0] > 0) {
              this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
              copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
            }
            linesLength && this.insertNewlineStyleObject(
              cursorLoc.lineIndex,
              cursorLoc.charIndex + addedLines[0],
              linesLength
            );
            for (var i2 = 1; i2 < linesLength; i2++) {
              if (addedLines[i2] > 0) {
                this.insertCharStyleObject(cursorLoc.lineIndex + i2, 0, addedLines[i2], copiedStyle);
              } else if (copiedStyle) {
                if (this.styles[cursorLoc.lineIndex + i2] && copiedStyle[0]) {
                  this.styles[cursorLoc.lineIndex + i2][0] = copiedStyle[0];
                }
              }
              copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i2] + 1);
            }
            if (addedLines[i2] > 0) {
              this.insertCharStyleObject(cursorLoc.lineIndex + i2, 0, addedLines[i2], copiedStyle);
            }
          },
          /**
           * Set the selectionStart and selectionEnd according to the new position of cursor
           * mimic the key - mouse navigation when shift is pressed.
           */
          setSelectionStartEndWithShift: function(start, end, newSelection) {
            if (newSelection <= start) {
              if (end === start) {
                this._selectionDirection = "left";
              } else if (this._selectionDirection === "right") {
                this._selectionDirection = "left";
                this.selectionEnd = start;
              }
              this.selectionStart = newSelection;
            } else if (newSelection > start && newSelection < end) {
              if (this._selectionDirection === "right") {
                this.selectionEnd = newSelection;
              } else {
                this.selectionStart = newSelection;
              }
            } else {
              if (end === start) {
                this._selectionDirection = "right";
              } else if (this._selectionDirection === "left") {
                this._selectionDirection = "right";
                this.selectionStart = end;
              }
              this.selectionEnd = newSelection;
            }
          },
          setSelectionInBoundaries: function() {
            var length = this.text.length;
            if (this.selectionStart > length) {
              this.selectionStart = length;
            } else if (this.selectionStart < 0) {
              this.selectionStart = 0;
            }
            if (this.selectionEnd > length) {
              this.selectionEnd = length;
            } else if (this.selectionEnd < 0) {
              this.selectionEnd = 0;
            }
          }
        }
      );
    })();
    fabric$1.util.object.extend(
      fabric$1.IText.prototype,
      /** @lends fabric.IText.prototype */
      {
        /**
         * Initializes "dbclick" event handler
         */
        initDoubleClickSimulation: function() {
          this.__lastClickTime = +/* @__PURE__ */ new Date();
          this.__lastLastClickTime = +/* @__PURE__ */ new Date();
          this.__lastPointer = {};
          this.on("mousedown", this.onMouseDown);
        },
        /**
         * Default event handler to simulate triple click
         * @private
         */
        onMouseDown: function(options) {
          if (!this.canvas) {
            return;
          }
          this.__newClickTime = +/* @__PURE__ */ new Date();
          var newPointer = options.pointer;
          if (this.isTripleClick(newPointer)) {
            this.fire("tripleclick", options);
            this._stopEvent(options.e);
          }
          this.__lastLastClickTime = this.__lastClickTime;
          this.__lastClickTime = this.__newClickTime;
          this.__lastPointer = newPointer;
          this.__lastIsEditing = this.isEditing;
          this.__lastSelected = this.selected;
        },
        isTripleClick: function(newPointer) {
          return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;
        },
        /**
         * @private
         */
        _stopEvent: function(e2) {
          e2.preventDefault && e2.preventDefault();
          e2.stopPropagation && e2.stopPropagation();
        },
        /**
         * Initializes event handlers related to cursor or selection
         */
        initCursorSelectionHandlers: function() {
          this.initMousedownHandler();
          this.initMouseupHandler();
          this.initClicks();
        },
        /**
         * Default handler for double click, select a word
         */
        doubleClickHandler: function(options) {
          if (!this.isEditing) {
            return;
          }
          this.selectWord(this.getSelectionStartFromPointer(options.e));
        },
        /**
         * Default handler for triple click, select a line
         */
        tripleClickHandler: function(options) {
          if (!this.isEditing) {
            return;
          }
          this.selectLine(this.getSelectionStartFromPointer(options.e));
        },
        /**
         * Initializes double and triple click event handlers
         */
        initClicks: function() {
          this.on("mousedblclick", this.doubleClickHandler);
          this.on("tripleclick", this.tripleClickHandler);
        },
        /**
         * Default event handler for the basic functionalities needed on _mouseDown
         * can be overridden to do something different.
         * Scope of this implementation is: find the click position, set selectionStart
         * find selectionEnd, initialize the drawing of either cursor or selection area
         * initializing a mousedDown on a text area will cancel fabricjs knowledge of
         * current compositionMode. It will be set to false.
         */
        _mouseDownHandler: function(options) {
          if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {
            return;
          }
          this.__isMousedown = true;
          if (this.selected) {
            this.inCompositionMode = false;
            this.setCursorByClick(options.e);
          }
          if (this.isEditing) {
            this.__selectionStartOnMouseDown = this.selectionStart;
            if (this.selectionStart === this.selectionEnd) {
              this.abortCursorAnimation();
            }
            this.renderCursorOrSelection();
          }
        },
        /**
         * Default event handler for the basic functionalities needed on mousedown:before
         * can be overridden to do something different.
         * Scope of this implementation is: verify the object is already selected when mousing down
         */
        _mouseDownHandlerBefore: function(options) {
          if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {
            return;
          }
          this.selected = this === this.canvas._activeObject;
        },
        /**
         * Initializes "mousedown" event handler
         */
        initMousedownHandler: function() {
          this.on("mousedown", this._mouseDownHandler);
          this.on("mousedown:before", this._mouseDownHandlerBefore);
        },
        /**
         * Initializes "mouseup" event handler
         */
        initMouseupHandler: function() {
          this.on("mouseup", this.mouseUpHandler);
        },
        /**
         * standard handler for mouse up, overridable
         * @private
         */
        mouseUpHandler: function(options) {
          this.__isMousedown = false;
          if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {
            return;
          }
          if (this.canvas) {
            var currentActive = this.canvas._activeObject;
            if (currentActive && currentActive !== this) {
              return;
            }
          }
          if (this.__lastSelected && !this.__corner) {
            this.selected = false;
            this.__lastSelected = false;
            this.enterEditing(options.e);
            if (this.selectionStart === this.selectionEnd) {
              this.initDelayedCursor(true);
            } else {
              this.renderCursorOrSelection();
            }
          } else {
            this.selected = true;
          }
        },
        /**
         * Changes cursor location in a text depending on passed pointer (x/y) object
         * @param {Event} e Event object
         */
        setCursorByClick: function(e2) {
          var newSelection = this.getSelectionStartFromPointer(e2), start = this.selectionStart, end = this.selectionEnd;
          if (e2.shiftKey) {
            this.setSelectionStartEndWithShift(start, end, newSelection);
          } else {
            this.selectionStart = newSelection;
            this.selectionEnd = newSelection;
          }
          if (this.isEditing) {
            this._fireSelectionChanged();
            this._updateTextarea();
          }
        },
        /**
         * Returns index of a character corresponding to where an object was clicked
         * @param {Event} e Event object
         * @return {Number} Index of a character
         */
        getSelectionStartFromPointer: function(e2) {
          var mouseOffset = this.getLocalPointer(e2), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;
          for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
            if (height <= mouseOffset.y) {
              height += this.getHeightOfLine(i2) * this.scaleY;
              lineIndex = i2;
              if (i2 > 0) {
                charIndex += this._textLines[i2 - 1].length + this.missingNewlineOffset(i2 - 1);
              }
            } else {
              break;
            }
          }
          lineLeftOffset = this._getLineLeftOffset(lineIndex);
          width = lineLeftOffset * this.scaleX;
          line = this._textLines[lineIndex];
          if (this.direction === "rtl") {
            mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;
          }
          for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
            prevWidth = width;
            width += this.__charBounds[lineIndex][j2].kernedWidth * this.scaleX;
            if (width <= mouseOffset.x) {
              charIndex++;
            } else {
              break;
            }
          }
          return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
        },
        /**
         * @private
         */
        _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index2, jlen) {
          var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index2 + offset;
          if (this.flipX) {
            newSelectionStart = jlen - newSelectionStart;
          }
          if (newSelectionStart > this._text.length) {
            newSelectionStart = this._text.length;
          }
          return newSelectionStart;
        }
      }
    );
    fabric$1.util.object.extend(
      fabric$1.IText.prototype,
      /** @lends fabric.IText.prototype */
      {
        /**
         * Initializes hidden textarea (needed to bring up keyboard in iOS)
         */
        initHiddenTextarea: function() {
          this.hiddenTextarea = fabric$1.document.createElement("textarea");
          this.hiddenTextarea.setAttribute("autocapitalize", "off");
          this.hiddenTextarea.setAttribute("autocorrect", "off");
          this.hiddenTextarea.setAttribute("autocomplete", "off");
          this.hiddenTextarea.setAttribute("spellcheck", "false");
          this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", "");
          this.hiddenTextarea.setAttribute("wrap", "off");
          var style = this._calcTextareaPosition();
          this.hiddenTextarea.style.cssText = "position: absolute; top: " + style.top + "; left: " + style.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: " + style.fontSize + ";";
          if (this.hiddenTextareaContainer) {
            this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);
          } else {
            fabric$1.document.body.appendChild(this.hiddenTextarea);
          }
          fabric$1.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this));
          fabric$1.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this));
          if (!this._clickHandlerInitialized && this.canvas) {
            fabric$1.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this));
            this._clickHandlerInitialized = true;
          }
        },
        /**
         * For functionalities on keyDown
         * Map a special key to a function of the instance/prototype
         * If you need different behaviour for ESC or TAB or arrows, you have to change
         * this map setting the name of a function that you build on the fabric.Itext or
         * your prototype.
         * the map change will affect all Instances unless you need for only some text Instances
         * in that case you have to clone this object and assign your Instance.
         * this.keysMap = fabric.util.object.clone(this.keysMap);
         * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
         */
        keysMap: {
          9: "exitEditing",
          27: "exitEditing",
          33: "moveCursorUp",
          34: "moveCursorDown",
          35: "moveCursorRight",
          36: "moveCursorLeft",
          37: "moveCursorLeft",
          38: "moveCursorUp",
          39: "moveCursorRight",
          40: "moveCursorDown"
        },
        keysMapRtl: {
          9: "exitEditing",
          27: "exitEditing",
          33: "moveCursorUp",
          34: "moveCursorDown",
          35: "moveCursorLeft",
          36: "moveCursorRight",
          37: "moveCursorRight",
          38: "moveCursorUp",
          39: "moveCursorLeft",
          40: "moveCursorDown"
        },
        /**
         * For functionalities on keyUp + ctrl || cmd
         */
        ctrlKeysMapUp: {
          67: "copy",
          88: "cut"
        },
        /**
         * For functionalities on keyDown + ctrl || cmd
         */
        ctrlKeysMapDown: {
          65: "selectAll"
        },
        onClick: function() {
          this.hiddenTextarea && this.hiddenTextarea.focus();
        },
        /**
         * Handles keydown event
         * only used for arrows and combination of modifier keys.
         * @param {Event} e Event object
         */
        onKeyDown: function(e2) {
          if (!this.isEditing) {
            return;
          }
          var keyMap = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
          if (e2.keyCode in keyMap) {
            this[keyMap[e2.keyCode]](e2);
          } else if (e2.keyCode in this.ctrlKeysMapDown && (e2.ctrlKey || e2.metaKey)) {
            this[this.ctrlKeysMapDown[e2.keyCode]](e2);
          } else {
            return;
          }
          e2.stopImmediatePropagation();
          e2.preventDefault();
          if (e2.keyCode >= 33 && e2.keyCode <= 40) {
            this.inCompositionMode = false;
            this.clearContextTop();
            this.renderCursorOrSelection();
          } else {
            this.canvas && this.canvas.requestRenderAll();
          }
        },
        /**
         * Handles keyup event
         * We handle KeyUp because ie11 and edge have difficulties copy/pasting
         * if a copy/cut event fired, keyup is dismissed
         * @param {Event} e Event object
         */
        onKeyUp: function(e2) {
          if (!this.isEditing || this._copyDone || this.inCompositionMode) {
            this._copyDone = false;
            return;
          }
          if (e2.keyCode in this.ctrlKeysMapUp && (e2.ctrlKey || e2.metaKey)) {
            this[this.ctrlKeysMapUp[e2.keyCode]](e2);
          } else {
            return;
          }
          e2.stopImmediatePropagation();
          e2.preventDefault();
          this.canvas && this.canvas.requestRenderAll();
        },
        /**
         * Handles onInput event
         * @param {Event} e Event object
         */
        onInput: function(e2) {
          var fromPaste = this.fromPaste;
          this.fromPaste = false;
          e2 && e2.stopPropagation();
          if (!this.isEditing) {
            return;
          }
          var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;
          if (this.hiddenTextarea.value === "") {
            this.styles = {};
            this.updateFromTextArea();
            this.fire("changed");
            if (this.canvas) {
              this.canvas.fire("text:changed", { target: this });
              this.canvas.requestRenderAll();
            }
            return;
          }
          var textareaSelection = this.fromStringToGraphemeSelection(
            this.hiddenTextarea.selectionStart,
            this.hiddenTextarea.selectionEnd,
            this.hiddenTextarea.value
          );
          var backDelete = selectionStart > textareaSelection.selectionStart;
          if (selection) {
            removedText = this._text.slice(selectionStart, selectionEnd);
            charDiff += selectionEnd - selectionStart;
          } else if (nextCharCount < charCount) {
            if (backDelete) {
              removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
            } else {
              removedText = this._text.slice(selectionStart, selectionStart - charDiff);
            }
          }
          insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
          if (removedText && removedText.length) {
            if (insertedText.length) {
              copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
              copiedStyle = insertedText.map(function() {
                return copiedStyle[0];
              });
            }
            if (selection) {
              removeFrom = selectionStart;
              removeTo = selectionEnd;
            } else if (backDelete) {
              removeFrom = selectionEnd - removedText.length;
              removeTo = selectionEnd;
            } else {
              removeFrom = selectionEnd;
              removeTo = selectionEnd + removedText.length;
            }
            this.removeStyleFromTo(removeFrom, removeTo);
          }
          if (insertedText.length) {
            if (fromPaste && insertedText.join("") === fabric$1.copiedText && !fabric$1.disableStyleCopyPaste) {
              copiedStyle = fabric$1.copiedTextStyle;
            }
            this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
          }
          this.updateFromTextArea();
          this.fire("changed");
          if (this.canvas) {
            this.canvas.fire("text:changed", { target: this });
            this.canvas.requestRenderAll();
          }
        },
        /**
         * Composition start
         */
        onCompositionStart: function() {
          this.inCompositionMode = true;
        },
        /**
         * Composition end
         */
        onCompositionEnd: function() {
          this.inCompositionMode = false;
        },
        // /**
        //  * Composition update
        //  */
        onCompositionUpdate: function(e2) {
          this.compositionStart = e2.target.selectionStart;
          this.compositionEnd = e2.target.selectionEnd;
          this.updateTextareaPosition();
        },
        /**
         * Copies selected text
         * @param {Event} e Event object
         */
        copy: function() {
          if (this.selectionStart === this.selectionEnd) {
            return;
          }
          fabric$1.copiedText = this.getSelectedText();
          if (!fabric$1.disableStyleCopyPaste) {
            fabric$1.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
          } else {
            fabric$1.copiedTextStyle = null;
          }
          this._copyDone = true;
        },
        /**
         * Pastes text
         * @param {Event} e Event object
         */
        paste: function() {
          this.fromPaste = true;
        },
        /**
         * @private
         * @param {Event} e Event object
         * @return {Object} Clipboard data object
         */
        _getClipboardData: function(e2) {
          return e2 && e2.clipboardData || fabric$1.window.clipboardData;
        },
        /**
         * Finds the width in pixels before the cursor on the same line
         * @private
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @return {Number} widthBeforeCursor width before cursor
         */
        _getWidthBeforeCursor: function(lineIndex, charIndex) {
          var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;
          if (charIndex > 0) {
            bound = this.__charBounds[lineIndex][charIndex - 1];
            widthBeforeCursor += bound.left + bound.width;
          }
          return widthBeforeCursor;
        },
        /**
         * Gets start offset of a selection
         * @param {Event} e Event object
         * @param {Boolean} isRight
         * @return {Number}
         */
        getDownCursorOffset: function(e2, isRight) {
          var selectionProp = this._getSelectionForOffset(e2, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;
          if (lineIndex === this._textLines.length - 1 || e2.metaKey || e2.keyCode === 34) {
            return this._text.length - selectionProp;
          }
          var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);
          return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
        },
        /**
         * private
         * Helps finding if the offset should be counted from Start or End
         * @param {Event} e Event object
         * @param {Boolean} isRight
         * @return {Number}
         */
        _getSelectionForOffset: function(e2, isRight) {
          if (e2.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
            return this.selectionEnd;
          } else {
            return this.selectionStart;
          }
        },
        /**
         * @param {Event} e Event object
         * @param {Boolean} isRight
         * @return {Number}
         */
        getUpCursorOffset: function(e2, isRight) {
          var selectionProp = this._getSelectionForOffset(e2, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;
          if (lineIndex === 0 || e2.metaKey || e2.keyCode === 33) {
            return -selectionProp;
          }
          var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
          return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
        },
        /**
         * for a given width it founds the matching character.
         * @private
         */
        _getIndexOnLine: function(lineIndex, width) {
          var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;
          for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
            charWidth = this.__charBounds[lineIndex][j2].width;
            widthOfCharsOnLine += charWidth;
            if (widthOfCharsOnLine > width) {
              foundMatch = true;
              var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);
              indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j2 : j2 - 1;
              break;
            }
          }
          if (!foundMatch) {
            indexOnLine = line.length - 1;
          }
          return indexOnLine;
        },
        /**
         * Moves cursor down
         * @param {Event} e Event object
         */
        moveCursorDown: function(e2) {
          if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
            return;
          }
          this._moveCursorUpOrDown("Down", e2);
        },
        /**
         * Moves cursor up
         * @param {Event} e Event object
         */
        moveCursorUp: function(e2) {
          if (this.selectionStart === 0 && this.selectionEnd === 0) {
            return;
          }
          this._moveCursorUpOrDown("Up", e2);
        },
        /**
         * Moves cursor up or down, fires the events
         * @param {String} direction 'Up' or 'Down'
         * @param {Event} e Event object
         */
        _moveCursorUpOrDown: function(direction2, e2) {
          var action = "get" + direction2 + "CursorOffset", offset = this[action](e2, this._selectionDirection === "right");
          if (e2.shiftKey) {
            this.moveCursorWithShift(offset);
          } else {
            this.moveCursorWithoutShift(offset);
          }
          if (offset !== 0) {
            this.setSelectionInBoundaries();
            this.abortCursorAnimation();
            this._currentCursorOpacity = 1;
            this.initDelayedCursor();
            this._fireSelectionChanged();
            this._updateTextarea();
          }
        },
        /**
         * Moves cursor with shift
         * @param {Number} offset
         */
        moveCursorWithShift: function(offset) {
          var newSelection = this._selectionDirection === "left" ? this.selectionStart + offset : this.selectionEnd + offset;
          this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
          return offset !== 0;
        },
        /**
         * Moves cursor up without shift
         * @param {Number} offset
         */
        moveCursorWithoutShift: function(offset) {
          if (offset < 0) {
            this.selectionStart += offset;
            this.selectionEnd = this.selectionStart;
          } else {
            this.selectionEnd += offset;
            this.selectionStart = this.selectionEnd;
          }
          return offset !== 0;
        },
        /**
         * Moves cursor left
         * @param {Event} e Event object
         */
        moveCursorLeft: function(e2) {
          if (this.selectionStart === 0 && this.selectionEnd === 0) {
            return;
          }
          this._moveCursorLeftOrRight("Left", e2);
        },
        /**
         * @private
         * @return {Boolean} true if a change happened
         */
        _move: function(e2, prop, direction2) {
          var newValue;
          if (e2.altKey) {
            newValue = this["findWordBoundary" + direction2](this[prop]);
          } else if (e2.metaKey || e2.keyCode === 35 || e2.keyCode === 36) {
            newValue = this["findLineBoundary" + direction2](this[prop]);
          } else {
            this[prop] += direction2 === "Left" ? -1 : 1;
            return true;
          }
          if (typeof newValue !== "undefined" && this[prop] !== newValue) {
            this[prop] = newValue;
            return true;
          }
        },
        /**
         * @private
         */
        _moveLeft: function(e2, prop) {
          return this._move(e2, prop, "Left");
        },
        /**
         * @private
         */
        _moveRight: function(e2, prop) {
          return this._move(e2, prop, "Right");
        },
        /**
         * Moves cursor left without keeping selection
         * @param {Event} e
         */
        moveCursorLeftWithoutShift: function(e2) {
          var change = true;
          this._selectionDirection = "left";
          if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
            change = this._moveLeft(e2, "selectionStart");
          }
          this.selectionEnd = this.selectionStart;
          return change;
        },
        /**
         * Moves cursor left while keeping selection
         * @param {Event} e
         */
        moveCursorLeftWithShift: function(e2) {
          if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) {
            return this._moveLeft(e2, "selectionEnd");
          } else if (this.selectionStart !== 0) {
            this._selectionDirection = "left";
            return this._moveLeft(e2, "selectionStart");
          }
        },
        /**
         * Moves cursor right
         * @param {Event} e Event object
         */
        moveCursorRight: function(e2) {
          if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
            return;
          }
          this._moveCursorLeftOrRight("Right", e2);
        },
        /**
         * Moves cursor right or Left, fires event
         * @param {String} direction 'Left', 'Right'
         * @param {Event} e Event object
         */
        _moveCursorLeftOrRight: function(direction2, e2) {
          var actionName = "moveCursor" + direction2 + "With";
          this._currentCursorOpacity = 1;
          if (e2.shiftKey) {
            actionName += "Shift";
          } else {
            actionName += "outShift";
          }
          if (this[actionName](e2)) {
            this.abortCursorAnimation();
            this.initDelayedCursor();
            this._fireSelectionChanged();
            this._updateTextarea();
          }
        },
        /**
         * Moves cursor right while keeping selection
         * @param {Event} e
         */
        moveCursorRightWithShift: function(e2) {
          if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) {
            return this._moveRight(e2, "selectionStart");
          } else if (this.selectionEnd !== this._text.length) {
            this._selectionDirection = "right";
            return this._moveRight(e2, "selectionEnd");
          }
        },
        /**
         * Moves cursor right without keeping selection
         * @param {Event} e Event object
         */
        moveCursorRightWithoutShift: function(e2) {
          var changed = true;
          this._selectionDirection = "right";
          if (this.selectionStart === this.selectionEnd) {
            changed = this._moveRight(e2, "selectionStart");
            this.selectionEnd = this.selectionStart;
          } else {
            this.selectionStart = this.selectionEnd;
          }
          return changed;
        },
        /**
         * Removes characters from start/end
         * start/end ar per grapheme position in _text array.
         *
         * @param {Number} start
         * @param {Number} end default to start + 1
         */
        removeChars: function(start, end) {
          if (typeof end === "undefined") {
            end = start + 1;
          }
          this.removeStyleFromTo(start, end);
          this._text.splice(start, end - start);
          this.text = this._text.join("");
          this.set("dirty", true);
          if (this._shouldClearDimensionCache()) {
            this.initDimensions();
            this.setCoords();
          }
          this._removeExtraneousStyles();
        },
        /**
         * insert characters at start position, before start position.
         * start  equal 1 it means the text get inserted between actual grapheme 0 and 1
         * if style array is provided, it must be as the same length of text in graphemes
         * if end is provided and is bigger than start, old text is replaced.
         * start/end ar per grapheme position in _text array.
         *
         * @param {String} text text to insert
         * @param {Array} style array of style objects
         * @param {Number} start
         * @param {Number} end default to start + 1
         */
        insertChars: function(text2, style, start, end) {
          if (typeof end === "undefined") {
            end = start;
          }
          if (end > start) {
            this.removeStyleFromTo(start, end);
          }
          var graphemes = fabric$1.util.string.graphemeSplit(text2);
          this.insertNewStyleBlock(graphemes, start, style);
          this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
          this.text = this._text.join("");
          this.set("dirty", true);
          if (this._shouldClearDimensionCache()) {
            this.initDimensions();
            this.setCoords();
          }
          this._removeExtraneousStyles();
        }
      }
    );
    (function() {
      var toFixed = fabric$1.util.toFixed, multipleSpacesRegex = /  +/g;
      fabric$1.util.object.extend(
        fabric$1.Text.prototype,
        /** @lends fabric.Text.prototype */
        {
          /**
           * Returns SVG representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          _toSVG: function() {
            var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
            return this._wrapSVGTextAndBg(textAndBg);
          },
          /**
           * Returns svg representation of an instance
           * @param {Function} [reviver] Method for further parsing of svg representation.
           * @return {String} svg representation of an instance
           */
          toSVG: function(reviver) {
            return this._createBaseSVGMarkup(
              this._toSVG(),
              { reviver, noStyle: true, withShadow: true }
            );
          },
          /**
           * @private
           */
          _getSVGLeftTopOffsets: function() {
            return {
              textLeft: -this.width / 2,
              textTop: -this.height / 2,
              lineTop: this.getHeightOfLine(0)
            };
          },
          /**
           * @private
           */
          _wrapSVGTextAndBg: function(textAndBg) {
            var noShadow = true, textDecoration = this.getSvgTextDecoration(this);
            return [
              textAndBg.textBgRects.join(""),
              '		<text xml:space="preserve" ',
              this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "",
              this.fontSize ? 'font-size="' + this.fontSize + '" ' : "",
              this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "",
              this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "",
              textDecoration ? 'text-decoration="' + textDecoration + '" ' : "",
              'style="',
              this.getSvgStyles(noShadow),
              '"',
              this.addPaintOrder(),
              " >",
              textAndBg.textSpans.join(""),
              "</text>\n"
            ];
          },
          /**
           * @private
           * @param {Number} textTopOffset Text top offset
           * @param {Number} textLeftOffset Text left offset
           * @return {Object}
           */
          _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
            var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;
            this._setSVGBg(textBgRects);
            for (var i2 = 0, len = this._textLines.length; i2 < len; i2++) {
              lineOffset = this._getLineLeftOffset(i2);
              if (this.textBackgroundColor || this.styleHas("textBackgroundColor", i2)) {
                this._setSVGTextLineBg(textBgRects, i2, textLeftOffset + lineOffset, height);
              }
              this._setSVGTextLineText(textSpans, i2, textLeftOffset + lineOffset, height);
              height += this.getHeightOfLine(i2);
            }
            return {
              textSpans,
              textBgRects
            };
          },
          /**
           * @private
           */
          _createTextCharSpan: function(_char, styleDecl, left, top) {
            var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style="' + styleProps + '"' : "", dy = styleDecl.deltaY, dySpan = "", NUM_FRACTION_DIGITS = fabric$1.Object.NUM_FRACTION_DIGITS;
            if (dy) {
              dySpan = ' dy="' + toFixed(dy, NUM_FRACTION_DIGITS) + '" ';
            }
            return [
              '<tspan x="',
              toFixed(left, NUM_FRACTION_DIGITS),
              '" y="',
              toFixed(top, NUM_FRACTION_DIGITS),
              '" ',
              dySpan,
              fillStyles,
              ">",
              fabric$1.util.string.escapeXml(_char),
              "</tspan>"
            ].join("");
          },
          _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
            var lineHeight2 = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf("justify") !== -1, actualStyle, nextStyle, charsToRender = "", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;
            textTopOffset += lineHeight2 * (1 - this._fontSizeFraction) / this.lineHeight;
            for (var i2 = 0, len = line.length - 1; i2 <= len; i2++) {
              timeToRender = i2 === len || this.charSpacing;
              charsToRender += line[i2];
              charBox = this.__charBounds[lineIndex][i2];
              if (boxWidth === 0) {
                textLeftOffset += charBox.kernedWidth - charBox.width;
                boxWidth += charBox.width;
              } else {
                boxWidth += charBox.kernedWidth;
              }
              if (isJustify && !timeToRender) {
                if (this._reSpaceAndTab.test(line[i2])) {
                  timeToRender = true;
                }
              }
              if (!timeToRender) {
                actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i2);
                nextStyle = this.getCompleteStyleDeclaration(lineIndex, i2 + 1);
                timeToRender = fabric$1.util.hasStyleChanged(actualStyle, nextStyle, true);
              }
              if (timeToRender) {
                style = this._getStyleDeclaration(lineIndex, i2) || {};
                textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
                charsToRender = "";
                actualStyle = nextStyle;
                textLeftOffset += boxWidth;
                boxWidth = 0;
              }
            }
          },
          _pushTextBgRect: function(textBgRects, color2, left, top, width, height) {
            var NUM_FRACTION_DIGITS = fabric$1.Object.NUM_FRACTION_DIGITS;
            textBgRects.push(
              "		<rect ",
              this._getFillAttributes(color2),
              ' x="',
              toFixed(left, NUM_FRACTION_DIGITS),
              '" y="',
              toFixed(top, NUM_FRACTION_DIGITS),
              '" width="',
              toFixed(width, NUM_FRACTION_DIGITS),
              '" height="',
              toFixed(height, NUM_FRACTION_DIGITS),
              '"></rect>\n'
            );
          },
          _setSVGTextLineBg: function(textBgRects, i2, leftOffset, textTopOffset) {
            var line = this._textLines[i2], heightOfLine = this.getHeightOfLine(i2) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i2, 0, "textBackgroundColor");
            for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
              charBox = this.__charBounds[i2][j2];
              currentColor = this.getValueOfPropertyAt(i2, j2, "textBackgroundColor");
              if (currentColor !== lastColor) {
                lastColor && this._pushTextBgRect(
                  textBgRects,
                  lastColor,
                  leftOffset + boxStart,
                  textTopOffset,
                  boxWidth,
                  heightOfLine
                );
                boxStart = charBox.left;
                boxWidth = charBox.width;
                lastColor = currentColor;
              } else {
                boxWidth += charBox.kernedWidth;
              }
            }
            currentColor && this._pushTextBgRect(
              textBgRects,
              currentColor,
              leftOffset + boxStart,
              textTopOffset,
              boxWidth,
              heightOfLine
            );
          },
          /**
           * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
           * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
           *
           * @private
           * @param {*} value
           * @return {String}
           */
          _getFillAttributes: function(value) {
            var fillColor = value && typeof value === "string" ? new fabric$1.Color(value) : "";
            if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
              return 'fill="' + value + '"';
            }
            return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
          },
          /**
           * @private
           */
          _getSVGLineTopOffset: function(lineIndex) {
            var lineTopOffset = 0, lastHeight = 0;
            for (var j2 = 0; j2 < lineIndex; j2++) {
              lineTopOffset += this.getHeightOfLine(j2);
            }
            lastHeight = this.getHeightOfLine(j2);
            return {
              lineTop: lineTopOffset,
              offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
            };
          },
          /**
           * Returns styles-string for svg-export
           * @param {Boolean} skipShadow a boolean to skip shadow filter output
           * @return {String}
           */
          getSvgStyles: function(skipShadow) {
            var svgStyle = fabric$1.Object.prototype.getSvgStyles.call(this, skipShadow);
            return svgStyle + " white-space: pre;";
          }
        }
      );
    })();
    (function(global2) {
      var fabric2 = global2.fabric || (global2.fabric = {});
      fabric2.Textbox = fabric2.util.createClass(fabric2.IText, fabric2.Observable, {
        /**
         * Type of an object
         * @type String
         * @default
         */
        type: "textbox",
        /**
         * Minimum width of textbox, in pixels.
         * @type Number
         * @default
         */
        minWidth: 20,
        /**
         * Minimum calculated width of a textbox, in pixels.
         * fixed to 2 so that an empty textbox cannot go to 0
         * and is still selectable without text.
         * @type Number
         * @default
         */
        dynamicMinWidth: 2,
        /**
         * Cached array of text wrapping.
         * @type Array
         */
        __cachedLines: null,
        /**
         * Override standard Object class values
         */
        lockScalingFlip: true,
        /**
         * Override standard Object class values
         * Textbox needs this on false
         */
        noScaleCache: false,
        /**
         * Properties which when set cause object to change dimensions
         * @type Object
         * @private
         */
        _dimensionAffectingProps: fabric2.Text.prototype._dimensionAffectingProps.concat("width"),
        /**
         * Use this regular expression to split strings in breakable lines
         * @private
         */
        _wordJoiners: /[ \t\r]/,
        /**
         * Use this boolean property in order to split strings that have no white space concept.
         * this is a cheap way to help with chinese/japanese
         * @type Boolean
         * @since 2.6.0
         */
        splitByGrapheme: false,
        /**
         * Unlike superclass's version of this function, Textbox does not update
         * its width.
         * @private
         * @override
         */
        initDimensions: function() {
          if (this.__skipDimension) {
            return;
          }
          this.isEditing && this.initDelayedCursor();
          this.clearContextTop();
          this._clearCache();
          this.dynamicMinWidth = 0;
          this._styleMap = this._generateStyleMap(this._splitText());
          if (this.dynamicMinWidth > this.width) {
            this._set("width", this.dynamicMinWidth);
          }
          if (this.textAlign.indexOf("justify") !== -1) {
            this.enlargeSpaces();
          }
          this.height = this.calcTextHeight();
          this.saveState({ propertySet: "_dimensionAffectingProps" });
        },
        /**
         * Generate an object that translates the style object so that it is
         * broken up by visual lines (new lines and automatic wrapping).
         * The original text styles object is broken up by actual lines (new lines only),
         * which is only sufficient for Text / IText
         * @private
         */
        _generateStyleMap: function(textInfo) {
          var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};
          for (var i2 = 0; i2 < textInfo.graphemeLines.length; i2++) {
            if (textInfo.graphemeText[charCount] === "\n" && i2 > 0) {
              realLineCharCount = 0;
              charCount++;
              realLineCount++;
            } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i2 > 0) {
              realLineCharCount++;
              charCount++;
            }
            map[i2] = { line: realLineCount, offset: realLineCharCount };
            charCount += textInfo.graphemeLines[i2].length;
            realLineCharCount += textInfo.graphemeLines[i2].length;
          }
          return map;
        },
        /**
         * Returns true if object has a style property or has it on a specified line
         * @param {Number} lineIndex
         * @return {Boolean}
         */
        styleHas: function(property, lineIndex) {
          if (this._styleMap && !this.isWrapping) {
            var map = this._styleMap[lineIndex];
            if (map) {
              lineIndex = map.line;
            }
          }
          return fabric2.Text.prototype.styleHas.call(this, property, lineIndex);
        },
        /**
         * Returns true if object has no styling or no styling in a line
         * @param {Number} lineIndex , lineIndex is on wrapped lines.
         * @return {Boolean}
         */
        isEmptyStyles: function(lineIndex) {
          if (!this.styles) {
            return true;
          }
          var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
          if (map) {
            lineIndex = map.line;
            offset = map.offset;
          }
          if (mapNextLine) {
            nextLineIndex = mapNextLine.line;
            shouldLimit = nextLineIndex === lineIndex;
            nextOffset = mapNextLine.offset;
          }
          obj = typeof lineIndex === "undefined" ? this.styles : { line: this.styles[lineIndex] };
          for (var p1 in obj) {
            for (var p2 in obj[p1]) {
              if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
                for (var p3 in obj[p1][p2]) {
                  return false;
                }
              }
            }
          }
          return true;
        },
        /**
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @private
         */
        _getStyleDeclaration: function(lineIndex, charIndex) {
          if (this._styleMap && !this.isWrapping) {
            var map = this._styleMap[lineIndex];
            if (!map) {
              return null;
            }
            lineIndex = map.line;
            charIndex = map.offset + charIndex;
          }
          return this.callSuper("_getStyleDeclaration", lineIndex, charIndex);
        },
        /**
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @param {Object} style
         * @private
         */
        _setStyleDeclaration: function(lineIndex, charIndex, style) {
          var map = this._styleMap[lineIndex];
          lineIndex = map.line;
          charIndex = map.offset + charIndex;
          this.styles[lineIndex][charIndex] = style;
        },
        /**
         * @param {Number} lineIndex
         * @param {Number} charIndex
         * @private
         */
        _deleteStyleDeclaration: function(lineIndex, charIndex) {
          var map = this._styleMap[lineIndex];
          lineIndex = map.line;
          charIndex = map.offset + charIndex;
          delete this.styles[lineIndex][charIndex];
        },
        /**
         * probably broken need a fix
         * Returns the real style line that correspond to the wrapped lineIndex line
         * Used just to verify if the line does exist or not.
         * @param {Number} lineIndex
         * @returns {Boolean} if the line exists or not
         * @private
         */
        _getLineStyle: function(lineIndex) {
          var map = this._styleMap[lineIndex];
          return !!this.styles[map.line];
        },
        /**
         * Set the line style to an empty object so that is initialized
         * @param {Number} lineIndex
         * @param {Object} style
         * @private
         */
        _setLineStyle: function(lineIndex) {
          var map = this._styleMap[lineIndex];
          this.styles[map.line] = {};
        },
        /**
         * Wraps text using the 'width' property of Textbox. First this function
         * splits text on newlines, so we preserve newlines entered by the user.
         * Then it wraps each line using the width of the Textbox by calling
         * _wrapLine().
         * @param {Array} lines The string array of text that is split into lines
         * @param {Number} desiredWidth width you want to wrap to
         * @returns {Array} Array of lines
         */
        _wrapText: function(lines, desiredWidth) {
          var wrapped = [], i2;
          this.isWrapping = true;
          for (i2 = 0; i2 < lines.length; i2++) {
            wrapped = wrapped.concat(this._wrapLine(lines[i2], i2, desiredWidth));
          }
          this.isWrapping = false;
          return wrapped;
        },
        /**
         * Helper function to measure a string of text, given its lineIndex and charIndex offset
         * it gets called when charBounds are not available yet.
         * @param {CanvasRenderingContext2D} ctx
         * @param {String} text
         * @param {number} lineIndex
         * @param {number} charOffset
         * @returns {number}
         * @private
         */
        _measureWord: function(word, lineIndex, charOffset) {
          var width = 0, prevGrapheme, skipLeft = true;
          charOffset = charOffset || 0;
          for (var i2 = 0, len = word.length; i2 < len; i2++) {
            var box = this._getGraphemeBox(word[i2], lineIndex, i2 + charOffset, prevGrapheme, skipLeft);
            width += box.kernedWidth;
            prevGrapheme = word[i2];
          }
          return width;
        },
        /**
         * Wraps a line of text using the width of the Textbox and a context.
         * @param {Array} line The grapheme array that represent the line
         * @param {Number} lineIndex
         * @param {Number} desiredWidth width you want to wrap the line to
         * @param {Number} reservedSpace space to remove from wrapping for custom functionalities
         * @returns {Array} Array of line(s) into which the given text is wrapped
         * to.
         */
        _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
          var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], words = splitByGrapheme ? fabric2.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = "", offset = 0, infix = splitByGrapheme ? "" : " ", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;
          if (words.length === 0) {
            words.push([]);
          }
          desiredWidth -= reservedSpace;
          for (var i2 = 0; i2 < words.length; i2++) {
            word = splitByGrapheme ? words[i2] : fabric2.util.string.graphemeSplit(words[i2]);
            wordWidth = this._measureWord(word, lineIndex, offset);
            offset += word.length;
            lineWidth += infixWidth + wordWidth - additionalSpace;
            if (lineWidth > desiredWidth && !lineJustStarted) {
              graphemeLines.push(line);
              line = [];
              lineWidth = wordWidth;
              lineJustStarted = true;
            } else {
              lineWidth += additionalSpace;
            }
            if (!lineJustStarted && !splitByGrapheme) {
              line.push(infix);
            }
            line = line.concat(word);
            infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
            offset++;
            lineJustStarted = false;
            if (wordWidth > largestWordWidth) {
              largestWordWidth = wordWidth;
            }
          }
          i2 && graphemeLines.push(line);
          if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
            this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
          }
          return graphemeLines;
        },
        /**
         * Detect if the text line is ended with an hard break
         * text and itext do not have wrapping, return false
         * @param {Number} lineIndex text to split
         * @return {Boolean}
         */
        isEndOfWrapping: function(lineIndex) {
          if (!this._styleMap[lineIndex + 1]) {
            return true;
          }
          if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
            return true;
          }
          return false;
        },
        /**
         * Detect if a line has a linebreak and so we need to account for it when moving
         * and counting style.
         * @return Number
         */
        missingNewlineOffset: function(lineIndex) {
          if (this.splitByGrapheme) {
            return this.isEndOfWrapping(lineIndex) ? 1 : 0;
          }
          return 1;
        },
        /**
        * Gets lines of text to render in the Textbox. This function calculates
        * text wrapping on the fly every time it is called.
        * @param {String} text text to split
        * @returns {Array} Array of lines in the Textbox.
        * @override
        */
        _splitTextIntoLines: function(text2) {
          var newText = fabric2.Text.prototype._splitTextIntoLines.call(this, text2), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);
          for (var i2 = 0; i2 < graphemeLines.length; i2++) {
            lines[i2] = graphemeLines[i2].join("");
          }
          newText.lines = lines;
          newText.graphemeLines = graphemeLines;
          return newText;
        },
        getMinWidth: function() {
          return Math.max(this.minWidth, this.dynamicMinWidth);
        },
        _removeExtraneousStyles: function() {
          var linesToKeep = {};
          for (var prop in this._styleMap) {
            if (this._textLines[prop]) {
              linesToKeep[this._styleMap[prop].line] = 1;
            }
          }
          for (var prop in this.styles) {
            if (!linesToKeep[prop]) {
              delete this.styles[prop];
            }
          }
        },
        /**
         * Returns object representation of an instance
         * @method toObject
         * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
         * @return {Object} object representation of an instance
         */
        toObject: function(propertiesToInclude) {
          return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(propertiesToInclude));
        }
      });
      fabric2.Textbox.fromObject = function(object, callback) {
        var styles = fabric2.util.stylesFromArray(object.styles, object.text);
        var objCopy = Object.assign({}, object, { styles });
        return fabric2.Object._fromObject("Textbox", objCopy, callback, "text");
      };
    })(exports);
    (function() {
      var controlsUtils = fabric$1.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric$1.Object.prototype.controls;
      objectControls.ml = new fabric$1.Control({
        x: -0.5,
        y: 0,
        cursorStyleHandler: scaleSkewStyleHandler,
        actionHandler: scalingXOrSkewingY,
        getActionName: scaleOrSkewActionName
      });
      objectControls.mr = new fabric$1.Control({
        x: 0.5,
        y: 0,
        cursorStyleHandler: scaleSkewStyleHandler,
        actionHandler: scalingXOrSkewingY,
        getActionName: scaleOrSkewActionName
      });
      objectControls.mb = new fabric$1.Control({
        x: 0,
        y: 0.5,
        cursorStyleHandler: scaleSkewStyleHandler,
        actionHandler: scalingYOrSkewingX,
        getActionName: scaleOrSkewActionName
      });
      objectControls.mt = new fabric$1.Control({
        x: 0,
        y: -0.5,
        cursorStyleHandler: scaleSkewStyleHandler,
        actionHandler: scalingYOrSkewingX,
        getActionName: scaleOrSkewActionName
      });
      objectControls.tl = new fabric$1.Control({
        x: -0.5,
        y: -0.5,
        cursorStyleHandler: scaleStyleHandler,
        actionHandler: scalingEqually
      });
      objectControls.tr = new fabric$1.Control({
        x: 0.5,
        y: -0.5,
        cursorStyleHandler: scaleStyleHandler,
        actionHandler: scalingEqually
      });
      objectControls.bl = new fabric$1.Control({
        x: -0.5,
        y: 0.5,
        cursorStyleHandler: scaleStyleHandler,
        actionHandler: scalingEqually
      });
      objectControls.br = new fabric$1.Control({
        x: 0.5,
        y: 0.5,
        cursorStyleHandler: scaleStyleHandler,
        actionHandler: scalingEqually
      });
      objectControls.mtr = new fabric$1.Control({
        x: 0,
        y: -0.5,
        actionHandler: controlsUtils.rotationWithSnapping,
        cursorStyleHandler: controlsUtils.rotationStyleHandler,
        offsetY: -40,
        withConnection: true,
        actionName: "rotate"
      });
      if (fabric$1.Textbox) {
        var textBoxControls = fabric$1.Textbox.prototype.controls = {};
        textBoxControls.mtr = objectControls.mtr;
        textBoxControls.tr = objectControls.tr;
        textBoxControls.br = objectControls.br;
        textBoxControls.tl = objectControls.tl;
        textBoxControls.bl = objectControls.bl;
        textBoxControls.mt = objectControls.mt;
        textBoxControls.mb = objectControls.mb;
        textBoxControls.mr = new fabric$1.Control({
          x: 0.5,
          y: 0,
          actionHandler: controlsUtils.changeWidth,
          cursorStyleHandler: scaleSkewStyleHandler,
          actionName: "resizing"
        });
        textBoxControls.ml = new fabric$1.Control({
          x: -0.5,
          y: 0,
          actionHandler: controlsUtils.changeWidth,
          cursorStyleHandler: scaleSkewStyleHandler,
          actionName: "resizing"
        });
      }
    })();
  })(fabric);
  return fabric;
}
var fabricExports = requireFabric();
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var current_ansi = 1252;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var CS2CP = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
};
var set_ansi = function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1) return;
  current_ansi = CS2CP[0] = cp;
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(cp) {
  set_ansi(cp);
};
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
function char_codes(data) {
  var o2 = [];
  for (var i2 = 0, len = data.length; i2 < len; ++i2) o2[i2] = data.charCodeAt(i2);
  return o2;
}
function utf16leread(data) {
  var o2 = [];
  for (var i2 = 0; i2 < data.length >> 1; ++i2) o2[i2] = String.fromCharCode(data.charCodeAt(2 * i2) + (data.charCodeAt(2 * i2 + 1) << 8));
  return o2.join("");
}
function utf16beread(data) {
  var o2 = [];
  for (var i2 = 0; i2 < data.length >> 1; ++i2) o2[i2] = String.fromCharCode(data.charCodeAt(2 * i2 + 1) + (data.charCodeAt(2 * i2) << 8));
  return o2.join("");
}
var debom = function(data) {
  var c1 = data.charCodeAt(0), c2 = data.charCodeAt(1);
  if (c1 == 255 && c2 == 254) return utf16leread(data.slice(2));
  if (c1 == 254 && c2 == 255) return utf16beread(data.slice(2));
  if (c1 == 65279) return data.slice(1);
  return data;
};
var _getchar = function _gc1(x2) {
  return String.fromCharCode(x2);
};
var _getansi = function _ga1(x2) {
  return String.fromCharCode(x2);
};
var $cptable;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o2 = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  for (var i2 = 0; i2 < input.length; ) {
    c1 = input.charCodeAt(i2++);
    e1 = c1 >> 2;
    c2 = input.charCodeAt(i2++);
    e2 = (c1 & 3) << 4 | c2 >> 4;
    c3 = input.charCodeAt(i2++);
    e3 = (c2 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c2)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o2 += Base64_map.charAt(e1) + Base64_map.charAt(e2) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o2;
}
function Base64_decode(input) {
  var o2 = "";
  var c1 = 0, c2 = 0, c3 = 0, e1 = 0, e2 = 0, e3 = 0, e4 = 0;
  input = input.replace(/[^\w\+\/\=]/g, "");
  for (var i2 = 0; i2 < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i2++));
    e2 = Base64_map.indexOf(input.charAt(i2++));
    c1 = e1 << 2 | e2 >> 4;
    o2 += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i2++));
    c2 = (e2 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o2 += String.fromCharCode(c2);
    }
    e4 = Base64_map.indexOf(input.charAt(i2++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o2 += String.fromCharCode(c3);
    }
  }
  return o2;
}
var has_buf = /* @__PURE__ */ (function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
})();
var Buffer_from = /* @__PURE__ */ (function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs) try {
      Buffer.from("foo", "utf8");
    } catch (e2) {
      nbfs = true;
    }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
})();
function new_raw_buf(len) {
  if (has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
function new_unsafe_buf(len) {
  if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
var s2a = function s2a2(s2) {
  if (has_buf) return Buffer_from(s2, "binary");
  return s2.split("").map(function(x2) {
    return x2.charCodeAt(0) & 255;
  });
};
function a2s(data) {
  if (Array.isArray(data)) return data.map(function(c2) {
    return String.fromCharCode(c2);
  }).join("");
  var o2 = [];
  for (var i2 = 0; i2 < data.length; ++i2) o2[i2] = String.fromCharCode(data[i2]);
  return o2.join("");
}
function ab2a(data) {
  if (typeof ArrayBuffer == "undefined") throw new Error("Unsupported");
  if (data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));
  var o2 = new Array(data.length);
  for (var i2 = 0; i2 < data.length; ++i2) o2[i2] = data[i2];
  return o2;
}
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i2 = 0, maxlen = 0;
    for (i2 = 0; i2 < bufs.length; ++i2) maxlen += bufs[i2].length;
    var o2 = new Uint8Array(maxlen);
    var len = 0;
    for (i2 = 0, maxlen = 0; i2 < bufs.length; maxlen += len, ++i2) {
      len = bufs[i2].length;
      if (bufs[i2] instanceof Uint8Array) o2.set(bufs[i2], maxlen);
      else if (typeof bufs[i2] == "string") {
        throw "wtf";
      } else o2.set(new Uint8Array(bufs[i2]), maxlen);
    }
    return o2;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content2) {
  var out = [], widx = 0, L2 = content2.length + 250;
  var o2 = new_raw_buf(content2.length + 255);
  for (var ridx = 0; ridx < content2.length; ++ridx) {
    var c2 = content2.charCodeAt(ridx);
    if (c2 < 128) o2[widx++] = c2;
    else if (c2 < 2048) {
      o2[widx++] = 192 | c2 >> 6 & 31;
      o2[widx++] = 128 | c2 & 63;
    } else if (c2 >= 55296 && c2 < 57344) {
      c2 = (c2 & 1023) + 64;
      var d2 = content2.charCodeAt(++ridx) & 1023;
      o2[widx++] = 240 | c2 >> 8 & 7;
      o2[widx++] = 128 | c2 >> 2 & 63;
      o2[widx++] = 128 | d2 >> 6 & 15 | (c2 & 3) << 4;
      o2[widx++] = 128 | d2 & 63;
    } else {
      o2[widx++] = 224 | c2 >> 12 & 15;
      o2[widx++] = 128 | c2 >> 6 & 63;
      o2[widx++] = 128 | c2 & 63;
    }
    if (widx > L2) {
      out.push(o2.slice(0, widx));
      widx = 0;
      o2 = new_raw_buf(65535);
      L2 = 65530;
    }
  }
  out.push(o2.slice(0, widx));
  return bconcat(out);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x2) {
  var o2 = "", i2 = x2.length - 1;
  while (i2 >= 0) o2 += x2.charAt(i2--);
  return o2;
}
function pad0(v2, d2) {
  var t3 = "" + v2;
  return t3.length >= d2 ? t3 : fill("0", d2 - t3.length) + t3;
}
function pad_(v2, d2) {
  var t3 = "" + v2;
  return t3.length >= d2 ? t3 : fill(" ", d2 - t3.length) + t3;
}
function rpad_(v2, d2) {
  var t3 = "" + v2;
  return t3.length >= d2 ? t3 : t3 + fill(" ", d2 - t3.length);
}
function pad0r1(v2, d2) {
  var t3 = "" + Math.round(v2);
  return t3.length >= d2 ? t3 : fill("0", d2 - t3.length) + t3;
}
function pad0r2(v2, d2) {
  var t3 = "" + v2;
  return t3.length >= d2 ? t3 : fill("0", d2 - t3.length) + t3;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v2, d2) {
  if (v2 > p2_32 || v2 < -p2_32) return pad0r1(v2, d2);
  var i2 = Math.round(v2);
  return pad0r2(i2, d2);
}
function SSF_isgeneral(s2, i2) {
  i2 = i2 || 0;
  return s2.length >= 7 + i2 && (s2.charCodeAt(i2) | 32) === 103 && (s2.charCodeAt(i2 + 1) | 32) === 101 && (s2.charCodeAt(i2 + 2) | 32) === 110 && (s2.charCodeAt(i2 + 3) | 32) === 101 && (s2.charCodeAt(i2 + 4) | 32) === 114 && (s2.charCodeAt(i2 + 5) | 32) === 97 && (s2.charCodeAt(i2 + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t3) {
  if (!t3) t3 = {};
  t3[0] = "General";
  t3[1] = "0";
  t3[2] = "0.00";
  t3[3] = "#,##0";
  t3[4] = "#,##0.00";
  t3[9] = "0%";
  t3[10] = "0.00%";
  t3[11] = "0.00E+00";
  t3[12] = "# ?/?";
  t3[13] = "# ??/??";
  t3[14] = "m/d/yy";
  t3[15] = "d-mmm-yy";
  t3[16] = "d-mmm";
  t3[17] = "mmm-yy";
  t3[18] = "h:mm AM/PM";
  t3[19] = "h:mm:ss AM/PM";
  t3[20] = "h:mm";
  t3[21] = "h:mm:ss";
  t3[22] = "m/d/yy h:mm";
  t3[37] = "#,##0 ;(#,##0)";
  t3[38] = "#,##0 ;[Red](#,##0)";
  t3[39] = "#,##0.00;(#,##0.00)";
  t3[40] = "#,##0.00;[Red](#,##0.00)";
  t3[45] = "mm:ss";
  t3[46] = "[h]:mm:ss";
  t3[47] = "mmss.0";
  t3[48] = "##0.0E+0";
  t3[49] = "@";
  t3[56] = '"ä¸å/ä¸å "hh"æ"mm"å"ss"ç§ "';
  return t3;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"ä¸å/ä¸å "hh"æ"mm"å"ss"ç§ "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x2, D2, mixed) {
  var sgn = x2 < 0 ? -1 : 1;
  var B3 = x2 * sgn;
  var P_2 = 0, P_1 = 1, P2 = 0;
  var Q_2 = 1, Q_1 = 0, Q2 = 0;
  var A2 = Math.floor(B3);
  while (Q_1 < D2) {
    A2 = Math.floor(B3);
    P2 = A2 * P_1 + P_2;
    Q2 = A2 * Q_1 + Q_2;
    if (B3 - A2 < 5e-8) break;
    B3 = 1 / (B3 - A2);
    P_2 = P_1;
    P_1 = P2;
    Q_2 = Q_1;
    Q_1 = Q2;
  }
  if (Q2 > D2) {
    if (Q_1 > D2) {
      Q2 = Q_2;
      P2 = P_2;
    } else {
      Q2 = Q_1;
      P2 = P_1;
    }
  }
  if (!mixed) return [0, sgn * P2, Q2];
  var q2 = Math.floor(sgn * P2 / Q2);
  return [q2, sgn * P2 - q2 * Q2, Q2];
}
function SSF_parse_date_code(v2, opts, b2) {
  if (v2 > 2958465 || v2 < 0) return null;
  var date = v2 | 0, time2 = Math.floor(86400 * (v2 - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time2, u: 86400 * (v2 - date) - time2, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6) out.u = 0;
  if (opts && opts.date1904) date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time2 == 86400) {
      out.T = time2 = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60) --date;
    var d2 = new Date(1900, 0, 1);
    d2.setDate(d2.getDate() + date - 1);
    dout = [d2.getFullYear(), d2.getMonth() + 1, d2.getDate()];
    dow = d2.getDay();
    if (date < 60) dow = (dow + 6) % 7;
    if (b2) dow = SSF_fix_hijri(d2, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time2 % 60;
  time2 = Math.floor(time2 / 60);
  out.M = time2 % 60;
  time2 = Math.floor(time2 / 60);
  out.H = time2;
  out.q = dow;
  return out;
}
var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function datenum_local(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
  else if (v2 >= SSFbase1904) epoch += 24 * 60 * 60 * 1e3;
  return (epoch - (SSFdnthresh + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function SSF_strip_decimal(o2) {
  return o2.indexOf(".") == -1 ? o2 : o2.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(o2) {
  if (o2.indexOf("E") == -1) return o2;
  return o2.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(v2) {
  var w2 = v2 < 0 ? 12 : 11;
  var o2 = SSF_strip_decimal(v2.toFixed(12));
  if (o2.length <= w2) return o2;
  o2 = v2.toPrecision(10);
  if (o2.length <= w2) return o2;
  return v2.toExponential(5);
}
function SSF_large_exp(v2) {
  var o2 = SSF_strip_decimal(v2.toFixed(11));
  return o2.length > (v2 < 0 ? 12 : 11) || o2 === "0" || o2 === "-0" ? v2.toPrecision(6) : o2;
}
function SSF_general_num(v2) {
  var V2 = Math.floor(Math.log(Math.abs(v2)) * Math.LOG10E), o2;
  if (V2 >= -4 && V2 <= -1) o2 = v2.toPrecision(10 + V2);
  else if (Math.abs(V2) <= 9) o2 = SSF_small_exp(v2);
  else if (V2 === 10) o2 = v2.toFixed(10).substr(0, 12);
  else o2 = SSF_large_exp(v2);
  return SSF_strip_decimal(SSF_normalize_exp(o2.toUpperCase()));
}
function SSF_general(v2, opts) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "TRUE" : "FALSE";
    case "number":
      return (v2 | 0) === v2 ? v2.toString(10) : SSF_general_num(v2);
    case "undefined":
      return "";
    case "object":
      if (v2 == null) return "";
      if (v2 instanceof Date) return SSF_format(14, datenum_local(v2, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v2);
}
function SSF_fix_hijri(date, o2) {
  o2[0] -= 581;
  var dow = date.getDay();
  if (date < 60) dow = (dow + 6) % 7;
  return dow;
}
function SSF_write_date(type, fmt, val, ss0) {
  var o2 = "", ss = 0, tt2 = 0, y2 = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y2 = val.y + 543;
    /* falls through */
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y2 % 100;
          outl = 2;
          break;
        default:
          out = y2 % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
      if (ss0 >= 2) tt2 = ss0 === 3 ? 1e3 : 100;
      else tt2 = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt2 * (val.S + val.u));
      if (ss >= 60 * tt2) ss = 0;
      if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt2;
      o2 = pad0(ss, 2 + ss0);
      if (fmt === "ss") return o2.substr(0, 2);
      return "." + o2.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y2;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
function commaify(s2) {
  var w2 = 3;
  if (s2.length <= w2) return s2;
  var j2 = s2.length % w2, o2 = s2.substr(0, j2);
  for (; j2 != s2.length; j2 += w2) o2 += (o2.length > 0 ? "," : "") + s2.substr(j2, w2);
  return o2;
}
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_exp(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (o2.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else o2 += "E+" + (fakee - ee2);
      while (o2.substr(0, 2) === "0.") {
        o2 = o2.charAt(0) + o2.substr(2, period) + "." + o2.substr(2 + period);
        o2 = o2.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r2, aval, sign) {
  var den = parseInt(r2[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r2[1].length + 1 + r2[4].length) : pad_(myn, r2[1].length) + r2[2] + "/" + r2[3] + pad0(myd, r2[4].length));
}
function write_num_f2(r2, aval, sign) {
  return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r2[1].length + 2 + r2[4].length);
}
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o2 = "", cc;
  for (var i2 = 0; i2 != str.length; ++i2) switch (cc = str.charCodeAt(i2)) {
    case 35:
      break;
    case 63:
      o2 += " ";
      break;
    case 48:
      o2 += "0";
      break;
    default:
      o2 += String.fromCharCode(cc);
  }
  return o2;
}
function rnd(val, d2) {
  var dd = Math.pow(10, d2);
  return "" + Math.round(val * dd) / dd;
}
function dec(val, d2) {
  var _frac = val - Math.floor(val), dd = Math.pow(10, d2);
  if (d2 < ("" + Math.round(_frac * dd)).length) return 0;
  return Math.round(_frac * dd);
}
function carry(val, d2) {
  if (d2 < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d2))).length) {
    return 1;
  }
  return 0;
}
function flr(val) {
  if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r2, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = pad0r(val, 0);
    if (o2 === "0") o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(frac1)) return write_num_f1(r2, aval, sign);
  if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r2 = fmt.match(dec1)) {
    o2 = rnd(val, r2[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r2[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + rnd(aval, r2[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
  }
  if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
  if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r2[1].length))) + "." + pad0(dec(val, r2[1].length), r2[1].length);
  }
  if (r2 = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
      return ri < o2.length ? o2.charAt(ri++) : x3 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_flt(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa = "";
  if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r2[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o2 = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r2[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
    o2 += oa + /*::String(*/
    r2[2] + "/" + /*::String(*/
    r2[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r2[4].length) oa = hashq(r2[4].substr(r2[4].length - oa.length)) + oa;
    o2 += oa;
    return o2;
  }
  if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r2[1].length, r2[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r2[2] + "/" + r2[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r2[2].length + r2[3].length));
  }
  if (r2 = fmt.match(/^[#0?]+$/)) {
    o2 = pad0r(val, 0);
    if (fmt.length <= o2.length) return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri = dec(val, r2[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri, r2[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x2 = commaify(pad0r(aval, 0));
      return x2 !== "0" ? sign + x2 : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_exp2(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (!o2.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else o2 += "E+" + (fakee - ee2);
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r2, ri, ff, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = "" + val;
    if (val === 0) o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(frac1)) return write_num_f2(r2, aval, sign);
  if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r2 = fmt.match(dec1)) {
    o2 = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1]));
    o2 = o2.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r2[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
  }
  if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
  if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r2[1].length);
  }
  if (r2 = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
      return ri < o2.length ? o2.charAt(ri++) : x3 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_int(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa = "";
  if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(
      /*::String(*/
      r2[4].length,
      7
    );
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, false);
    o2 = "" + sign;
    oa = write_num(
      "n",
      /*::String(*/
      r2[1],
      ff[1]
    );
    if (oa.charAt(oa.length - 1) == " ") oa = oa.substr(0, oa.length - 1) + "0";
    o2 += oa + /*::String(*/
    r2[2] + "/" + /*::String(*/
    r2[3];
    oa = rpad_(ff[2], ri);
    if (oa.length < r2[4].length) oa = hashq(r2[4].substr(r2[4].length - oa.length)) + oa;
    o2 += oa;
    return o2;
  }
  if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri = Math.min(Math.max(r2[1].length, r2[4].length), 7);
    ff = SSF_frac(aval, Math.pow(10, ri) - 1, true);
    return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r2[2] + "/" + r2[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r2[2].length + r2[3].length));
  }
  if (r2 = fmt.match(/^[#0?]+$/)) {
    o2 = "" + val;
    if (fmt.length <= o2.length) return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r2[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x2 = commaify("" + aval);
      return x2 !== "0" ? sign + x2 : "";
    default:
      if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i2 = 0, j2 = 0; i2 < fmt.length; ++i2) switch (
    /*cc=*/
    fmt.charCodeAt(i2)
  ) {
    case 34:
      in_str = !in_str;
      break;
    case 95:
    case 42:
    case 92:
      ++i2;
      break;
    case 59:
      out[out.length] = fmt.substr(j2, i2 - j2);
      j2 = i2 + 1;
  }
  out[out.length] = fmt.substr(j2);
  if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i2 = 0, c2 = "", o2 = "";
  while (i2 < fmt.length) {
    switch (c2 = fmt.charAt(i2)) {
      case "G":
        if (SSF_isgeneral(fmt, i2)) i2 += 6;
        i2++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i2) !== 34 && i2 < fmt.length;
        ) {
        }
        ++i2;
        break;
      case "\\":
        i2 += 2;
        break;
      case "_":
        i2 += 2;
        break;
      case "@":
        ++i2;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2") return true;
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "ä¸":
        if (fmt.substr(i2, 3).toUpperCase() === "A/P") return true;
        if (fmt.substr(i2, 5).toUpperCase() === "AM/PM") return true;
        if (fmt.substr(i2, 5).toUpperCase() === "ä¸å/ä¸å") return true;
        ++i2;
        break;
      case "[":
        o2 = c2;
        while (fmt.charAt(i2++) !== "]" && i2 < fmt.length) o2 += fmt.charAt(i2);
        if (o2.match(SSF_abstime)) return true;
        break;
      case ".":
      /* falls through */
      case "0":
      case "#":
        while (i2 < fmt.length && ("0#?.,E+-%".indexOf(c2 = fmt.charAt(++i2)) > -1 || c2 == "\\" && fmt.charAt(i2 + 1) == "-" && "0#".indexOf(fmt.charAt(i2 + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i2) === c2) {
        }
        break;
      case "*":
        ++i2;
        if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*") ++i2;
        break;
      case "(":
      case ")":
        ++i2;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1) {
        }
        break;
      case " ":
        ++i2;
        break;
      default:
        ++i2;
        break;
    }
  }
  return false;
}
function eval_fmt(fmt, v2, opts, flen) {
  var out = [], o2 = "", i2 = 0, c2 = "", lst = "t", dt2, j2, cc;
  var hr = "H";
  while (i2 < fmt.length) {
    switch (c2 = fmt.charAt(i2)) {
      case "G":
        if (!SSF_isgeneral(fmt, i2)) throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i2 += 7;
        break;
      case '"':
        for (o2 = ""; (cc = fmt.charCodeAt(++i2)) !== 34 && i2 < fmt.length; ) o2 += String.fromCharCode(cc);
        out[out.length] = { t: "t", v: o2 };
        ++i2;
        break;
      case "\\":
        var w2 = fmt.charAt(++i2), t3 = w2 === "(" || w2 === ")" ? w2 : "t";
        out[out.length] = { t: t3, v: w2 };
        ++i2;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i2 += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v: v2 };
        ++i2;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2") {
          if (dt2 == null) {
            dt2 = SSF_parse_date_code(v2, opts, fmt.charAt(i2 + 1) === "2");
            if (dt2 == null) return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i2, 2) };
          lst = c2;
          i2 += 2;
          break;
        }
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c2 = c2.toLowerCase();
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v2 < 0) return "";
        if (dt2 == null) {
          dt2 = SSF_parse_date_code(v2, opts);
          if (dt2 == null) return "";
        }
        o2 = c2;
        while (++i2 < fmt.length && fmt.charAt(i2).toLowerCase() === c2) o2 += c2;
        if (c2 === "m" && lst.toLowerCase() === "h") c2 = "M";
        if (c2 === "h") c2 = hr;
        out[out.length] = { t: c2, v: o2 };
        lst = c2;
        break;
      case "A":
      case "a":
      case "ä¸":
        var q2 = { t: c2, v: c2 };
        if (dt2 == null) dt2 = SSF_parse_date_code(v2, opts);
        if (fmt.substr(i2, 3).toUpperCase() === "A/P") {
          if (dt2 != null) q2.v = dt2.H >= 12 ? "P" : "A";
          q2.t = "T";
          hr = "h";
          i2 += 3;
        } else if (fmt.substr(i2, 5).toUpperCase() === "AM/PM") {
          if (dt2 != null) q2.v = dt2.H >= 12 ? "PM" : "AM";
          q2.t = "T";
          i2 += 5;
          hr = "h";
        } else if (fmt.substr(i2, 5).toUpperCase() === "ä¸å/ä¸å") {
          if (dt2 != null) q2.v = dt2.H >= 12 ? "ä¸å" : "ä¸å";
          q2.t = "T";
          i2 += 5;
          hr = "h";
        } else {
          q2.t = "t";
          ++i2;
        }
        if (dt2 == null && q2.t === "T") return "";
        out[out.length] = q2;
        lst = c2;
        break;
      case "[":
        o2 = c2;
        while (fmt.charAt(i2++) !== "]" && i2 < fmt.length) o2 += fmt.charAt(i2);
        if (o2.slice(-1) !== "]") throw 'unterminated "[" block: |' + o2 + "|";
        if (o2.match(SSF_abstime)) {
          if (dt2 == null) {
            dt2 = SSF_parse_date_code(v2, opts);
            if (dt2 == null) return "";
          }
          out[out.length] = { t: "Z", v: o2.toLowerCase() };
          lst = o2.charAt(1);
        } else if (o2.indexOf("$") > -1) {
          o2 = (o2.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o2 };
        }
        break;
      /* Numbers */
      case ".":
        if (dt2 != null) {
          o2 = c2;
          while (++i2 < fmt.length && (c2 = fmt.charAt(i2)) === "0") o2 += c2;
          out[out.length] = { t: "s", v: o2 };
          break;
        }
      /* falls through */
      case "0":
      case "#":
        o2 = c2;
        while (++i2 < fmt.length && "0#?.,E+-%".indexOf(c2 = fmt.charAt(i2)) > -1) o2 += c2;
        out[out.length] = { t: "n", v: o2 };
        break;
      case "?":
        o2 = c2;
        while (fmt.charAt(++i2) === c2) o2 += c2;
        out[out.length] = { t: c2, v: o2 };
        lst = c2;
        break;
      case "*":
        ++i2;
        if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*") ++i2;
        break;
      // **
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c2, v: c2 };
        ++i2;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o2 = c2;
        while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1) o2 += fmt.charAt(i2);
        out[out.length] = { t: "D", v: o2 };
        break;
      case " ":
        out[out.length] = { t: c2, v: c2 };
        ++i2;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i2;
        break;
      default:
        if (",$-+/():!^&'~{}<>=â¬acfijklopqrtuvwxzP".indexOf(c2) === -1) throw new Error("unrecognized character " + c2 + " in " + fmt);
        out[out.length] = { t: "t", v: c2 };
        ++i2;
        break;
    }
  }
  var bt2 = 0, ss0 = 0, ssm;
  for (i2 = out.length - 1, lst = "t"; i2 >= 0; --i2) {
    switch (out[i2].t) {
      case "h":
      case "H":
        out[i2].t = hr;
        lst = "h";
        if (bt2 < 1) bt2 = 1;
        break;
      case "s":
        if (ssm = out[i2].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
        if (bt2 < 3) bt2 = 3;
      /* falls through */
      case "d":
      case "y":
      case "M":
      case "e":
        lst = out[i2].t;
        break;
      case "m":
        if (lst === "s") {
          out[i2].t = "M";
          if (bt2 < 2) bt2 = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt2 < 1 && out[i2].v.match(/[Hh]/)) bt2 = 1;
        if (bt2 < 2 && out[i2].v.match(/[Mm]/)) bt2 = 2;
        if (bt2 < 3 && out[i2].v.match(/[Ss]/)) bt2 = 3;
    }
  }
  switch (bt2) {
    case 0:
      break;
    case 1:
      if (dt2.u >= 0.5) {
        dt2.u = 0;
        ++dt2.S;
      }
      if (dt2.S >= 60) {
        dt2.S = 0;
        ++dt2.M;
      }
      if (dt2.M >= 60) {
        dt2.M = 0;
        ++dt2.H;
      }
      break;
    case 2:
      if (dt2.u >= 0.5) {
        dt2.u = 0;
        ++dt2.S;
      }
      if (dt2.S >= 60) {
        dt2.S = 0;
        ++dt2.M;
      }
      break;
  }
  var nstr = "", jj;
  for (i2 = 0; i2 < out.length; ++i2) {
    switch (out[i2].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i2].v = "";
        out[i2].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i2].v = SSF_write_date(out[i2].t.charCodeAt(0), out[i2].v, dt2, ss0);
        out[i2].t = "t";
        break;
      case "n":
      case "?":
        jj = i2 + 1;
        while (out[jj] != null && ((c2 = out[jj].t) === "?" || c2 === "D" || (c2 === " " || c2 === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i2].t === "(" && (c2 === " " || c2 === "n" || c2 === ")") || c2 === "t" && (out[jj].v === "/" || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
          out[i2].v += out[jj].v;
          out[jj] = { v: "", t: ";" };
          ++jj;
        }
        nstr += out[i2].v;
        i2 = jj - 1;
        break;
      case "G":
        out[i2].t = "t";
        out[i2].v = SSF_general(v2, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v2 < 0 && nstr.charCodeAt(0) === 45 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v2 < 0 && flen > 1 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj = ostr.length - 1;
    var decpt = out.length;
    for (i2 = 0; i2 < out.length; ++i2) if (out[i2] != null && out[i2].t != "t" && out[i2].v.indexOf(".") > -1) {
      decpt = i2;
      break;
    }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i2 = out.length - 1; i2 >= 0; --i2) {
        if (out[i2] == null || "n?".indexOf(out[i2].t) === -1) continue;
        if (jj >= out[i2].v.length - 1) {
          jj -= out[i2].v.length;
          out[i2].v = ostr.substr(jj + 1, out[i2].v.length);
        } else if (jj < 0) out[i2].v = "";
        else {
          out[i2].v = ostr.substr(0, jj + 1);
          jj = -1;
        }
        out[i2].t = "t";
        lasti = i2;
      }
      if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj = ostr.indexOf(".") - 1;
      for (i2 = decpt; i2 >= 0; --i2) {
        if (out[i2] == null || "n?".indexOf(out[i2].t) === -1) continue;
        j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") - 1 : out[i2].v.length - 1;
        vv = out[i2].v.substr(j2 + 1);
        for (; j2 >= 0; --j2) {
          if (jj >= 0 && (out[i2].v.charAt(j2) === "0" || out[i2].v.charAt(j2) === "#")) vv = ostr.charAt(jj--) + vv;
        }
        out[i2].v = vv;
        out[i2].t = "t";
        lasti = i2;
      }
      if (jj >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
      jj = ostr.indexOf(".") + 1;
      for (i2 = decpt; i2 < out.length; ++i2) {
        if (out[i2] == null || "n?(".indexOf(out[i2].t) === -1 && i2 !== decpt) continue;
        j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") + 1 : 0;
        vv = out[i2].v.substr(0, j2);
        for (; j2 < out[i2].v.length; ++j2) {
          if (jj < ostr.length) vv += ostr.charAt(jj++);
        }
        out[i2].v = vv;
        out[i2].t = "t";
        lasti = i2;
      }
    }
  }
  for (i2 = 0; i2 < out.length; ++i2) if (out[i2] != null && "n?".indexOf(out[i2].t) > -1) {
    myv = flen > 1 && v2 < 0 && i2 > 0 && out[i2 - 1].v === "-" ? -v2 : v2;
    out[i2].v = write_num(out[i2].t, out[i2].v, myv);
    out[i2].t = "t";
  }
  var retval = "";
  for (i2 = 0; i2 !== out.length; ++i2) if (out[i2] != null) retval += out[i2].v;
  return retval;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v2, rr) {
  if (rr == null) return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v2 == thresh) return true;
      break;
    case ">":
      if (v2 > thresh) return true;
      break;
    case "<":
      if (v2 < thresh) return true;
      break;
    case "<>":
      if (v2 != thresh) return true;
      break;
    case ">=":
      if (v2 >= thresh) return true;
      break;
    case "<=":
      if (v2 <= thresh) return true;
      break;
  }
  return false;
}
function choose_fmt(f2, v2) {
  var fmt = SSF_split_fmt(f2);
  var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
  if (l2 < 4 && lat > -1) --l2;
  if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v2 !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff = v2 > 0 ? fmt[0] : v2 < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l2, ff];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m2 = fmt[1].match(cfregex2);
    return chkcond(v2, m1) ? [l2, fmt[0]] : chkcond(v2, m2) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m2 != null ? 2 : 1]];
  }
  return [l2, ff];
}
function SSF_format(fmt, v2, o2) {
  if (o2 == null) o2 = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o2.dateNF) sfmt = o2.dateNF;
      else sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o2.dateNF) sfmt = o2.dateNF;
      else sfmt = (o2.table != null ? o2.table : table_fmt)[fmt];
      if (sfmt == null) sfmt = o2.table && o2.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null) sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0)) return SSF_general(v2, o2);
  if (v2 instanceof Date) v2 = datenum_local(v2, o2.date1904);
  var f2 = choose_fmt(sfmt, v2);
  if (SSF_isgeneral(f2[1])) return SSF_general(v2, o2);
  if (v2 === true) v2 = "TRUE";
  else if (v2 === false) v2 = "FALSE";
  else if (v2 === "" || v2 == null) return "";
  return eval_fmt(f2[1], v2, o2, f2[0]);
}
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i2 = 0; i2 < 392; ++i2) {
      if (table_fmt[i2] == void 0) {
        if (idx < 0) idx = i2;
        continue;
      }
      if (table_fmt[i2] == fmt) {
        idx = i2;
        break;
      }
    }
    if (idx < 0) idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSFImplicit = {
  "5": '"$"#,##0_);\\("$"#,##0\\)',
  "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "23": "General",
  "24": "General",
  "25": "General",
  "26": "General",
  "27": "m/d/yy",
  "28": "m/d/yy",
  "29": "m/d/yy",
  "30": "m/d/yy",
  "31": "m/d/yy",
  "32": "h:mm:ss",
  "33": "h:mm:ss",
  "34": "h:mm:ss",
  "35": "h:mm:ss",
  "36": "m/d/yy",
  "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  "50": "m/d/yy",
  "51": "m/d/yy",
  "52": "m/d/yy",
  "53": "m/d/yy",
  "54": "m/d/yy",
  "55": "m/d/yy",
  "56": "m/d/yy",
  "57": "m/d/yy",
  "58": "m/d/yy",
  "59": "0",
  "60": "0.00",
  "61": "#,##0",
  "62": "#,##0.00",
  "63": '"$"#,##0_);\\("$"#,##0\\)',
  "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "67": "0%",
  "68": "0.00%",
  "69": "# ?/?",
  "70": "# ??/??",
  "71": "m/d/yy",
  "72": "m/d/yy",
  "73": "d-mmm-yy",
  "74": "d-mmm",
  "75": "mmm-yy",
  "76": "h:mm",
  "77": "h:mm:ss",
  "78": "m/d/yy h:mm",
  "79": "mm:ss",
  "80": "[h]:mm:ss",
  "81": "mmss.0"
};
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  return new RegExp("^" + fmt + "$");
}
function dateNF_fix(str, dateNF, match) {
  var Y2 = -1, m2 = -1, d2 = -1, H4 = -1, M2 = -1, S2 = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n2, i2) {
    var v2 = parseInt(match[i2 + 1], 10);
    switch (n2.toLowerCase().charAt(0)) {
      case "y":
        Y2 = v2;
        break;
      case "d":
        d2 = v2;
        break;
      case "h":
        H4 = v2;
        break;
      case "s":
        S2 = v2;
        break;
      case "m":
        if (H4 >= 0) M2 = v2;
        else m2 = v2;
        break;
    }
  });
  if (S2 >= 0 && M2 == -1 && m2 >= 0) {
    M2 = m2;
    m2 = -1;
  }
  var datestr = ("" + (Y2 >= 0 ? Y2 : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m2 >= 1 ? m2 : 1)).slice(-2) + "-" + ("00" + (d2 >= 1 ? d2 : 1)).slice(-2);
  if (datestr.length == 7) datestr = "0" + datestr;
  if (datestr.length == 8) datestr = "20" + datestr;
  var timestr = ("00" + (H4 >= 0 ? H4 : 0)).slice(-2) + ":" + ("00" + (M2 >= 0 ? M2 : 0)).slice(-2) + ":" + ("00" + (S2 >= 0 ? S2 : 0)).slice(-2);
  if (H4 == -1 && M2 == -1 && S2 == -1) return datestr;
  if (Y2 == -1 && m2 == -1 && d2 == -1) return timestr;
  return datestr + "T" + timestr;
}
var CRC32 = /* @__PURE__ */ (function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c2 = 0, table = new Array(256);
    for (var n2 = 0; n2 != 256; ++n2) {
      c2 = n2;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      c2 = c2 & 1 ? -306674912 ^ c2 >>> 1 : c2 >>> 1;
      table[n2] = c2;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  var T0 = signed_crc_table();
  function slice_by_16_tables(T10) {
    var c2 = 0, v2 = 0, n2 = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n2 = 0; n2 != 256; ++n2) table[n2] = T10[n2];
    for (n2 = 0; n2 != 256; ++n2) {
      v2 = T10[n2];
      for (c2 = 256 + n2; c2 < 4096; c2 += 256) v2 = table[c2] = v2 >>> 8 ^ T10[v2 & 255];
    }
    var out = [];
    for (n2 = 1; n2 != 16; ++n2) out[n2 - 1] = typeof Int32Array !== "undefined" ? table.subarray(n2 * 256, n2 * 256 + 256) : table.slice(n2 * 256, n2 * 256 + 256);
    return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
  var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
  function crc32_bstr(bstr, seed) {
    var C2 = seed ^ -1;
    for (var i2 = 0, L2 = bstr.length; i2 < L2; ) C2 = C2 >>> 8 ^ T0[(C2 ^ bstr.charCodeAt(i2++)) & 255];
    return ~C2;
  }
  function crc32_buf(B3, seed) {
    var C2 = seed ^ -1, L2 = B3.length - 15, i2 = 0;
    for (; i2 < L2; ) C2 = Tf[B3[i2++] ^ C2 & 255] ^ Te[B3[i2++] ^ C2 >> 8 & 255] ^ Td[B3[i2++] ^ C2 >> 16 & 255] ^ Tc[B3[i2++] ^ C2 >>> 24] ^ Tb[B3[i2++]] ^ Ta[B3[i2++]] ^ T9[B3[i2++]] ^ T8[B3[i2++]] ^ T7[B3[i2++]] ^ T6[B3[i2++]] ^ T5[B3[i2++]] ^ T4[B3[i2++]] ^ T3[B3[i2++]] ^ T2[B3[i2++]] ^ T1[B3[i2++]] ^ T0[B3[i2++]];
    L2 += 15;
    while (i2 < L2) C2 = C2 >>> 8 ^ T0[(C2 ^ B3[i2++]) & 255];
    return ~C2;
  }
  function crc32_str(str, seed) {
    var C2 = seed ^ -1;
    for (var i2 = 0, L2 = str.length, c2 = 0, d2 = 0; i2 < L2; ) {
      c2 = str.charCodeAt(i2++);
      if (c2 < 128) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ c2) & 255];
      } else if (c2 < 2048) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (192 | c2 >> 6 & 31)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      } else if (c2 >= 55296 && c2 < 57344) {
        c2 = (c2 & 1023) + 64;
        d2 = str.charCodeAt(i2++) & 1023;
        C2 = C2 >>> 8 ^ T0[(C2 ^ (240 | c2 >> 8 & 7)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 2 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d2 >> 6 & 15 | (c2 & 3) << 4)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d2 & 63)) & 255];
      } else {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (224 | c2 >> 12 & 15)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 >> 6 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c2 & 63)) & 255];
      }
    }
    return ~C2;
  }
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
})();
var CFB = /* @__PURE__ */ (function _CFB() {
  var exports = {};
  exports.version = "1.2.1";
  function namecmp(l2, r2) {
    var L2 = l2.split("/"), R2 = r2.split("/");
    for (var i3 = 0, c2 = 0, Z2 = Math.min(L2.length, R2.length); i3 < Z2; ++i3) {
      if (c2 = L2[i3].length - R2[i3].length) return c2;
      if (L2[i3] != R2[i3]) return L2[i3] < R2[i3] ? -1 : 1;
    }
    return L2.length - R2.length;
  }
  function dirname(p2) {
    if (p2.charAt(p2.length - 1) == "/") return p2.slice(0, -1).indexOf("/") === -1 ? p2 : dirname(p2.slice(0, -1));
    var c2 = p2.lastIndexOf("/");
    return c2 === -1 ? p2 : p2.slice(0, c2 + 1);
  }
  function filename(p2) {
    if (p2.charAt(p2.length - 1) == "/") return filename(p2.slice(0, -1));
    var c2 = p2.lastIndexOf("/");
    return c2 === -1 ? p2 : p2.slice(c2 + 1);
  }
  function write_dos_date(buf, date) {
    if (typeof date === "string") date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d2 = ymd & 31;
    ymd >>>= 5;
    var m2 = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m2 - 1);
    val.setDate(d2);
    var S2 = hms & 31;
    hms >>>= 5;
    var M2 = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M2);
    val.setSeconds(S2 << 1);
    return val;
  }
  function parse_extra_field(blob) {
    prep_blob(blob, 0);
    var o2 = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob.l <= blob.length - 4) {
      var type = blob.read_shift(2);
      var sz = blob.read_shift(2), tgt = blob.l + sz;
      var p2 = {};
      switch (type) {
        /* UNIX-style Timestamps */
        case 21589:
          {
            flags = blob.read_shift(1);
            if (flags & 1) p2.mtime = blob.read_shift(4);
            if (sz > 5) {
              if (flags & 2) p2.atime = blob.read_shift(4);
              if (flags & 4) p2.ctime = blob.read_shift(4);
            }
            if (p2.mtime) p2.mt = new Date(p2.mtime * 1e3);
          }
          break;
      }
      blob.l = tgt;
      o2[type] = p2;
    }
    return o2;
  }
  var fs;
  function get_fs() {
    return fs || (fs = {});
  }
  function parse2(file, options) {
    if (file[0] == 80 && file[1] == 75) return parse_zip2(file, options);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
    if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob, 0);
    var mv = check_get_mver(blob);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0) return parse_zip2(file, options);
      /* falls through */
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob, mver);
    var dir_cnt = blob.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob.l += 4;
    dir_start = blob.read_shift(4, "i");
    blob.l += 4;
    blob.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob.read_shift(4, "i");
    nmfs = blob.read_shift(4, "i");
    difat_start = blob.read_shift(4, "i");
    difat_sec_cnt = blob.read_shift(4, "i");
    for (var q3 = -1, j2 = 0; j2 < 109; ++j2) {
      q3 = blob.read_shift(4, "i");
      if (q3 < 0) break;
      fat_addrs[j2] = q3;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o2 = {
      FileIndex,
      FullPaths
    };
    if (options && options.raw) o2.raw = { header, sectors };
    return o2;
  }
  function check_get_mver(blob) {
    if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
    blob.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob.l += 16;
    var mver = blob.read_shift(2, "u");
    return [blob.read_shift(2, "u"), mver];
  }
  function check_shifts(blob, mver) {
    var shift = 9;
    blob.l += 2;
    switch (shift = blob.read_shift(2)) {
      case 9:
        if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift);
        break;
      case 12:
        if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift);
    }
    blob.chk("0600", "Mini Sector Shift: ");
    blob.chk("000000000000", "Reserved: ");
  }
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i3 = 1; i3 < nsectors; ++i3) sectors[i3 - 1] = file.slice(i3 * ssz, (i3 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  function build_full_paths(FI, FP, Paths) {
    var i3 = 0, L2 = 0, R2 = 0, C2 = 0, j2 = 0, pl = Paths.length;
    var dad = [], q3 = [];
    for (; i3 < pl; ++i3) {
      dad[i3] = q3[i3] = i3;
      FP[i3] = Paths[i3];
    }
    for (; j2 < q3.length; ++j2) {
      i3 = q3[j2];
      L2 = FI[i3].L;
      R2 = FI[i3].R;
      C2 = FI[i3].C;
      if (dad[i3] === i3) {
        if (L2 !== -1 && dad[L2] !== L2) dad[i3] = dad[L2];
        if (R2 !== -1 && dad[R2] !== R2) dad[i3] = dad[R2];
      }
      if (C2 !== -1) dad[C2] = i3;
      if (L2 !== -1 && i3 != dad[i3]) {
        dad[L2] = dad[i3];
        if (q3.lastIndexOf(L2) < j2) q3.push(L2);
      }
      if (R2 !== -1 && i3 != dad[i3]) {
        dad[R2] = dad[i3];
        if (q3.lastIndexOf(R2) < j2) q3.push(R2);
      }
    }
    for (i3 = 1; i3 < pl; ++i3) if (dad[i3] === i3) {
      if (R2 !== -1 && dad[R2] !== R2) dad[i3] = dad[R2];
      else if (L2 !== -1 && dad[L2] !== L2) dad[i3] = dad[L2];
    }
    for (i3 = 1; i3 < pl; ++i3) {
      if (FI[i3].type === 0) continue;
      j2 = i3;
      if (j2 != dad[j2]) do {
        j2 = dad[j2];
        FP[i3] = FP[j2] + "/" + FP[i3];
      } while (j2 !== 0 && -1 !== dad[j2] && j2 != dad[j2]);
      dad[i3] = -1;
    }
    FP[0] += "/";
    for (i3 = 1; i3 < pl; ++i3) {
      if (FI[i3].type !== 2) FP[i3] += "/";
    }
  }
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size = entry.size;
    var o2 = [];
    var idx = start;
    while (mini && size > 0 && idx >= 0) {
      o2.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o2.length === 0) return new_buf(0);
    return bconcat(o2).slice(0, entry.size);
  }
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q3 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m2 = (ssz >>> 2) - 1;
      if (!sector) return;
      for (var i3 = 0; i3 < m2; ++i3) {
        if ((q3 = __readInt32LE(sector, i3 * 4)) === ENDOFCHAIN) break;
        fat_addrs.push(q3);
      }
      sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd) chkd = [];
    var modulus = ssz - 1, j2 = 0, jj = 0;
    for (j2 = start; j2 >= 0; ) {
      chkd[j2] = true;
      buf[buf.length] = j2;
      buf_chain.push(sectors[j2]);
      var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
      jj = j2 * 4 & modulus;
      if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
      if (!sectors[addr]) break;
      j2 = __readInt32LE(sectors[addr], jj);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i3 = 0, j2 = 0, k2 = 0, jj = 0;
    for (i3 = 0; i3 < sl; ++i3) {
      buf = [];
      k2 = i3 + dir_start;
      if (k2 >= sl) k2 -= sl;
      if (chkd[k2]) continue;
      buf_chain = [];
      var seen = [];
      for (j2 = k2; j2 >= 0; ) {
        seen[j2] = true;
        chkd[j2] = true;
        buf[buf.length] = j2;
        buf_chain.push(sectors[j2]);
        var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
        jj = j2 * 4 & modulus;
        if (ssz < 4 + jj) throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
        if (!sectors[addr]) break;
        j2 = __readInt32LE(sectors[addr], jj);
        if (seen[j2]) break;
      }
      sector_list[k2] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i3 = 0, namelen = 0, name;
    for (; i3 < sector.length; i3 += 128) {
      var blob = (
        /*::(*/
        sector.slice(i3, i3 + 128)
      );
      prep_blob(blob, 64);
      namelen = blob.read_shift(2);
      name = __utf16le(blob, 0, namelen - pl);
      Paths.push(name);
      var o2 = {
        name,
        type: blob.read_shift(1),
        color: blob.read_shift(1),
        L: blob.read_shift(4, "i"),
        R: blob.read_shift(4, "i"),
        C: blob.read_shift(4, "i"),
        clsid: blob.read_shift(16),
        state: blob.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (ctime !== 0) o2.ct = read_date(blob, blob.l - 8);
      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (mtime !== 0) o2.mt = read_date(blob, blob.l - 8);
      o2.start = blob.read_shift(4, "i");
      o2.size = blob.read_shift(4, "i");
      if (o2.size < 0 && o2.start < 0) {
        o2.size = o2.type = 0;
        o2.start = ENDOFCHAIN;
        o2.name = "";
      }
      if (o2.type === 5) {
        minifat_store = o2.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
      } else if (o2.size >= 4096) {
        o2.storage = "fat";
        if (sector_list[o2.start] === void 0) sector_list[o2.start] = get_sector_list(sectors, o2.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o2.start].name = o2.name;
        o2.content = sector_list[o2.start].data.slice(0, o2.size);
      } else {
        o2.storage = "minifat";
        if (o2.size < 0) o2.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o2.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o2.content = get_mfat_entry(o2, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o2.content) prep_blob(o2.content, 0);
      files[name] = o2;
      FileIndex.push(o2);
    }
  }
  function read_date(blob, offset) {
    return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3);
  }
  function read_file(filename2, options) {
    get_fs();
    return parse2(fs.readFileSync(filename2), options);
  }
  function read(blob, options) {
    var type = options && options.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob, options);
      case "base64":
        return parse2(s2a(Base64_decode(blob)), options);
      case "binary":
        return parse2(s2a(blob), options);
    }
    return parse2(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob,
      options
    );
  }
  function init_cfb(cfb, opts) {
    var o2 = opts || {}, root = o2.root || "Root Entry";
    if (!cfb.FullPaths) cfb.FullPaths = [];
    if (!cfb.FileIndex) cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root + "/";
      cfb.FileIndex[0] = { name: root, type: 5 };
    }
    if (o2.CLSID) cfb.FileIndex[0].clsid = o2.CLSID;
    seed_cfb(cfb);
  }
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm)) return;
    var p2 = new_buf(4);
    p2[0] = 55;
    p2[1] = p2[3] = 50;
    p2[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p2, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb, f2) {
    init_cfb(cfb);
    var gc = false, s2 = false;
    for (var i3 = cfb.FullPaths.length - 1; i3 >= 0; --i3) {
      var _file = cfb.FileIndex[i3];
      switch (_file.type) {
        case 0:
          if (s2) gc = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s2 = true;
          if (isNaN(_file.R * _file.L * _file.C)) gc = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc = true;
          break;
        default:
          gc = true;
          break;
      }
    }
    if (!gc && !f2) return;
    var now = new Date(1987, 1, 19), j2 = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i3 = 0; i3 < cfb.FullPaths.length; ++i3) {
      fullPaths[cfb.FullPaths[i3]] = true;
      if (cfb.FileIndex[i3].type === 0) continue;
      data.push([cfb.FullPaths[i3], cfb.FileIndex[i3]]);
    }
    for (i3 = 0; i3 < data.length; ++i3) {
      var dad = dirname(data[i3][0]);
      s2 = fullPaths[dad];
      if (!s2) {
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now,
          mt: now,
          content: null
        }]);
        fullPaths[dad] = true;
      }
    }
    data.sort(function(x2, y2) {
      return namecmp(x2[0], y2[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i3 = 0; i3 < data.length; ++i3) {
      cfb.FullPaths[i3] = data[i3][0];
      cfb.FileIndex[i3] = data[i3][1];
    }
    for (i3 = 0; i3 < data.length; ++i3) {
      var elt = cfb.FileIndex[i3];
      var nm = cfb.FullPaths[i3];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i3 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j2 = i3 + 1; j2 < data.length; ++j2) if (dirname(cfb.FullPaths[j2]) == nm) break;
        elt.C = j2 >= data.length ? -1 : j2;
        for (j2 = i3 + 1; j2 < data.length; ++j2) if (dirname(cfb.FullPaths[j2]) == dirname(nm)) break;
        elt.R = j2 >= data.length ? -1 : j2;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i3 + 1] || "") == dirname(nm)) elt.R = i3 + 1;
        elt.type = 2;
      }
    }
  }
  function _write(cfb, options) {
    var _opts = options || {};
    if (_opts.fileType == "mad") return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip(cfb, _opts);
    }
    var L2 = (function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i4 = 0; i4 < cfb2.FileIndex.length; ++i4) {
        var file2 = cfb2.FileIndex[i4];
        if (!file2.content) continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096) mini_size += flen2 + 63 >> 6;
          else fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L3 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L3[7] = (cfb2.FileIndex[0].start = L3[0] + L3[1] + L3[2] + L3[3] + L3[4] + L3[5]) + (L3[6] + 7 >> 3);
      return L3;
    })(cfb);
    var o2 = new_buf(L2[7] << 9);
    var i3 = 0, T2 = 0;
    {
      for (i3 = 0; i3 < 8; ++i3) o2.write_shift(1, HEADER_SIG[i3]);
      for (i3 = 0; i3 < 8; ++i3) o2.write_shift(2, 0);
      o2.write_shift(2, 62);
      o2.write_shift(2, 3);
      o2.write_shift(2, 65534);
      o2.write_shift(2, 9);
      o2.write_shift(2, 6);
      for (i3 = 0; i3 < 3; ++i3) o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, L2[2]);
      o2.write_shift(4, L2[0] + L2[1] + L2[2] + L2[3] - 1);
      o2.write_shift(4, 0);
      o2.write_shift(4, 1 << 12);
      o2.write_shift(4, L2[3] ? L2[0] + L2[1] + L2[2] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L2[3]);
      o2.write_shift(-4, L2[1] ? L2[0] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L2[1]);
      for (i3 = 0; i3 < 109; ++i3) o2.write_shift(-4, i3 < L2[2] ? L2[1] + i3 : -1);
    }
    if (L2[1]) {
      for (T2 = 0; T2 < L2[1]; ++T2) {
        for (; i3 < 236 + T2 * 127; ++i3) o2.write_shift(-4, i3 < L2[2] ? L2[1] + i3 : -1);
        o2.write_shift(-4, T2 === L2[1] - 1 ? ENDOFCHAIN : T2 + 1);
      }
    }
    var chainit = function(w2) {
      for (T2 += w2; i3 < T2 - 1; ++i3) o2.write_shift(-4, i3 + 1);
      if (w2) {
        ++i3;
        o2.write_shift(-4, ENDOFCHAIN);
      }
    };
    T2 = i3 = 0;
    for (T2 += L2[1]; i3 < T2; ++i3) o2.write_shift(-4, consts.DIFSECT);
    for (T2 += L2[2]; i3 < T2; ++i3) o2.write_shift(-4, consts.FATSECT);
    chainit(L2[3]);
    chainit(L2[4]);
    var j2 = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content) continue;
      flen = file.content.length;
      if (flen < 4096) continue;
      file.start = T2;
      chainit(flen + 511 >> 9);
    }
    chainit(L2[6] + 7 >> 3);
    while (o2.l & 511) o2.write_shift(-4, consts.ENDOFCHAIN);
    T2 = i3 = 0;
    for (j2 = 0; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content) continue;
      flen = file.content.length;
      if (!flen || flen >= 4096) continue;
      file.start = T2;
      chainit(flen + 63 >> 6);
    }
    while (o2.l & 511) o2.write_shift(-4, consts.ENDOFCHAIN);
    for (i3 = 0; i3 < L2[4] << 2; ++i3) {
      var nm = cfb.FullPaths[i3];
      if (!nm || nm.length === 0) {
        for (j2 = 0; j2 < 17; ++j2) o2.write_shift(4, 0);
        for (j2 = 0; j2 < 3; ++j2) o2.write_shift(4, -1);
        for (j2 = 0; j2 < 12; ++j2) o2.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i3];
      if (i3 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i3 === 0 && _opts.root || file.name;
      flen = 2 * (_nm.length + 1);
      o2.write_shift(64, _nm, "utf16le");
      o2.write_shift(2, flen);
      o2.write_shift(1, file.type);
      o2.write_shift(1, file.color);
      o2.write_shift(-4, file.L);
      o2.write_shift(-4, file.R);
      o2.write_shift(-4, file.C);
      if (!file.clsid) for (j2 = 0; j2 < 4; ++j2) o2.write_shift(4, 0);
      else o2.write_shift(16, file.clsid, "hex");
      o2.write_shift(4, file.state || 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, file.start);
      o2.write_shift(4, file.size);
      o2.write_shift(4, 0);
    }
    for (i3 = 1; i3 < cfb.FileIndex.length; ++i3) {
      file = cfb.FileIndex[i3];
      if (file.size >= 4096) {
        o2.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 511 & -512;
        } else {
          for (j2 = 0; j2 < file.size; ++j2) o2.write_shift(1, file.content[j2]);
          for (; j2 & 511; ++j2) o2.write_shift(1, 0);
        }
      }
    }
    for (i3 = 1; i3 < cfb.FileIndex.length; ++i3) {
      file = cfb.FileIndex[i3];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 63 & -64;
        } else {
          for (j2 = 0; j2 < file.size; ++j2) o2.write_shift(1, file.content[j2]);
          for (; j2 & 63; ++j2) o2.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o2.l = o2.length;
    } else {
      while (o2.l < o2.length) o2.write_shift(1, 0);
    }
    return o2;
  }
  function find(cfb, path2) {
    var UCFullPaths = cfb.FullPaths.map(function(x2) {
      return x2.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x2) {
      var y2 = x2.split("/");
      return y2[y2.length - (x2.slice(-1) == "/" ? 2 : 1)];
    });
    var k2 = false;
    if (path2.charCodeAt(0) === 47) {
      k2 = true;
      path2 = UCFullPaths[0].slice(0, -1) + path2;
    } else k2 = path2.indexOf("/") !== -1;
    var UCPath = path2.toUpperCase();
    var w2 = k2 === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w2 !== -1) return cfb.FileIndex[w2];
    var m2 = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m2) UCPath = UCPath.replace(chr1, "!");
    for (w2 = 0; w2 < UCFullPaths.length; ++w2) {
      if ((m2 ? UCFullPaths[w2].replace(chr1, "!") : UCFullPaths[w2]).replace(chr0, "") == UCPath) return cfb.FileIndex[w2];
      if ((m2 ? UCPaths[w2].replace(chr1, "!") : UCPaths[w2]).replace(chr0, "") == UCPath) return cfb.FileIndex[w2];
    }
    return null;
  }
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options) {
    get_fs();
    var o2 = _write(cfb, options);
    fs.writeFileSync(filename2, o2);
  }
  function a2s2(o2) {
    var out = new Array(o2.length);
    for (var i3 = 0; i3 < o2.length; ++i3) out[i3] = String.fromCharCode(o2[i3]);
    return out.join("");
  }
  function write(cfb, options) {
    var o2 = _write(cfb, options);
    switch (options && options.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options.filename, o2);
        return o2;
      case "binary":
        return typeof o2 == "string" ? o2 : a2s2(o2);
      case "base64":
        return Base64_encode(typeof o2 == "string" ? o2 : a2s2(o2));
      case "buffer":
        if (has_buf) return Buffer.isBuffer(o2) ? o2 : Buffer_from(o2);
      /* falls through */
      case "array":
        return typeof o2 == "string" ? s2a(o2) : o2;
    }
    return o2;
  }
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead) _zlib = zlib;
      else throw new Error("zlib does not expose bytesRead");
    } catch (e2) {
      console.error("cannot use native zlib: " + (e2.message || e2));
    }
  }
  function _inflateRawSync(payload, usz) {
    if (!_zlib) return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n2) {
    var t3 = (n2 << 1 | n2 << 11) & 139536 | (n2 << 5 | n2 << 15) & 558144;
    return (t3 >> 16 | t3 >> 8 | t3) & 255;
  }
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q2 = 0; q2 < 1 << 8; ++q2) bitswap8[q2] = bit_swap_8(q2);
  function bit_swap_n(n2, b2) {
    var rev2 = bitswap8[n2 & 255];
    if (b2 <= 8) return rev2 >>> 8 - b2;
    rev2 = rev2 << 8 | bitswap8[n2 >> 8 & 255];
    if (b2 <= 16) return rev2 >>> 16 - b2;
    rev2 = rev2 << 8 | bitswap8[n2 >> 16 & 255];
    return rev2 >>> 24 - b2;
  }
  function read_bits_2(buf, bl) {
    var w2 = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w2 <= 6 ? 0 : buf[h2 + 1] << 8)) >>> w2 & 3;
  }
  function read_bits_3(buf, bl) {
    var w2 = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w2 <= 5 ? 0 : buf[h2 + 1] << 8)) >>> w2 & 7;
  }
  function read_bits_4(buf, bl) {
    var w2 = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w2 <= 4 ? 0 : buf[h2 + 1] << 8)) >>> w2 & 15;
  }
  function read_bits_5(buf, bl) {
    var w2 = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w2 <= 3 ? 0 : buf[h2 + 1] << 8)) >>> w2 & 31;
  }
  function read_bits_7(buf, bl) {
    var w2 = bl & 7, h2 = bl >>> 3;
    return (buf[h2] | (w2 <= 1 ? 0 : buf[h2 + 1] << 8)) >>> w2 & 127;
  }
  function read_bits_n(buf, bl, n2) {
    var w2 = bl & 7, h2 = bl >>> 3, f2 = (1 << n2) - 1;
    var v2 = buf[h2] >>> w2;
    if (n2 < 8 - w2) return v2 & f2;
    v2 |= buf[h2 + 1] << 8 - w2;
    if (n2 < 16 - w2) return v2 & f2;
    v2 |= buf[h2 + 2] << 16 - w2;
    if (n2 < 24 - w2) return v2 & f2;
    v2 |= buf[h2 + 3] << 24 - w2;
    return v2 & f2;
  }
  function write_bits_3(buf, bl, v2) {
    var w2 = bl & 7, h2 = bl >>> 3;
    if (w2 <= 5) buf[h2] |= (v2 & 7) << w2;
    else {
      buf[h2] |= v2 << w2 & 255;
      buf[h2 + 1] = (v2 & 7) >> 8 - w2;
    }
    return bl + 3;
  }
  function write_bits_1(buf, bl, v2) {
    var w2 = bl & 7, h2 = bl >>> 3;
    v2 = (v2 & 1) << w2;
    buf[h2] |= v2;
    return bl + 1;
  }
  function write_bits_8(buf, bl, v2) {
    var w2 = bl & 7, h2 = bl >>> 3;
    v2 <<= w2;
    buf[h2] |= v2 & 255;
    v2 >>>= 8;
    buf[h2 + 1] = v2;
    return bl + 8;
  }
  function write_bits_16(buf, bl, v2) {
    var w2 = bl & 7, h2 = bl >>> 3;
    v2 <<= w2;
    buf[h2] |= v2 & 255;
    v2 >>>= 8;
    buf[h2 + 1] = v2 & 255;
    buf[h2 + 2] = v2 >>> 8;
    return bl + 16;
  }
  function realloc(b2, sz) {
    var L2 = b2.length, M2 = 2 * L2 > sz ? 2 * L2 : sz + 5, i3 = 0;
    if (L2 >= sz) return b2;
    if (has_buf) {
      var o2 = new_unsafe_buf(M2);
      if (b2.copy) b2.copy(o2);
      else for (; i3 < b2.length; ++i3) o2[i3] = b2[i3];
      return o2;
    } else if (use_typed_arrays) {
      var a2 = new Uint8Array(M2);
      if (a2.set) a2.set(b2);
      else for (; i3 < L2; ++i3) a2[i3] = b2[i3];
      return a2;
    }
    b2.length = M2;
    return b2;
  }
  function zero_fill_array(n2) {
    var o2 = new Array(n2);
    for (var i3 = 0; i3 < n2; ++i3) o2[i3] = 0;
    return o2;
  }
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w2 = 0, i3 = 0, j2 = 0, ccode = 0, L2 = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i3 = 0; i3 < 32; ++i3) bl_count[i3] = 0;
    for (i3 = L2; i3 < MAX; ++i3) clens[i3] = 0;
    L2 = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L2) : zero_fill_array(L2);
    for (i3 = 0; i3 < L2; ++i3) {
      bl_count[w2 = clens[i3]]++;
      if (maxlen < w2) maxlen = w2;
      ctree[i3] = 0;
    }
    bl_count[0] = 0;
    for (i3 = 1; i3 <= maxlen; ++i3) bl_count[i3 + 16] = ccode = ccode + bl_count[i3 - 1] << 1;
    for (i3 = 0; i3 < L2; ++i3) {
      ccode = clens[i3];
      if (ccode != 0) ctree[i3] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i3 = 0; i3 < L2; ++i3) {
      cleni = clens[i3];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i3], maxlen) >> maxlen - cleni;
        for (j2 = (1 << maxlen + 4 - cleni) - 1; j2 >= 0; --j2)
          cmap[ccode | j2 << cleni] = cleni & 15 | i3 << 4;
      }
    }
    return maxlen;
  }
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i2 = 0; i2 < 512; ++i2) fix_lmap[i2] = 0;
    for (i2 = 0; i2 < 32; ++i2) fix_dmap[i2] = 0;
  }
  (function() {
    var dlens = [];
    var i3 = 0;
    for (; i3 < 32; i3++) dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i3 = 0;
    for (; i3 <= 143; i3++) clens.push(8);
    for (; i3 <= 255; i3++) clens.push(9);
    for (; i3 <= 279; i3++) clens.push(7);
    for (; i3 <= 287; i3++) clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ (function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j2 = 0, k2 = 0;
    for (; j2 < DST_LN.length - 1; ++j2) {
      for (; k2 < DST_LN[j2 + 1]; ++k2) DST_LN_RE[k2] = j2;
    }
    for (; k2 < 32768; ++k2) DST_LN_RE[k2] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j2 = 0, k2 = 0; j2 < LEN_LN.length - 1; ++j2) {
      for (; k2 < LEN_LN[j2 + 1]; ++k2) LEN_LN_RE[k2] = j2;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L2 = Math.min(65535, data.length - boff);
        var h2 = boff + L2 == data.length;
        out.write_shift(1, +h2);
        out.write_shift(2, L2);
        out.write_shift(2, ~L2 & 65535);
        while (L2-- > 0) out[out.l++] = data[boff++];
      }
      return out.l;
    }
    function write_huff_fixed(data, out) {
      var bl = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L2 = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L2 < 10) {
          bl = write_bits_3(out, bl, +!!(boff + L2 == data.length));
          if (bl & 7) bl += 8 - (bl & 7);
          out.l = bl / 8 | 0;
          out.write_shift(2, L2);
          out.write_shift(2, ~L2 & 65535);
          while (L2-- > 0) out[out.l++] = data[boff++];
          bl = out.l * 8;
          continue;
        }
        bl = write_bits_3(out, bl, +!!(boff + L2 == data.length) + 2);
        var hash = 0;
        while (L2-- > 0) {
          var d2 = data[boff];
          hash = (hash << 5 ^ d2) & 32767;
          var match = -1, mlen = 0;
          if (match = addrs[hash]) {
            match |= boff & -32768;
            if (match > boff) match -= 32768;
            if (match < boff) while (data[match + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
          }
          if (mlen > 2) {
            d2 = LEN_LN_RE[mlen];
            if (d2 <= 22) bl = write_bits_8(out, bl, bitswap8[d2 + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl, 3);
              bl += 5;
              write_bits_8(out, bl, bitswap8[d2 - 23] >> 5);
              bl += 3;
            }
            var len_eb = d2 < 8 ? 0 : d2 - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl, mlen - LEN_LN[d2]);
              bl += len_eb;
            }
            d2 = DST_LN_RE[boff - match];
            bl = write_bits_8(out, bl, bitswap8[d2] >> 3);
            bl -= 3;
            var dst_eb = d2 < 4 ? 0 : d2 - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl, boff - match - DST_LN[d2]);
              bl += dst_eb;
            }
            for (var q3 = 0; q3 < mlen; ++q3) {
              addrs[hash] = boff & 32767;
              hash = (hash << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L2 -= mlen - 1;
          } else {
            if (d2 <= 143) d2 = d2 + 48;
            else bl = write_bits_1(out, bl, 1);
            bl = write_bits_8(out, bl, bitswap8[d2]);
            addrs[hash] = boff & 32767;
            ++boff;
          }
        }
        bl = write_bits_8(out, bl, 0) - 1;
      }
      out.l = (bl + 7) / 8 | 0;
      return out.l;
    }
    return function _deflateRaw2(data, out) {
      if (data.length < 8) return write_stored(data, out);
      return write_huff_fixed(data, out);
    };
  })();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w2 = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L2 = clens.length;
    for (var i3 = 0; i3 < _HCLEN; ++i3) {
      clens[CLEN_ORDER[i3]] = w2 = read_bits_3(data, boff);
      if (maxlen < w2) maxlen = w2;
      bl_count[w2]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i3 = 1; i3 <= maxlen; ++i3) next_code[i3] = ccode = ccode + bl_count[i3 - 1] << 1;
    for (i3 = 0; i3 < L2; ++i3) if ((ccode = clens[i3]) != 0) ctree[i3] = next_code[ccode]++;
    var cleni = 0;
    for (i3 = 0; i3 < L2; ++i3) {
      cleni = clens[i3];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i3]] >> 8 - cleni;
        for (var j2 = (1 << 7 - cleni) - 1; j2 >= 0; --j2) dyn_cmap[ccode | j2 << cleni] = cleni & 7 | i3 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w2 = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w2-- > 0) hcodes.push(ccode);
          break;
        case 17:
          w2 = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w2-- > 0) hcodes.push(0);
          break;
        case 18:
          w2 = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w2-- > 0) hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode) maxlen = ccode;
          break;
      }
    }
    var h1 = hcodes.slice(0, _HLIT), h2 = hcodes.slice(_HLIT);
    for (i3 = _HLIT; i3 < 286; ++i3) h1[i3] = 0;
    for (i3 = _HDIST; i3 < 30; ++i3) h2[i3] = 0;
    dyn_len_1 = build_tree(h1, dyn_lmap, 286);
    dyn_len_2 = build_tree(h2, dyn_dmap, 30);
    return boff;
  }
  function inflate2(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7) boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
        else if (code == 256) break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5) len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz) return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate2(data, usz);
    payload.l += out[1];
    return out[0];
  }
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined") console.error(msg);
    } else throw new Error(msg);
  }
  function parse_zip2(file, options) {
    var blob = (
      /*::(*/
      file
    );
    prep_blob(blob, 0);
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2, { root: options.root });
    var i3 = blob.length - 4;
    while ((blob[i3] != 80 || blob[i3 + 1] != 75 || blob[i3 + 2] != 5 || blob[i3 + 3] != 6) && i3 >= 0) --i3;
    blob.l = i3 + 4;
    blob.l += 4;
    var fcnt = blob.read_shift(2);
    blob.l += 6;
    var start_cd = blob.read_shift(4);
    blob.l = start_cd;
    for (i3 = 0; i3 < fcnt; ++i3) {
      blob.l += 20;
      var csz = blob.read_shift(4);
      var usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var fcsz = blob.read_shift(2);
      blob.l += 8;
      var offset = blob.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob.slice(blob.l + namelen, blob.l + namelen + efsz)
        /*:: :any)*/
      );
      blob.l += namelen + efsz + fcsz;
      var L2 = blob.l;
      blob.l = offset + 4;
      parse_local_file(blob, csz, usz, o2, EF);
      blob.l = L2;
    }
    return o2;
  }
  function parse_local_file(blob, csz, usz, o2, EF) {
    blob.l += 2;
    var flags = blob.read_shift(2);
    var meth = blob.read_shift(2);
    var date = parse_dos_date(blob);
    if (flags & 8257) throw new Error("Unsupported ZIP encryption");
    var crc322 = blob.read_shift(4);
    var _csz = blob.read_shift(4);
    var _usz = blob.read_shift(4);
    var namelen = blob.read_shift(2);
    var efsz = blob.read_shift(2);
    var name = "";
    for (var i3 = 0; i3 < namelen; ++i3) name += String.fromCharCode(blob[blob.l++]);
    if (efsz) {
      var ef = parse_extra_field(
        /*::(*/
        blob.slice(blob.l, blob.l + efsz)
        /*:: :any)*/
      );
      if ((ef[21589] || {}).mt) date = ef[21589].mt;
      if (((EF || {})[21589] || {}).mt) date = EF[21589].mt;
    }
    blob.l += efsz;
    var data = blob.slice(blob.l, blob.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob, _usz);
        break;
      case 0:
        break;
      // TODO: scan for magic number
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc322 = blob.read_shift(4);
      if (crc322 == 134695760) {
        crc322 = blob.read_shift(4);
        wrn = true;
      }
      _csz = blob.read_shift(4);
      _usz = blob.read_shift(4);
    }
    if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o2, name, data, { unsafe: true, mt: date });
  }
  function write_zip(cfb, options) {
    var _opts = options || {};
    var out = [], cdirs = [];
    var o2 = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i3 = 0, j2 = 0;
    var start_cd = 0, fcnt = 0;
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i3 = 1; i3 < cfb.FullPaths.length; ++i3) {
      fp = cfb.FullPaths[i3].slice(root.length);
      fi = cfb.FileIndex[i3];
      if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j2 = 0; j2 < fp.length; ++j2) namebuf.write_shift(1, fp.charCodeAt(j2) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = CRC32.buf(
        /*::((*/
        fi.content,
        0
      );
      var outbuf = fi.content;
      if (method == 8) outbuf = _deflateRawSync(outbuf);
      o2 = new_buf(30);
      o2.write_shift(4, 67324752);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      if (fi.mt) write_dos_date(o2, fi.mt);
      else o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      start_cd += o2.length;
      out.push(o2);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o2 = new_buf(46);
      o2.write_shift(4, 33639248);
      o2.write_shift(2, 0);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, start);
      sz_cd += o2.l;
      cdirs.push(o2);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o2 = new_buf(22);
    o2.write_shift(4, 101010256);
    o2.write_shift(2, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, fcnt);
    o2.write_shift(2, fcnt);
    o2.write_shift(4, sz_cd);
    o2.write_shift(4, start_cd);
    o2.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o2]);
  }
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi, fp) {
    if (fi.ctype) return fi.ctype;
    var ext = fi.name || "", m2 = ext.match(/\.([^\.]+)$/);
    if (m2 && ContentTypeMap[m2[1]]) return ContentTypeMap[m2[1]];
    if (fp) {
      m2 = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m2 && ContentTypeMap[m2[1]]) return ContentTypeMap[m2[1]];
    }
    return "application/octet-stream";
  }
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o2 = [];
    for (var i3 = 0; i3 < data.length; i3 += 76) o2.push(data.slice(i3, i3 + 76));
    return o2.join("\r\n") + "\r\n";
  }
  function write_quoted_printable(text2) {
    var encoded = text2.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c2) {
      var w2 = c2.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w2.length == 1 ? "0" + w2 : w2);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o2 = [], split = encoded.split("\r\n");
    for (var si = 0; si < split.length; ++si) {
      var str = split[si];
      if (str.length == 0) {
        o2.push("");
        continue;
      }
      for (var i3 = 0; i3 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i3, i3 + end);
        if (tmp.charAt(end - 1) == "=") end--;
        else if (tmp.charAt(end - 2) == "=") end -= 2;
        else if (tmp.charAt(end - 3) == "=") end -= 3;
        tmp = str.slice(i3, i3 + end);
        i3 += end;
        if (i3 < str.length) tmp += "=";
        o2.push(tmp);
      }
    }
    return o2.join("\r\n");
  }
  function parse_quoted_printable(data) {
    var o2 = [];
    for (var di = 0; di < data.length; ++di) {
      var line = data[di];
      while (di <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di];
      o2.push(line);
    }
    for (var oi = 0; oi < o2.length; ++oi) o2[oi] = o2[oi].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
      return String.fromCharCode(parseInt($$.slice(1), 16));
    });
    return s2a(o2.join("\r\n"));
  }
  function parse_mime(cfb, data, root) {
    var fname = "", cte = "", ctype = "", fdata;
    var di = 0;
    for (; di < 10; ++di) {
      var line = data[di];
      if (!line || line.match(/^\s*$/)) break;
      var m2 = line.match(/^(.*?):\s*([^\s].*)$/);
      if (m2) switch (m2[1].toLowerCase()) {
        case "content-location":
          fname = m2[2].trim();
          break;
        case "content-type":
          ctype = m2[2].trim();
          break;
        case "content-transfer-encoding":
          cte = m2[2].trim();
          break;
      }
    }
    ++di;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
    if (ctype) file.ctype = ctype;
  }
  function parse_mad(file, options) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var root = options && options.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di = 0, row = "";
    for (di = 0; di < data.length; ++di) {
      row = data[di];
      if (!/^Content-Location:/i.test(row)) continue;
      row = row.slice(row.indexOf("file"));
      if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root.length) == root) continue;
      while (root.length > 0) {
        root = root.slice(0, root.length - 1);
        root = root.slice(0, root.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root) break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary) throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2);
    var start_di, fcnt = 0;
    for (di = 0; di < data.length; ++di) {
      var line = data[di];
      if (line !== boundary && line !== boundary + "--") continue;
      if (fcnt++) parse_mime(o2, data.slice(start_di, di), root);
      start_di = di;
    }
    return o2;
  }
  function write_mad(cfb, options) {
    var opts = options || {};
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root = cfb.FullPaths[0], fp = root, fi = cfb.FileIndex[0];
    for (var i3 = 1; i3 < cfb.FullPaths.length; ++i3) {
      fp = cfb.FullPaths[i3].slice(root.length);
      fi = cfb.FileIndex[i3];
      if (!fi.size || !fi.content || fp == "Sh33tJ5") continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c2) {
        return "_x" + c2.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u2) {
        return "_u" + u2.charCodeAt(0).toString(16) + "_";
      });
      var ca = fi.content;
      var cstr = has_buf && Buffer.isBuffer(ca) ? ca.toString("binary") : a2s2(ca);
      var dispcnt = 0, L2 = Math.min(1024, cstr.length), cc = 0;
      for (var csl = 0; csl <= L2; ++csl) if ((cc = cstr.charCodeAt(csl)) >= 32 && cc < 128) ++dispcnt;
      var qp = dispcnt >= L2 * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  function cfb_new(opts) {
    var o2 = {};
    init_cfb(o2, opts);
    return o2;
  }
  function cfb_add(cfb, name, content2, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe) init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath) fpath = name;
      else {
        if (fpath.slice(-1) != "/") fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe) CFB.utils.cfb_gc(cfb);
    }
    file.content = content2;
    file.size = content2 ? content2.length : 0;
    if (opts) {
      if (opts.CLSID) file.clsid = opts.CLSID;
      if (opts.mt) file.mt = opts.mt;
      if (opts.ct) file.ct = opts.ct;
    }
    return file;
  }
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2) if (cfb.FileIndex[j2] == file) {
        cfb.FileIndex.splice(j2, 1);
        cfb.FullPaths.splice(j2, 1);
        return true;
      }
    }
    return false;
  }
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2) if (cfb.FileIndex[j2] == file) {
        cfb.FileIndex[j2].name = filename(new_name);
        cfb.FullPaths[j2] = new_name;
        return true;
      }
    }
    return false;
  }
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  exports.find = find;
  exports.read = read;
  exports.parse = parse2;
  exports.write = write;
  exports.writeFile = write_file;
  exports.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports;
})();
function read_binary(path2) {
  if (typeof Deno !== "undefined") return Deno.readFileSync(path2);
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
    var infile = File(path2);
    infile.open("r");
    infile.encoding = "binary";
    var data = infile.read();
    infile.close();
    return data;
  } catch (e2) {
    if (!e2.message || !e2.message.match(/onstruct/)) throw e2;
  }
  throw new Error("Cannot access file " + path2);
}
function keys(o2) {
  var ks = Object.keys(o2), o22 = [];
  for (var i2 = 0; i2 < ks.length; ++i2) if (Object.prototype.hasOwnProperty.call(o2, ks[i2])) o22.push(ks[i2]);
  return o22;
}
function evert(obj) {
  var o2 = [], K2 = keys(obj);
  for (var i2 = 0; i2 !== K2.length; ++i2) o2[obj[K2[i2]]] = K2[i2];
  return o2;
}
var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function datenum(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
}
var refdate = /* @__PURE__ */ new Date();
var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
function numdate(v2) {
  var out = /* @__PURE__ */ new Date();
  out.setTime(v2 * 24 * 60 * 60 * 1e3 + dnthresh);
  if (out.getTimezoneOffset() !== refoffset) {
    out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
  }
  return out;
}
function parse_isodur(s2) {
  var sec = 0, mt2 = 0, time2 = false;
  var m2 = s2.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!m2) throw new Error("|" + s2 + "| is not an ISO8601 Duration");
  for (var i2 = 1; i2 != m2.length; ++i2) {
    if (!m2[i2]) continue;
    mt2 = 1;
    if (i2 > 3) time2 = true;
    switch (m2[i2].slice(m2[i2].length - 1)) {
      case "Y":
        throw new Error("Unsupported ISO Duration Field: " + m2[i2].slice(m2[i2].length - 1));
      case "D":
        mt2 *= 24;
      /* falls through */
      case "H":
        mt2 *= 60;
      /* falls through */
      case "M":
        if (!time2) throw new Error("Unsupported ISO Duration Field: M");
        else mt2 *= 60;
    }
    sec += mt2 * parseInt(m2[i2], 10);
  }
  return sec;
}
var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
function parseDate(str, fixdate) {
  var d2 = new Date(str);
  if (good_pd) {
    if (fixdate > 0) d2.setTime(d2.getTime() + d2.getTimezoneOffset() * 60 * 1e3);
    else if (fixdate < 0) d2.setTime(d2.getTime() - d2.getTimezoneOffset() * 60 * 1e3);
    return d2;
  }
  if (str instanceof Date) return str;
  if (good_pd_date.getFullYear() == 1917 && !isNaN(d2.getFullYear())) {
    var s2 = d2.getFullYear();
    if (str.indexOf("" + s2) > -1) return d2;
    d2.setFullYear(d2.getFullYear() + 100);
    return d2;
  }
  var n2 = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
  var out = new Date(+n2[0], +n2[1] - 1, +n2[2], +n2[3] || 0, +n2[4] || 0, +n2[5] || 0);
  if (str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
  return out;
}
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255) return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined") try {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
      if (arr[0] == 254 && arr[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
    }
    var rev2 = {
      "â¬": "Â",
      "â": "Â",
      "Æ": "Â",
      "â": "Â",
      "â¦": "Â",
      "â ": "Â",
      "â¡": "Â",
      "Ë": "Â",
      "â°": "Â",
      "Å ": "Â",
      "â¹": "Â",
      "Å": "Â",
      "Å½": "Â",
      "â": "Â",
      "â": "Â",
      "â": "Â",
      "â": "Â",
      "â¢": "Â",
      "â": "Â",
      "â": "Â",
      "Ë": "Â",
      "â¢": "Â",
      "Å¡": "Â",
      "âº": "Â",
      "Å": "Â",
      "Å¾": "Â",
      "Å¸": "Â"
    };
    if (Array.isArray(arr)) arr = new Uint8Array(arr);
    return new TextDecoder("latin1").decode(arr).replace(/[â¬âÆââ¦â â¡Ëâ°Å â¹ÅÅ½âââââ¢ââËâ¢Å¡âºÅÅ¾Å¸]/g, function(c2) {
      return rev2[c2] || c2;
    });
  } catch (e2) {
  }
  var o2 = [];
  for (var i2 = 0; i2 != arr.length; ++i2) o2.push(String.fromCharCode(arr[i2]));
  return o2.join("");
}
function dup(o2) {
  if (typeof JSON != "undefined" && !Array.isArray(o2)) return JSON.parse(JSON.stringify(o2));
  if (typeof o2 != "object" || o2 == null) return o2;
  if (o2 instanceof Date) return new Date(o2.getTime());
  var out = {};
  for (var k2 in o2) if (Object.prototype.hasOwnProperty.call(o2, k2)) out[k2] = dup(o2[k2]);
  return out;
}
function fill(c2, l2) {
  var o2 = "";
  while (o2.length < l2) o2 += c2;
  return o2;
}
function fuzzynum(s2) {
  var v2 = Number(s2);
  if (!isNaN(v2)) return isFinite(v2) ? v2 : NaN;
  if (!/\d/.test(s2)) return v2;
  var wt2 = 1;
  var ss = s2.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt2 *= 100;
    return "";
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt2;
  ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
    wt2 = -wt2;
    return $1;
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt2;
  return v2;
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s2) {
  var o2 = new Date(s2), n2 = /* @__PURE__ */ new Date(NaN);
  var y2 = o2.getYear(), m2 = o2.getMonth(), d2 = o2.getDate();
  if (isNaN(d2)) return n2;
  var lower = s2.toLowerCase();
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1) return n2;
  } else if (lower.match(/[a-z]/)) return n2;
  if (y2 < 0 || y2 > 8099) return n2;
  if ((m2 > 0 || d2 > 1) && y2 != 101) return o2;
  if (s2.match(/[^-0-9:,\/\\]/)) return n2;
  return o2;
}
var split_regex = /* @__PURE__ */ (function() {
  var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
  return function split_regex2(str, re2, def) {
    if (safe_split_regex || typeof re2 == "string") return str.split(re2);
    var p2 = str.split(re2), o2 = [p2[0]];
    for (var i2 = 1; i2 < p2.length; ++i2) {
      o2.push(def);
      o2.push(p2[i2]);
    }
    return o2;
  };
})();
function getdatastr(data) {
  if (!data) return null;
  if (data.content && data.type) return cc2str(data.content, true);
  if (data.data) return debom(data.data);
  if (data.asNodeBuffer && has_buf) return debom(data.asNodeBuffer().toString("binary"));
  if (data.asBinary) return debom(data.asBinary());
  if (data._data && data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
  return null;
}
function getdatabin(data) {
  if (!data) return null;
  if (data.data) return char_codes(data.data);
  if (data.asNodeBuffer && has_buf) return data.asNodeBuffer();
  if (data._data && data._data.getContent) {
    var o2 = data._data.getContent();
    if (typeof o2 == "string") return char_codes(o2);
    return Array.prototype.slice.call(o2);
  }
  if (data.content && data.type) return data.content;
  return null;
}
function getdata(data) {
  return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
}
function safegetzipfile(zip, file) {
  var k2 = zip.FullPaths || keys(zip.files);
  var f2 = file.toLowerCase().replace(/[\/]/g, "\\"), g2 = f2.replace(/\\/g, "/");
  for (var i2 = 0; i2 < k2.length; ++i2) {
    var n2 = k2[i2].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (f2 == n2 || g2 == n2) return zip.files ? zip.files[k2[i2]] : zip.FileIndex[i2];
  }
  return null;
}
function getzipfile(zip, file) {
  var o2 = safegetzipfile(zip, file);
  if (o2 == null) throw new Error("Cannot find file " + file + " in zip");
  return o2;
}
function getzipdata(zip, file, safe) {
  if (!safe) return getdata(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipdata(zip, file);
  } catch (e2) {
    return null;
  }
}
function getzipstr(zip, file, safe) {
  if (!safe) return getdatastr(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipstr(zip, file);
  } catch (e2) {
    return null;
  }
}
function getzipbin(zip, file, safe) {
  return getdatabin(getzipfile(zip, file));
}
function zipentries(zip) {
  var k2 = zip.FullPaths || keys(zip.files), o2 = [];
  for (var i2 = 0; i2 < k2.length; ++i2) if (k2[i2].slice(-1) != "/") o2.push(k2[i2].replace(/^Root Entry[\/]/, ""));
  return o2.sort();
}
function zip_add_file(zip, path2, content2) {
  if (zip.FullPaths) {
    if (typeof content2 == "string") {
      var res;
      if (has_buf) res = Buffer_from(content2);
      else res = utf8decode(content2);
      return CFB.utils.cfb_add(zip, path2, res);
    }
    CFB.utils.cfb_add(zip, path2, content2);
  } else zip.file(path2, content2);
}
function zip_read(d2, o2) {
  switch (o2.type) {
    case "base64":
      return CFB.read(d2, { type: "base64" });
    case "binary":
      return CFB.read(d2, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(d2, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + o2.type);
}
function resolve_path(path2, base) {
  if (path2.charAt(0) == "/") return path2.slice(1);
  var result = base.split("/");
  if (base.slice(-1) != "/") result.pop();
  var target = path2.split("/");
  while (target.length !== 0) {
    var step = target.shift();
    if (step === "..") result.pop();
    else if (step !== ".") result.push(step);
  }
  return result.join("/");
}
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^>]*>/g;
var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(tag, skip_root, skip_LC) {
  var z2 = {};
  var eq = 0, c2 = 0;
  for (; eq !== tag.length; ++eq) if ((c2 = tag.charCodeAt(eq)) === 32 || c2 === 10 || c2 === 13) break;
  if (!skip_root) z2[0] = tag.slice(0, eq);
  if (eq === tag.length) return z2;
  var m2 = tag.match(attregexg), j2 = 0, v2 = "", i2 = 0, q2 = "", cc = "", quot = 1;
  if (m2) for (i2 = 0; i2 != m2.length; ++i2) {
    cc = m2[i2];
    for (c2 = 0; c2 != cc.length; ++c2) if (cc.charCodeAt(c2) === 61) break;
    q2 = cc.slice(0, c2).trim();
    while (cc.charCodeAt(c2 + 1) == 32) ++c2;
    quot = (eq = cc.charCodeAt(c2 + 1)) == 34 || eq == 39 ? 1 : 0;
    v2 = cc.slice(c2 + 1 + quot, cc.length - quot);
    for (j2 = 0; j2 != q2.length; ++j2) if (q2.charCodeAt(j2) === 58) break;
    if (j2 === q2.length) {
      if (q2.indexOf("_") > 0) q2 = q2.slice(0, q2.indexOf("_"));
      z2[q2] = v2;
      z2[q2.toLowerCase()] = v2;
    } else {
      var k2 = (j2 === 5 && q2.slice(0, 5) === "xmlns" ? "xmlns" : "") + q2.slice(j2 + 1);
      if (z2[k2] && q2.slice(j2 - 3, j2) == "ext") continue;
      z2[k2] = v2;
      z2[k2.toLowerCase()] = v2;
    }
  }
  return z2;
}
function strip_ns(x2) {
  return x2.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var unescapexml = /* @__PURE__ */ (function() {
  var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
  return function unescapexml2(text2) {
    var s2 = text2 + "", i2 = s2.indexOf("<![CDATA[");
    if (i2 == -1) return s2.replace(encregex, function($$, $1) {
      return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
    }).replace(coderegex, function(m2, c2) {
      return String.fromCharCode(parseInt(c2, 16));
    });
    var j2 = s2.indexOf("]]>");
    return unescapexml2(s2.slice(0, i2)) + s2.slice(i2 + 9, j2) + unescapexml2(s2.slice(j2 + 3));
  };
})();
var decregex = /[&<>'"]/g;
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text2) {
  var s2 = text2 + "";
  return s2.replace(decregex, function(y2) {
    return rencoding[y2];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s3) {
    return "&#x" + ("000" + s3.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ (function() {
  var entregex = /&#(\d+);/g;
  function entrepl($$, $1) {
    return String.fromCharCode(parseInt($1, 10));
  }
  return function xlml_fixstr2(str) {
    return str.replace(entregex, entrepl);
  };
})();
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
    case "TRUE":
      return true;
    /* case '0': case 'false': case 'FALSE':*/
    default:
      return false;
  }
}
function utf8reada(orig) {
  var out = "", i2 = 0, c2 = 0, d2 = 0, e2 = 0, f2 = 0, w2 = 0;
  while (i2 < orig.length) {
    c2 = orig.charCodeAt(i2++);
    if (c2 < 128) {
      out += String.fromCharCode(c2);
      continue;
    }
    d2 = orig.charCodeAt(i2++);
    if (c2 > 191 && c2 < 224) {
      f2 = (c2 & 31) << 6;
      f2 |= d2 & 63;
      out += String.fromCharCode(f2);
      continue;
    }
    e2 = orig.charCodeAt(i2++);
    if (c2 < 240) {
      out += String.fromCharCode((c2 & 15) << 12 | (d2 & 63) << 6 | e2 & 63);
      continue;
    }
    f2 = orig.charCodeAt(i2++);
    w2 = ((c2 & 7) << 18 | (d2 & 63) << 12 | (e2 & 63) << 6 | f2 & 63) - 65536;
    out += String.fromCharCode(55296 + (w2 >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w2 & 1023));
  }
  return out;
}
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w2, i2, j2 = 1, k2 = 0, ww = 0, c2;
  for (i2 = 0; i2 < data.length; i2 += j2) {
    j2 = 1;
    if ((c2 = data.charCodeAt(i2)) < 128) w2 = c2;
    else if (c2 < 224) {
      w2 = (c2 & 31) * 64 + (data.charCodeAt(i2 + 1) & 63);
      j2 = 2;
    } else if (c2 < 240) {
      w2 = (c2 & 15) * 4096 + (data.charCodeAt(i2 + 1) & 63) * 64 + (data.charCodeAt(i2 + 2) & 63);
      j2 = 3;
    } else {
      j2 = 4;
      w2 = (c2 & 7) * 262144 + (data.charCodeAt(i2 + 1) & 63) * 4096 + (data.charCodeAt(i2 + 2) & 63) * 64 + (data.charCodeAt(i2 + 3) & 63);
      w2 -= 65536;
      ww = 55296 + (w2 >>> 10 & 1023);
      w2 = 56320 + (w2 & 1023);
    }
    if (ww !== 0) {
      out[k2++] = ww & 255;
      out[k2++] = ww >>> 8;
      ww = 0;
    }
    out[k2++] = w2 % 256;
    out[k2++] = w2 >>> 8;
  }
  return out.slice(0, k2).toString("ucs2");
}
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
var utf8corpus = "foo bar bazÃ¢ÂÂÃ°ÂÂÂ£";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i2 = 0, c2 = 0, d2 = 0;
  while (i2 < orig.length) {
    c2 = orig.charCodeAt(i2++);
    switch (true) {
      case c2 < 128:
        out.push(String.fromCharCode(c2));
        break;
      case c2 < 2048:
        out.push(String.fromCharCode(192 + (c2 >> 6)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
        break;
      case (c2 >= 55296 && c2 < 57344):
        c2 -= 55296;
        d2 = orig.charCodeAt(i2++) - 56320 + (c2 << 10);
        out.push(String.fromCharCode(240 + (d2 >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d2 >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d2 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d2 & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c2 >> 12)));
        out.push(String.fromCharCode(128 + (c2 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c2 & 63)));
    }
  }
  return out.join("");
};
var matchtag = /* @__PURE__ */ (function() {
  var mtcache = {};
  return function matchtag2(f2, g2) {
    var t3 = f2 + "|" + (g2 || "");
    if (mtcache[t3]) return mtcache[t3];
    return mtcache[t3] = new RegExp("<(?:\\w+:)?" + f2 + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f2 + ">", g2 || "");
  };
})();
var htmldecode = /* @__PURE__ */ (function() {
  var entities = [
    ["nbsp", " "],
    ["middot", "Â·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x2) {
    return [new RegExp("&" + x2[0] + ";", "ig"), x2[1]];
  });
  return function htmldecode2(str) {
    var o2 = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
    for (var i2 = 0; i2 < entities.length; ++i2) o2 = o2.replace(entities[i2][0], entities[i2][1]);
    return o2;
  };
})();
var vtregex = /* @__PURE__ */ (function() {
  var vt_cache = {};
  return function vt_regex(bt2) {
    if (vt_cache[bt2] !== void 0) return vt_cache[bt2];
    return vt_cache[bt2] = new RegExp("<(?:vt:)?" + bt2 + ">([\\s\\S]*?)</(?:vt:)?" + bt2 + ">", "g");
  };
})();
var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
function parseVector(data, opts) {
  var h2 = parsexmltag(data);
  var matches = data.match(vtregex(h2.baseType)) || [];
  var res = [];
  if (matches.length != h2.size) {
    if (opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h2.size);
    return res;
  }
  matches.forEach(function(x2) {
    var v2 = x2.replace(vtvregex, "").match(vtmregex);
    if (v2) res.push({ v: utf8read(v2[2]), t: v2[1] });
  });
  return res;
}
function xlml_normalize(d2) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(d2)) return d2.toString("utf8");
  if (typeof d2 === "string") return d2;
  if (typeof Uint8Array !== "undefined" && d2 instanceof Uint8Array) return utf8read(a2s(ab2a(d2)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg;
var XMLNS = {
  CT: "http://schemas.openxmlformats.org/package/2006/content-types"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
function read_double_le(b2, idx) {
  var s2 = 1 - 2 * (b2[idx + 7] >>> 7);
  var e2 = ((b2[idx + 7] & 127) << 4) + (b2[idx + 6] >>> 4 & 15);
  var m2 = b2[idx + 6] & 15;
  for (var i2 = 5; i2 >= 0; --i2) m2 = m2 * 256 + b2[idx + i2];
  if (e2 == 2047) return m2 == 0 ? s2 * Infinity : NaN;
  if (e2 == 0) e2 = -1022;
  else {
    e2 -= 1023;
    m2 += Math.pow(2, 52);
  }
  return s2 * Math.pow(2, e2 - 52) * m2;
}
function write_double_le(b2, v2, idx) {
  var bs = (v2 < 0 || 1 / v2 == -Infinity ? 1 : 0) << 7, e2 = 0, m2 = 0;
  var av = bs ? -v2 : v2;
  if (!isFinite(av)) {
    e2 = 2047;
    m2 = isNaN(v2) ? 26985 : 0;
  } else if (av == 0) e2 = m2 = 0;
  else {
    e2 = Math.floor(Math.log(av) / Math.LN2);
    m2 = av * Math.pow(2, 52 - e2);
    if (e2 <= -1023 && (!isFinite(m2) || m2 < Math.pow(2, 52))) {
      e2 = -1022;
    } else {
      m2 -= Math.pow(2, 52);
      e2 += 1023;
    }
  }
  for (var i2 = 0; i2 <= 5; ++i2, m2 /= 256) b2[idx + i2] = m2 & 255;
  b2[idx + 6] = (e2 & 15) << 4 | m2 & 15;
  b2[idx + 7] = e2 >> 4 | bs;
}
var ___toBuffer = function(bufs) {
  var x2 = [], w2 = 10240;
  for (var i2 = 0; i2 < bufs[0].length; ++i2) if (bufs[0][i2]) for (var j2 = 0, L2 = bufs[0][i2].length; j2 < L2; j2 += w2) x2.push.apply(x2, bufs[0][i2].slice(j2, j2 + w2));
  return x2;
};
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x2) {
    return Buffer.isBuffer(x2) ? x2 : Buffer_from(x2);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = function(b2, s2, e2) {
  var ss = [];
  for (var i2 = s2; i2 < e2; i2 += 2) ss.push(String.fromCharCode(__readUInt16LE(b2, i2)));
  return ss.join("").replace(chr0, "");
};
var __utf16le = has_buf ? function(b2, s2, e2) {
  if (!Buffer.isBuffer(b2)) return ___utf16le(b2, s2, e2);
  return b2.toString("utf16le", s2, e2).replace(chr0, "");
} : ___utf16le;
var ___hexlify = function(b2, s2, l2) {
  var ss = [];
  for (var i2 = s2; i2 < s2 + l2; ++i2) ss.push(("0" + b2[i2].toString(16)).slice(-2));
  return ss.join("");
};
var __hexlify = has_buf ? function(b2, s2, l2) {
  return Buffer.isBuffer(b2) ? b2.toString("hex", s2, s2 + l2) : ___hexlify(b2, s2, l2);
} : ___hexlify;
var ___utf8 = function(b2, s2, e2) {
  var ss = [];
  for (var i2 = s2; i2 < e2; i2++) ss.push(String.fromCharCode(__readUInt8(b2, i2)));
  return ss.join("");
};
var __utf8 = has_buf ? function utf8_b(b2, s2, e2) {
  return Buffer.isBuffer(b2) ? b2.toString("utf8", s2, e2) : ___utf8(b2, s2, e2);
} : ___utf8;
var ___lpstr = function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
};
var __lpstr = ___lpstr;
var ___cpstr = function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
};
var __cpstr = ___cpstr;
var ___lpwstr = function(b2, i2) {
  var len = 2 * __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len - 1) : "";
};
var __lpwstr = ___lpwstr;
var ___lpp4 = function lpp4_(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf16le(b2, i2 + 4, i2 + 4 + len) : "";
};
var __lpp4 = ___lpp4;
var ___8lpp4 = function(b2, i2) {
  var len = __readUInt32LE(b2, i2);
  return len > 0 ? __utf8(b2, i2 + 4, i2 + 4 + len) : "";
};
var __8lpp4 = ___8lpp4;
var ___double = function(b2, idx) {
  return read_double_le(b2, idx);
};
var __double = ___double;
var is_buf = function is_buf_a(a2) {
  return Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
};
if (has_buf) {
  __lpstr = function lpstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2)) return ___lpstr(b2, i2);
    var len = b2.readUInt32LE(i2);
    return len > 0 ? b2.toString("utf8", i2 + 4, i2 + 4 + len - 1) : "";
  };
  __cpstr = function cpstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2)) return ___cpstr(b2, i2);
    var len = b2.readUInt32LE(i2);
    return len > 0 ? b2.toString("utf8", i2 + 4, i2 + 4 + len - 1) : "";
  };
  __lpwstr = function lpwstr_b(b2, i2) {
    if (!Buffer.isBuffer(b2)) return ___lpwstr(b2, i2);
    var len = 2 * b2.readUInt32LE(i2);
    return b2.toString("utf16le", i2 + 4, i2 + 4 + len - 1);
  };
  __lpp4 = function lpp4_b(b2, i2) {
    if (!Buffer.isBuffer(b2)) return ___lpp4(b2, i2);
    var len = b2.readUInt32LE(i2);
    return b2.toString("utf16le", i2 + 4, i2 + 4 + len);
  };
  __8lpp4 = function lpp4_8b(b2, i2) {
    if (!Buffer.isBuffer(b2)) return ___8lpp4(b2, i2);
    var len = b2.readUInt32LE(i2);
    return b2.toString("utf8", i2 + 4, i2 + 4 + len);
  };
  __double = function double_(b2, i2) {
    if (Buffer.isBuffer(b2)) return b2.readDoubleLE(i2);
    return ___double(b2, i2);
  };
  is_buf = function is_buf_b(a2) {
    return Buffer.isBuffer(a2) || Array.isArray(a2) || typeof Uint8Array !== "undefined" && a2 instanceof Uint8Array;
  };
}
var __readUInt8 = function(b2, idx) {
  return b2[idx];
};
var __readUInt16LE = function(b2, idx) {
  return b2[idx + 1] * (1 << 8) + b2[idx];
};
var __readInt16LE = function(b2, idx) {
  var u2 = b2[idx + 1] * (1 << 8) + b2[idx];
  return u2 < 32768 ? u2 : (65535 - u2 + 1) * -1;
};
var __readUInt32LE = function(b2, idx) {
  return b2[idx + 3] * (1 << 24) + (b2[idx + 2] << 16) + (b2[idx + 1] << 8) + b2[idx];
};
var __readInt32LE = function(b2, idx) {
  return b2[idx + 3] << 24 | b2[idx + 2] << 16 | b2[idx + 1] << 8 | b2[idx];
};
var __readInt32BE = function(b2, idx) {
  return b2[idx] << 24 | b2[idx + 1] << 16 | b2[idx + 2] << 8 | b2[idx + 3];
};
function ReadShift(size, t3) {
  var o2 = "", oI, oR, oo = [], w2, vv, i2, loc;
  switch (t3) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this)) o2 = this.slice(this.l, this.l + 2 * size).toString("utf16le");
      else for (i2 = 0; i2 < size; ++i2) {
        o2 += String.fromCharCode(__readUInt16LE(this, loc));
        loc += 2;
      }
      size *= 2;
      break;
    case "utf8":
      o2 = __utf8(this, this.l, this.l + size);
      break;
    case "utf16le":
      size *= 2;
      o2 = __utf16le(this, this.l, this.l + size);
      break;
    case "wstr":
      return ReadShift.call(this, size, "dbcs");
    /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
    case "lpstr-ansi":
      o2 = __lpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o2 = __cpstr(this, this.l);
      size = 4 + __readUInt32LE(this, this.l);
      break;
    /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
    case "lpwstr":
      o2 = __lpwstr(this, this.l);
      size = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
    case "lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o2 = __lpp4(this, this.l);
      if (size & 2) size += 2;
      break;
    /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
    case "8lpp4":
      size = 4 + __readUInt32LE(this, this.l);
      o2 = __8lpp4(this, this.l);
      if (size & 3) size += 4 - (size & 3);
      break;
    case "cstr":
      size = 0;
      o2 = "";
      while ((w2 = __readUInt8(this, this.l + size++)) !== 0) oo.push(_getchar(w2));
      o2 = oo.join("");
      break;
    case "_wstr":
      size = 0;
      o2 = "";
      while ((w2 = __readUInt16LE(this, this.l + size)) !== 0) {
        oo.push(_getchar(w2));
        size += 2;
      }
      size += 2;
      o2 = oo.join("");
      break;
    /* sbcs and dbcs support continue records in the SST way TODO codepages */
    case "dbcs-cont":
      o2 = "";
      loc = this.l;
      for (i2 = 0; i2 < size; ++i2) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i2, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o2 = oo.join("");
      size *= 2;
      break;
    case "cpstr":
    /* falls through */
    case "sbcs-cont":
      o2 = "";
      loc = this.l;
      for (i2 = 0; i2 != size; ++i2) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w2 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size - i2, w2 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o2 = oo.join("");
      break;
    default:
      switch (size) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t3 === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t3 === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t3 === "f") {
            if (size == 8) oR = __double(this, this.l);
            else oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else size = 8;
        /* falls through */
        case 16:
          o2 = __hexlify(this, this.l, size);
          break;
      }
  }
  this.l += size;
  return o2;
}
var __writeUInt32LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
  b2[idx + 2] = val >>> 16 & 255;
  b2[idx + 3] = val >>> 24 & 255;
};
var __writeInt32LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >> 8 & 255;
  b2[idx + 2] = val >> 16 & 255;
  b2[idx + 3] = val >> 24 & 255;
};
var __writeUInt16LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
};
function WriteShift(t3, val, f2) {
  var size = 0, i2 = 0;
  if (f2 === "dbcs") {
    for (i2 = 0; i2 != val.length; ++i2) __writeUInt16LE(this, val.charCodeAt(i2), this.l + 2 * i2);
    size = 2 * val.length;
  } else if (f2 === "sbcs") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i2 = 0; i2 != val.length; ++i2) this[this.l + i2] = val.charCodeAt(i2) & 255;
    }
    size = val.length;
  } else if (f2 === "hex") {
    for (; i2 < t3; ++i2) {
      this[this.l++] = parseInt(val.slice(2 * i2, 2 * i2 + 2), 16) || 0;
    }
    return this;
  } else if (f2 === "utf16le") {
    var end = Math.min(this.l + t3, this.length);
    for (i2 = 0; i2 < Math.min(val.length, t3); ++i2) {
      var cc = val.charCodeAt(i2);
      this[this.l++] = cc & 255;
      this[this.l++] = cc >> 8;
    }
    while (this.l < end) this[this.l++] = 0;
    return this;
  } else switch (t3) {
    case 1:
      size = 1;
      this[this.l] = val & 255;
      break;
    case 2:
      size = 2;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      break;
    case 3:
      size = 3;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      val >>>= 8;
      this[this.l + 2] = val & 255;
      break;
    case 4:
      size = 4;
      __writeUInt32LE(this, val, this.l);
      break;
    case 8:
      size = 8;
      if (f2 === "f") {
        write_double_le(this, val, this.l);
        break;
      }
    /* falls through */
    case 16:
      break;
    case -4:
      size = 4;
      __writeInt32LE(this, val, this.l);
      break;
  }
  this.l += size;
  return this;
}
function CheckField(hexstr, fld) {
  var m2 = __hexlify(this, this.l, hexstr.length >> 1);
  if (m2 !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m2);
  this.l += hexstr.length >> 1;
}
function prep_blob(blob, pos) {
  blob.l = pos;
  blob.read_shift = /*::(*/
  ReadShift;
  blob.chk = CheckField;
  blob.write_shift = WriteShift;
}
function parsenoop(blob, length) {
  blob.l += length;
}
function new_buf(sz) {
  var o2 = new_raw_buf(sz);
  prep_blob(o2, 0);
  return o2;
}
function recordhopper(data, cb, opts) {
  if (!data) return;
  var tmpbyte, cntbyte, length;
  prep_blob(data, data.l || 0);
  var L2 = data.length, RT = 0, tgt = 0;
  while (data.l < L2) {
    RT = data.read_shift(1);
    if (RT & 128) RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
    var R2 = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
    tmpbyte = data.read_shift(1);
    length = tmpbyte & 127;
    for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte) length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
    tgt = data.l + length;
    var d2 = R2.f && R2.f(data, length, opts);
    data.l = tgt;
    if (cb(d2, R2, RT)) return;
  }
}
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = function ba_newblk(sz) {
    var o2 = new_buf(sz);
    prep_blob(o2, 0);
    return o2;
  };
  var curbuf = newblk(blksz);
  var endbuf = function ba_endbuf() {
    if (!curbuf) return;
    if (curbuf.length > curbuf.l) {
      curbuf = curbuf.slice(0, curbuf.l);
      curbuf.l = curbuf.length;
    }
    if (curbuf.length > 0) bufs.push(curbuf);
    curbuf = null;
  };
  var next = function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  };
  var end = function ba_end() {
    endbuf();
    return bconcat(bufs);
  };
  var push = function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null) curbuf.l = curbuf.length;
    next(blksz);
  };
  return { next, push, end, _bufs: bufs };
}
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel) out.c += tgt.s.c;
    if (out.rRel) out.r += tgt.s.r;
  } else {
    if (out.cRel) out.c += tgt.c;
    if (out.rRel) out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256) out.c -= 256;
    while (out.r >= 65536) out.r -= 65536;
  }
  return out;
}
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
function encode_cell_xls(c2, biff) {
  if (c2.cRel && c2.c < 0) {
    c2 = dup(c2);
    while (c2.c < 0) c2.c += biff > 8 ? 16384 : 256;
  }
  if (c2.rRel && c2.r < 0) {
    c2 = dup(c2);
    while (c2.r < 0) c2.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s2 = encode_cell(c2);
  if (!c2.cRel && c2.cRel != null) s2 = fix_col(s2);
  if (!c2.rRel && c2.rRel != null) s2 = fix_row(s2);
  return s2;
}
function encode_range_xls(r2, opts) {
  if (r2.s.r == 0 && !r2.s.rRel) {
    if (r2.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r2.e.rRel) {
      return (r2.s.cRel ? "" : "$") + encode_col(r2.s.c) + ":" + (r2.e.cRel ? "" : "$") + encode_col(r2.e.c);
    }
  }
  if (r2.s.c == 0 && !r2.s.cRel) {
    if (r2.e.c == (opts.biff >= 12 ? 16383 : 255) && !r2.e.cRel) {
      return (r2.s.rRel ? "" : "$") + encode_row(r2.s.r) + ":" + (r2.e.rRel ? "" : "$") + encode_row(r2.e.r);
    }
  }
  return encode_cell_xls(r2.s, opts.biff) + ":" + encode_cell_xls(r2.e, opts.biff);
}
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
function encode_row(row) {
  return "" + (row + 1);
}
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
function decode_col(colstr) {
  var c2 = unfix_col(colstr), d2 = 0, i2 = 0;
  for (; i2 !== c2.length; ++i2) d2 = 26 * d2 + c2.charCodeAt(i2) - 64;
  return d2 - 1;
}
function encode_col(col) {
  if (col < 0) throw new Error("invalid column " + col);
  var s2 = "";
  for (++col; col; col = Math.floor((col - 1) / 26)) s2 = String.fromCharCode((col - 1) % 26 + 65) + s2;
  return s2;
}
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
function decode_cell(cstr) {
  var R2 = 0, C2 = 0;
  for (var i2 = 0; i2 < cstr.length; ++i2) {
    var cc = cstr.charCodeAt(i2);
    if (cc >= 48 && cc <= 57) R2 = 10 * R2 + (cc - 48);
    else if (cc >= 65 && cc <= 90) C2 = 26 * C2 + (cc - 64);
  }
  return { c: C2 - 1, r: R2 - 1 };
}
function encode_cell(cell) {
  var col = cell.c + 1;
  var s2 = "";
  for (; col; col = (col - 1) / 26 | 0) s2 = String.fromCharCode((col - 1) % 26 + 65) + s2;
  return s2 + (cell.r + 1);
}
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
function encode_range(cs, ce2) {
  if (typeof ce2 === "undefined" || typeof ce2 === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string") cs = encode_cell(cs);
  if (typeof ce2 !== "string") ce2 = encode_cell(ce2);
  return cs == ce2 ? cs : cs + ":" + ce2;
}
function safe_decode_range(range) {
  var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i2 = 0, cc = 0;
  var len = range.length;
  for (idx = 0; i2 < len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o2.s.c = --idx;
  for (idx = 0; i2 < len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o2.s.r = --idx;
  if (i2 === len || cc != 10) {
    o2.e.c = o2.s.c;
    o2.e.r = o2.s.r;
    return o2;
  }
  ++i2;
  for (idx = 0; i2 != len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 64) < 1 || cc > 26) break;
    idx = 26 * idx + cc;
  }
  o2.e.c = --idx;
  for (idx = 0; i2 != len; ++i2) {
    if ((cc = range.charCodeAt(i2) - 48) < 0 || cc > 9) break;
    idx = 10 * idx + cc;
  }
  o2.e.r = --idx;
  return o2;
}
function safe_format_cell(cell, v2) {
  var q2 = cell.t == "d" && v2 instanceof Date;
  if (cell.z != null) try {
    return cell.w = SSF_format(cell.z, q2 ? datenum(v2) : v2);
  } catch (e2) {
  }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q2 ? 14 : 0), q2 ? datenum(v2) : v2);
  } catch (e2) {
    return "" + v2;
  }
}
function format_cell(cell, v2, o2) {
  if (cell == null || cell.t == null || cell.t == "z") return "";
  if (cell.w !== void 0) return cell.w;
  if (cell.t == "d" && !cell.z && o2 && o2.dateNF) cell.z = o2.dateNF;
  if (cell.t == "e") return BErr[cell.v] || cell.v;
  if (v2 == void 0) return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v2);
}
function sheet_to_workbook(sheet, opts) {
  var n2 = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n2] = sheet;
  return { SheetNames: [n2], Sheets: sheets };
}
function sheet_add_aoa(_ws, data, opts) {
  var o2 = opts || {};
  var dense = _ws ? Array.isArray(_ws) : o2.dense;
  var ws = _ws || (dense ? [] : {});
  var _R = 0, _C = 0;
  if (ws && o2.origin != null) {
    if (typeof o2.origin == "number") _R = o2.origin;
    else {
      var _origin = typeof o2.origin == "string" ? decode_cell(o2.origin) : o2.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
    if (!ws["!ref"]) ws["!ref"] = "A1:A1";
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) range.e.r = _R = _range.e.r + 1;
  }
  for (var R2 = 0; R2 != data.length; ++R2) {
    if (!data[R2]) continue;
    if (!Array.isArray(data[R2])) throw new Error("aoa_to_sheet expects an array of arrays");
    for (var C2 = 0; C2 != data[R2].length; ++C2) {
      if (typeof data[R2][C2] === "undefined") continue;
      var cell = { v: data[R2][C2] };
      var __R = _R + R2, __C = _C + C2;
      if (range.s.r > __R) range.s.r = __R;
      if (range.s.c > __C) range.s.c = __C;
      if (range.e.r < __R) range.e.r = __R;
      if (range.e.c < __C) range.e.c = __C;
      if (data[R2][C2] && typeof data[R2][C2] === "object" && !Array.isArray(data[R2][C2]) && !(data[R2][C2] instanceof Date)) cell = data[R2][C2];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R2][C2][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f) cell.t = "n";
          else if (o2.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o2.sheetStubs) continue;
          else cell.t = "z";
        } else if (typeof cell.v === "number") cell.t = "n";
        else if (typeof cell.v === "boolean") cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o2.dateNF || table_fmt[14];
          if (o2.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else cell.t = "s";
      }
      if (dense) {
        if (!ws[__R]) ws[__R] = [];
        if (ws[__R][__C] && ws[__R][__C].z) cell.z = ws[__R][__C].z;
        ws[__R][__C] = cell;
      } else {
        var cell_ref = encode_cell({ c: __C, r: __R });
        if (ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (range.s.c < 1e7) ws["!ref"] = encode_range(range);
  return ws;
}
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
function parse_RichStr(data, length) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z2 = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i2 = 0; i2 != dwSizeStrRun; ++i2) rgsStrRun.push(parse_StrRun(data));
    z2.r = rgsStrRun;
  } else z2.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length;
  return z2;
}
var parse_BrtCommentText = parse_RichStr;
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
var parse_XLSBCodeName = parse_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
function parse_RkNumber(data) {
  var b2 = data.slice(data.l, data.l + 4);
  var fX100 = b2[0] & 1, fInt = b2[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b2[0] & 252, b2[1], b2[2], b2[3]], 0) : __readInt32LE(b2, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
var parse_UncheckedRfX = parse_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
function parse_BrtColor(data) {
  var out = {};
  var d2 = data.read_shift(1);
  var xColorType = d2 >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv) out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
function parse_FontFlags(data) {
  var d2 = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d2 & 1,
    fItalic: d2 & 2,
    fUnderline: d2 & 4,
    fStrikeout: d2 & 8,
    fOutline: d2 & 16,
    fShadow: d2 & 32,
    fCondense: d2 & 64,
    fExtend: d2 & 128
  };
  return out;
}
function parse_ClipboardFormatOrString(o2, w2) {
  var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
  var m2 = o2.read_shift(4);
  switch (m2) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return ClipFmt[o2.read_shift(4)] || "";
  }
  if (m2 > 400) throw new Error("Unsupported Clipboard: " + m2.toString(16));
  o2.l -= 4;
  return o2.read_shift(0, w2 == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(o2) {
  return parse_ClipboardFormatOrString(o2, 1);
}
function parse_ClipboardFormatOrUnicodeString(o2) {
  return parse_ClipboardFormatOrString(o2, 2);
}
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_VARIANT = 12;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var VT_USTR = 81;
var VT_CUSTOM = [VT_STRING, VT_USTR];
var DocSummaryPIDDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Category", t: VT_STRING },
  /*::[*/
  3: { n: "PresentationFormat", t: VT_STRING },
  /*::[*/
  4: { n: "ByteCount", t: VT_I4 },
  /*::[*/
  5: { n: "LineCount", t: VT_I4 },
  /*::[*/
  6: { n: "ParagraphCount", t: VT_I4 },
  /*::[*/
  7: { n: "SlideCount", t: VT_I4 },
  /*::[*/
  8: { n: "NoteCount", t: VT_I4 },
  /*::[*/
  9: { n: "HiddenCount", t: VT_I4 },
  /*::[*/
  10: { n: "MultimediaClipCount", t: VT_I4 },
  /*::[*/
  11: { n: "ScaleCrop", t: VT_BOOL },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: VT_STRING },
  /*::[*/
  15: { n: "Company", t: VT_STRING },
  /*::[*/
  16: { n: "LinksUpToDate", t: VT_BOOL },
  /*::[*/
  17: { n: "CharacterCount", t: VT_I4 },
  /*::[*/
  19: { n: "SharedDoc", t: VT_BOOL },
  /*::[*/
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  /*::[*/
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: VT_BLOB },
  /*::[*/
  26: { n: "ContentType", t: VT_STRING },
  /*::[*/
  27: { n: "ContentStatus", t: VT_STRING },
  /*::[*/
  28: { n: "Language", t: VT_STRING },
  /*::[*/
  29: { n: "Version", t: VT_STRING },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var SummaryPIDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Title", t: VT_STRING },
  /*::[*/
  3: { n: "Subject", t: VT_STRING },
  /*::[*/
  4: { n: "Author", t: VT_STRING },
  /*::[*/
  5: { n: "Keywords", t: VT_STRING },
  /*::[*/
  6: { n: "Comments", t: VT_STRING },
  /*::[*/
  7: { n: "Template", t: VT_STRING },
  /*::[*/
  8: { n: "LastAuthor", t: VT_STRING },
  /*::[*/
  9: { n: "RevNumber", t: VT_STRING },
  /*::[*/
  10: { n: "EditTime", t: VT_FILETIME },
  /*::[*/
  11: { n: "LastPrinted", t: VT_FILETIME },
  /*::[*/
  12: { n: "CreatedDate", t: VT_FILETIME },
  /*::[*/
  13: { n: "ModifiedDate", t: VT_FILETIME },
  /*::[*/
  14: { n: "PageCount", t: VT_I4 },
  /*::[*/
  15: { n: "WordCount", t: VT_I4 },
  /*::[*/
  16: { n: "CharCount", t: VT_I4 },
  /*::[*/
  17: { n: "Thumbnail", t: VT_CF },
  /*::[*/
  18: { n: "Application", t: VT_STRING },
  /*::[*/
  19: { n: "DocSecurity", t: VT_I4 },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var CountryEnum = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
};
var XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(arr) {
  return arr.map(function(x2) {
    return [x2 >> 16 & 255, x2 >> 8 & 255, x2 & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
};
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(data) {
  var ct2 = new_ct();
  if (!data || !data.match) return ct2;
  var ctext = {};
  (data.match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (y2[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        ct2.xmlns = y2["xmlns" + (y2[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        ctext[y2.Extension] = y2.ContentType;
        break;
      case "<Override":
        if (ct2[ct2type[y2.ContentType]] !== void 0) ct2[ct2type[y2.ContentType]].push(y2.PartName);
        break;
    }
  });
  if (ct2.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct2.xmlns);
  ct2.calcchain = ct2.calcchains.length > 0 ? ct2.calcchains[0] : "";
  ct2.sst = ct2.strs.length > 0 ? ct2.strs[0] : "";
  ct2.style = ct2.styles.length > 0 ? ct2.styles[0] : "";
  ct2.defaults = ctext;
  delete ct2.calcchains;
  return ct2;
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n2 = file.lastIndexOf("/");
  return file.slice(0, n2 + 1) + "_rels/" + file.slice(n2 + 1) + ".rels";
}
function parse_rels(data, currentFilePath) {
  var rels = { "!id": {} };
  if (!data) return rels;
  if (currentFilePath.charAt(0) !== "/") {
    currentFilePath = "/" + currentFilePath;
  }
  var hash = {};
  (data.match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    if (y2[0] === "<Relationship") {
      var rel = {};
      rel.Type = y2.Type;
      rel.Target = y2.Target;
      rel.Id = y2.Id;
      if (y2.TargetMode) rel.TargetMode = y2.TargetMode;
      var canonictarget = y2.TargetMode === "External" ? y2.Target : resolve_path(y2.Target, currentFilePath);
      rels[canonictarget] = rel;
      hash[y2.Id] = rel;
    }
  });
  rels["!id"] = hash;
  return rels;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(d2, opts) {
  var str = xlml_normalize(d2);
  var Rn;
  var FEtag;
  while (Rn = xlmlregex.exec(str)) switch (Rn[3]) {
    case "manifest":
      break;
    // 4.2 <manifest:manifest>
    case "file-entry":
      FEtag = parsexmltag(Rn[0], false);
      if (FEtag.path == "/" && FEtag.type !== CT_ODS) throw new Error("This OpenDocument is not a spreadsheet");
      break;
    case "encryption-data":
    // 4.4 <manifest:encryption-data>
    case "algorithm":
    // 4.5 <manifest:algorithm>
    case "start-key-generation":
    // 4.6 <manifest:start-key-generation>
    case "key-derivation":
      throw new Error("Unsupported ODS Encryption");
    default:
      if (opts && opts.WTF) throw Rn;
  }
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
var CORE_PROPS_REGEX = /* @__PURE__ */ (function() {
  var r2 = new Array(CORE_PROPS.length);
  for (var i2 = 0; i2 < CORE_PROPS.length; ++i2) {
    var f2 = CORE_PROPS[i2];
    var g2 = "(?:" + f2[0].slice(0, f2[0].indexOf(":")) + ":)" + f2[0].slice(f2[0].indexOf(":") + 1);
    r2[i2] = new RegExp("<" + g2 + "[^>]*>([\\s\\S]*?)</" + g2 + ">");
  }
  return r2;
})();
function parse_core_props(data) {
  var p2 = {};
  data = utf8read(data);
  for (var i2 = 0; i2 < CORE_PROPS.length; ++i2) {
    var f2 = CORE_PROPS[i2], cur = data.match(CORE_PROPS_REGEX[i2]);
    if (cur != null && cur.length > 0) p2[f2[1]] = unescapexml(cur[1]);
    if (f2[2] === "date" && p2[f2[1]]) p2[f2[1]] = parseDate(p2[f2[1]]);
  }
  return p2;
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
function load_props_pairs(HP, TOP, props, opts) {
  var v2 = [];
  if (typeof HP == "string") v2 = parseVector(HP, opts);
  else for (var j2 = 0; j2 < HP.length; ++j2) v2 = v2.concat(HP[j2].map(function(hp) {
    return { v: hp };
  }));
  var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x2) {
    return x2.v;
  }) : TOP;
  var idx = 0, len = 0;
  if (parts.length > 0) for (var i2 = 0; i2 !== v2.length; i2 += 2) {
    len = +v2[i2 + 1].v;
    switch (v2[i2].v) {
      case "Worksheets":
      case "å·¥ä½è¡¨":
      case "ÐÐ¸ÑÑÑ":
      case "Ø£ÙØ±Ø§Ù Ø§ÙØ¹ÙÙ":
      case "ã¯ã¼ã¯ã·ã¼ã":
      case "××××× ××ª ×¢××××":
      case "ArbeitsblÃ¤tter":
      case "ÃalÄ±Åma SayfalarÄ±":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de cÃ¡lculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de cÃ¡lculo":
      case "Werkbladen":
        props.Worksheets = len;
        props.SheetNames = parts.slice(idx, idx + len);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "ååä»ãä¸è¦§":
      case "Benannte Bereiche":
      case "Navngivne omrÃ¥der":
        props.NamedRanges = len;
        props.DefinedNames = parts.slice(idx, idx + len);
        break;
      case "Charts":
      case "Diagramme":
        props.Chartsheets = len;
        props.ChartNames = parts.slice(idx, idx + len);
        break;
    }
    idx += len;
  }
}
function parse_ext_props(data, p2, opts) {
  var q2 = {};
  if (!p2) p2 = {};
  data = utf8read(data);
  EXT_PROPS.forEach(function(f2) {
    var xml2 = (data.match(matchtag(f2[0])) || [])[1];
    switch (f2[2]) {
      case "string":
        if (xml2) p2[f2[1]] = unescapexml(xml2);
        break;
      case "bool":
        p2[f2[1]] = xml2 === "true";
        break;
      case "raw":
        var cur = data.match(new RegExp("<" + f2[0] + "[^>]*>([\\s\\S]*?)</" + f2[0] + ">"));
        if (cur && cur.length > 0) q2[f2[1]] = cur[1];
        break;
    }
  });
  if (q2.HeadingPairs && q2.TitlesOfParts) load_props_pairs(q2.HeadingPairs, q2.TitlesOfParts, p2, opts);
  return p2;
}
var custregex = /<[^>]+>[^<]*/g;
function parse_cust_props(data, opts) {
  var p2 = {}, name = "";
  var m2 = data.match(custregex);
  if (m2) for (var i2 = 0; i2 != m2.length; ++i2) {
    var x2 = m2[i2], y2 = parsexmltag(x2);
    switch (y2[0]) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        name = unescapexml(y2.name);
        break;
      case "</property>":
        name = null;
        break;
      default:
        if (x2.indexOf("<vt:") === 0) {
          var toks = x2.split(">");
          var type = toks[0].slice(4), text2 = toks[1];
          switch (type) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              p2[name] = unescapexml(text2);
              break;
            case "bool":
              p2[name] = parsexmlbool(text2);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              p2[name] = parseInt(text2, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              p2[name] = parseFloat(text2);
              break;
            case "filetime":
            case "date":
              p2[name] = parseDate(text2);
              break;
            case "cy":
            case "error":
              p2[name] = unescapexml(text2);
              break;
            default:
              if (type.slice(-1) == "/") break;
              if (opts.WTF && typeof console !== "undefined") console.warn("Unexpected", x2, type, toks);
          }
        } else if (x2.slice(0, 2) === "</") ;
        else if (opts.WTF) throw new Error(x2);
    }
  }
  return p2;
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
var evert_XLMLDPM;
function xlml_set_prop(Props, tag, val) {
  if (!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);
  tag = evert_XLMLDPM[tag] || tag;
  Props[tag] = val;
}
function parse_FILETIME(blob) {
  var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
  return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function parse_lpstr(blob, type, pad) {
  var start = blob.l;
  var str = blob.read_shift(0, "lpstr-cp");
  if (pad) while (blob.l - start & 3) ++blob.l;
  return str;
}
function parse_lpwstr(blob, type, pad) {
  var str = blob.read_shift(0, "lpwstr");
  return str;
}
function parse_VtStringBase(blob, stringType, pad) {
  if (stringType === 31) return parse_lpwstr(blob);
  return parse_lpstr(blob, stringType, pad);
}
function parse_VtString(blob, t3, pad) {
  return parse_VtStringBase(blob, t3, pad === false ? 0 : 4);
}
function parse_VtUnalignedString(blob, t3) {
  if (!t3) throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(blob, t3, 0);
}
function parse_VtVecLpwstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i2 = 0; i2 != length; ++i2) {
    var start = blob.l;
    ret[i2] = blob.read_shift(0, "lpwstr").replace(chr0, "");
    if (blob.l - start & 2) blob.l += 2;
  }
  return ret;
}
function parse_VtVecUnalignedLpstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i2 = 0; i2 != length; ++i2) ret[i2] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
  return ret;
}
function parse_VtHeadingPair(blob) {
  var start = blob.l;
  var headingString = parse_TypedPropertyValue(blob, VT_USTR);
  if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2) blob.l += 2;
  var headerParts = parse_TypedPropertyValue(blob, VT_I4);
  return [headingString, headerParts];
}
function parse_VtVecHeadingPairValue(blob) {
  var cElements = blob.read_shift(4);
  var out = [];
  for (var i2 = 0; i2 < cElements / 2; ++i2) out.push(parse_VtHeadingPair(blob));
  return out;
}
function parse_dictionary(blob, CodePage) {
  var cnt = blob.read_shift(4);
  var dict = {};
  for (var j2 = 0; j2 != cnt; ++j2) {
    var pid = blob.read_shift(4);
    var len = blob.read_shift(4);
    dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
    if (CodePage === 1200 && len % 2) blob.l += 2;
  }
  if (blob.l & 3) blob.l = blob.l >> 2 + 1 << 2;
  return dict;
}
function parse_BLOB(blob) {
  var size = blob.read_shift(4);
  var bytes = blob.slice(blob.l, blob.l + size);
  blob.l += size;
  if ((size & 3) > 0) blob.l += 4 - (size & 3) & 3;
  return bytes;
}
function parse_ClipboardData(blob) {
  var o2 = {};
  o2.Size = blob.read_shift(4);
  blob.l += o2.Size + 3 - (o2.Size - 1) % 4;
  return o2;
}
function parse_TypedPropertyValue(blob, type, _opts) {
  var t3 = blob.read_shift(2), ret, opts = _opts || {};
  blob.l += 2;
  if (type !== VT_VARIANT) {
    if (t3 !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t3 & 65534) == 4126)) throw new Error("Expected type " + type + " saw " + t3);
  }
  switch (type === VT_VARIANT ? t3 : type) {
    case 2:
      ret = blob.read_shift(2, "i");
      if (!opts.raw) blob.l += 2;
      return ret;
    case 3:
      ret = blob.read_shift(4, "i");
      return ret;
    case 11:
      return blob.read_shift(4) !== 0;
    case 19:
      ret = blob.read_shift(4);
      return ret;
    case 30:
      return parse_lpstr(blob, t3, 4).replace(chr0, "");
    case 31:
      return parse_lpwstr(blob);
    case 64:
      return parse_FILETIME(blob);
    case 65:
      return parse_BLOB(blob);
    case 71:
      return parse_ClipboardData(blob);
    case 80:
      return parse_VtString(blob, t3, !opts.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        blob,
        t3
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(blob);
    case 4126:
    case 4127:
      return t3 == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + t3);
  }
}
function parse_PropertySet(blob, PIDSI) {
  var start_addr = blob.l;
  var size = blob.read_shift(4);
  var NumProps = blob.read_shift(4);
  var Props = [], i2 = 0;
  var CodePage = 0;
  var Dictionary = -1, DictObj = {};
  for (i2 = 0; i2 != NumProps; ++i2) {
    var PropID = blob.read_shift(4);
    var Offset = blob.read_shift(4);
    Props[i2] = [PropID, Offset + start_addr];
  }
  Props.sort(function(x2, y2) {
    return x2[1] - y2[1];
  });
  var PropH = {};
  for (i2 = 0; i2 != NumProps; ++i2) {
    if (blob.l !== Props[i2][1]) {
      var fail = true;
      if (i2 > 0 && PIDSI) switch (PIDSI[Props[i2 - 1][0]].t) {
        case 2:
          if (blob.l + 2 === Props[i2][1]) {
            blob.l += 2;
            fail = false;
          }
          break;
        case 80:
          if (blob.l <= Props[i2][1]) {
            blob.l = Props[i2][1];
            fail = false;
          }
          break;
        case 4108:
          if (blob.l <= Props[i2][1]) {
            blob.l = Props[i2][1];
            fail = false;
          }
          break;
      }
      if ((!PIDSI || i2 == 0) && blob.l <= Props[i2][1]) {
        fail = false;
        blob.l = Props[i2][1];
      }
      if (fail) throw new Error("Read Error: Expected address " + Props[i2][1] + " at " + blob.l + " :" + i2);
    }
    if (PIDSI) {
      var piddsi = PIDSI[Props[i2][0]];
      PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
      if (piddsi.p === "version") PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
      if (piddsi.n == "CodePage") switch (PropH[piddsi.n]) {
        case 0:
          PropH[piddsi.n] = 1252;
        /* falls through */
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
      }
    } else {
      if (Props[i2][0] === 1) {
        CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
        set_cp(CodePage);
        if (Dictionary !== -1) {
          var oldpos = blob.l;
          blob.l = Props[Dictionary][1];
          DictObj = parse_dictionary(blob, CodePage);
          blob.l = oldpos;
        }
      } else if (Props[i2][0] === 0) {
        if (CodePage === 0) {
          Dictionary = i2;
          blob.l = Props[i2 + 1][1];
          continue;
        }
        DictObj = parse_dictionary(blob, CodePage);
      } else {
        var name = DictObj[Props[i2][0]];
        var val;
        switch (blob[blob.l]) {
          case 65:
            blob.l += 4;
            val = parse_BLOB(blob);
            break;
          case 30:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 31:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 3:
            blob.l += 4;
            val = blob.read_shift(4, "i");
            break;
          case 19:
            blob.l += 4;
            val = blob.read_shift(4);
            break;
          case 5:
            blob.l += 4;
            val = blob.read_shift(8, "f");
            break;
          case 11:
            blob.l += 4;
            val = parsebool(blob, 4);
            break;
          case 64:
            blob.l += 4;
            val = parseDate(parse_FILETIME(blob));
            break;
          default:
            throw new Error("unparsed value: " + blob[blob.l]);
        }
        PropH[name] = val;
      }
    }
  }
  blob.l = start_addr + size;
  return PropH;
}
function parse_PropertySetStream(file, PIDSI, clsid) {
  var blob = file.content;
  if (!blob) return {};
  prep_blob(blob, 0);
  var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
  blob.chk("feff", "Byte Order: ");
  blob.read_shift(2);
  var SystemIdentifier = blob.read_shift(4);
  var CLSID = blob.read_shift(16);
  if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);
  NumSets = blob.read_shift(4);
  if (NumSets !== 1 && NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);
  FMTID0 = blob.read_shift(16);
  Offset0 = blob.read_shift(4);
  if (NumSets === 1 && Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
  else if (NumSets === 2) {
    FMTID1 = blob.read_shift(16);
    Offset1 = blob.read_shift(4);
  }
  var PSet0 = parse_PropertySet(blob, PIDSI);
  var rval = { SystemIdentifier };
  for (var y2 in PSet0) rval[y2] = PSet0[y2];
  rval.FMTID = FMTID0;
  if (NumSets === 1) return rval;
  if (Offset1 - blob.l == 2) blob.l += 2;
  if (blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
  var PSet1;
  try {
    PSet1 = parse_PropertySet(blob, null);
  } catch (e2) {
  }
  for (y2 in PSet1) rval[y2] = PSet1[y2];
  rval.FMTID = [FMTID0, FMTID1];
  return rval;
}
function parsenoop2(blob, length) {
  blob.read_shift(length);
  return null;
}
function parslurp(blob, length, cb) {
  var arr = [], target = blob.l + length;
  while (blob.l < target) arr.push(cb(blob, target - blob.l));
  if (target !== blob.l) throw new Error("Slurp error");
  return arr;
}
function parsebool(blob, length) {
  return blob.read_shift(length) === 1;
}
function parseuint16(blob) {
  return blob.read_shift(2, "u");
}
function parseuint16a(blob, length) {
  return parslurp(blob, length, parseuint16);
}
function parse_Bes(blob) {
  var v2 = blob.read_shift(1), t3 = blob.read_shift(1);
  return t3 === 1 ? v2 : v2 === 1;
}
function parse_ShortXLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  if (opts && opts.biff >= 8) ;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
  var o2 = cch ? blob.read_shift(cch, encoding) : "";
  return o2;
}
function parse_XLUnicodeRichExtendedString(blob) {
  var cch = blob.read_shift(2), flags = blob.read_shift(1);
  var fExtSt = flags & 4, fRichSt = flags & 8;
  var width = 1 + (flags & 1);
  var cRun = 0, cbExtRst;
  var z2 = {};
  if (fRichSt) cRun = blob.read_shift(2);
  if (fExtSt) cbExtRst = blob.read_shift(4);
  var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
  var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
  if (fRichSt) blob.l += 4 * cRun;
  if (fExtSt) blob.l += cbExtRst;
  z2.t = msg;
  if (!fRichSt) {
    z2.raw = "<t>" + z2.t + "</t>";
    z2.r = z2.t;
  }
  return z2;
}
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
    if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob.read_shift(1);
  if (fHighByte === 0) {
    retval = blob.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
function parse_XLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
function parse_XLUnicodeString2(blob, length, opts) {
  if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
}
function parse_ControlInfo(blob) {
  var flags = blob.read_shift(1);
  blob.l++;
  var accel = blob.read_shift(2);
  blob.l += 2;
  return [flags, accel];
}
function parse_URLMoniker(blob) {
  var len = blob.read_shift(4), start = blob.l;
  var extra = false;
  if (len > 24) {
    blob.l += len - 24;
    if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;
    blob.l = start;
  }
  var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
  if (extra) blob.l += 24;
  return url;
}
function parse_FileMoniker(blob) {
  var cAnti = blob.read_shift(2);
  var preamble = "";
  while (cAnti-- > 0) preamble += "../";
  var ansiPath = blob.read_shift(0, "lpstr-ansi");
  blob.l += 2;
  if (blob.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var sz = blob.read_shift(4);
  if (sz === 0) return preamble + ansiPath.replace(/\\/g, "/");
  var bytes = blob.read_shift(4);
  if (blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
  return preamble + unicodePath;
}
function parse_HyperlinkMoniker(blob, length) {
  var clsid = blob.read_shift(16);
  switch (clsid) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(blob);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(blob);
    default:
      throw new Error("Unsupported Moniker " + clsid);
  }
}
function parse_HyperlinkString(blob) {
  var len = blob.read_shift(4);
  var o2 = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
  return o2;
}
function parse_Hyperlink(blob, length) {
  var end = blob.l + length;
  var sVer = blob.read_shift(4);
  if (sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);
  var flags = blob.read_shift(2);
  blob.l += 2;
  var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
  if (flags & 16) displayName = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 128) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 257) moniker = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 1) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
  if (flags & 8) Loc = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 32) guid = blob.read_shift(16);
  if (flags & 64) fileTime = parse_FILETIME(
    blob
    /*, 8*/
  );
  blob.l = end;
  var target = targetFrameName || moniker || oleMoniker || "";
  if (target && Loc) target += "#" + Loc;
  if (!target) target = "#" + Loc;
  if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/") target = "file://" + target;
  var out = { Target: target };
  if (guid) out.guid = guid;
  if (fileTime) out.time = fileTime;
  if (displayName) out.Tooltip = displayName;
  return out;
}
function parse_LongRGBA(blob) {
  var r2 = blob.read_shift(1), g2 = blob.read_shift(1), b2 = blob.read_shift(1), a2 = blob.read_shift(1);
  return [r2, g2, b2, a2];
}
function parse_LongRGB(blob, length) {
  var x2 = parse_LongRGBA(blob);
  x2[3] = 0;
  return x2;
}
function parse_XLSCell(blob) {
  var rw = blob.read_shift(2);
  var col = blob.read_shift(2);
  var ixfe = blob.read_shift(2);
  return { r: rw, c: col, ixfe };
}
function parse_frtHeader(blob) {
  var rt2 = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 8;
  return { type: rt2, flags };
}
function parse_OptXLUnicodeString(blob, length, opts) {
  return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
}
function parse_XTI(blob, length, opts) {
  var w2 = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob.read_shift(w2), itabFirst = blob.read_shift(w2, "i"), itabLast = blob.read_shift(w2, "i");
  return [iSupBook, itabFirst, itabLast];
}
function parse_RkRec(blob) {
  var ixfe = blob.read_shift(2);
  var RK = parse_RkNumber(blob);
  return [ixfe, RK];
}
function parse_AddinUdf(blob, length, opts) {
  blob.l += 4;
  length -= 4;
  var l2 = blob.l + length;
  var udfName = parse_ShortXLUnicodeString(blob, length, opts);
  var cb = blob.read_shift(2);
  l2 -= blob.l;
  if (cb !== l2) throw new Error("Malformed AddinUdf: padding = " + l2 + " != " + cb);
  blob.l += cb;
  return udfName;
}
function parse_Ref8U(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(2);
  var colLast = blob.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
function parse_RefU(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(1);
  var colLast = blob.read_shift(1);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(blob) {
  blob.l += 4;
  var ot2 = blob.read_shift(2);
  var id = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 12;
  return [id, ot2, flags];
}
function parse_FtNts(blob) {
  var out = {};
  blob.l += 4;
  blob.l += 16;
  out.fSharedNote = blob.read_shift(2);
  blob.l += 4;
  return out;
}
function parse_FtCf(blob) {
  var out = {};
  blob.l += 4;
  blob.cf = blob.read_shift(2);
  return out;
}
function parse_FtSkip(blob) {
  blob.l += 2;
  blob.l += blob.read_shift(2);
}
var FtTab = {
  /*::[*/
  0: parse_FtSkip,
  /* FtEnd */
  /*::[*/
  4: parse_FtSkip,
  /* FtMacro */
  /*::[*/
  5: parse_FtSkip,
  /* FtButton */
  /*::[*/
  6: parse_FtSkip,
  /* FtGmo */
  /*::[*/
  7: parse_FtCf,
  /* FtCf */
  /*::[*/
  8: parse_FtSkip,
  /* FtPioGrbit */
  /*::[*/
  9: parse_FtSkip,
  /* FtPictFmla */
  /*::[*/
  10: parse_FtSkip,
  /* FtCbls */
  /*::[*/
  11: parse_FtSkip,
  /* FtRbo */
  /*::[*/
  12: parse_FtSkip,
  /* FtSbs */
  /*::[*/
  13: parse_FtNts,
  /* FtNts */
  /*::[*/
  14: parse_FtSkip,
  /* FtSbsFmla */
  /*::[*/
  15: parse_FtSkip,
  /* FtGboData */
  /*::[*/
  16: parse_FtSkip,
  /* FtEdoData */
  /*::[*/
  17: parse_FtSkip,
  /* FtRboData */
  /*::[*/
  18: parse_FtSkip,
  /* FtCblsData */
  /*::[*/
  19: parse_FtSkip,
  /* FtLbsData */
  /*::[*/
  20: parse_FtSkip,
  /* FtCblsFmla */
  /*::[*/
  21: parse_FtCmo
};
function parse_FtArray(blob, length) {
  var tgt = blob.l + length;
  var fts = [];
  while (blob.l < tgt) {
    var ft2 = blob.read_shift(2);
    blob.l -= 2;
    try {
      fts.push(FtTab[ft2](blob, tgt - blob.l));
    } catch (e2) {
      blob.l = tgt;
      return fts;
    }
  }
  if (blob.l != tgt) blob.l = tgt;
  return fts;
}
function parse_BOF(blob, length) {
  var o2 = { BIFFVer: 0, dt: 0 };
  o2.BIFFVer = blob.read_shift(2);
  length -= 2;
  if (length >= 2) {
    o2.dt = blob.read_shift(2);
    blob.l -= 2;
  }
  switch (o2.BIFFVer) {
    case 1536:
    /* BIFF8 */
    case 1280:
    /* BIFF5 */
    case 1024:
    /* BIFF4 */
    case 768:
    /* BIFF3 */
    case 512:
    /* BIFF2 */
    case 2:
    case 7:
      break;
    default:
      if (length > 6) throw new Error("Unexpected BIFF Ver " + o2.BIFFVer);
  }
  blob.read_shift(length);
  return o2;
}
function parse_InterfaceHdr(blob, length) {
  if (length === 0) return 1200;
  if (blob.read_shift(2) !== 1200) ;
  return 1200;
}
function parse_WriteAccess(blob, length, opts) {
  if (opts.enc) {
    blob.l += length;
    return "";
  }
  var l2 = blob.l;
  var UserName = parse_XLUnicodeString2(blob, 0, opts);
  blob.read_shift(length + l2 - blob.l);
  return UserName;
}
function parse_WsBool(blob, length, opts) {
  var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
  return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
}
function parse_BoundSheet8(blob, length, opts) {
  var pos = blob.read_shift(4);
  var hidden = blob.read_shift(1) & 3;
  var dt2 = blob.read_shift(1);
  switch (dt2) {
    case 0:
      dt2 = "Worksheet";
      break;
    case 1:
      dt2 = "Macrosheet";
      break;
    case 2:
      dt2 = "Chartsheet";
      break;
    case 6:
      dt2 = "VBAModule";
      break;
  }
  var name = parse_ShortXLUnicodeString(blob, 0, opts);
  if (name.length === 0) name = "Sheet1";
  return { pos, hs: hidden, dt: dt2, name };
}
function parse_SST(blob, length) {
  var end = blob.l + length;
  var cnt = blob.read_shift(4);
  var ucnt = blob.read_shift(4);
  var strs2 = [];
  for (var i2 = 0; i2 != ucnt && blob.l < end; ++i2) {
    strs2.push(parse_XLUnicodeRichExtendedString(blob));
  }
  strs2.Count = cnt;
  strs2.Unique = ucnt;
  return strs2;
}
function parse_ExtSST(blob, length) {
  var extsst = {};
  extsst.dsst = blob.read_shift(2);
  blob.l += length - 2;
  return extsst;
}
function parse_Row(blob) {
  var z2 = {};
  z2.r = blob.read_shift(2);
  z2.c = blob.read_shift(2);
  z2.cnt = blob.read_shift(2) - z2.c;
  var miyRw = blob.read_shift(2);
  blob.l += 4;
  var flags = blob.read_shift(1);
  blob.l += 3;
  if (flags & 7) z2.level = flags & 7;
  if (flags & 32) z2.hidden = true;
  if (flags & 64) z2.hpt = miyRw / 20;
  return z2;
}
function parse_ForceFullCalculation(blob) {
  var header = parse_frtHeader(blob);
  if (header.type != 2211) throw new Error("Invalid Future Record " + header.type);
  var fullcalc = blob.read_shift(4);
  return fullcalc !== 0;
}
function parse_RecalcId(blob) {
  blob.read_shift(2);
  return blob.read_shift(4);
}
function parse_DefaultRowHeight(blob, length, opts) {
  var f2 = 0;
  if (!(opts && opts.biff == 2)) {
    f2 = blob.read_shift(2);
  }
  var miyRw = blob.read_shift(2);
  if (opts && opts.biff == 2) {
    f2 = 1 - (miyRw >> 15);
    miyRw &= 32767;
  }
  var fl2 = { Unsynced: f2 & 1, DyZero: (f2 & 2) >> 1, ExAsc: (f2 & 4) >> 2, ExDsc: (f2 & 8) >> 3 };
  return [fl2, miyRw];
}
function parse_Window1(blob) {
  var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
  var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
  var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
  return {
    Pos: [xWn, yWn],
    Dim: [dxWn, dyWn],
    Flags: flags,
    CurTab: iTabCur,
    FirstTab: iTabFirst,
    Selected: ctabSel,
    TabRatio: wTabRatio
  };
}
function parse_Window2(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff < 5) return {};
  var f2 = blob.read_shift(2);
  return { RTL: f2 & 64 };
}
function parse_Pane() {
}
function parse_Font(blob, length, opts) {
  var o2 = {
    dyHeight: blob.read_shift(2),
    fl: blob.read_shift(2)
  };
  switch (opts && opts.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      blob.l += 2;
      break;
    default:
      blob.l += 10;
      break;
  }
  o2.name = parse_ShortXLUnicodeString(blob, 0, opts);
  return o2;
}
function parse_LabelSst(blob) {
  var cell = parse_XLSCell(blob);
  cell.isst = blob.read_shift(4);
  return cell;
}
function parse_Label(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var target = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2) blob.l++;
  var str = parse_XLUnicodeString(blob, target - blob.l, opts);
  cell.val = str;
  return cell;
}
function parse_Format(blob, length, opts) {
  var numFmtId = blob.read_shift(2);
  var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
  return [numFmtId, fmtstr];
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function parse_Dimensions(blob, length, opts) {
  var end = blob.l + length;
  var w2 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var r2 = blob.read_shift(w2), R2 = blob.read_shift(w2);
  var c2 = blob.read_shift(2), C2 = blob.read_shift(2);
  blob.l = end;
  return { s: { r: r2, c: c2 }, e: { r: R2, c: C2 } };
}
function parse_RK(blob) {
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrec = parse_RkRec(blob);
  return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
}
function parse_MulRk(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrecs = [];
  while (blob.l < target) rkrecs.push(parse_RkRec(blob));
  if (blob.l !== target) throw new Error("MulRK read error");
  var lastcol = blob.read_shift(2);
  if (rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");
  return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
}
function parse_MulBlank(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var ixfes = [];
  while (blob.l < target) ixfes.push(blob.read_shift(2));
  if (blob.l !== target) throw new Error("MulBlank read error");
  var lastcol = blob.read_shift(2);
  if (ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");
  return { r: rw, c: col, C: lastcol, ixfe: ixfes };
}
function parse_CellStyleXF(blob, length, style, opts) {
  var o2 = {};
  var a2 = blob.read_shift(4), b2 = blob.read_shift(4);
  var c2 = blob.read_shift(4), d2 = blob.read_shift(2);
  o2.patternType = XLSFillPattern[c2 >> 26];
  if (!opts.cellStyles) return o2;
  o2.alc = a2 & 7;
  o2.fWrap = a2 >> 3 & 1;
  o2.alcV = a2 >> 4 & 7;
  o2.fJustLast = a2 >> 7 & 1;
  o2.trot = a2 >> 8 & 255;
  o2.cIndent = a2 >> 16 & 15;
  o2.fShrinkToFit = a2 >> 20 & 1;
  o2.iReadOrder = a2 >> 22 & 2;
  o2.fAtrNum = a2 >> 26 & 1;
  o2.fAtrFnt = a2 >> 27 & 1;
  o2.fAtrAlc = a2 >> 28 & 1;
  o2.fAtrBdr = a2 >> 29 & 1;
  o2.fAtrPat = a2 >> 30 & 1;
  o2.fAtrProt = a2 >> 31 & 1;
  o2.dgLeft = b2 & 15;
  o2.dgRight = b2 >> 4 & 15;
  o2.dgTop = b2 >> 8 & 15;
  o2.dgBottom = b2 >> 12 & 15;
  o2.icvLeft = b2 >> 16 & 127;
  o2.icvRight = b2 >> 23 & 127;
  o2.grbitDiag = b2 >> 30 & 3;
  o2.icvTop = c2 & 127;
  o2.icvBottom = c2 >> 7 & 127;
  o2.icvDiag = c2 >> 14 & 127;
  o2.dgDiag = c2 >> 21 & 15;
  o2.icvFore = d2 & 127;
  o2.icvBack = d2 >> 7 & 127;
  o2.fsxButton = d2 >> 14 & 1;
  return o2;
}
function parse_XF(blob, length, opts) {
  var o2 = {};
  o2.ifnt = blob.read_shift(2);
  o2.numFmtId = blob.read_shift(2);
  o2.flags = blob.read_shift(2);
  o2.fStyle = o2.flags >> 2 & 1;
  length -= 6;
  o2.data = parse_CellStyleXF(blob, length, o2.fStyle, opts);
  return o2;
}
function parse_Guts(blob) {
  blob.l += 4;
  var out = [blob.read_shift(2), blob.read_shift(2)];
  if (out[0] !== 0) out[0]--;
  if (out[1] !== 0) out[1]--;
  if (out[0] > 7 || out[1] > 7) throw new Error("Bad Gutters: " + out.join("|"));
  return out;
}
function parse_BoolErr(blob, length, opts) {
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2 || length == 9) ++blob.l;
  var val = parse_Bes(blob);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function parse_Number(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var cell = parse_XLSCell(blob);
  var xnum = parse_Xnum(blob);
  cell.val = xnum;
  return cell;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(blob, length, opts) {
  var end = blob.l + length;
  var ctab = blob.read_shift(2);
  var cch = blob.read_shift(2);
  opts.sbcch = cch;
  if (cch == 1025 || cch == 14849) return [cch, ctab];
  if (cch < 1 || cch > 255) throw new Error("Unexpected SupBook type: " + cch);
  var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
  var rgst = [];
  while (end > blob.l) rgst.push(parse_XLUnicodeString(blob));
  return [cch, ctab, virtPath, rgst];
}
function parse_ExternName(blob, length, opts) {
  var flags = blob.read_shift(2);
  var body;
  var o2 = {
    fBuiltIn: flags & 1,
    fWantAdvise: flags >>> 1 & 1,
    fWantPict: flags >>> 2 & 1,
    fOle: flags >>> 3 & 1,
    fOleLink: flags >>> 4 & 1,
    cf: flags >>> 5 & 1023,
    fIcon: flags >>> 15 & 1
  };
  if (opts.sbcch === 14849) body = parse_AddinUdf(blob, length - 2, opts);
  o2.body = body || blob.read_shift(length - 2);
  if (typeof body === "string") o2.Name = body;
  return o2;
}
var XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
function parse_Lbl(blob, length, opts) {
  var target = blob.l + length;
  var flags = blob.read_shift(2);
  var chKey = blob.read_shift(1);
  var cch = blob.read_shift(1);
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var itab = 0;
  if (!opts || opts.biff >= 5) {
    if (opts.biff != 5) blob.l += 2;
    itab = blob.read_shift(2);
    if (opts.biff == 5) blob.l += 2;
    blob.l += 4;
  }
  var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
  if (flags & 32) name = XLSLblBuiltIn[name.charCodeAt(0)];
  var npflen = target - blob.l;
  if (opts && opts.biff == 2) --npflen;
  var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
  return {
    chKey,
    Name: name,
    itab,
    rgce
  };
}
function parse_ExternSheet(blob, length, opts) {
  if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
  var o2 = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0) o2.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  return o2;
}
function parse_BIFF5ExternSheet(blob, length, opts) {
  if (blob[blob.l + 1] == 3) blob[blob.l]++;
  var o2 = parse_ShortXLUnicodeString(blob, length, opts);
  return o2.charCodeAt(0) == 3 ? o2.slice(1) : o2;
}
function parse_NameCmt(blob, length, opts) {
  if (opts.biff < 8) {
    blob.l += length;
    return;
  }
  var cchName = blob.read_shift(2);
  var cchComment = blob.read_shift(2);
  var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
  var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
  return [name, comment];
}
function parse_ShrFmla(blob, length, opts) {
  var ref = parse_RefU(blob);
  blob.l++;
  var cUse = blob.read_shift(1);
  length -= 8;
  return [parse_SharedParsedFormula(blob, length, opts), cUse, ref];
}
function parse_Array(blob, length, opts) {
  var ref = parse_Ref(blob);
  switch (opts.biff) {
    case 2:
      blob.l++;
      length -= 7;
      break;
    case 3:
    case 4:
      blob.l += 2;
      length -= 8;
      break;
    default:
      blob.l += 6;
      length -= 12;
  }
  return [ref, parse_ArrayParsedFormula(blob, length, opts)];
}
function parse_MTRSettings(blob) {
  var fMTREnabled = blob.read_shift(4) !== 0;
  var fUserSetThreadCount = blob.read_shift(4) !== 0;
  var cUserThreadCount = blob.read_shift(4);
  return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}
function parse_NoteSh(blob, length, opts) {
  if (opts.biff < 8) return;
  var row = blob.read_shift(2), col = blob.read_shift(2);
  var flags = blob.read_shift(2), idObj = blob.read_shift(2);
  var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
  if (opts.biff < 8) blob.read_shift(1);
  return [{ r: row, c: col }, stAuthor, idObj, flags];
}
function parse_Note(blob, length, opts) {
  return parse_NoteSh(blob, length, opts);
}
function parse_MergeCells(blob, length) {
  var merges = [];
  var cmcs = blob.read_shift(2);
  while (cmcs--) merges.push(parse_Ref8U(blob));
  return merges;
}
function parse_Obj(blob, length, opts) {
  if (opts && opts.biff < 8) return parse_BIFF5Obj(blob, length, opts);
  var cmo = parse_FtCmo(blob);
  var fts = parse_FtArray(blob, length - 22, cmo[1]);
  return { cmo, ft: fts };
}
var parse_BIFF5OT = {
  8: function(blob, length) {
    var tgt = blob.l + length;
    blob.l += 10;
    var cf = blob.read_shift(2);
    blob.l += 4;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 4;
    var cchName = blob.read_shift(1);
    blob.l += cchName;
    blob.l = tgt;
    return { fmt: cf };
  }
};
function parse_BIFF5Obj(blob, length, opts) {
  blob.l += 4;
  var ot2 = blob.read_shift(2);
  var id = blob.read_shift(2);
  var grbit = blob.read_shift(2);
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 6;
  length -= 36;
  var fts = [];
  fts.push((parse_BIFF5OT[ot2] || parsenoop)(blob, length, opts));
  return { cmo: [id, ot2, grbit], ft: fts };
}
function parse_TxO(blob, length, opts) {
  var s2 = blob.l;
  var texts = "";
  try {
    blob.l += 4;
    var ot2 = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
    var controlInfo;
    if ([0, 5, 7, 11, 12, 14].indexOf(ot2) == -1) blob.l += 6;
    else controlInfo = parse_ControlInfo(blob, 6, opts);
    var cchText = blob.read_shift(2);
    blob.read_shift(2);
    parseuint16(blob, 2);
    var len = blob.read_shift(2);
    blob.l += len;
    for (var i2 = 1; i2 < blob.lens.length - 1; ++i2) {
      if (blob.l - s2 != blob.lens[i2]) throw new Error("TxO: bad continue record");
      var hdr = blob[blob.l];
      var t3 = parse_XLUnicodeStringNoCch(blob, blob.lens[i2 + 1] - blob.lens[i2] - 1);
      texts += t3;
      if (texts.length >= (hdr ? cchText : 2 * cchText)) break;
    }
    if (texts.length !== cchText && texts.length !== cchText * 2) {
      throw new Error("cchText: " + cchText + " != " + texts.length);
    }
    blob.l = s2 + length;
    return { t: texts };
  } catch (e2) {
    blob.l = s2 + length;
    return { t: texts };
  }
}
function parse_HLink(blob, length) {
  var ref = parse_Ref8U(blob);
  blob.l += 16;
  var hlink = parse_Hyperlink(blob, length - 24);
  return [ref, hlink];
}
function parse_HLinkTooltip(blob, length) {
  blob.read_shift(2);
  var ref = parse_Ref8U(blob);
  var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
  wzTooltip = wzTooltip.replace(chr0, "");
  return [ref, wzTooltip];
}
function parse_Country(blob) {
  var o2 = [0, 0], d2;
  d2 = blob.read_shift(2);
  o2[0] = CountryEnum[d2] || d2;
  d2 = blob.read_shift(2);
  o2[1] = CountryEnum[d2] || d2;
  return o2;
}
function parse_ClrtClient(blob) {
  var ccv = blob.read_shift(2);
  var o2 = [];
  while (ccv-- > 0) o2.push(parse_LongRGB(blob));
  return o2;
}
function parse_Palette(blob) {
  var ccv = blob.read_shift(2);
  var o2 = [];
  while (ccv-- > 0) o2.push(parse_LongRGB(blob));
  return o2;
}
function parse_XFCRC(blob) {
  blob.l += 2;
  var o2 = { cxfs: 0, crc: 0 };
  o2.cxfs = blob.read_shift(2);
  o2.crc = blob.read_shift(4);
  return o2;
}
function parse_ColInfo(blob, length, opts) {
  if (!opts.cellStyles) return parsenoop(blob, length);
  var w2 = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob.read_shift(w2);
  var colLast = blob.read_shift(w2);
  var coldx = blob.read_shift(w2);
  var ixfe = blob.read_shift(w2);
  var flags = blob.read_shift(2);
  if (w2 == 2) blob.l += 2;
  var o2 = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff) o2.level = flags >> 8 & 7;
  return o2;
}
function parse_Setup(blob, length) {
  var o2 = {};
  if (length < 32) return o2;
  blob.l += 16;
  o2.header = parse_Xnum(blob);
  o2.footer = parse_Xnum(blob);
  blob.l += 2;
  return o2;
}
function parse_ShtProps(blob, length, opts) {
  var def = { area: false };
  if (opts.biff != 5) {
    blob.l += length;
    return def;
  }
  var d2 = blob.read_shift(1);
  blob.l += 3;
  if (d2 & 16) def.area = true;
  return def;
}
var parse_Blank = parse_XLSCell;
var parse_Scl = parseuint16a;
var parse_String = parse_XLUnicodeString;
function parse_ImData(blob) {
  var cf = blob.read_shift(2);
  var env = blob.read_shift(2);
  var lcb = blob.read_shift(4);
  var o2 = { fmt: cf, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
  blob.l += lcb;
  return o2;
}
function parse_BIFF2STR(blob, length, opts) {
  if (opts.biffguess && opts.biff == 5) opts.biff = 2;
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var str = parse_XLUnicodeString2(blob, length - 7, opts);
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF2NUM(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = parse_Xnum(blob);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function parse_BIFF2INT(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = blob.read_shift(2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function parse_BIFF2STRING(blob) {
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, "sbcs-cont");
}
function parse_BIFF2FONTXTRA(blob, length) {
  blob.l += 6;
  blob.l += 2;
  blob.l += 1;
  blob.l += 3;
  blob.l += 1;
  blob.l += length - 13;
}
function parse_RString(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  var cch = blob.read_shift(2);
  var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
  blob.l = end;
  cell.t = "str";
  cell.val = str;
  return cell;
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
var DBF = /* @__PURE__ */ (function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  };
  var dbf_reverse_map = evert({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d2 = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d2 = s2a(Base64_decode(buf));
        break;
      case "binary":
        d2 = s2a(buf);
        break;
      case "buffer":
      case "array":
        d2 = buf;
        break;
    }
    prep_blob(d2, 0);
    var ft2 = d2.read_shift(1);
    var memo = !!(ft2 & 136);
    var vfp = false, l7 = false;
    switch (ft2) {
      case 2:
        break;
      // dBASE II
      case 3:
        break;
      // dBASE III
      case 48:
        vfp = true;
        memo = true;
        break;
      // VFP
      case 49:
        vfp = true;
        memo = true;
        break;
      // VFP with autoincrement
      // 0x43 dBASE IV SQL table files
      // 0x63 dBASE IV SQL system files
      case 131:
        break;
      // dBASE III with memo
      case 139:
        break;
      // dBASE IV with memo
      case 140:
        l7 = true;
        break;
      // dBASE Level 7 with memo
      // case 0xCB dBASE IV SQL table files with memo
      case 245:
        break;
      // FoxPro 2.x with memo
      // case 0xFB FoxBASE
      default:
        throw new Error("DBF Unsupported Version: " + ft2.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft2 == 2) nrow = d2.read_shift(2);
    d2.l += 3;
    if (ft2 != 2) nrow = d2.read_shift(4);
    if (nrow > 1048576) nrow = 1e6;
    if (ft2 != 2) fpos = d2.read_shift(2);
    var rlen = d2.read_shift(2);
    var current_cp = opts.codepage || 1252;
    if (ft2 != 2) {
      d2.l += 16;
      d2.read_shift(1);
      if (d2[d2.l] !== 0) current_cp = dbf_codepage_map[d2[d2.l]];
      d2.l += 1;
      d2.l += 2;
    }
    if (l7) d2.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d2.length, ft2 == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d2.l < hend && d2[d2.l] != 13) {
      field = {};
      field.name = $cptable.utils.decode(current_cp, d2.slice(d2.l, d2.l + ww)).replace(/[\u0000\r\n].*$/g, "");
      d2.l += ww;
      field.type = String.fromCharCode(d2.read_shift(1));
      if (ft2 != 2 && !l7) field.offset = d2.read_shift(4);
      field.len = d2.read_shift(1);
      if (ft2 == 2) field.offset = d2.read_shift(2);
      field.dec = d2.read_shift(1);
      if (field.name.length) fields.push(field);
      if (ft2 != 2) d2.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        // General (FoxPro and dBASE L7)
        case "P":
          if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        // Autoincrement (dBASE L7 only)
        case "0":
        // _NullFlags (VFP only)
        case "@":
        // Timestamp (dBASE L7 only)
        case "C":
        // Character (dBASE II)
        case "D":
        // Date (dBASE III)
        case "F":
        // Float (dBASE IV)
        case "I":
        // Long (VFP and dBASE L7)
        case "L":
        // Logical (dBASE II)
        case "M":
        // Memo (dBASE III)
        case "N":
        // Number (dBASE II)
        case "O":
        // Double (dBASE L7 only)
        case "T":
        // Datetime (VFP only)
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d2[d2.l] !== 13) d2.l = fpos - 1;
    if (d2.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d2.l + " " + d2[d2.l]);
    d2.l = fpos;
    var R2 = 0, C2 = 0;
    out[0] = [];
    for (C2 = 0; C2 != fields.length; ++C2) out[0][C2] = fields[C2].name;
    while (nrow-- > 0) {
      if (d2[d2.l] === 42) {
        d2.l += rlen;
        continue;
      }
      ++d2.l;
      out[++R2] = [];
      C2 = 0;
      for (C2 = 0; C2 != fields.length; ++C2) {
        var dd = d2.slice(d2.l, d2.l + fields[C2].len);
        d2.l += fields[C2].len;
        prep_blob(dd, 0);
        var s2 = $cptable.utils.decode(current_cp, dd);
        switch (fields[C2].type) {
          case "C":
            if (s2.trim().length) out[R2][C2] = s2.replace(/\s+$/, "");
            break;
          case "D":
            if (s2.length === 8) out[R2][C2] = new Date(+s2.slice(0, 4), +s2.slice(4, 6) - 1, +s2.slice(6, 8));
            else out[R2][C2] = s2;
            break;
          case "F":
            out[R2][C2] = parseFloat(s2.trim());
            break;
          case "+":
          case "I":
            out[R2][C2] = l7 ? dd.read_shift(-4, "i") ^ 2147483648 : dd.read_shift(4, "i");
            break;
          case "L":
            switch (s2.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R2][C2] = true;
                break;
              case "N":
              case "F":
                out[R2][C2] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s2 + "|");
            }
            break;
          case "M":
            if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft2.toString(16));
            out[R2][C2] = "##MEMO##" + (l7 ? parseInt(s2.trim(), 10) : dd.read_shift(4));
            break;
          case "N":
            s2 = s2.replace(/\u0000/g, "").trim();
            if (s2 && s2 != ".") out[R2][C2] = +s2 || 0;
            break;
          case "@":
            out[R2][C2] = new Date(dd.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            out[R2][C2] = new Date((dd.read_shift(4) - 2440588) * 864e5 + dd.read_shift(4));
            break;
          case "Y":
            out[R2][C2] = dd.read_shift(4, "i") / 1e4 + dd.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R2][C2] = -dd.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C2].len == 8) {
              out[R2][C2] = dd.read_shift(8, "f");
              break;
            }
          /* falls through */
          case "G":
          case "P":
            dd.l += fields[C2].len;
            break;
          case "0":
            if (fields[C2].name === "_NullFlags") break;
          /* falls through */
          default:
            throw new Error("DBF Unsupported data type " + fields[C2].type);
        }
      }
    }
    if (ft2 != 2) {
      if (d2.l < d2.length && d2[d2.l++] != 26) throw new Error("DBF EOF Marker missing " + (d2.l - 1) + " of " + d2.length + " " + d2[d2.l - 1].toString(16));
    }
    if (opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  function dbf_to_sheet(buf, opts) {
    var o2 = opts || {};
    if (!o2.dateNF) o2.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o2), o2);
    ws["!cols"] = o2.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o2.DBF;
    return ws;
  }
  function dbf_to_workbook(buf, opts) {
    try {
      return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
    } catch (e2) {
      if (opts && opts.WTF) throw e2;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i2 = 0, j2 = 0, hcnt = 0, rlen = 1;
    for (i2 = 0; i2 < headers.length; ++i2) {
      if (((cols[i2] || {}).DBF || {}).name) {
        headers[i2] = cols[i2].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i2] == null) continue;
      ++hcnt;
      if (typeof headers[i2] === "number") headers[i2] = headers[i2].toString(10);
      if (typeof headers[i2] !== "string") throw new Error("DBF Invalid column name " + headers[i2] + " |" + typeof headers[i2] + "|");
      if (headers.indexOf(headers[i2]) !== i2) {
        for (j2 = 0; j2 < 1024; ++j2)
          if (headers.indexOf(headers[i2] + "_" + j2) == -1) {
            headers[i2] += "_" + j2;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i2 = 0; i2 <= range.e.c - range.s.c; ++i2) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j2 = 0; j2 < data.length; ++j2) {
        if (data[j2][i2] != null) col.push(data[j2][i2]);
      }
      if (col.length == 0 || headers[i2] == null) {
        coltypes[i2] = "?";
        continue;
      }
      for (j2 = 0; j2 < col.length; ++j2) {
        switch (typeof col[j2]) {
          /* TODO: check if L2 compat is desired */
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j2] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j2]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250) maxlen = 250;
      _guess = ((cols[i2] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i2].DBF.len > maxlen) maxlen = cols[i2].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i2] = cols[i2].DBF.dec;
        maxlen = cols[i2].DBF.len;
      }
      colwidths[i2] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i2];
      coltypes[i2] = guess;
    }
    var h2 = ba.next(32);
    h2.write_shift(4, 318902576);
    h2.write_shift(4, data.length);
    h2.write_shift(2, 296 + 32 * hcnt);
    h2.write_shift(2, rlen);
    for (i2 = 0; i2 < 4; ++i2) h2.write_shift(4, 0);
    h2.write_shift(4, 0 | (+dbf_reverse_map[
      /*::String(*/
      current_ansi
      /*::)*/
    ] || 3) << 8);
    for (i2 = 0, j2 = 0; i2 < headers.length; ++i2) {
      if (headers[i2] == null) continue;
      var hf = ba.next(32);
      var _f = (headers[i2].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i2] == "?" ? "C" : coltypes[i2], "sbcs");
      hf.write_shift(4, j2);
      hf.write_shift(1, colwidths[i2] || _RLEN[coltypes[i2]] || 0);
      hf.write_shift(1, coldecimals[i2] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j2 += colwidths[i2] || _RLEN[coltypes[i2]] || 0;
    }
    var hb = ba.next(264);
    hb.write_shift(4, 13);
    for (i2 = 0; i2 < 65; ++i2) hb.write_shift(4, 0);
    for (i2 = 0; i2 < data.length; ++i2) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j2 = 0; j2 < headers.length; ++j2) {
        if (headers[j2] == null) continue;
        switch (coltypes[j2]) {
          case "L":
            rout.write_shift(1, data[i2][j2] == null ? 63 : data[i2][j2] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i2][j2] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i2][j2] == "number") _n = data[i2][j2].toFixed(coldecimals[j2] || 0);
            for (hcnt = 0; hcnt < colwidths[j2] - _n.length; ++hcnt) rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i2][j2]) rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i2][j2].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i2][j2].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i2][j2].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _s = String(data[i2][j2] != null ? data[i2][j2] : "").slice(0, colwidths[j2]);
            rout.write_shift(1, _s, "sbcs");
            for (hcnt = 0; hcnt < colwidths[j2] - _s.length; ++hcnt) rout.write_shift(1, 32);
            break;
        }
      }
    }
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
})();
var SYLK = /* @__PURE__ */ (function() {
  var sylk_escapes = {
    AA: "Ã",
    BA: "Ã",
    CA: "Ã",
    DA: 195,
    HA: "Ã",
    JA: 197,
    AE: "Ã",
    BE: "Ã",
    CE: "Ã",
    HE: "Ã",
    AI: "Ã",
    BI: "Ã",
    CI: "Ã",
    HI: "Ã",
    AO: "Ã",
    BO: "Ã",
    CO: "Ã",
    DO: 213,
    HO: "Ã",
    AU: "Ã",
    BU: "Ã",
    CU: "Ã",
    HU: "Ã",
    Aa: "Ã ",
    Ba: "Ã¡",
    Ca: "Ã¢",
    Da: 227,
    Ha: "Ã¤",
    Ja: 229,
    Ae: "Ã¨",
    Be: "Ã©",
    Ce: "Ãª",
    He: "Ã«",
    Ai: "Ã¬",
    Bi: "Ã­",
    Ci: "Ã®",
    Hi: "Ã¯",
    Ao: "Ã²",
    Bo: "Ã³",
    Co: "Ã´",
    Do: 245,
    Ho: "Ã¶",
    Au: "Ã¹",
    Bu: "Ãº",
    Cu: "Ã»",
    Hu: "Ã¼",
    KC: "Ã",
    Kc: "Ã§",
    q: "Ã¦",
    z: "Å",
    a: "Ã",
    j: "Å",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  var sylk_char_fn = function(_2, $1) {
    var o2 = sylk_escapes[$1];
    return typeof o2 == "number" ? _getansi(o2) : o2;
  };
  var decode_sylk_char = function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  };
  sylk_escapes["|"] = 254;
  function sylk_to_aoa(d2, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d2), opts);
      case "binary":
        return sylk_to_aoa_str(d2, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R2 = -1, C2 = -1, ri = 0, rj = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j2;
    if (+opts.codepage >= 0) set_cp(+opts.codepage);
    for (; ri !== records.length; ++ri) {
      Mval = 0;
      var rstr = records[ri].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x2) {
        return x2.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0) switch (RT) {
        case "ID":
          break;
        /* header */
        case "E":
          break;
        /* EOF */
        case "B":
          break;
        /* dimensions */
        case "O":
          break;
        /* options? */
        case "W":
          break;
        /* window? */
        case "P":
          if (record[1].charAt(0) == "P")
            formats.push(rstr.slice(3).replace(/;;/g, ";"));
          break;
        case "C":
          var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
          for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
            case "A":
              break;
            // TODO: comment
            case "X":
              C2 = parseInt(record[rj].slice(1)) - 1;
              C_seen_X = true;
              break;
            case "Y":
              R2 = parseInt(record[rj].slice(1)) - 1;
              if (!C_seen_X) C2 = 0;
              for (j2 = arr.length; j2 <= R2; ++j2) arr[j2] = [];
              break;
            case "K":
              val = record[rj].slice(1);
              if (val.charAt(0) === '"') val = val.slice(1, val.length - 1);
              else if (val === "TRUE") val = true;
              else if (val === "FALSE") val = false;
              else if (!isNaN(fuzzynum(val))) {
                val = fuzzynum(val);
                if (next_cell_format !== null && fmt_is_date(next_cell_format)) val = numdate(val);
              } else if (!isNaN(fuzzydate(val).getDate())) {
                val = parseDate(val);
              }
              C_seen_K = true;
              break;
            case "E":
              C_seen_E = true;
              var formula = rc_to_a1(record[rj].slice(1), { r: R2, c: C2 });
              arr[R2][C2] = [arr[R2][C2], formula];
              break;
            case "S":
              C_seen_S = true;
              arr[R2][C2] = [arr[R2][C2], "S5S"];
              break;
            case "G":
              break;
            // unknown
            case "R":
              _R = parseInt(record[rj].slice(1)) - 1;
              break;
            case "C":
              _C = parseInt(record[rj].slice(1)) - 1;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (C_seen_K) {
            if (arr[R2][C2] && arr[R2][C2].length == 2) arr[R2][C2][0] = val;
            else arr[R2][C2] = val;
            next_cell_format = null;
          }
          if (C_seen_S) {
            if (C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
            var shrbase = _R > -1 && arr[_R][_C];
            if (!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
            arr[R2][C2][1] = shift_formula_str(shrbase[1], { r: R2 - _R, c: C2 - _C });
          }
          break;
        case "F":
          var F_seen = 0;
          for (rj = 1; rj < record.length; ++rj) switch (record[rj].charAt(0)) {
            case "X":
              C2 = parseInt(record[rj].slice(1)) - 1;
              ++F_seen;
              break;
            case "Y":
              R2 = parseInt(record[rj].slice(1)) - 1;
              for (j2 = arr.length; j2 <= R2; ++j2) arr[j2] = [];
              break;
            case "M":
              Mval = parseInt(record[rj].slice(1)) / 20;
              break;
            case "F":
              break;
            /* ??? */
            case "G":
              break;
            /* hide grid */
            case "P":
              next_cell_format = formats[parseInt(record[rj].slice(1))];
              break;
            case "S":
              break;
            /* cell style */
            case "D":
              break;
            /* column */
            case "N":
              break;
            /* font */
            case "W":
              cw = record[rj].slice(1).split(" ");
              for (j2 = parseInt(cw[0], 10); j2 <= parseInt(cw[1], 10); ++j2) {
                Mval = parseInt(cw[2], 10);
                colinfo[j2 - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                process_col(colinfo[j2 - 1]);
              }
              break;
            case "C":
              C2 = parseInt(record[rj].slice(1)) - 1;
              if (!colinfo[C2]) colinfo[C2] = {};
              break;
            case "R":
              R2 = parseInt(record[rj].slice(1)) - 1;
              if (!rowinfo[R2]) rowinfo[R2] = {};
              if (Mval > 0) {
                rowinfo[R2].hpt = Mval;
                rowinfo[R2].hpx = pt2px(Mval);
              } else if (Mval === 0) rowinfo[R2].hidden = true;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (F_seen < 1) next_cell_format = null;
          break;
        default:
          if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
      }
    }
    if (rowinfo.length > 0) sht["!rows"] = rowinfo;
    if (colinfo.length > 0) sht["!cols"] = colinfo;
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return [arr, sht];
  }
  function sylk_to_sheet(d2, opts) {
    var aoasht = sylk_to_aoa(d2, opts);
    var aoa = aoasht[0], ws = aoasht[1];
    var o2 = aoa_to_sheet(aoa, opts);
    keys(ws).forEach(function(k2) {
      o2[k2] = ws[k2];
    });
    return o2;
  }
  function sylk_to_workbook(d2, opts) {
    return sheet_to_workbook(sylk_to_sheet(d2, opts), opts);
  }
  function write_ws_cell_sylk(cell, ws, R2, C2) {
    var o2 = "C;Y" + (R2 + 1) + ";X" + (C2 + 1) + ";K";
    switch (cell.t) {
      case "n":
        o2 += cell.v || 0;
        if (cell.f && !cell.F) o2 += ";E" + a1_to_rc(cell.f, { r: R2, c: C2 });
        break;
      case "b":
        o2 += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o2 += cell.w || cell.v;
        break;
      case "d":
        o2 += '"' + (cell.w || cell.v) + '"';
        break;
      case "s":
        o2 += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o2;
  }
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i2) {
      var rec = "F;W" + (i2 + 1) + " " + (i2 + 1) + " ";
      if (col.hidden) rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx) col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch) col.wch = px2char(col.wpx);
        if (typeof col.wch == "number") rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ") out.push(rec);
    });
  }
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i2) {
      var rec = "F;";
      if (row.hidden) rec += "M0;";
      else if (row.hpt) rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2) out.push(rec + "R" + (i2 + 1));
    });
  }
  function sheet_to_sylk(ws, opts) {
    var preamble = ["ID;PWXL;N;E"], o2 = [];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    var RS = "\r\n";
    preamble.push("P;PGeneral");
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
    preamble.push("B;Y" + (r2.e.r - r2.s.r + 1) + ";X" + (r2.e.c - r2.s.c + 1) + ";D" + [r2.s.c, r2.s.r, r2.e.c, r2.e.r].join(" "));
    for (var R2 = r2.s.r; R2 <= r2.e.r; ++R2) {
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
        o2.push(write_ws_cell_sylk(cell, ws, R2, C2));
      }
    }
    return preamble.join(RS) + RS + o2.join(RS) + RS + "E" + RS;
  }
  return {
    to_workbook: sylk_to_workbook,
    to_sheet: sylk_to_sheet,
    from_sheet: sheet_to_sylk
  };
})();
var DIF = /* @__PURE__ */ (function() {
  function dif_to_aoa(d2, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d2), opts);
      case "binary":
        return dif_to_aoa_str(d2, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R2 = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      if (records[ri].trim() === "BOT") {
        arr[++R2] = [];
        C2 = 0;
        continue;
      }
      if (R2 < 0) continue;
      var metadata = records[ri].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri;
      var data = records[ri] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri < records.length - 1) data += "\n" + records[++ri];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R2] = [];
            C2 = 0;
            continue;
          } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE") arr[R2][C2] = true;
          else if (data === "FALSE") arr[R2][C2] = false;
          else if (!isNaN(fuzzynum(value))) arr[R2][C2] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate())) arr[R2][C2] = parseDate(value);
          else arr[R2][C2] = value;
          ++C2;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/)) data = data.slice(2, -1);
          arr[R2][C2++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD") break;
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  function dif_to_workbook(str, opts) {
    return sheet_to_workbook(dif_to_sheet(str, opts), opts);
  }
  var sheet_to_dif = /* @__PURE__ */ (function() {
    var push_field = function pf(o2, topic, v2, n2, s2) {
      o2.push(topic);
      o2.push(v2 + "," + n2);
      o2.push('"' + s2.replace(/"/g, '""') + '"');
    };
    var push_value = function po(o2, type, v2, s2) {
      o2.push(type + "," + v2);
      o2.push(type == 1 ? '"' + s2.replace(/"/g, '""') + '"' : s2);
    };
    return function sheet_to_dif2(ws) {
      var o2 = [];
      var r2 = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      push_field(o2, "TABLE", 0, 1, "sheetjs");
      push_field(o2, "VECTORS", 0, r2.e.r - r2.s.r + 1, "");
      push_field(o2, "TUPLES", 0, r2.e.c - r2.s.c + 1, "");
      push_field(o2, "DATA", 0, 0, "");
      for (var R2 = r2.s.r; R2 <= r2.e.r; ++R2) {
        push_value(o2, -1, 0, "BOT");
        for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
          var coord = encode_cell({ r: R2, c: C2 });
          cell = dense ? (ws[R2] || [])[C2] : ws[coord];
          if (!cell) {
            push_value(o2, 1, 0, "");
            continue;
          }
          switch (cell.t) {
            case "n":
              var val = cell.w;
              if (!val && cell.v != null) val = cell.v;
              if (val == null) {
                if (cell.f && !cell.F) push_value(o2, 1, 0, "=" + cell.f);
                else push_value(o2, 1, 0, "");
              } else push_value(o2, 0, val, "V");
              break;
            case "b":
              push_value(o2, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
              break;
            case "s":
              push_value(o2, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
              break;
            case "d":
              if (!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
              push_value(o2, 0, cell.w, "V");
              break;
            default:
              push_value(o2, 1, 0, "");
          }
        }
      }
      push_value(o2, -1, 0, "EOD");
      var RS = "\r\n";
      var oo = o2.join(RS);
      return oo;
    };
  })();
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
})();
var ETH = /* @__PURE__ */ (function() {
  function decode2(s2) {
    return s2.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  function encode2(s2) {
    return s2.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R2 = -1, C2 = -1, ri = 0, arr = [];
    for (; ri !== records.length; ++ri) {
      var record = records[ri].trim().split(":");
      if (record[0] !== "cell") continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R2 = arr.length; R2 <= addr.r; ++R2) if (!arr[R2]) arr[R2] = [];
      }
      R2 = addr.r;
      C2 = addr.c;
      switch (record[2]) {
        case "t":
          arr[R2][C2] = decode2(record[3]);
          break;
        case "v":
          arr[R2][C2] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        /* falls through */
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R2][C2] = +record[4] ? true : false;
              break;
            default:
              arr[R2][C2] = +record[4];
              break;
          }
          if (record[2] == "vtf") arr[R2][C2] = [arr[R2][C2], _f];
      }
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function eth_to_sheet(d2, opts) {
    return aoa_to_sheet(eth_to_aoa(d2, opts), opts);
  }
  function eth_to_workbook(d2, opts) {
    return sheet_to_workbook(eth_to_sheet(d2, opts), opts);
  }
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"]) return "";
    var o2 = [], oo = [], cell, coord = "";
    var r2 = decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    for (var R2 = r2.s.r; R2 <= r2.e.r; ++R2) {
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z") continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode2(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode2(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode2(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t3 = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t3;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t3);
            break;
          case "e":
            continue;
        }
        o2.push(oo.join(":"));
      }
    }
    o2.push("sheet:c:" + (r2.e.c - r2.s.c + 1) + ":r:" + (r2.e.r - r2.s.r + 1) + ":tvf:1");
    o2.push("valueformat:1:text-wiki");
    return o2.join("\n");
  }
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
})();
var PRN = /* @__PURE__ */ (function() {
  function set_text_arr(data, arr, R2, C2, o2) {
    if (o2.raw) arr[R2][C2] = data;
    else if (data === "") ;
    else if (data === "TRUE") arr[R2][C2] = true;
    else if (data === "FALSE") arr[R2][C2] = false;
    else if (!isNaN(fuzzynum(data))) arr[R2][C2] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate())) arr[R2][C2] = parseDate(data);
    else arr[R2][C2] = data;
  }
  function prn_to_aoa_str(f2, opts) {
    var o2 = opts || {};
    var arr = [];
    if (!f2 || f2.length === 0) return arr;
    var lines = f2.split(/[\r\n]/);
    var L2 = lines.length - 1;
    while (L2 >= 0 && lines[L2].length === 0) --L2;
    var start = 10, idx = 0;
    var R2 = 0;
    for (; R2 <= L2; ++R2) {
      idx = lines[R2].indexOf(" ");
      if (idx == -1) idx = lines[R2].length;
      else idx++;
      start = Math.max(start, idx);
    }
    for (R2 = 0; R2 <= L2; ++R2) {
      arr[R2] = [];
      var C2 = 0;
      set_text_arr(lines[R2].slice(0, start).trim(), arr, R2, C2, o2);
      for (C2 = 1; C2 <= (lines[R2].length - start) / 10 + 1; ++C2)
        set_text_arr(lines[R2].slice(start + (C2 - 1) * 10, start + C2 * 10).trim(), arr, R2, C2, o2);
    }
    if (o2.sheetRows) arr = arr.slice(0, o2.sheetRows);
    return arr;
  }
  var guess_seps = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  };
  var guess_sep_weights = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc = 0;
    for (; end < str.length; ++end) {
      if ((cc = str.charCodeAt(end)) == 34) instr = !instr;
      else if (!instr && cc in guess_seps) cnt[cc] = (cnt[cc] || 0) + 1;
    }
    cc = [];
    for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
      cc.push([cnt[end], end]);
    }
    if (!cc.length) {
      cnt = guess_sep_weights;
      for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc.push([cnt[end], end]);
      }
    }
    cc.sort(function(a2, b2) {
      return a2[0] - b2[0] || guess_sep_weights[a2[1]] - guess_sep_weights[b2[1]];
    });
    return guess_seps[cc.pop()[1]] || 44;
  }
  function dsv_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var sep = "";
    var ws = o2.dense ? [] : {};
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else sep = guess_sep(str.slice(0, 1024));
    } else if (o2 && o2.FS) sep = o2.FS;
    else sep = guess_sep(str.slice(0, 1024));
    var R2 = 0, C2 = 0, v2 = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc = 0, startcc = str.charCodeAt(0);
    str = str.replace(/\r\n/mg, "\n");
    var _re = o2.dateNF != null ? dateNF_regex(o2.dateNF) : null;
    function finish_cell() {
      var s2 = str.slice(start, end);
      var cell = {};
      if (s2.charAt(0) == '"' && s2.charAt(s2.length - 1) == '"') s2 = s2.slice(1, -1).replace(/""/g, '"');
      if (s2.length === 0) cell.t = "z";
      else if (o2.raw) {
        cell.t = "s";
        cell.v = s2;
      } else if (s2.trim().length === 0) {
        cell.t = "s";
        cell.v = s2;
      } else if (s2.charCodeAt(0) == 61) {
        if (s2.charCodeAt(1) == 34 && s2.charCodeAt(s2.length - 1) == 34) {
          cell.t = "s";
          cell.v = s2.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s2)) {
          cell.t = "n";
          cell.f = s2.slice(1);
        } else {
          cell.t = "s";
          cell.v = s2;
        }
      } else if (s2 == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s2 == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v2 = fuzzynum(s2))) {
        cell.t = "n";
        if (o2.cellText !== false) cell.w = s2;
        cell.v = v2;
      } else if (!isNaN(fuzzydate(s2).getDate()) || _re && s2.match(_re)) {
        cell.z = o2.dateNF || table_fmt[14];
        var k2 = 0;
        if (_re && s2.match(_re)) {
          s2 = dateNF_fix(s2, o2.dateNF, s2.match(_re) || []);
          k2 = 1;
        }
        if (o2.cellDates) {
          cell.t = "d";
          cell.v = parseDate(s2, k2);
        } else {
          cell.t = "n";
          cell.v = datenum(parseDate(s2, k2));
        }
        if (o2.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
        if (!o2.cellNF) delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s2;
      }
      if (cell.t == "z") ;
      else if (o2.dense) {
        if (!ws[R2]) ws[R2] = [];
        ws[R2][C2] = cell;
      } else ws[encode_cell({ c: C2, r: R2 })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C2) range.e.c = C2;
      if (range.e.r < R2) range.e.r = R2;
      if (cc == sepcc) ++C2;
      else {
        C2 = 0;
        ++R2;
        if (o2.sheetRows && o2.sheetRows <= R2) return true;
      }
    }
    outer: for (; end < str.length; ++end) switch (cc = str.charCodeAt(end)) {
      case 34:
        if (startcc === 34) instr = !instr;
        break;
      case sepcc:
      case 10:
      case 13:
        if (!instr && finish_cell()) break outer;
        break;
    }
    if (end - start > 0) finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
    if (opts.FS) return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  function prn_to_sheet(d2, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d2, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d2);
        break;
      case "binary":
        str = d2;
        break;
      case "buffer":
        if (opts.codepage == 65001) str = d2.toString("utf8");
        else if (opts.codepage && typeof $cptable !== "undefined") ;
        else str = has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2);
        break;
      case "array":
        str = cc2str(d2);
        break;
      case "string":
        str = d2;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001) str = utf8read(str);
    else if (opts.type == "binary" && typeof $cptable !== "undefined") ;
    if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  function prn_to_workbook(d2, opts) {
    return sheet_to_workbook(prn_to_sheet(d2, opts), opts);
  }
  function sheet_to_prn(ws) {
    var o2 = [];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R2 = r2.s.r; R2 <= r2.e.r; ++R2) {
      var oo = [];
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w2 = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w2.length < 10) w2 += " ";
        oo.push(w2 + (C2 === 0 ? " " : ""));
      }
      o2.push(oo.join(""));
    }
    return o2.join("\n");
  }
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
})();
function read_wb_ID(d2, opts) {
  var o2 = opts || {}, OLD_WTF = !!o2.WTF;
  o2.WTF = true;
  try {
    var out = SYLK.to_workbook(d2, o2);
    o2.WTF = OLD_WTF;
    return out;
  } catch (e2) {
    o2.WTF = OLD_WTF;
    if (!e2.message.match(/SYLK bad record ID/) && OLD_WTF) throw e2;
    return PRN.to_workbook(d2, opts);
  }
}
var WK_ = /* @__PURE__ */ (function() {
  function lotushopper(data, cb, opts) {
    if (!data) return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R2 = Enum[RT] || Enum[65535];
      var length = data.read_shift(2);
      var tgt = data.l + length;
      var d2 = R2.f && R2.f(data, length, opts);
      data.l = tgt;
      if (cb(d2, R2, RT)) return;
    }
  }
  function lotus_to_workbook(d2, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d2)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d2), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d2, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  function lotus_to_workbook_buf(d2, opts) {
    if (!d2) return d2;
    var o2 = opts || {};
    var s2 = o2.dense ? [] : {}, n2 = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o2.sheetRows || 0;
    if (d2[2] == 0) {
      if (d2[3] == 8 || d2[3] == 9) {
        if (d2.length >= 16 && d2[14] == 5 && d2[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d2[2] == 2) {
      o2.Enum = WK1Enum;
      lotushopper(d2, function(val, R2, RT) {
        switch (RT) {
          case 0:
            o2.vers = val;
            if (val >= 4096) o2.qpro = true;
            break;
          case 6:
            refguess = val;
            break;
          /* RANGE */
          case 204:
            if (val) next_n = val;
            break;
          /* SHEETNAMECS */
          case 222:
            next_n = val;
            break;
          /* SHEETNAMELP */
          case 15:
          /* LABEL */
          case 51:
            if (!o2.qpro) val[1].v = val[1].v.slice(1);
          /* falls through */
          case 13:
          /* INTEGER */
          case 14:
          /* NUMBER */
          case 16:
            if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o2.dateNF || table_fmt[14];
              if (o2.cellDates) {
                val[1].t = "d";
                val[1].v = numdate(val[1].v);
              }
            }
            if (o2.qpro) {
              if (val[3] > sidx) {
                s2["!ref"] = encode_range(refguess);
                sheets[n2] = s2;
                snames.push(n2);
                s2 = o2.dense ? [] : {};
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n2 = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o2.dense ? (s2[val[0].r] || [])[val[0].c] : s2[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null) tmpcell.z = val[1].z;
              if (val[1].f != null) tmpcell.f = val[1].f;
              break;
            }
            if (o2.dense) {
              if (!s2[val[0].r]) s2[val[0].r] = [];
              s2[val[0].r][val[0].c] = val[1];
            } else s2[encode_cell(val[0])] = val[1];
            break;
        }
      }, o2);
    } else if (d2[2] == 26 || d2[2] == 14) {
      o2.Enum = WK3Enum;
      if (d2[2] == 14) {
        o2.qpro = true;
        d2.l = 0;
      }
      lotushopper(d2, function(val, R2, RT) {
        switch (RT) {
          case 204:
            n2 = val;
            break;
          /* SHEETNAMECS */
          case 22:
            val[1].v = val[1].v.slice(1);
          /* falls through */
          case 23:
          /* NUMBER17 */
          case 24:
          /* NUMBER18 */
          case 25:
          /* FORMULA19 */
          case 37:
          /* NUMBER25 */
          case 39:
          /* NUMBER27 */
          case 40:
            if (val[3] > sidx) {
              s2["!ref"] = encode_range(refguess);
              sheets[n2] = s2;
              snames.push(n2);
              s2 = o2.dense ? [] : {};
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n2 = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows) break;
            if (o2.dense) {
              if (!s2[val[0].r]) s2[val[0].r] = [];
              s2[val[0].r][val[0].c] = val[1];
            } else s2[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c) refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r) refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3]) realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx) n2 = val[1];
            break;
        }
      }, o2);
    } else throw new Error("Unrecognized LOTUS BOF " + d2[2]);
    s2["!ref"] = encode_range(refguess);
    sheets[next_n || n2] = s2;
    snames.push(next_n || n2);
    if (!realnames.length) return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i2 = 0; i2 < realnames.length; ++i2) if (sheets[snames[i2]]) {
      rnames.push(realnames[i2] || snames[i2]);
      osheets[realnames[i2]] = sheets[realnames[i2]] || sheets[snames[i2]];
    } else {
      rnames.push(realnames[i2]);
      osheets[realnames[i2]] = { "!ref": "A1" };
    }
    return { SheetNames: rnames, Sheets: osheets };
  }
  function sheet_to_wk1(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    var range = safe_decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var R2 = range.s.r; R2 <= max_R; ++R2) {
      var rr = encode_row(R2);
      for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
        if (R2 === range.s.r) cols[C2] = encode_col(C2);
        var ref = cols[C2] + rr;
        var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
        if (!cell || cell.t == "z") continue;
        if (cell.t == "n") {
          if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 13, write_INTEGER(R2, C2, cell.v));
          else write_biff_rec(ba, 14, write_NUMBER(R2, C2, cell.v));
        } else {
          var str = format_cell(cell);
          write_biff_rec(ba, 15, write_LABEL(R2, C2, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function book_to_wk3(wb, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb));
    for (var i2 = 0, cnt = 0; i2 < wb.SheetNames.length; ++i2) if ((wb.Sheets[wb.SheetNames[i2]] || {})["!ref"]) write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb.SheetNames[i2], cnt++));
    var wsidx = 0;
    for (i2 = 0; i2 < wb.SheetNames.length; ++i2) {
      var ws = wb.Sheets[wb.SheetNames[i2]];
      if (!ws || !ws["!ref"]) continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R2 = range.s.r; R2 <= max_R; ++R2) {
        var rr = encode_row(R2);
        for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
          if (R2 === range.s.r) cols[C2] = encode_col(C2);
          var ref = cols[C2] + rr;
          var cell = dense ? (ws[R2] || [])[C2] : ws[ref];
          if (!cell || cell.t == "z") continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R2, C2, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R2, C2, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function write_BOF_WK1(v2) {
    var out = new_buf(2);
    out.write_shift(2, v2);
    return out;
  }
  function write_BOF_WK3(wb) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i2 = 0; i2 < wb.SheetNames.length; ++i2) {
      var name = wb.SheetNames[i2];
      var ws = wb.Sheets[name];
      if (!ws || !ws["!ref"]) continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r) rows = range.e.r;
      if (cols < range.e.c) cols = range.e.c;
    }
    if (rows > 8191) rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  function parse_RANGE(blob, length, opts) {
    var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length == 8 && opts.qpro) {
      o2.s.c = blob.read_shift(1);
      blob.l++;
      o2.s.r = blob.read_shift(2);
      o2.e.c = blob.read_shift(1);
      blob.l++;
      o2.e.r = blob.read_shift(2);
      return o2;
    }
    o2.s.c = blob.read_shift(2);
    o2.s.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    o2.e.c = blob.read_shift(2);
    o2.e.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    if (o2.s.c == 65535) o2.s.c = o2.e.c = o2.s.r = o2.e.r = 0;
    return o2;
  }
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  function parse_cell(blob, length, opts) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o2[0].c = blob.read_shift(1);
      o2[3] = blob.read_shift(1);
      o2[0].r = blob.read_shift(2);
      blob.l += 2;
    } else {
      o2[2] = blob.read_shift(1);
      o2[0].c = blob.read_shift(2);
      o2[0].r = blob.read_shift(2);
    }
    return o2;
  }
  function parse_LABEL(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].t = "s";
    if (opts.vers == 20768) {
      blob.l++;
      var len = blob.read_shift(1);
      o2[1].v = blob.read_shift(len, "utf8");
      return o2;
    }
    if (opts.qpro) blob.l++;
    o2[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o2;
  }
  function write_LABEL(R2, C2, s2) {
    var o2 = new_buf(7 + s2.length);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(1, 39);
    for (var i2 = 0; i2 < o2.length; ++i2) {
      var cc = s2.charCodeAt(i2);
      o2.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  function parse_INTEGER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(2, "i");
    return o2;
  }
  function write_INTEGER(R2, C2, v2) {
    var o2 = new_buf(7);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(2, v2, "i");
    return o2;
  }
  function parse_NUMBER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    return o2;
  }
  function write_NUMBER(R2, C2, v2) {
    var o2 = new_buf(13);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R2);
    o2.write_shift(8, v2, "f");
    return o2;
  }
  function parse_FORMULA(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    if (opts.qpro) blob.l = tgt;
    else {
      var flen = blob.read_shift(2);
      wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o2);
      blob.l += flen;
    }
    return o2;
  }
  function wk1_parse_rc(B3, V2, col) {
    var rel = V2 & 32768;
    V2 &= -32769;
    V2 = (rel ? B3 : 0) + (V2 >= 8192 ? V2 - 16384 : V2);
    return (rel ? "" : "$") + (col ? encode_col(V2) : encode_row(V2));
  }
  var FuncTab = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob, o2) {
    prep_blob(blob, 0);
    var out = [], argc = 0, R2 = "", C2 = "", argL = "", argR = "";
    while (blob.l < blob.length) {
      var cc = blob[blob.l++];
      switch (cc) {
        case 0:
          out.push(blob.read_shift(8, "f"));
          break;
        case 1:
          {
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(C2 + R2);
          }
          break;
        case 2:
          {
            var c2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            var r2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(c2 + r2 + ":" + C2 + R2);
          }
          break;
        case 3:
          if (blob.l < blob.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob.read_shift(2));
          break;
        case 6:
          {
            var Z2 = "";
            while (cc = blob[blob.l++]) Z2 += String.fromCharCode(cc);
            out.push('"' + Z2.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc < 32 && BinOpTab[cc]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc] + argR);
          } else if (FuncTab[cc]) {
            argc = FuncTab[cc][1];
            if (argc == 69) argc = blob[blob.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc][0] + "(" + args.join(",") + ")");
          } else if (cc <= 7) return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 24) return console.error("WK1 unsupported op " + cc.toString(16));
          else if (cc <= 30) return console.error("WK1 invalid opcode " + cc.toString(16));
          else if (cc <= 115) return console.error("WK1 unsupported function opcode " + cc.toString(16));
          else return console.error("WK1 unrecognized opcode " + cc.toString(16));
      }
    }
    if (out.length == 1) o2[1].f = "" + out[0];
    else console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  function parse_cell_3(blob) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o2[0].r = blob.read_shift(2);
    o2[3] = blob[blob.l++];
    o2[0].c = blob[blob.l++];
    return o2;
  }
  function parse_LABEL_16(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].t = "s";
    o2[1].v = blob.read_shift(length - 4, "cstr");
    return o2;
  }
  function write_LABEL_16(R2, C2, wsidx, s2) {
    var o2 = new_buf(6 + s2.length);
    o2.write_shift(2, R2);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    o2.write_shift(1, 39);
    for (var i2 = 0; i2 < s2.length; ++i2) {
      var cc = s2.charCodeAt(i2);
      o2.write_shift(1, cc >= 128 ? 95 : cc);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  function parse_NUMBER_18(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].v = blob.read_shift(2);
    var v2 = o2[1].v >> 1;
    if (o2[1].v & 1) {
      switch (v2 & 7) {
        case 0:
          v2 = (v2 >> 3) * 5e3;
          break;
        case 1:
          v2 = (v2 >> 3) * 500;
          break;
        case 2:
          v2 = (v2 >> 3) / 20;
          break;
        case 3:
          v2 = (v2 >> 3) / 200;
          break;
        case 4:
          v2 = (v2 >> 3) / 2e3;
          break;
        case 5:
          v2 = (v2 >> 3) / 2e4;
          break;
        case 6:
          v2 = (v2 >> 3) / 16;
          break;
        case 7:
          v2 = (v2 >> 3) / 64;
          break;
      }
    }
    o2[1].v = v2;
    return o2;
  }
  function parse_NUMBER_17(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    var v2 = blob.read_shift(4);
    var e2 = blob.read_shift(2);
    if (e2 == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o2[1].t = "e";
        o2[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o2[1].t = "e";
        o2[1].v = 42;
      } else o2[1].v = 0;
      return o2;
    }
    var s2 = e2 & 32768;
    e2 = (e2 & 32767) - 16446;
    o2[1].v = (1 - s2 * 2) * (v2 * Math.pow(2, e2 + 32) + v1 * Math.pow(2, e2));
    return o2;
  }
  function write_NUMBER_17(R2, C2, wsidx, v2) {
    var o2 = new_buf(14);
    o2.write_shift(2, R2);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    if (v2 == 0) {
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(2, 65535);
      return o2;
    }
    var s2 = 0, e2 = 0, v1 = 0, v22 = 0;
    if (v2 < 0) {
      s2 = 1;
      v2 = -v2;
    }
    e2 = Math.log2(v2) | 0;
    v2 /= Math.pow(2, e2 - 31);
    v22 = v2 >>> 0;
    if ((v22 & 2147483648) == 0) {
      v2 /= 2;
      ++e2;
      v22 = v2 >>> 0;
    }
    v2 -= v22;
    v22 |= 2147483648;
    v22 >>>= 0;
    v2 *= Math.pow(2, 32);
    v1 = v2 >>> 0;
    o2.write_shift(4, v1);
    o2.write_shift(4, v22);
    e2 += 16383 + (s2 ? 32768 : 0);
    o2.write_shift(2, e2);
    return o2;
  }
  function parse_FORMULA_19(blob, length) {
    var o2 = parse_NUMBER_17(blob);
    blob.l += length - 14;
    return o2;
  }
  function parse_NUMBER_25(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    o2[1].v = v1 >> 6;
    return o2;
  }
  function parse_NUMBER_27(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(8, "f");
    o2[1].v = v1;
    return o2;
  }
  function parse_FORMULA_28(blob, length) {
    var o2 = parse_NUMBER_27(blob);
    blob.l += length - 10;
    return o2;
  }
  function parse_SHEETNAMECS(blob, length) {
    return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
  }
  function parse_SHEETNAMELP(blob, length) {
    var len = blob[blob.l++];
    if (len > length - 1) len = length - 1;
    var o2 = "";
    while (o2.length < len) o2 += String.fromCharCode(blob[blob.l++]);
    return o2;
  }
  function parse_SHEETINFOQP(blob, length, opts) {
    if (!opts.qpro || length < 21) return;
    var id = blob.read_shift(1);
    blob.l += 17;
    blob.l += 1;
    blob.l += 2;
    var nm = blob.read_shift(length - 21, "cstr");
    return [id, nm];
  }
  function parse_XFORMAT(blob, length) {
    var o2 = {}, tgt = blob.l + length;
    while (blob.l < tgt) {
      var dt2 = blob.read_shift(2);
      if (dt2 == 14e3) {
        o2[dt2] = [0, ""];
        o2[dt2][0] = blob.read_shift(2);
        while (blob[blob.l]) {
          o2[dt2][1] += String.fromCharCode(blob[blob.l]);
          blob.l++;
        }
        blob.l++;
      }
    }
    return o2;
  }
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i2 = 0; i2 < name.length; ++i2) {
      var cc = name.charCodeAt(i2);
      out[out.l++] = cc > 127 ? 95 : cc;
    }
    out[out.l++] = 0;
    return out;
  }
  var WK1Enum = {
    /*::[*/
    0: { n: "BOF", f: parseuint16 },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: parse_RANGE },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: parse_INTEGER },
    /*::[*/
    14: { n: "NUMBER", f: parse_NUMBER },
    /*::[*/
    15: { n: "LABEL", f: parse_LABEL },
    /*::[*/
    16: { n: "FORMULA", f: parse_FORMULA },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: parse_LABEL },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    /*::[*/
    65535: { n: "" }
  };
  var WK3Enum = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: parse_LABEL_16 },
    /*::[*/
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    /*::[*/
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    /*::[*/
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: parse_XFORMAT },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    /*::[*/
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
})();
function parse_rpr(rpr) {
  var font = {}, m2 = rpr.match(tagregex), i2 = 0;
  var pass = false;
  if (m2) for (; i2 != m2.length; ++i2) {
    var y2 = parsexmltag(m2[i2]);
    switch (y2[0].replace(/\w*:/g, "")) {
      /* 18.8.12 condense CT_BooleanProperty */
      /* ** not required . */
      case "<condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      /* ** not required . */
      case "<extend":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      /* ** not required . */
      case "<shadow":
        if (!y2.val) break;
      /* falls through */
      case "<shadow>":
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "</shadow>":
        break;
      /* 18.4.1 charset CT_IntProperty TODO */
      case "<charset":
        if (y2.val == "1") break;
        font.cp = CS2CP[parseInt(y2.val, 10)];
        break;
      /* 18.4.2 outline CT_BooleanProperty TODO */
      case "<outline":
        if (!y2.val) break;
      /* falls through */
      case "<outline>":
      case "<outline/>":
        font.outline = 1;
        break;
      case "</outline>":
        break;
      /* 18.4.5 rFont CT_FontName */
      case "<rFont":
        font.name = y2.val;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        font.sz = y2.val;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        if (!y2.val) break;
      /* falls through */
      case "<strike>":
      case "<strike/>":
        font.strike = 1;
        break;
      case "</strike>":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        if (!y2.val) break;
        switch (y2.val) {
          case "double":
            font.uval = "double";
            break;
          case "singleAccounting":
            font.uval = "single-accounting";
            break;
          case "doubleAccounting":
            font.uval = "double-accounting";
            break;
        }
      /* falls through */
      case "<u>":
      case "<u/>":
        font.u = 1;
        break;
      case "</u>":
        break;
      /* 18.8.2 b */
      case "<b":
        if (y2.val == "0") break;
      /* falls through */
      case "<b>":
      case "<b/>":
        font.b = 1;
        break;
      case "</b>":
        break;
      /* 18.8.26 i */
      case "<i":
        if (y2.val == "0") break;
      /* falls through */
      case "<i>":
      case "<i/>":
        font.i = 1;
        break;
      case "</i>":
        break;
      /* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */
      case "<color":
        if (y2.rgb) font.color = y2.rgb.slice(2, 8);
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      /* 18.8.18 family ST_FontFamily */
      case "<family":
        font.family = y2.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */
      case "<vertAlign":
        font.valign = y2.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.35 scheme CT_FontScheme TODO */
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (y2[0].charCodeAt(1) !== 47 && !pass) throw new Error("Unrecognized rich format " + y2[0]);
    }
  }
  return font;
}
var parse_rs = /* @__PURE__ */ (function() {
  var tregex = matchtag("t"), rpregex = matchtag("rPr");
  function parse_r(r2) {
    var t3 = r2.match(tregex);
    if (!t3) return { t: "s", v: "" };
    var o2 = { t: "s", v: unescapexml(t3[1]) };
    var rpr = r2.match(rpregex);
    if (rpr) o2.s = parse_rpr(rpr[1]);
    return o2;
  }
  var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
  return function parse_rs2(rs) {
    return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r2) {
      return r2.v;
    });
  };
})();
var rs_to_html = /* @__PURE__ */ (function parse_rs_factory() {
  var nlregex = /(\r\n|\n)/g;
  function parse_rpr2(font, intro, outro) {
    var style = [];
    if (font.u) style.push("text-decoration: underline;");
    if (font.uval) style.push("text-underline-style:" + font.uval + ";");
    if (font.sz) style.push("font-size:" + font.sz + "pt;");
    if (font.outline) style.push("text-effect: outline;");
    if (font.shadow) style.push("text-shadow: auto;");
    intro.push('<span style="' + style.join("") + '">');
    if (font.b) {
      intro.push("<b>");
      outro.push("</b>");
    }
    if (font.i) {
      intro.push("<i>");
      outro.push("</i>");
    }
    if (font.strike) {
      intro.push("<s>");
      outro.push("</s>");
    }
    var align = font.valign || "";
    if (align == "superscript" || align == "super") align = "sup";
    else if (align == "subscript") align = "sub";
    if (align != "") {
      intro.push("<" + align + ">");
      outro.push("</" + align + ">");
    }
    outro.push("</span>");
    return font;
  }
  function r_to_html(r2) {
    var terms = [[], r2.v, []];
    if (!r2.v) return "";
    if (r2.s) parse_rpr2(r2.s, terms[0], terms[2]);
    return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
  }
  return function parse_rs2(rs) {
    return rs.map(r_to_html).join("");
  };
})();
var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r>/;
var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function parse_si(x2, opts) {
  var html2 = opts ? opts.cellHTML : true;
  var z2 = {};
  if (!x2) return { t: "" };
  if (x2.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
    z2.t = unescapexml(utf8read(x2.slice(x2.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""));
    z2.r = utf8read(x2);
    if (html2) z2.h = escapehtml(z2.t);
  } else if (
    /*y = */
    x2.match(sirregex)
  ) {
    z2.r = utf8read(x2);
    z2.t = unescapexml(utf8read((x2.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")));
    if (html2) z2.h = rs_to_html(parse_rs(z2.r));
  }
  return z2;
}
var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(data, opts) {
  var s2 = [], ss = "";
  if (!data) return s2;
  var sst = data.match(sstr0);
  if (sst) {
    ss = sst[2].replace(sstr1, "").split(sstr2);
    for (var i2 = 0; i2 != ss.length; ++i2) {
      var o2 = parse_si(ss[i2].trim(), opts);
      if (o2 != null) s2[s2.length] = o2;
    }
    sst = parsexmltag(sst[1]);
    s2.Count = sst.count;
    s2.Unique = sst.uniqueCount;
  }
  return s2;
}
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
function parse_sst_bin(data, opts) {
  var s2 = [];
  var pass = false;
  recordhopper(data, function hopper_sst(val, R2, RT) {
    switch (RT) {
      case 159:
        s2.Count = val[0];
        s2.Unique = val[1];
        break;
      case 19:
        s2.push(val);
        break;
      case 160:
        return true;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R2.T) ;
        if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return s2;
}
function _JS2ANSI(str) {
  var o2 = [], oo = str.split("");
  for (var i2 = 0; i2 < oo.length; ++i2) o2[i2] = oo[i2].charCodeAt(0);
  return o2;
}
function parse_CRYPTOVersion(blob, length) {
  var o2 = {};
  o2.Major = blob.read_shift(2);
  o2.Minor = blob.read_shift(2);
  if (length >= 4) blob.l += length - 4;
  return o2;
}
function parse_DataSpaceVersionInfo(blob) {
  var o2 = {};
  o2.id = blob.read_shift(0, "lpp4");
  o2.R = parse_CRYPTOVersion(blob, 4);
  o2.U = parse_CRYPTOVersion(blob, 4);
  o2.W = parse_CRYPTOVersion(blob, 4);
  return o2;
}
function parse_DataSpaceMapEntry(blob) {
  var len = blob.read_shift(4);
  var end = blob.l + len - 4;
  var o2 = {};
  var cnt = blob.read_shift(4);
  var comps = [];
  while (cnt-- > 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
  o2.name = blob.read_shift(0, "lpp4");
  o2.comps = comps;
  if (blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
  return o2;
}
function parse_DataSpaceMap(blob) {
  var o2 = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o2.push(parse_DataSpaceMapEntry(blob));
  return o2;
}
function parse_DataSpaceDefinition(blob) {
  var o2 = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o2.push(blob.read_shift(0, "lpp4"));
  return o2;
}
function parse_TransformInfoHeader(blob) {
  var o2 = {};
  blob.read_shift(4);
  blob.l += 4;
  o2.id = blob.read_shift(0, "lpp4");
  o2.name = blob.read_shift(0, "lpp4");
  o2.R = parse_CRYPTOVersion(blob, 4);
  o2.U = parse_CRYPTOVersion(blob, 4);
  o2.W = parse_CRYPTOVersion(blob, 4);
  return o2;
}
function parse_Primary(blob) {
  var hdr = parse_TransformInfoHeader(blob);
  hdr.ename = blob.read_shift(0, "8lpp4");
  hdr.blksz = blob.read_shift(4);
  hdr.cmode = blob.read_shift(4);
  if (blob.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return hdr;
}
function parse_EncryptionHeader(blob, length) {
  var tgt = blob.l + length;
  var o2 = {};
  o2.Flags = blob.read_shift(4) & 63;
  blob.l += 4;
  o2.AlgID = blob.read_shift(4);
  var valid = false;
  switch (o2.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      valid = o2.Flags == 36;
      break;
    case 26625:
      valid = o2.Flags == 4;
      break;
    case 0:
      valid = o2.Flags == 16 || o2.Flags == 4 || o2.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + o2.AlgID;
  }
  if (!valid) throw new Error("Encryption Flags/AlgID mismatch");
  o2.AlgIDHash = blob.read_shift(4);
  o2.KeySize = blob.read_shift(4);
  o2.ProviderType = blob.read_shift(4);
  blob.l += 8;
  o2.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
  blob.l = tgt;
  return o2;
}
function parse_EncryptionVerifier(blob, length) {
  var o2 = {}, tgt = blob.l + length;
  blob.l += 4;
  o2.Salt = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  o2.Verifier = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  blob.read_shift(4);
  o2.VerifierHash = blob.slice(blob.l, tgt);
  blob.l = tgt;
  return o2;
}
function parse_EncryptionInfo(blob) {
  var vers = parse_CRYPTOVersion(blob);
  switch (vers.Minor) {
    case 2:
      return [vers.Minor, parse_EncInfoStd(blob)];
    case 3:
      return [vers.Minor, parse_EncInfoExt()];
    case 4:
      return [vers.Minor, parse_EncInfoAgl(blob)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
}
function parse_EncInfoStd(blob) {
  var flags = blob.read_shift(4);
  if ((flags & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var sz = blob.read_shift(4);
  var hdr = parse_EncryptionHeader(blob, sz);
  var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
  return { t: "Std", h: hdr, v: verifier };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(blob) {
  var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  blob.l += 4;
  var xml2 = blob.read_shift(blob.length - blob.l, "utf8");
  var o2 = {};
  xml2.replace(tagregex, function xml_agile(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        KeyData.forEach(function(k2) {
          o2[k2] = y2[k2];
        });
        break;
      case "<dataIntegrity":
        o2.encryptedHmacKey = y2.encryptedHmacKey;
        o2.encryptedHmacValue = y2.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        o2.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        o2.uri = y2.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        o2.encs.push(y2);
        break;
      default:
        throw y2[0];
    }
  });
  return o2;
}
function parse_RC4CryptoHeader(blob, length) {
  var o2 = {};
  var vers = o2.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  length -= 4;
  if (vers.Minor != 2) throw new Error("unrecognized minor version code: " + vers.Minor);
  if (vers.Major > 4 || vers.Major < 2) throw new Error("unrecognized major version code: " + vers.Major);
  o2.Flags = blob.read_shift(4);
  length -= 4;
  var sz = blob.read_shift(4);
  length -= 4;
  o2.EncryptionHeader = parse_EncryptionHeader(blob, sz);
  length -= sz;
  o2.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
  return o2;
}
function parse_RC4Header(blob) {
  var o2 = {};
  var vers = o2.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  if (vers.Major != 1 || vers.Minor != 1) throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
  o2.Salt = blob.read_shift(16);
  o2.EncryptedVerifier = blob.read_shift(16);
  o2.EncryptedVerifierHash = blob.read_shift(16);
  return o2;
}
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i2, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i2 = 1; i2 != len; ++i2) PasswordArray[i2] = PasswordDecoded[i2 - 1];
  for (i2 = len - 1; i2 >= 0; --i2) {
    PasswordByte = PasswordArray[i2];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ (function() {
  var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
  var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
  var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
  var Ror = function(Byte) {
    return (Byte / 2 | Byte * 128) & 255;
  };
  var XorRor = function(byte1, byte2) {
    return Ror(byte1 ^ byte2);
  };
  var CreateXorKey_Method1 = function(Password) {
    var XorKey = InitialCode[Password.length - 1];
    var CurrentElement = 104;
    for (var i2 = Password.length - 1; i2 >= 0; --i2) {
      var Char = Password[i2];
      for (var j2 = 0; j2 != 7; ++j2) {
        if (Char & 64) XorKey ^= XorMatrix[CurrentElement];
        Char *= 2;
        --CurrentElement;
      }
    }
    return XorKey;
  };
  return function(password) {
    var Password = _JS2ANSI(password);
    var XorKey = CreateXorKey_Method1(Password);
    var Index = Password.length;
    var ObfuscationArray = new_raw_buf(16);
    for (var i2 = 0; i2 != 16; ++i2) ObfuscationArray[i2] = 0;
    var Temp, PasswordLastChar, PadIndex;
    if ((Index & 1) === 1) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
      --Index;
      Temp = XorKey & 255;
      PasswordLastChar = Password[Password.length - 1];
      ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
    }
    while (Index > 0) {
      --Index;
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
    }
    Index = 15;
    PadIndex = 15 - Password.length;
    while (PadIndex > 0) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
      --Index;
      --PadIndex;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      --PadIndex;
    }
    return ObfuscationArray;
  };
})();
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O2) {
  if (!O2) O2 = Data;
  if (!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
  var Index, Value;
  for (Index = 0; Index != Data.length; ++Index) {
    Value = Data[Index];
    Value ^= XorArray[XorArrayIndex];
    Value = (Value >> 5 | Value << 3) & 255;
    O2[Index] = Value;
    ++XorArrayIndex;
  }
  return [O2, XorArrayIndex, XorArray];
};
var crypto_MakeXorDecryptor = function(password) {
  var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
  return function(Data) {
    var O2 = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
    XorArrayIndex = O2[1];
    return O2[0];
  };
};
function parse_XORObfuscation(blob, length, opts, out) {
  var o2 = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
  if (opts.password) o2.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
  out.valid = o2.verificationBytes === o2.verifier;
  if (out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);
  return o2;
}
function parse_FilePassHeader(blob, length, oo) {
  var o2 = oo || {};
  o2.Info = blob.read_shift(2);
  blob.l -= 2;
  if (o2.Info === 1) o2.Data = parse_RC4Header(blob);
  else o2.Data = parse_RC4CryptoHeader(blob, length);
  return o2;
}
function parse_FilePass(blob, length, opts) {
  var o2 = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
  if (o2.Type) parse_FilePassHeader(blob, length - 2, o2);
  else parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o2);
  return o2;
}
var RTF = /* @__PURE__ */ (function() {
  function rtf_to_sheet(d2, opts) {
    switch (opts.type) {
      case "base64":
        return rtf_to_sheet_str(Base64_decode(d2), opts);
      case "binary":
        return rtf_to_sheet_str(d2, opts);
      case "buffer":
        return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d2) ? d2.toString("binary") : a2s(d2), opts);
      case "array":
        return rtf_to_sheet_str(cc2str(d2), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function rtf_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var ws = o2.dense ? [] : {};
    var rows = str.match(/\\trowd.*?\\row\b/g);
    if (!rows.length) throw new Error("RTF missing table");
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
    rows.forEach(function(rowtf, R2) {
      if (Array.isArray(ws)) ws[R2] = [];
      var rtfre = /\\\w+\b/g;
      var last_index = 0;
      var res;
      var C2 = -1;
      while (res = rtfre.exec(rowtf)) {
        switch (res[0]) {
          case "\\cell":
            var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
            if (data[0] == " ") data = data.slice(1);
            ++C2;
            if (data.length) {
              var cell = { v: data, t: "s" };
              if (Array.isArray(ws)) ws[R2][C2] = cell;
              else ws[encode_cell({ r: R2, c: C2 })] = cell;
            }
            break;
        }
        last_index = rtfre.lastIndex;
      }
      if (C2 > range.e.c) range.e.c = C2;
    });
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function rtf_to_workbook(d2, opts) {
    return sheet_to_workbook(rtf_to_sheet(d2, opts), opts);
  }
  function sheet_to_rtf(ws) {
    var o2 = ["{\\rtf1\\ansi"];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R2 = r2.s.r; R2 <= r2.e.r; ++R2) {
      o2.push("\\trowd\\trautofit1");
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) o2.push("\\cellx" + (C2 + 1));
      o2.push("\\pard\\intbl");
      for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R2, c: C2 });
        cell = dense ? (ws[R2] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
        o2.push(" " + (cell.w || (format_cell(cell), cell.w)));
        o2.push("\\cell");
      }
      o2.push("\\pard\\intbl\\row");
    }
    return o2.join("") + "}";
  }
  return {
    to_workbook: rtf_to_workbook,
    to_sheet: rtf_to_sheet,
    from_sheet: sheet_to_rtf
  };
})();
function hex2RGB(h2) {
  var o2 = h2.slice(h2[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(o2.slice(0, 2), 16), parseInt(o2.slice(2, 4), 16), parseInt(o2.slice(4, 6), 16)];
}
function rgb2Hex(rgb2) {
  for (var i2 = 0, o2 = 1; i2 != 3; ++i2) o2 = o2 * 256 + (rgb2[i2] > 255 ? 255 : rgb2[i2] < 0 ? 0 : rgb2[i2]);
  return o2.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(rgb2) {
  var R2 = rgb2[0] / 255, G2 = rgb2[1] / 255, B3 = rgb2[2] / 255;
  var M2 = Math.max(R2, G2, B3), m2 = Math.min(R2, G2, B3), C2 = M2 - m2;
  if (C2 === 0) return [0, 0, R2];
  var H6 = 0, S2 = 0, L2 = M2 + m2;
  S2 = C2 / (L2 > 1 ? 2 - L2 : L2);
  switch (M2) {
    case R2:
      H6 = ((G2 - B3) / C2 + 6) % 6;
      break;
    case G2:
      H6 = (B3 - R2) / C2 + 2;
      break;
    case B3:
      H6 = (R2 - G2) / C2 + 4;
      break;
  }
  return [H6 / 6, S2, L2 / 2];
}
function hsl2RGB(hsl2) {
  var H4 = hsl2[0], S2 = hsl2[1], L2 = hsl2[2];
  var C2 = S2 * 2 * (L2 < 0.5 ? L2 : 1 - L2), m2 = L2 - C2 / 2;
  var rgb2 = [m2, m2, m2], h6 = 6 * H4;
  var X2;
  if (S2 !== 0) switch (h6 | 0) {
    case 0:
    case 6:
      X2 = C2 * h6;
      rgb2[0] += C2;
      rgb2[1] += X2;
      break;
    case 1:
      X2 = C2 * (2 - h6);
      rgb2[0] += X2;
      rgb2[1] += C2;
      break;
    case 2:
      X2 = C2 * (h6 - 2);
      rgb2[1] += C2;
      rgb2[2] += X2;
      break;
    case 3:
      X2 = C2 * (4 - h6);
      rgb2[1] += X2;
      rgb2[2] += C2;
      break;
    case 4:
      X2 = C2 * (h6 - 4);
      rgb2[2] += C2;
      rgb2[0] += X2;
      break;
    case 5:
      X2 = C2 * (6 - h6);
      rgb2[2] += X2;
      rgb2[0] += C2;
      break;
  }
  for (var i2 = 0; i2 != 3; ++i2) rgb2[i2] = Math.round(rgb2[i2] * 255);
  return rgb2;
}
function rgb_tint(hex, tint) {
  if (tint === 0) return hex;
  var hsl2 = rgb2HSL(hex2RGB(hex));
  if (tint < 0) hsl2[2] = hsl2[2] * (1 + tint);
  else hsl2[2] = 1 - (1 - hsl2[2]) * (1 - tint);
  return rgb2Hex(hsl2RGB(hsl2));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width) {
  return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(collw) {
  return char2width(px2char(width2px(collw)));
}
function find_mdw_colw(collw) {
  var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
  if (delta > 5e-3) {
    for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) if (Math.abs(collw - cycle_width(collw)) <= delta) {
      delta = Math.abs(collw - cycle_width(collw));
      _MDW = MDW;
    }
  }
  MDW = _MDW;
}
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth) delete coll.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
function pt2px(pt2) {
  return pt2 * PPI / 96;
}
var XLMLPatternTypeMap = {
  "None": "none",
  "Solid": "solid",
  "Gray50": "mediumGray",
  "Gray75": "darkGray",
  "Gray25": "lightGray",
  "HorzStripe": "darkHorizontal",
  "VertStripe": "darkVertical",
  "ReverseDiagStripe": "darkDown",
  "DiagStripe": "darkUp",
  "DiagCross": "darkGrid",
  "ThickDiagCross": "darkTrellis",
  "ThinHorzStripe": "lightHorizontal",
  "ThinVertStripe": "lightVertical",
  "ThinReverseDiagStripe": "lightDown",
  "ThinHorzCross": "lightGrid"
};
function parse_borders(t3, styles, themes, opts) {
  styles.Borders = [];
  var border = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      /* 18.8.4 border CT_Border */
      case "<border":
      case "<border>":
      case "<border/>":
        border = /*::(*/
        {};
        if (y2.diagonalUp) border.diagonalUp = parsexmlbool(y2.diagonalUp);
        if (y2.diagonalDown) border.diagonalDown = parsexmlbool(y2.diagonalDown);
        styles.Borders.push(border);
        break;
      case "</border>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      /* 18.8.43 top CT_BorderPr */
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      /* 18.8.6 bottom CT_BorderPr */
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      /* 18.8.13 diagonal CT_BorderPr */
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      /* 18.8.25 horizontal CT_BorderPr */
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      /* 18.8.44 vertical CT_BorderPr */
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      /* 18.8.37 start CT_BorderPr */
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      /* 18.8.16 end CT_BorderPr */
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y2[0] + " in borders");
        }
    }
  });
}
function parse_fills(t3, styles, themes, opts) {
  styles.Fills = [];
  var fill2 = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      /* 18.8.20 fill CT_Fill */
      case "<fill>":
      case "<fill":
      case "<fill/>":
        fill2 = {};
        styles.Fills.push(fill2);
        break;
      case "</fill>":
        break;
      /* 18.8.24 gradientFill CT_GradientFill */
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        styles.Fills.push(fill2);
        fill2 = {};
        break;
      /* 18.8.32 patternFill CT_PatternFill */
      case "<patternFill":
      case "<patternFill>":
        if (y2.patternType) fill2.patternType = y2.patternType;
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      /* 18.8.3 bgColor CT_Color */
      case "<bgColor":
        if (!fill2.bgColor) fill2.bgColor = {};
        if (y2.indexed) fill2.bgColor.indexed = parseInt(y2.indexed, 10);
        if (y2.theme) fill2.bgColor.theme = parseInt(y2.theme, 10);
        if (y2.tint) fill2.bgColor.tint = parseFloat(y2.tint);
        if (y2.rgb) fill2.bgColor.rgb = y2.rgb.slice(-6);
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      /* 18.8.19 fgColor CT_Color */
      case "<fgColor":
        if (!fill2.fgColor) fill2.fgColor = {};
        if (y2.theme) fill2.fgColor.theme = parseInt(y2.theme, 10);
        if (y2.tint) fill2.fgColor.tint = parseFloat(y2.tint);
        if (y2.rgb != null) fill2.fgColor.rgb = y2.rgb.slice(-6);
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      /* 18.8.38 stop CT_GradientStop */
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y2[0] + " in fills");
        }
    }
  });
}
function parse_fonts(t3, styles, themes, opts) {
  styles.Fonts = [];
  var font = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      /* 18.8.22 font CT_Font */
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        styles.Fonts.push(font);
        font = {};
        break;
      /* 18.8.29 name CT_FontName */
      case "<name":
        if (y2.val) font.name = utf8read(y2.val);
        break;
      case "<name/>":
      case "</name>":
        break;
      /* 18.8.2  b CT_BooleanProperty */
      case "<b":
        font.bold = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<b/>":
        font.bold = 1;
        break;
      /* 18.8.26 i CT_BooleanProperty */
      case "<i":
        font.italic = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<i/>":
        font.italic = 1;
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        switch (y2.val) {
          case "none":
            font.underline = 0;
            break;
          case "single":
            font.underline = 1;
            break;
          case "double":
            font.underline = 2;
            break;
          case "singleAccounting":
            font.underline = 33;
            break;
          case "doubleAccounting":
            font.underline = 34;
            break;
        }
        break;
      case "<u/>":
        font.underline = 1;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        font.strike = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<strike/>":
        font.strike = 1;
        break;
      /* 18.4.2  outline CT_BooleanProperty */
      case "<outline":
        font.outline = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<outline/>":
        font.outline = 1;
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      case "<shadow":
        font.shadow = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<shadow/>":
        font.shadow = 1;
        break;
      /* 18.8.12 condense CT_BooleanProperty */
      case "<condense":
        font.condense = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<condense/>":
        font.condense = 1;
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      case "<extend":
        font.extend = y2.val ? parsexmlbool(y2.val) : 1;
        break;
      case "<extend/>":
        font.extend = 1;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        if (y2.val) font.sz = +y2.val;
        break;
      case "<sz/>":
      case "</sz>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty */
      case "<vertAlign":
        if (y2.val) font.vertAlign = y2.val;
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.18 family CT_FontFamily */
      case "<family":
        if (y2.val) font.family = parseInt(y2.val, 10);
        break;
      case "<family/>":
      case "</family>":
        break;
      /* 18.8.35 scheme CT_FontScheme */
      case "<scheme":
        if (y2.val) font.scheme = y2.val;
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.4.1 charset CT_IntProperty */
      case "<charset":
        if (y2.val == "1") break;
        y2.codepage = CS2CP[parseInt(y2.val, 10)];
        break;
      /* 18.?.? color CT_Color */
      case "<color":
        if (!font.color) font.color = {};
        if (y2.auto) font.color.auto = parsexmlbool(y2.auto);
        if (y2.rgb) font.color.rgb = y2.rgb.slice(-6);
        else if (y2.indexed) {
          font.color.index = parseInt(y2.indexed, 10);
          var icv = XLSIcv[font.color.index];
          if (font.color.index == 81) icv = XLSIcv[1];
          if (!icv) icv = XLSIcv[1];
          font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
        } else if (y2.theme) {
          font.color.theme = parseInt(y2.theme, 10);
          if (y2.tint) font.color.tint = parseFloat(y2.tint);
          if (y2.theme && themes.themeElements && themes.themeElements.clrScheme) {
            font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
          }
        }
        break;
      case "<color/>":
      case "</color>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y2[0] + " in fonts");
        }
    }
  });
}
function parse_numFmts(t3, styles, opts) {
  styles.NumberFmt = [];
  var k2 = keys(table_fmt);
  for (var i2 = 0; i2 < k2.length; ++i2) styles.NumberFmt[k2[i2]] = table_fmt[k2[i2]];
  var m2 = t3[0].match(tagregex);
  if (!m2) return;
  for (i2 = 0; i2 < m2.length; ++i2) {
    var y2 = parsexmltag(m2[i2]);
    switch (strip_ns(y2[0])) {
      case "<numFmts":
      case "</numFmts>":
      case "<numFmts/>":
      case "<numFmts>":
        break;
      case "<numFmt":
        {
          var f2 = unescapexml(utf8read(y2.formatCode)), j2 = parseInt(y2.numFmtId, 10);
          styles.NumberFmt[j2] = f2;
          if (j2 > 0) {
            if (j2 > 392) {
              for (j2 = 392; j2 > 60; --j2) if (styles.NumberFmt[j2] == null) break;
              styles.NumberFmt[j2] = f2;
            }
            SSF_load(f2, j2);
          }
        }
        break;
      case "</numFmt>":
        break;
      default:
        if (opts.WTF) throw new Error("unrecognized " + y2[0] + " in numFmts");
    }
  }
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(t3, styles, opts) {
  styles.CellXf = [];
  var xf;
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2), i2 = 0;
    switch (strip_ns(y2[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      /* 18.8.45 xf CT_Xf */
      case "<xf":
      case "<xf/>":
        xf = y2;
        delete xf[0];
        for (i2 = 0; i2 < cellXF_uint.length; ++i2) if (xf[cellXF_uint[i2]])
          xf[cellXF_uint[i2]] = parseInt(xf[cellXF_uint[i2]], 10);
        for (i2 = 0; i2 < cellXF_bool.length; ++i2) if (xf[cellXF_bool[i2]])
          xf[cellXF_bool[i2]] = parsexmlbool(xf[cellXF_bool[i2]]);
        if (styles.NumberFmt && xf.numFmtId > 392) {
          for (i2 = 392; i2 > 60; --i2) if (styles.NumberFmt[xf.numFmtId] == styles.NumberFmt[i2]) {
            xf.numFmtId = i2;
            break;
          }
        }
        styles.CellXf.push(xf);
        break;
      case "</xf>":
        break;
      /* 18.8.1 alignment CT_CellAlignment */
      case "<alignment":
      case "<alignment/>":
        var alignment = {};
        if (y2.vertical) alignment.vertical = y2.vertical;
        if (y2.horizontal) alignment.horizontal = y2.horizontal;
        if (y2.textRotation != null) alignment.textRotation = y2.textRotation;
        if (y2.indent) alignment.indent = y2.indent;
        if (y2.wrapText) alignment.wrapText = parsexmlbool(y2.wrapText);
        xf.alignment = alignment;
        break;
      case "</alignment>":
        break;
      /* 18.8.33 protection CT_CellProtection */
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y2[0] + " in cellXfs");
        }
    }
  });
}
var parse_sty_xml = /* @__PURE__ */ (function make_pstyx() {
  var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
  var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
  var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
  var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
  var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function parse_sty_xml2(data, themes, opts) {
    var styles = {};
    if (!data) return styles;
    data = data.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var t3;
    if (t3 = data.match(numFmtRegex)) parse_numFmts(t3, styles, opts);
    if (t3 = data.match(fontsRegex)) parse_fonts(t3, styles, themes, opts);
    if (t3 = data.match(fillsRegex)) parse_fills(t3, styles, themes, opts);
    if (t3 = data.match(bordersRegex)) parse_borders(t3, styles, themes, opts);
    if (t3 = data.match(cellXfRegex)) parse_cellXfs(t3, styles, opts);
    return styles;
  };
})();
function parse_BrtFmt(data, length) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
function parse_BrtFont(data, length, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic) out.italic = 1;
  if (grbit.fCondense) out.condense = 1;
  if (grbit.fExtend) out.extend = 1;
  if (grbit.fShadow) out.shadow = 1;
  if (grbit.fOutline) out.outline = 1;
  if (grbit.fStrikeout) out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700) out.bold = 1;
  switch (data.read_shift(2)) {
    /* case 0: out.vertAlign = "baseline"; break; */
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0) out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0) out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0) out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    /* case 0: out.scheme = "none": break; */
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
var parse_BrtFill = parsenoop;
function parse_BrtXF(data, length) {
  var tgt = data.l + length;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
var parse_BrtBorder = parsenoop;
function parse_sty_bin(data, themes, opts) {
  var styles = {};
  styles.NumberFmt = [];
  for (var y2 in table_fmt) styles.NumberFmt[y2] = table_fmt[y2];
  styles.CellXf = [];
  styles.Fonts = [];
  var state = [];
  var pass = false;
  recordhopper(data, function hopper_sty(val, R2, RT) {
    switch (RT) {
      case 44:
        styles.NumberFmt[val[0]] = val[1];
        SSF_load(val[1], val[0]);
        break;
      case 43:
        styles.Fonts.push(val);
        if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
          val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
        }
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        if (state[state.length - 1] == 617) {
          styles.CellXf.push(val);
        }
        break;
      case 48:
      /* BrtStyle */
      case 507:
      /* BrtDXF */
      case 572:
      /* BrtMRUColor */
      case 475:
        break;
      case 1171:
      /* BrtDXF14 */
      case 2102:
      /* BrtDXF15 */
      case 1130:
      /* BrtSlicerStyleElement */
      case 512:
      /* BrtTableStyleElement */
      case 2095:
      /* BrtTimelineStyleElement */
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      default:
        if (R2.T > 0) state.push(RT);
        else if (R2.T < 0) state.pop();
        else if (!pass || opts.WTF && state[state.length - 1] != 37) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return styles;
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(t3, themes, opts) {
  themes.themeElements.clrScheme = [];
  var color2 = {};
  (t3[0].match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (y2[0]) {
      /* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      /* 20.1.2.3.32 srgbClr CT_SRgbColor */
      case "<a:srgbClr":
        color2.rgb = y2.val;
        break;
      /* 20.1.2.3.33 sysClr CT_SystemColor */
      case "<a:sysClr":
        color2.rgb = y2.lastClr;
        break;
      /* 20.1.4.1.1 accent1 (Accent 1) */
      /* 20.1.4.1.2 accent2 (Accent 2) */
      /* 20.1.4.1.3 accent3 (Accent 3) */
      /* 20.1.4.1.4 accent4 (Accent 4) */
      /* 20.1.4.1.5 accent5 (Accent 5) */
      /* 20.1.4.1.6 accent6 (Accent 6) */
      /* 20.1.4.1.9 dk1 (Dark 1) */
      /* 20.1.4.1.10 dk2 (Dark 2) */
      /* 20.1.4.1.15 folHlink (Followed Hyperlink) */
      /* 20.1.4.1.19 hlink (Hyperlink) */
      /* 20.1.4.1.22 lt1 (Light 1) */
      /* 20.1.4.1.23 lt2 (Light 2) */
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        if (y2[0].charAt(1) === "/") {
          themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y2[0])] = color2;
          color2 = {};
        } else {
          color2.name = y2[0].slice(3, y2[0].length - 1);
        }
        break;
      default:
        if (opts && opts.WTF) throw new Error("Unrecognized " + y2[0] + " in clrScheme");
    }
  });
}
function parse_fontScheme() {
}
function parse_fmtScheme() {
}
var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function parse_themeElements(data, themes, opts) {
  themes.themeElements = {};
  var t3;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", clrsregex, parse_clrScheme],
    /* fontScheme CT_FontScheme */
    ["fontScheme", fntsregex, parse_fontScheme],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", fmtsregex, parse_fmtScheme]
  ].forEach(function(m2) {
    if (!(t3 = data.match(m2[1]))) throw new Error(m2[0] + " not found in themeElements");
    m2[2](t3, themes, opts);
  });
}
var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function parse_theme_xml(data, opts) {
  if (!data || data.length === 0) data = write_theme();
  var t3;
  var themes = {};
  if (!(t3 = data.match(themeltregex))) throw new Error("themeElements not found in theme");
  parse_themeElements(t3[0], themes, opts);
  themes.raw = data;
  return themes;
}
function write_theme(Themes, opts) {
  var o2 = [XML_HEADER];
  o2[o2.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o2[o2.length] = "<a:themeElements>";
  o2[o2.length] = '<a:clrScheme name="Office">';
  o2[o2.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o2[o2.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o2[o2.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o2[o2.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o2[o2.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o2[o2.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o2[o2.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o2[o2.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o2[o2.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o2[o2.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o2[o2.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o2[o2.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o2[o2.length] = "</a:clrScheme>";
  o2[o2.length] = '<a:fontScheme name="Office">';
  o2[o2.length] = "<a:majorFont>";
  o2[o2.length] = '<a:latin typeface="Cambria"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã´ã·ãã¯"/>';
  o2[o2.length] = '<a:font script="Hang" typeface="ë§ì ê³ ë"/>';
  o2[o2.length] = '<a:font script="Hans" typeface="å®ä½"/>';
  o2[o2.length] = '<a:font script="Hant" typeface="æ°ç´°æé«"/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:majorFont>";
  o2[o2.length] = "<a:minorFont>";
  o2[o2.length] = '<a:latin typeface="Calibri"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã´ã·ãã¯"/>';
  o2[o2.length] = '<a:font script="Hang" typeface="ë§ì ê³ ë"/>';
  o2[o2.length] = '<a:font script="Hans" typeface="å®ä½"/>';
  o2[o2.length] = '<a:font script="Hant" typeface="æ°ç´°æé«"/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:minorFont>";
  o2[o2.length] = "</a:fontScheme>";
  o2[o2.length] = '<a:fmtScheme name="Office">';
  o2[o2.length] = "<a:fillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="1"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="0"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:fillStyleLst>";
  o2[o2.length] = "<a:lnStyleLst>";
  o2[o2.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = "</a:lnStyleLst>";
  o2[o2.length] = "<a:effectStyleLst>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o2[o2.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "</a:effectStyleLst>";
  o2[o2.length] = "<a:bgFillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:bgFillStyleLst>";
  o2[o2.length] = "</a:fmtScheme>";
  o2[o2.length] = "</a:themeElements>";
  o2[o2.length] = "<a:objectDefaults>";
  o2[o2.length] = "<a:spDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:spDef>";
  o2[o2.length] = "<a:lnDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:lnDef>";
  o2[o2.length] = "</a:objectDefaults>";
  o2[o2.length] = "<a:extraClrSchemeLst/>";
  o2[o2.length] = "</a:theme>";
  return o2.join("");
}
function parse_Theme(blob, length, opts) {
  var end = blob.l + length;
  var dwThemeVersion = blob.read_shift(4);
  if (dwThemeVersion === 124226) return;
  if (!opts.cellStyles) {
    blob.l = end;
    return;
  }
  var data = blob.slice(blob.l);
  blob.l = end;
  var zip;
  try {
    zip = zip_read(data, { type: "array" });
  } catch (e2) {
    return;
  }
  var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
  if (!themeXML) return;
  return parse_theme_xml(themeXML, opts);
}
function parse_ColorTheme(blob) {
  return blob.read_shift(4);
}
function parse_FullColorExt(blob) {
  var o2 = {};
  o2.xclrType = blob.read_shift(2);
  o2.nTintShade = blob.read_shift(2);
  switch (o2.xclrType) {
    case 0:
      blob.l += 4;
      break;
    case 1:
      o2.xclrValue = parse_IcvXF(blob, 4);
      break;
    case 2:
      o2.xclrValue = parse_LongRGBA(blob);
      break;
    case 3:
      o2.xclrValue = parse_ColorTheme(blob);
      break;
    case 4:
      blob.l += 4;
      break;
  }
  blob.l += 8;
  return o2;
}
function parse_IcvXF(blob, length) {
  return parsenoop(blob, length);
}
function parse_XFExtGradient(blob, length) {
  return parsenoop(blob, length);
}
function parse_ExtProp(blob) {
  var extType = blob.read_shift(2);
  var cb = blob.read_shift(2) - 4;
  var o2 = [extType];
  switch (extType) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      o2[1] = parse_FullColorExt(blob);
      break;
    case 6:
      o2[1] = parse_XFExtGradient(blob, cb);
      break;
    case 14:
    case 15:
      o2[1] = blob.read_shift(cb === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + extType + " " + cb);
  }
  return o2;
}
function parse_XFExt(blob, length) {
  var end = blob.l + length;
  blob.l += 2;
  var ixfe = blob.read_shift(2);
  blob.l += 2;
  var cexts = blob.read_shift(2);
  var ext = [];
  while (cexts-- > 0) ext.push(parse_ExtProp(blob, end - blob.l));
  return { ixfe, ext };
}
function update_xfext(xf, xfext) {
  xfext.forEach(function(xfe) {
    switch (xfe[0]) {
    }
  });
}
function parse_BrtMdtinfo(data, length) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
function parse_xlmeta_bin(data, name, _opts) {
  var out = { Types: [], Cell: [], Value: [] };
  var opts = _opts || {};
  var state = [];
  var pass = false;
  var metatype = 2;
  recordhopper(data, function(val, R2, RT) {
    switch (RT) {
      case 335:
        out.Types.push({ name: val.name });
        break;
      case 51:
        val.forEach(function(r2) {
          if (metatype == 1)
            out.Cell.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
        });
        break;
      case 337:
        metatype = val ? 1 : 0;
        break;
      case 338:
        metatype = 2;
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      default:
        if (R2.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlmeta_xml(data, name, opts) {
  var out = { Types: [], Cell: [], Value: [] };
  if (!data)
    return out;
  var pass = false;
  var metatype = 2;
  var lastmeta;
  data.replace(tagregex, function(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        out.Types.push({ name: y2.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var j2 = 0; j2 < out.Types.length; ++j2)
          if (out.Types[j2].name == y2.name)
            lastmeta = out.Types[j2];
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        if (metatype == 1)
          out.Cell.push({ type: out.Types[y2.t - 1].name, index: +y2.v });
        else if (metatype == 0)
          out.Value.push({ type: out.Types[y2.t - 1].name, index: +y2.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        metatype = 1;
        break;
      case "</cellMetadata>":
        metatype = 2;
        break;
      case "<valueMetadata":
        metatype = 0;
        break;
      case "</valueMetadata>":
        metatype = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<rvb":
        if (!lastmeta)
          break;
        if (!lastmeta.offsets)
          lastmeta.offsets = [];
        lastmeta.offsets.push(+y2.i);
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y2[0] + " in metadata");
    }
    return x2;
  });
  return out;
}
function parse_cc_xml(data) {
  var d2 = [];
  if (!data) return d2;
  var i2 = 1;
  (data.match(tagregex) || []).forEach(function(x2) {
    var y2 = parsexmltag(x2);
    switch (y2[0]) {
      case "<?xml":
        break;
      /* 18.6.2  calcChain CT_CalcChain 1 */
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      /* 18.6.1  c CT_CalcCell 1 */
      case "<c":
        delete y2[0];
        if (y2.i) i2 = y2.i;
        else y2.i = i2;
        d2.push(y2);
        break;
    }
  });
  return d2;
}
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2) out.l = "1";
  if (flags & 8) out.a = "1";
  return out;
}
function parse_cc_bin(data, name, opts) {
  var out = [];
  recordhopper(data, function hopper_cc(val, R2, RT) {
    switch (RT) {
      case 63:
        out.push(val);
        break;
      default:
        if (R2.T) ;
        else throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(data, rel, name, _opts) {
  if (!data) return data;
  var opts = _opts || {};
  var pass = false;
  recordhopper(data, function xlink_parse(val, R2, RT) {
    switch (RT) {
      case 359:
      /* 'BrtSupTabs' */
      case 363:
      /* 'BrtExternTableStart' */
      case 364:
      /* 'BrtExternTableEnd' */
      case 366:
      /* 'BrtExternRowHdr' */
      case 367:
      /* 'BrtExternCellBlank' */
      case 368:
      /* 'BrtExternCellReal' */
      case 369:
      /* 'BrtExternCellBool' */
      case 370:
      /* 'BrtExternCellError' */
      case 371:
      /* 'BrtExternCellString' */
      case 472:
      /* 'BrtExternValueMeta' */
      case 577:
      /* 'BrtSupNameStart' */
      case 578:
      /* 'BrtSupNameValueStart' */
      case 579:
      /* 'BrtSupNameValueEnd' */
      case 580:
      /* 'BrtSupNameNum' */
      case 581:
      /* 'BrtSupNameErr' */
      case 582:
      /* 'BrtSupNameSt' */
      case 583:
      /* 'BrtSupNameNil' */
      case 584:
      /* 'BrtSupNameBool' */
      case 585:
      /* 'BrtSupNameFmla' */
      case 586:
      /* 'BrtSupNameBits' */
      case 587:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R2.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
}
function parse_drawing(data, rels) {
  if (!data) return "??";
  var id = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return rels["!id"][id].Target;
}
function sheet_insert_comments(sheet, comments, threaded, people) {
  var dense = Array.isArray(sheet);
  var cell;
  comments.forEach(function(comment) {
    var r2 = decode_cell(comment.ref);
    if (dense) {
      if (!sheet[r2.r]) sheet[r2.r] = [];
      cell = sheet[r2.r][r2.c];
    } else cell = sheet[comment.ref];
    if (!cell) {
      cell = { t: "z" };
      if (dense) sheet[r2.r][r2.c] = cell;
      else sheet[comment.ref] = cell;
      var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
      if (range.s.r > r2.r) range.s.r = r2.r;
      if (range.e.r < r2.r) range.e.r = r2.r;
      if (range.s.c > r2.c) range.s.c = r2.c;
      if (range.e.c < r2.c) range.e.c = r2.c;
      var encoded = encode_range(range);
      if (encoded !== sheet["!ref"]) sheet["!ref"] = encoded;
    }
    if (!cell.c) cell.c = [];
    var o2 = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
    if (comment.h) o2.h = comment.h;
    for (var i2 = cell.c.length - 1; i2 >= 0; --i2) {
      if (!threaded && cell.c[i2].T) return;
      if (threaded && !cell.c[i2].T) cell.c.splice(i2, 1);
    }
    if (threaded && people) for (i2 = 0; i2 < people.length; ++i2) {
      if (o2.a == people[i2].id) {
        o2.a = people[i2].name || o2.a;
        break;
      }
    }
    cell.c.push(o2);
  });
}
function parse_comments_xml(data, opts) {
  if (data.match(/<(?:\w+:)?comments *\/>/)) return [];
  var authors = [];
  var commentList = [];
  var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  if (authtag && authtag[1]) authtag[1].split(/<\/\w*:?author>/).forEach(function(x2) {
    if (x2 === "" || x2.trim() === "") return;
    var a2 = x2.match(/<(?:\w+:)?author[^>]*>(.*)/);
    if (a2) authors.push(a2[1]);
  });
  var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  if (cmnttag && cmnttag[1]) cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x2) {
    if (x2 === "" || x2.trim() === "") return;
    var cm = x2.match(/<(?:\w+:)?comment[^>]*>/);
    if (!cm) return;
    var y2 = parsexmltag(cm[0]);
    var comment = { author: y2.authorId && authors[y2.authorId] || "sheetjsghost", ref: y2.ref, guid: y2.guid };
    var cell = decode_cell(y2.ref);
    if (opts.sheetRows && opts.sheetRows <= cell.r) return;
    var textMatch = x2.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
    var rt2 = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
    comment.r = rt2.r;
    if (rt2.r == "<t></t>") rt2.t = rt2.h = "";
    comment.t = (rt2.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    if (opts.cellHTML) comment.h = rt2.h;
    commentList.push(comment);
  });
  return commentList;
}
function parse_tcmnt_xml(data, opts) {
  var out = [];
  var pass = false, comment = {}, tidx = 0;
  data.replace(tagregex, function xml_tcmnt(x2, idx) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<?xml":
        break;
      /* 2.6.207 ThreadedComments CT_ThreadedComments */
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      /* 2.6.205 threadedComment CT_ThreadedComment */
      case "<threadedComment":
        comment = { author: y2.personId, guid: y2.id, ref: y2.ref, T: 1 };
        break;
      case "</threadedComment>":
        if (comment.t != null) out.push(comment);
        break;
      case "<text>":
      case "<text":
        tidx = idx + x2.length;
        break;
      case "</text>":
        comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        break;
      /* 2.6.206 mentions CT_ThreadedCommentMentions TODO */
      case "<mentions":
      case "<mentions>":
        pass = true;
        break;
      case "</mentions>":
        pass = false;
        break;
      /* 2.6.202 mention CT_Mention TODO */
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y2[0] + " in threaded comments");
    }
    return x2;
  });
  return out;
}
function parse_people_xml(data, opts) {
  var out = [];
  var pass = false;
  data.replace(tagregex, function xml_tcmnt(x2) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<?xml":
        break;
      /* 2.4.85 personList CT_PersonList */
      case "<personList":
        break;
      case "</personList>":
        break;
      /* 2.6.203 person CT_Person TODO: providers */
      case "<person":
        out.push({ name: y2.displayname, id: y2.id });
        break;
      case "</person>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y2[0] + " in threaded comments");
    }
    return x2;
  });
  return out;
}
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function parse_comments_bin(data, opts) {
  var out = [];
  var authors = [];
  var c2 = {};
  var pass = false;
  recordhopper(data, function hopper_cmnt(val, R2, RT) {
    switch (RT) {
      case 632:
        authors.push(val);
        break;
      case 635:
        c2 = val;
        break;
      case 637:
        c2.t = val.t;
        c2.h = val.h;
        c2.r = val.r;
        break;
      case 636:
        c2.author = authors[c2.iauthor];
        delete c2.iauthor;
        if (opts.sheetRows && c2.rfx && opts.sheetRows <= c2.rfx.r) break;
        if (!c2.t) c2.t = "";
        delete c2.rfx;
        out.push(c2);
        break;
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R2.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(cfb) {
  var newcfb = CFB.utils.cfb_new({ root: "R" });
  cfb.FullPaths.forEach(function(p2, i2) {
    if (p2.slice(-1) === "/" || !p2.match(/_VBA_PROJECT_CUR/))
      return;
    var newpath = p2.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i2].content);
  });
  return CFB.write(newcfb);
}
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ (function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0) rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0) cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R2 = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C2 = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel) C2 += rcbase.c;
    else --C2;
    if (rRel) R2 += rcbase.r;
    else --R2;
    return $1 + (cRel ? "" : "$") + encode_col(C2) + (rRel ? "" : "$") + encode_row(R2);
  }
  return function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  };
})();
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var a1_to_rc = /* @__PURE__ */ (function() {
  return function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c2 = decode_col($3) - ($2 ? 0 : base.c);
      var r2 = decode_row($5) - ($4 ? 0 : base.r);
      var R2 = r2 == 0 ? "" : !$4 ? "[" + r2 + "]" : r2 + 1;
      var C2 = c2 == 0 ? "" : !$2 ? "[" + c2 + "]" : c2 + 1;
      return $1 + "R" + R2 + "C" + C2;
    });
  };
})();
function shift_formula_str(f2, delta) {
  return f2.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
function shift_formula_xlsx(f2, range, cell) {
  var r2 = decode_range(range), s2 = r2.s, c2 = decode_cell(cell);
  var delta = { r: c2.r - s2.r, c: c2.c - s2.c };
  return shift_formula_str(f2, delta);
}
function fuzzyfmla(f2) {
  if (f2.length == 1) return false;
  return true;
}
function _xlfn(f2) {
  return f2.replace(/_xlfn\./g, "");
}
function parseread1(blob) {
  blob.l += 1;
  return;
}
function parse_ColRelU(blob, length) {
  var c2 = blob.read_shift(2);
  return [c2 & 16383, c2 >> 14 & 1, c2 >> 15 & 1];
}
function parse_RgceArea(blob, length, opts) {
  var w2 = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob);
    else if (opts.biff == 12) w2 = 4;
  }
  var r2 = blob.read_shift(w2), R2 = blob.read_shift(w2);
  var c2 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r: r2, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R2, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceArea_BIFF2(blob) {
  var r2 = parse_ColRelU(blob), R2 = parse_ColRelU(blob);
  var c2 = blob.read_shift(1);
  var C2 = blob.read_shift(1);
  return { s: { r: r2[0], c: c2, cRel: r2[1], rRel: r2[2] }, e: { r: R2[0], c: C2, cRel: R2[1], rRel: R2[2] } };
}
function parse_RgceAreaRel(blob, length, opts) {
  if (opts.biff < 8) return parse_RgceArea_BIFF2(blob);
  var r2 = blob.read_shift(opts.biff == 12 ? 4 : 2), R2 = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r: r2, c: c2[0], cRel: c2[1], rRel: c2[2] }, e: { r: R2, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceLoc(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob);
  var r2 = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c2 = parse_ColRelU(blob);
  return { r: r2, c: c2[0], cRel: c2[1], rRel: c2[2] };
}
function parse_RgceLoc_BIFF2(blob) {
  var r2 = parse_ColRelU(blob);
  var c2 = blob.read_shift(1);
  return { r: r2[0], c: c2, cRel: r2[1], rRel: r2[2] };
}
function parse_RgceElfLoc(blob) {
  var r2 = blob.read_shift(2);
  var c2 = blob.read_shift(2);
  return { r: r2, c: c2 & 255, fQuoted: !!(c2 & 16384), cRel: c2 >> 15, rRel: c2 >> 15 };
}
function parse_RgceLocRel(blob, length, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob);
  var r2 = blob.read_shift(biff >= 12 ? 4 : 2);
  var cl = blob.read_shift(2);
  var cRel = (cl & 16384) >> 14, rRel = (cl & 32768) >> 15;
  cl &= 16383;
  if (rRel == 1) while (r2 > 524287) r2 -= 1048576;
  if (cRel == 1) while (cl > 8191) cl = cl - 16384;
  return { r: r2, c: cl, cRel, rRel };
}
function parse_RgceLocRel_BIFF2(blob) {
  var rl = blob.read_shift(2);
  var c2 = blob.read_shift(1);
  var rRel = (rl & 32768) >> 15, cRel = (rl & 16384) >> 14;
  rl &= 16383;
  if (rRel == 1 && rl >= 8192) rl = rl - 16384;
  if (cRel == 1 && c2 >= 128) c2 = c2 - 256;
  return { r: rl, c: c2, cRel, rRel };
}
function parse_PtgArea(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
function parse_PtgArea3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2, "i");
  var w2 = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w2 = 6;
      break;
    case 12:
      w2 = 12;
      break;
  }
  var area = parse_RgceArea(blob, w2, opts);
  return [type, ixti, area];
}
function parse_PtgAreaErr(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
function parse_PtgAreaErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w2 = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w2 = 6;
      break;
    case 12:
      w2 = 12;
      break;
  }
  blob.l += w2;
  return [type, ixti];
}
function parse_PtgAreaN(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob, length - 1, opts);
  return [type, area];
}
function parse_PtgArray(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
function parse_PtgAttrBaxcel(blob) {
  var bitSemi = blob[blob.l + 1] & 1;
  var bitBaxcel = 1;
  blob.l += 4;
  return [bitSemi, bitBaxcel];
}
function parse_PtgAttrChoose(blob, length, opts) {
  blob.l += 2;
  var offset = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o2 = [];
  for (var i2 = 0; i2 <= offset; ++i2) o2.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o2;
}
function parse_PtgAttrGoto(blob, length, opts) {
  var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(blob, length, opts) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(blob) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(2)];
}
function parse_PtgAttrSemi(blob, length, opts) {
  var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
function parse_PtgAttrSpaceType(blob) {
  var type = blob.read_shift(1), cch = blob.read_shift(1);
  return [type, cch];
}
function parse_PtgAttrSpace(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgAttrSpaceSemi(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgRef(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRefN(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLocRel(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRef3d(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var ixti = blob.read_shift(2);
  if (opts && opts.biff == 5) blob.l += 12;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, ixti, loc];
}
function parse_PtgFunc(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
function parse_PtgFuncVar(blob, length, opts) {
  var type = blob[blob.l++];
  var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
function parsetab(blob) {
  return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
}
function parse_PtgAttrSum(blob, length, opts) {
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
function parse_PtgExp(blob, length, opts) {
  blob.l++;
  if (opts && opts.biff == 12) return [blob.read_shift(4, "i"), 0];
  var row = blob.read_shift(2);
  var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
function parse_PtgErr(blob) {
  blob.l++;
  return BErr[blob.read_shift(1)];
}
function parse_PtgInt(blob) {
  blob.l++;
  return blob.read_shift(2);
}
function parse_PtgBool(blob) {
  blob.l++;
  return blob.read_shift(1) !== 0;
}
function parse_PtgNum(blob) {
  blob.l++;
  return parse_Xnum(blob);
}
function parse_PtgStr(blob, length, opts) {
  blob.l++;
  return parse_ShortXLUnicodeString(blob, length - 1, opts);
}
function parse_SerAr(blob, biff) {
  var val = [blob.read_shift(1)];
  if (biff == 12) switch (val[0]) {
    case 2:
      val[0] = 4;
      break;
    /* SerBool */
    case 4:
      val[0] = 16;
      break;
    /* SerErr */
    case 0:
      val[0] = 1;
      break;
    /* SerNum */
    case 1:
      val[0] = 2;
      break;
  }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
      if (biff != 12) blob.l += 7;
      break;
    case 37:
    /* appears to be an alias */
    case 16:
      val[1] = BErr[blob[blob.l]];
      blob.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
function parse_PtgExtraMem(blob, cce, opts) {
  var count = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i2 = 0; i2 != count; ++i2) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
  return out;
}
function parse_PtgExtraArray(blob, length, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob.read_shift(4);
    cols = blob.read_shift(4);
  } else {
    cols = 1 + blob.read_shift(1);
    rows = 1 + blob.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0) cols = 256;
  }
  for (var i2 = 0, o2 = []; i2 != rows && (o2[i2] = []); ++i2)
    for (var j2 = 0; j2 != cols; ++j2) o2[i2][j2] = parse_SerAr(blob, opts.biff);
  return o2;
}
function parse_PtgName(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var w2 = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob.read_shift(w2);
  switch (opts.biff) {
    case 2:
      blob.l += 5;
      break;
    case 3:
    case 4:
      blob.l += 8;
      break;
    case 5:
      blob.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
function parse_PtgNameX(blob, length, opts) {
  if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob);
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2);
  var nameindex = blob.read_shift(4);
  return [type, ixti, nameindex];
}
function parse_PtgNameX_BIFF5(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2, "i");
  blob.l += 8;
  var nameindex = blob.read_shift(2);
  blob.l += 12;
  return [type, ixti, nameindex];
}
function parse_PtgMemArea(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgMemFunc(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgRefErr(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += 4;
  if (opts.biff < 8) blob.l--;
  if (opts.biff == 12) blob.l += 2;
  return [type];
}
function parse_PtgRefErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w2 = 4;
  if (opts) switch (opts.biff) {
    case 5:
      w2 = 15;
      break;
    case 12:
      w2 = 6;
      break;
  }
  blob.l += w2;
  return [type, ixti];
}
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob, length, opts) {
  blob.l += 2;
  return [parse_RgceElfLoc(blob)];
}
function parse_PtgElfNoop(blob) {
  blob.l += 6;
  return [];
}
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob) {
  blob.l += 2;
  return [parseuint16(blob), blob.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob) {
  blob.l += 2;
  var ixti = blob.read_shift(2);
  var flags = blob.read_shift(2);
  var idx = blob.read_shift(4);
  var c2 = blob.read_shift(2);
  var C2 = blob.read_shift(2);
  var rt2 = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt: rt2, idx, c: c2, C: C2 };
}
function parse_PtgSxName(blob) {
  blob.l += 2;
  return [blob.read_shift(4)];
}
function parse_PtgSheet(blob, length, opts) {
  blob.l += 5;
  blob.l += 2;
  blob.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
function parse_PtgEndSheet(blob, length, opts) {
  blob.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgMemNoMemN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgAttrNoop(blob) {
  blob.l += 4;
  return [0, 0];
}
var PtgTypes = {
  /*::[*/
  1: { n: "PtgExp", f: parse_PtgExp },
  /*::[*/
  2: { n: "PtgTbl", f: parse_PtgTbl },
  /*::[*/
  3: { n: "PtgAdd", f: parseread1 },
  /*::[*/
  4: { n: "PtgSub", f: parseread1 },
  /*::[*/
  5: { n: "PtgMul", f: parseread1 },
  /*::[*/
  6: { n: "PtgDiv", f: parseread1 },
  /*::[*/
  7: { n: "PtgPower", f: parseread1 },
  /*::[*/
  8: { n: "PtgConcat", f: parseread1 },
  /*::[*/
  9: { n: "PtgLt", f: parseread1 },
  /*::[*/
  10: { n: "PtgLe", f: parseread1 },
  /*::[*/
  11: { n: "PtgEq", f: parseread1 },
  /*::[*/
  12: { n: "PtgGe", f: parseread1 },
  /*::[*/
  13: { n: "PtgGt", f: parseread1 },
  /*::[*/
  14: { n: "PtgNe", f: parseread1 },
  /*::[*/
  15: { n: "PtgIsect", f: parseread1 },
  /*::[*/
  16: { n: "PtgUnion", f: parseread1 },
  /*::[*/
  17: { n: "PtgRange", f: parseread1 },
  /*::[*/
  18: { n: "PtgUplus", f: parseread1 },
  /*::[*/
  19: { n: "PtgUminus", f: parseread1 },
  /*::[*/
  20: { n: "PtgPercent", f: parseread1 },
  /*::[*/
  21: { n: "PtgParen", f: parseread1 },
  /*::[*/
  22: { n: "PtgMissArg", f: parseread1 },
  /*::[*/
  23: { n: "PtgStr", f: parse_PtgStr },
  /*::[*/
  26: { n: "PtgSheet", f: parse_PtgSheet },
  /*::[*/
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  /*::[*/
  28: { n: "PtgErr", f: parse_PtgErr },
  /*::[*/
  29: { n: "PtgBool", f: parse_PtgBool },
  /*::[*/
  30: { n: "PtgInt", f: parse_PtgInt },
  /*::[*/
  31: { n: "PtgNum", f: parse_PtgNum },
  /*::[*/
  32: { n: "PtgArray", f: parse_PtgArray },
  /*::[*/
  33: { n: "PtgFunc", f: parse_PtgFunc },
  /*::[*/
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  /*::[*/
  35: { n: "PtgName", f: parse_PtgName },
  /*::[*/
  36: { n: "PtgRef", f: parse_PtgRef },
  /*::[*/
  37: { n: "PtgArea", f: parse_PtgArea },
  /*::[*/
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  /*::[*/
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  /*::[*/
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  /*::[*/
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  /*::[*/
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  /*::[*/
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  /*::[*/
  44: { n: "PtgRefN", f: parse_PtgRefN },
  /*::[*/
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  /*::[*/
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  /*::[*/
  57: { n: "PtgNameX", f: parse_PtgNameX },
  /*::[*/
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  /*::[*/
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  /*::[*/
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  /*::[*/
  255: {}
};
var PtgDupes = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var Ptg18 = {
  /*::[*/
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  /*::[*/
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  /*::[*/
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  /*::[*/
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  /*::[*/
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  /*::[*/
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  /*::[*/
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  /*::[*/
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  /*::[*/
  25: { n: "PtgList", f: parse_PtgList },
  /*::[*/
  29: { n: "PtgSxName", f: parse_PtgSxName },
  /*::[*/
  255: {}
};
var Ptg19 = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  /*::[*/
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  /*::[*/
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  /*::[*/
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  /*::[*/
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  /*::[*/
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  /*::[*/
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  /*::[*/
  255: {}
};
function parse_RgbExtra(blob, length, rgce, opts) {
  if (opts.biff < 8) return parsenoop(blob, length);
  var target = blob.l + length;
  var o2 = [];
  for (var i2 = 0; i2 !== rgce.length; ++i2) {
    switch (rgce[i2][0]) {
      case "PtgArray":
        rgce[i2][1] = parse_PtgExtraArray(blob, 0, opts);
        o2.push(rgce[i2][1]);
        break;
      case "PtgMemArea":
        rgce[i2][2] = parse_PtgExtraMem(blob, rgce[i2][1], opts);
        o2.push(rgce[i2][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i2][1][1] = blob.read_shift(4);
          o2.push(rgce[i2][1]);
        }
        break;
      case "PtgList":
      /* TODO: PtgList -> PtgExtraList */
      case "PtgElfRadicalS":
      /* TODO: PtgElfRadicalS -> PtgExtraElf */
      case "PtgElfColS":
      /* TODO: PtgElfColS -> PtgExtraElf */
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i2][0];
    }
  }
  length = target - blob.l;
  if (length !== 0) o2.push(parsenoop(blob, length));
  return o2;
}
function parse_Rgce(blob, length, opts) {
  var target = blob.l + length;
  var R2, id, ptgs = [];
  while (target != blob.l) {
    length = target - blob.l;
    id = blob[blob.l];
    R2 = PtgTypes[id] || PtgTypes[PtgDupes[id]];
    if (id === 24 || id === 25) R2 = (id === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
    if (!R2 || !R2.f) {
      parsenoop(blob, length);
    } else {
      ptgs.push([R2.n, R2.f(blob, length, opts)]);
    }
  }
  return ptgs;
}
function stringify_array(f2) {
  var o2 = [];
  for (var i2 = 0; i2 < f2.length; ++i2) {
    var x2 = f2[i2], r2 = [];
    for (var j2 = 0; j2 < x2.length; ++j2) {
      var y2 = x2[j2];
      if (y2) switch (y2[0]) {
        // TODO: handle embedded quotes
        case 2:
          r2.push('"' + y2[1].replace(/"/g, '""') + '"');
          break;
        default:
          r2.push(y2[1]);
      }
      else r2.push("");
    }
    o2.push(r2.join(","));
  }
  return o2.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname + "'";
  return sname;
}
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks) return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
  if (!supbooks.XTI) return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4) ixti -= 65536;
    if (ixti < 0) ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI) return "SH33TJSERR1";
  var o2 = "";
  if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
    case 357:
      o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
    case 358:
      if (opts.SID != null) return supbooks.SheetNames[opts.SID];
      return "SH33TJSSAME" + supbooks[XTI[0]][0];
    case 355:
    /* 'BrtSupBookSrc' */
    /* falls through */
    default:
      return "SH33TJSSRC" + supbooks[XTI[0]][0];
  }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    //return "SH33TJSERR8";
    default:
      if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
      o2 = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 } }
  );
  var stack = [], e1, e2, c2, ixti = 0, nameidx = 0, r2, sname = "";
  if (!formula[0] || !formula[0][0]) return "";
  var last_sp = -1, sp = "";
  for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
    var f2 = formula[0][ff];
    switch (f2[0]) {
      case "PtgUminus":
        stack.push("-" + stack.pop());
        break;
      case "PtgUplus":
        stack.push("+" + stack.pop());
        break;
      case "PtgPercent":
        stack.push(stack.pop() + "%");
        break;
      case "PtgAdd":
      /* [MS-XLS] 2.5.198.26 */
      case "PtgConcat":
      /* [MS-XLS] 2.5.198.43 */
      case "PtgDiv":
      /* [MS-XLS] 2.5.198.45 */
      case "PtgEq":
      /* [MS-XLS] 2.5.198.56 */
      case "PtgGe":
      /* [MS-XLS] 2.5.198.64 */
      case "PtgGt":
      /* [MS-XLS] 2.5.198.65 */
      case "PtgLe":
      /* [MS-XLS] 2.5.198.68 */
      case "PtgLt":
      /* [MS-XLS] 2.5.198.69 */
      case "PtgMul":
      /* [MS-XLS] 2.5.198.75 */
      case "PtgNe":
      /* [MS-XLS] 2.5.198.78 */
      case "PtgPower":
      /* [MS-XLS] 2.5.198.82 */
      case "PtgSub":
        e1 = stack.pop();
        e2 = stack.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e2 = e2 + sp;
          last_sp = -1;
        }
        stack.push(e2 + PtgBinOp[f2[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack.pop();
        e2 = stack.pop();
        stack.push(e2 + ":" + e1);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c2 = shift_cell_xls(f2[1][1], _range, opts);
        stack.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRefN":
        c2 = cell ? shift_cell_xls(f2[1][1], cell, opts) : f2[1][1];
        stack.push(encode_cell_xls(c2, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f2[1][1];
        c2 = shift_cell_xls(f2[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_cell_xls(c2, biff));
        break;
      case "PtgFunc":
      /* [MS-XLS] 2.5.198.62 */
      case "PtgFuncVar":
        var argc = f2[1][0], func = f2[1][1];
        if (!argc) argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack.slice(-argc);
        stack.length -= argc;
        if (func === "User") func = args.shift();
        stack.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack.push(f2[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack.push(String(f2[1]));
        break;
      case "PtgStr":
        stack.push('"' + f2[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r2 = shift_range_xls(f2[1][1], cell ? { s: cell } : _range, opts);
        stack.push(encode_range_xls(r2, opts));
        break;
      case "PtgArea":
        r2 = shift_range_xls(f2[1][1], _range, opts);
        stack.push(encode_range_xls(r2, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f2[1][1];
        r2 = f2[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_range_xls(r2, opts));
        break;
      case "PtgAttrSum":
        stack.push("SUM(" + stack.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      /* [MS-XLS] 2.5.198.33 */
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f2[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
        stack.push(name);
        break;
      case "PtgNameX":
        var bookidx = f2[1][1];
        nameidx = f2[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0) bookidx = -bookidx;
          if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
        } else {
          var o2 = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o2 = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else o2 = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o2 += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx]) o2 += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1]) o2 = ixtidata[nameidx - 1];
            else o2 += "SH33TJSERRX";
          }
          stack.push(o2);
          break;
        }
        if (!externbook) externbook = { Name: "SH33TJSERRY" };
        stack.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            // $FlowIgnore
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            // $FlowIgnore
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            // $FlowIgnore
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            // $FlowIgnore
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack.push(lp + stack.pop() + rp);
        break;
      case "PtgRefErr":
        stack.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack.push("#REF!");
        break;
      case "PtgExp":
        c2 = { c: f2[1][1], r: f2[1][0] };
        var q2 = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c2)]) {
          var parsedf = supbooks.sharedf[encode_cell(c2)];
          stack.push(stringify_formula(parsedf, _range, q2, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e2 = supbooks.arrayf[e1];
            if (c2.c < e2[0].s.c || c2.c > e2[0].e.c) continue;
            if (c2.r < e2[0].s.r || c2.r > e2[0].e.r) continue;
            stack.push(stringify_formula(e2[1], _range, q2, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd) stack.push(
            /*::String(*/
            f2[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        stack.push("{" + stringify_array(
          /*::(*/
          f2[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      /* [MS-XLS] 2.5.198.38 */
      case "PtgAttrSpaceSemi":
        last_sp = ff;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack.push("");
        break;
      case "PtgAreaErr":
        stack.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack.push("#REF!");
        break;
      case "PtgList":
        stack.push("Table" + f2[1].idx + "[#" + f2[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      /* [MS-XLS] 2.5.198.46 */
      case "PtgElfColS":
      /* [MS-XLS] 2.5.198.47 */
      case "PtgElfColSV":
      /* [MS-XLS] 2.5.198.48 */
      case "PtgElfColV":
      /* [MS-XLS] 2.5.198.49 */
      case "PtgElfLel":
      /* [MS-XLS] 2.5.198.50 */
      case "PtgElfRadical":
      /* [MS-XLS] 2.5.198.51 */
      case "PtgElfRadicalLel":
      /* [MS-XLS] 2.5.198.52 */
      case "PtgElfRadicalS":
      /* [MS-XLS] 2.5.198.53 */
      case "PtgElfRw":
      /* [MS-XLS] 2.5.198.54 */
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f2));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f2));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff][0]) == -1) {
        f2 = formula[0][last_sp];
        var _left = true;
        switch (f2[1][0]) {
          /* note: some bad XLSB files omit the PtgParen */
          case 4:
            _left = false;
          /* falls through */
          case 0:
            sp = fill(" ", f2[1][1]);
            break;
          case 5:
            _left = false;
          /* falls through */
          case 1:
            sp = fill("\r", f2[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f2[1][0]);
        }
        stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack.length > 1 && opts.WTF) throw new Error("bad formula stack");
  return stack[0];
}
function parse_ArrayParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_XLSCellParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_NameParsedFormula(blob, length, opts, cce) {
  var target = blob.l + length;
  var rgce = parse_Rgce(blob, cce, opts);
  var rgcb;
  if (target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
  return [rgce, rgcb];
}
function parse_SharedParsedFormula(blob, length, opts) {
  var target = blob.l + length;
  var rgcb, cce = blob.read_shift(2);
  var rgce = parse_Rgce(blob, cce, opts);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  if (length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
  return [rgce, rgcb];
}
function parse_FormulaValue(blob) {
  var b2;
  if (__readUInt16LE(blob, blob.l + 6) !== 65535) return [parse_Xnum(blob), "n"];
  switch (blob[blob.l]) {
    case 0:
      blob.l += 8;
      return ["String", "s"];
    case 1:
      b2 = blob[blob.l + 2] === 1;
      blob.l += 8;
      return [b2, "b"];
    case 2:
      b2 = blob[blob.l + 2];
      blob.l += 8;
      return [b2, "e"];
    case 3:
      blob.l += 8;
      return ["", "s"];
  }
  return [];
}
function parse_Formula(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2) ++blob.l;
  var val = parse_FormulaValue(blob);
  var flags = blob.read_shift(1);
  if (opts.biff != 2) {
    blob.read_shift(1);
    if (opts.biff >= 5) {
      blob.read_shift(4);
    }
  }
  var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
  return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
}
function parse_XLSBParsedFormula(data, length, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb = data.read_shift(4);
  var rgcb = cb > 0 ? parse_RgbExtra(data, cb, rgce, opts) : null;
  return [rgce, rgcb];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(f2) {
  if (f2.slice(0, 3) == "of:") f2 = f2.slice(3);
  if (f2.charCodeAt(0) == 61) {
    f2 = f2.slice(1);
    if (f2.charCodeAt(0) == 61) f2 = f2.slice(1);
  }
  f2 = f2.replace(/COM\.MICROSOFT\./g, "");
  f2 = f2.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
    return $1.replace(/\./g, "");
  });
  f2 = f2.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
  return f2.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function ods_to_csf_3D(r2) {
  var a2 = r2.split(":");
  var s2 = a2[0].split(".")[0];
  return [s2, a2[0].split(".")[1] + (a2.length > 1 ? ":" + (a2[1].split(".")[1] || a2[1].split(".")[0]) : "")];
}
var strs = {};
var _ssfopts = {};
function default_margins(margins, mode) {
  if (!margins) return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml") defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null) margins.left = defs[0];
  if (margins.right == null) margins.right = defs[1];
  if (margins.top == null) margins.top = defs[2];
  if (margins.bottom == null) margins.bottom = defs[3];
  if (margins.header == null) margins.header = defs[4];
  if (margins.footer == null) margins.footer = defs[5];
}
function safe_format(p2, fmtid, fillid, opts, themes, styles) {
  try {
    if (opts.cellNF) p2.z = table_fmt[fmtid];
  } catch (e2) {
    if (opts.WTF) throw e2;
  }
  if (p2.t === "z" && !opts.cellStyles) return;
  if (p2.t === "d" && typeof p2.v === "string") p2.v = parseDate(p2.v);
  if ((!opts || opts.cellText !== false) && p2.t !== "z") try {
    if (table_fmt[fmtid] == null) SSF_load(SSFImplicit[fmtid] || "General", fmtid);
    if (p2.t === "e") p2.w = p2.w || BErr[p2.v];
    else if (fmtid === 0) {
      if (p2.t === "n") {
        if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
        else p2.w = SSF_general_num(p2.v);
      } else if (p2.t === "d") {
        var dd = datenum(p2.v);
        if ((dd | 0) === dd) p2.w = dd.toString(10);
        else p2.w = SSF_general_num(dd);
      } else if (p2.v === void 0) return "";
      else p2.w = SSF_general(p2.v, _ssfopts);
    } else if (p2.t === "d") p2.w = SSF_format(fmtid, datenum(p2.v), _ssfopts);
    else p2.w = SSF_format(fmtid, p2.v, _ssfopts);
  } catch (e2) {
    if (opts.WTF) throw e2;
  }
  if (!opts.cellStyles) return;
  if (fillid != null) try {
    p2.s = styles.Fills[fillid];
    if (p2.s.fgColor && p2.s.fgColor.theme && !p2.s.fgColor.rgb) {
      p2.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb, p2.s.fgColor.tint || 0);
      if (opts.WTF) p2.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb;
    }
    if (p2.s.bgColor && p2.s.bgColor.theme) {
      p2.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb, p2.s.bgColor.tint || 0);
      if (opts.WTF) p2.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb;
    }
  } catch (e2) {
    if (opts.WTF && styles.Fills) throw e2;
  }
}
function parse_ws_xml_dim(ws, s2) {
  var d2 = safe_decode_range(s2);
  if (d2.s.r <= d2.e.r && d2.s.c <= d2.e.c && d2.s.r >= 0 && d2.s.c >= 0) ws["!ref"] = encode_range(d2);
}
var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
var sheetdataregex = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;
var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/mg;
var dimregex = /"(\w*:\w*)"/;
var colregex = /<(?:\w:)?col\b[^>]*[\/]?>/g;
var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
var sheetprregex = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;
var sheetprregex2 = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;
var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function parse_ws_xml(data, opts, idx, rels, wb, themes, styles) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s2 = opts.dense ? [] : {};
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var data1 = "", data2 = "";
  var mtch = data.match(sheetdataregex);
  if (mtch) {
    data1 = data.slice(0, mtch.index);
    data2 = data.slice(mtch.index + mtch[0].length);
  } else data1 = data2 = data;
  var sheetPr = data1.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s2, wb, idx);
  else if (sheetPr = data1.match(sheetprregex2)) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s2, wb, idx);
  var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (ridx > 0) {
    var ref = data1.slice(ridx, ridx + 50).match(dimregex);
    if (ref) parse_ws_xml_dim(s2, ref[1]);
  }
  var svs = data1.match(svsregex);
  if (svs && svs[1]) parse_ws_xml_sheetviews(svs[1], wb);
  var columns = [];
  if (opts.cellStyles) {
    var cols = data1.match(colregex);
    if (cols) parse_ws_xml_cols(columns, cols);
  }
  if (mtch) parse_ws_xml_data(mtch[1], s2, opts, refguess, themes, styles);
  var afilter = data2.match(afregex);
  if (afilter) s2["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
  var merges = [];
  var _merge = data2.match(mergecregex);
  if (_merge) for (ridx = 0; ridx != _merge.length; ++ridx)
    merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
  var hlink = data2.match(hlinkregex);
  if (hlink) parse_ws_xml_hlinks(s2, hlink, rels);
  var margins = data2.match(marginregex);
  if (margins) s2["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
  if (!s2["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r) s2["!ref"] = encode_range(refguess);
  if (opts.sheetRows > 0 && s2["!ref"]) {
    var tmpref = safe_decode_range(s2["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s2["!fullref"] = s2["!ref"];
      s2["!ref"] = encode_range(tmpref);
    }
  }
  if (columns.length > 0) s2["!cols"] = columns;
  if (merges.length > 0) s2["!merges"] = merges;
  return s2;
}
function parse_ws_xml_sheetpr(sheetPr, s2, wb, idx) {
  var data = parsexmltag(sheetPr);
  if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
  if (data.codeName) wb.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
}
function parse_ws_xml_sheetpr2(sheetPr, body, s2, wb, idx) {
  parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s2, wb, idx);
}
function parse_ws_xml_hlinks(s2, data, rels) {
  var dense = Array.isArray(s2);
  for (var i2 = 0; i2 != data.length; ++i2) {
    var val = parsexmltag(utf8read(data[i2]), true);
    if (!val.ref) return;
    var rel = ((rels || {})["!id"] || [])[val.id];
    if (rel) {
      val.Target = rel.Target;
      if (val.location) val.Target += "#" + unescapexml(val.location);
    } else {
      val.Target = "#" + unescapexml(val.location);
      rel = { Target: val.Target, TargetMode: "Internal" };
    }
    val.Rel = rel;
    if (val.tooltip) {
      val.Tooltip = val.tooltip;
      delete val.tooltip;
    }
    var rng = safe_decode_range(val.ref);
    for (var R2 = rng.s.r; R2 <= rng.e.r; ++R2) for (var C2 = rng.s.c; C2 <= rng.e.c; ++C2) {
      var addr = encode_cell({ c: C2, r: R2 });
      if (dense) {
        if (!s2[R2]) s2[R2] = [];
        if (!s2[R2][C2]) s2[R2][C2] = { t: "z", v: void 0 };
        s2[R2][C2].l = val;
      } else {
        if (!s2[addr]) s2[addr] = { t: "z", v: void 0 };
        s2[addr].l = val;
      }
    }
  }
}
function parse_ws_xml_margins(margin) {
  var o2 = {};
  ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k2) {
    if (margin[k2]) o2[k2] = parseFloat(margin[k2]);
  });
  return o2;
}
function parse_ws_xml_cols(columns, cols) {
  var seencol = false;
  for (var coli = 0; coli != cols.length; ++coli) {
    var coll = parsexmltag(cols[coli], true);
    if (coll.hidden) coll.hidden = parsexmlbool(coll.hidden);
    var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
    if (coll.outlineLevel) coll.level = +coll.outlineLevel || 0;
    delete coll.min;
    delete coll.max;
    coll.width = +coll.width;
    if (!seencol && coll.width) {
      seencol = true;
      find_mdw_colw(coll.width);
    }
    process_col(coll);
    while (colm <= colM) columns[colm++] = dup(coll);
  }
}
function parse_ws_xml_autofilter(data) {
  var o2 = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
  return o2;
}
var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
function parse_ws_xml_sheetviews(data, wb) {
  if (!wb.Views) wb.Views = [{}];
  (data.match(sviewregex) || []).forEach(function(r2, i2) {
    var tag = parsexmltag(r2);
    if (!wb.Views[i2]) wb.Views[i2] = {};
    if (+tag.zoomScale) wb.Views[i2].zoom = +tag.zoomScale;
    if (parsexmlbool(tag.rightToLeft)) wb.Views[i2].RTL = true;
  });
}
var parse_ws_xml_data = /* @__PURE__ */ (function() {
  var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
  var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
  var refregex = /ref=["']([^"']*)["']/;
  var match_v = matchtag("v"), match_f = matchtag("f");
  return function parse_ws_xml_data2(sdata, s2, opts, guess, themes, styles) {
    var ri = 0, x2 = "", cells = [], cref = [], idx = 0, i2 = 0, cc = 0, d2 = "", p2;
    var tag, tagr = 0, tagc = 0;
    var sstr, ftag;
    var fmtid = 0, fillid = 0;
    var do_format = Array.isArray(styles.CellXf), cf;
    var arrayf = [];
    var sharedf = [];
    var dense = Array.isArray(s2);
    var rows = [], rowobj = {}, rowrite = false;
    var sheetStubs = !!opts.sheetStubs;
    for (var marr = sdata.split(rowregex), mt2 = 0, marrlen = marr.length; mt2 != marrlen; ++mt2) {
      x2 = marr[mt2].trim();
      var xlen = x2.length;
      if (xlen === 0) continue;
      var rstarti = 0;
      outa: for (ri = 0; ri < xlen; ++ri) switch (
        /*x.charCodeAt(ri)*/
        x2[ri]
      ) {
        case ">":
          if (
            /*x.charCodeAt(ri-1) != 47*/
            x2[ri - 1] != "/"
          ) {
            ++ri;
            break outa;
          }
          if (opts && opts.cellStyles) {
            tag = parsexmltag(x2.slice(rstarti, ri), true);
            tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
            tagc = -1;
            if (opts.sheetRows && opts.sheetRows < tagr) continue;
            rowobj = {};
            rowrite = false;
            if (tag.ht) {
              rowrite = true;
              rowobj.hpt = parseFloat(tag.ht);
              rowobj.hpx = pt2px(rowobj.hpt);
            }
            if (tag.hidden == "1") {
              rowrite = true;
              rowobj.hidden = true;
            }
            if (tag.outlineLevel != null) {
              rowrite = true;
              rowobj.level = +tag.outlineLevel;
            }
            if (rowrite) rows[tagr - 1] = rowobj;
          }
          break;
        case "<":
          rstarti = ri;
          break;
      }
      if (rstarti >= ri) break;
      tag = parsexmltag(x2.slice(rstarti, ri), true);
      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
      tagc = -1;
      if (opts.sheetRows && opts.sheetRows < tagr) continue;
      if (guess.s.r > tagr - 1) guess.s.r = tagr - 1;
      if (guess.e.r < tagr - 1) guess.e.r = tagr - 1;
      if (opts && opts.cellStyles) {
        rowobj = {};
        rowrite = false;
        if (tag.ht) {
          rowrite = true;
          rowobj.hpt = parseFloat(tag.ht);
          rowobj.hpx = pt2px(rowobj.hpt);
        }
        if (tag.hidden == "1") {
          rowrite = true;
          rowobj.hidden = true;
        }
        if (tag.outlineLevel != null) {
          rowrite = true;
          rowobj.level = +tag.outlineLevel;
        }
        if (rowrite) rows[tagr - 1] = rowobj;
      }
      cells = x2.slice(ri).split(cellregex);
      for (var rslice = 0; rslice != cells.length; ++rslice) if (cells[rslice].trim().charAt(0) != "<") break;
      cells = cells.slice(rslice);
      for (ri = 0; ri != cells.length; ++ri) {
        x2 = cells[ri].trim();
        if (x2.length === 0) continue;
        cref = x2.match(rregex);
        idx = ri;
        i2 = 0;
        cc = 0;
        x2 = "<c " + (x2.slice(0, 1) == "<" ? ">" : "") + x2;
        if (cref != null && cref.length === 2) {
          idx = 0;
          d2 = cref[1];
          for (i2 = 0; i2 != d2.length; ++i2) {
            if ((cc = d2.charCodeAt(i2) - 64) < 1 || cc > 26) break;
            idx = 26 * idx + cc;
          }
          --idx;
          tagc = idx;
        } else ++tagc;
        for (i2 = 0; i2 != x2.length; ++i2) if (x2.charCodeAt(i2) === 62) break;
        ++i2;
        tag = parsexmltag(x2.slice(0, i2), true);
        if (!tag.r) tag.r = encode_cell({ r: tagr - 1, c: tagc });
        d2 = x2.slice(i2);
        p2 = { t: "" };
        if ((cref = d2.match(match_v)) != null && /*::cref != null && */
        cref[1] !== "") p2.v = unescapexml(cref[1]);
        if (opts.cellFormula) {
          if ((cref = d2.match(match_f)) != null && /*::cref != null && */
          cref[1] !== "") {
            p2.f = unescapexml(utf8read(cref[1])).replace(/\r\n/g, "\n");
            if (!opts.xlfn) p2.f = _xlfn(p2.f);
            if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="array"') > -1
            ) {
              p2.F = (d2.match(refregex) || [])[1];
              if (p2.F.indexOf(":") > -1) arrayf.push([safe_decode_range(p2.F), p2.F]);
            } else if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="shared"') > -1
            ) {
              ftag = parsexmltag(cref[0]);
              var ___f = unescapexml(utf8read(cref[1]));
              if (!opts.xlfn) ___f = _xlfn(___f);
              sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
            }
          } else if (cref = d2.match(/<f[^>]*\/>/)) {
            ftag = parsexmltag(cref[0]);
            if (sharedf[ftag.si]) p2.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
          }
          var _tag = decode_cell(tag.r);
          for (i2 = 0; i2 < arrayf.length; ++i2)
            if (_tag.r >= arrayf[i2][0].s.r && _tag.r <= arrayf[i2][0].e.r) {
              if (_tag.c >= arrayf[i2][0].s.c && _tag.c <= arrayf[i2][0].e.c)
                p2.F = arrayf[i2][1];
            }
        }
        if (tag.t == null && p2.v === void 0) {
          if (p2.f || p2.F) {
            p2.v = 0;
            p2.t = "n";
          } else if (!sheetStubs) continue;
          else p2.t = "z";
        } else p2.t = tag.t || "n";
        if (guess.s.c > tagc) guess.s.c = tagc;
        if (guess.e.c < tagc) guess.e.c = tagc;
        switch (p2.t) {
          case "n":
            if (p2.v == "" || p2.v == null) {
              if (!sheetStubs) continue;
              p2.t = "z";
            } else p2.v = parseFloat(p2.v);
            break;
          case "s":
            if (typeof p2.v == "undefined") {
              if (!sheetStubs) continue;
              p2.t = "z";
            } else {
              sstr = strs[parseInt(p2.v, 10)];
              p2.v = sstr.t;
              p2.r = sstr.r;
              if (opts.cellHTML) p2.h = sstr.h;
            }
            break;
          case "str":
            p2.t = "s";
            p2.v = p2.v != null ? utf8read(p2.v) : "";
            if (opts.cellHTML) p2.h = escapehtml(p2.v);
            break;
          case "inlineStr":
            cref = d2.match(isregex);
            p2.t = "s";
            if (cref != null && (sstr = parse_si(cref[1]))) {
              p2.v = sstr.t;
              if (opts.cellHTML) p2.h = sstr.h;
            } else p2.v = "";
            break;
          case "b":
            p2.v = parsexmlbool(p2.v);
            break;
          case "d":
            if (opts.cellDates) p2.v = parseDate(p2.v, 1);
            else {
              p2.v = datenum(parseDate(p2.v, 1));
              p2.t = "n";
            }
            break;
          /* error string in .w, number in .v */
          case "e":
            if (!opts || opts.cellText !== false) p2.w = p2.v;
            p2.v = RBErr[p2.v];
            break;
        }
        fmtid = fillid = 0;
        cf = null;
        if (do_format && tag.s !== void 0) {
          cf = styles.CellXf[tag.s];
          if (cf != null) {
            if (cf.numFmtId != null) fmtid = cf.numFmtId;
            if (opts.cellStyles) {
              if (cf.fillId != null) fillid = cf.fillId;
            }
          }
        }
        safe_format(p2, fmtid, fillid, opts, themes, styles);
        if (opts.cellDates && do_format && p2.t == "n" && fmt_is_date(table_fmt[fmtid])) {
          p2.t = "d";
          p2.v = numdate(p2.v);
        }
        if (tag.cm && opts.xlmeta) {
          var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
          if (cm && cm.type == "XLDAPR") p2.D = true;
        }
        if (dense) {
          var _r = decode_cell(tag.r);
          if (!s2[_r.r]) s2[_r.r] = [];
          s2[_r.r][_r.c] = p2;
        } else s2[tag.r] = p2;
      }
    }
    if (rows.length > 0) s2["!rows"] = rows;
  };
})();
function parse_BrtRowHdr(data, length) {
  var z2 = {};
  var tgt = data.l + length;
  z2.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7) z2.level = flags & 7;
  if (flags & 16) z2.hidden = true;
  if (flags & 32) z2.hpt = miyRw / 20;
  return z2;
}
var parse_BrtWsDim = parse_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(data, length) {
  var z2 = {};
  var f2 = data[data.l];
  ++data.l;
  z2.above = !(f2 & 64);
  z2.left = !(f2 & 128);
  data.l += 18;
  z2.name = parse_XLSBCodeName(data);
  return z2;
}
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function parse_BrtFmlaBool(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaError(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaNum(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o2 = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaString(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o2 = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
var parse_BrtMergeCell = parse_UncheckedRfX;
function parse_BrtHLink(data, length) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip = parse_XLWideString(data);
  var display2 = parse_XLWideString(data);
  data.l = end;
  var o2 = { rfx, relId, loc, display: display2 };
  if (tooltip) o2.Tooltip = tooltip;
  return o2;
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o2 = [rfx];
  o2[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
  } else data.l = end;
  return o2;
}
function parse_BrtShrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var o2 = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
    data.l = end;
  } else data.l = end;
  return o2;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k2) {
    margins[k2] = parse_Xnum(data);
  });
  return margins;
}
function parse_BrtBeginWsView(data) {
  var f2 = data.read_shift(2);
  data.l += 28;
  return { RTL: f2 & 32 };
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(data, _opts, idx, rels, wb, themes, styles) {
  if (!data) return data;
  var opts = _opts || {};
  if (!rels) rels = { "!id": {} };
  var s2 = opts.dense ? [] : {};
  var ref;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var pass = false, end = false;
  var row, p2, cf, R2, C2, addr, sstr, rr, cell;
  var merges = [];
  opts.biff = 12;
  opts["!row"] = 0;
  var ai = 0, af = false;
  var arrayf = [];
  var sharedf = {};
  var supbooks = opts.supbooks || /*::(*/
  wb.supbooks || [[]];
  supbooks.sharedf = sharedf;
  supbooks.arrayf = arrayf;
  supbooks.SheetNames = wb.SheetNames || wb.Sheets.map(function(x2) {
    return x2.name;
  });
  if (!opts.supbooks) {
    opts.supbooks = supbooks;
    if (wb.Names) for (var i2 = 0; i2 < wb.Names.length; ++i2) supbooks[0][i2 + 1] = wb.Names[i2];
  }
  var colinfo = [], rowinfo = [];
  var seencol = false;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var cm;
  recordhopper(data, function ws_parse(val, RR, RT) {
    if (end) return;
    switch (RT) {
      case 148:
        ref = val;
        break;
      case 0:
        row = val;
        if (opts.sheetRows && opts.sheetRows <= row.r) end = true;
        rr = encode_row(R2 = row.r);
        opts["!row"] = row.r;
        if (val.hidden || val.hpt || val.level != null) {
          if (val.hpt) val.hpx = pt2px(val.hpt);
          rowinfo[val.r] = val;
        }
        break;
      case 2:
      /* 'BrtCellRk' */
      case 3:
      /* 'BrtCellError' */
      case 4:
      /* 'BrtCellBool' */
      case 5:
      /* 'BrtCellReal' */
      case 6:
      /* 'BrtCellSt' */
      case 7:
      /* 'BrtCellIsst' */
      case 8:
      /* 'BrtFmlaString' */
      case 9:
      /* 'BrtFmlaNum' */
      case 10:
      /* 'BrtFmlaBool' */
      case 11:
      /* 'BrtFmlaError' */
      case 13:
      /* 'BrtShortRk' */
      case 14:
      /* 'BrtShortError' */
      case 15:
      /* 'BrtShortBool' */
      case 16:
      /* 'BrtShortReal' */
      case 17:
      /* 'BrtShortSt' */
      case 18:
      /* 'BrtShortIsst' */
      case 62:
        p2 = { t: val[2] };
        switch (val[2]) {
          case "n":
            p2.v = val[1];
            break;
          case "s":
            sstr = strs[val[1]];
            p2.v = sstr.t;
            p2.r = sstr.r;
            break;
          case "b":
            p2.v = val[1] ? true : false;
            break;
          case "e":
            p2.v = val[1];
            if (opts.cellText !== false) p2.w = BErr[p2.v];
            break;
          case "str":
            p2.t = "s";
            p2.v = val[1];
            break;
          case "is":
            p2.t = "s";
            p2.v = val[1].t;
            break;
        }
        if (cf = styles.CellXf[val[0].iStyleRef]) safe_format(p2, cf.numFmtId, null, opts, themes, styles);
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s2[R2]) s2[R2] = [];
          s2[R2][C2] = p2;
        } else s2[encode_col(C2) + rr] = p2;
        if (opts.cellFormula) {
          af = false;
          for (ai = 0; ai < arrayf.length; ++ai) {
            var aii = arrayf[ai];
            if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
              if (C2 >= aii[0].s.c && C2 <= aii[0].e.c) {
                p2.F = encode_range(aii[0]);
                af = true;
              }
            }
          }
          if (!af && val.length > 3) p2.f = val[3];
        }
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (opts.cellDates && cf && p2.t == "n" && fmt_is_date(table_fmt[cf.numFmtId])) {
          var _d = SSF_parse_date_code(p2.v);
          if (_d) {
            p2.t = "d";
            p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
          }
        }
        if (cm) {
          if (cm.type == "XLDAPR") p2.D = true;
          cm = void 0;
        }
        break;
      case 1:
      /* 'BrtCellBlank' */
      case 12:
        if (!opts.sheetStubs || pass) break;
        p2 = { t: "z", v: void 0 };
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s2[R2]) s2[R2] = [];
          s2[R2][C2] = p2;
        } else s2[encode_col(C2) + rr] = p2;
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (cm) {
          if (cm.type == "XLDAPR") p2.D = true;
          cm = void 0;
        }
        break;
      case 176:
        merges.push(val);
        break;
      case 49:
        {
          cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
        }
        break;
      case 494:
        var rel = rels["!id"][val.relId];
        if (rel) {
          val.Target = rel.Target;
          if (val.loc) val.Target += "#" + val.loc;
          val.Rel = rel;
        } else if (val.relId == "") {
          val.Target = "#" + val.loc;
        }
        for (R2 = val.rfx.s.r; R2 <= val.rfx.e.r; ++R2) for (C2 = val.rfx.s.c; C2 <= val.rfx.e.c; ++C2) {
          if (opts.dense) {
            if (!s2[R2]) s2[R2] = [];
            if (!s2[R2][C2]) s2[R2][C2] = { t: "z", v: void 0 };
            s2[R2][C2].l = val;
          } else {
            addr = encode_cell({ c: C2, r: R2 });
            if (!s2[addr]) s2[addr] = { t: "z", v: void 0 };
            s2[addr].l = val;
          }
        }
        break;
      case 426:
        if (!opts.cellFormula) break;
        arrayf.push(val);
        cell = opts.dense ? s2[R2][C2] : s2[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        cell.F = encode_range(val[0]);
        break;
      case 427:
        if (!opts.cellFormula) break;
        sharedf[encode_cell(val[0].s)] = val[1];
        cell = opts.dense ? s2[R2][C2] : s2[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        break;
      /* identical to 'ColInfo' in XLS */
      case 60:
        if (!opts.cellStyles) break;
        while (val.e >= val.s) {
          colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
          if (!seencol) {
            seencol = true;
            find_mdw_colw(val.w / 256);
          }
          process_col(colinfo[val.e + 1]);
        }
        break;
      case 161:
        s2["!autofilter"] = { ref: encode_range(val) };
        break;
      case 476:
        s2["!margins"] = val;
        break;
      case 147:
        if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
        if (val.name) wb.Sheets[idx].CodeName = val.name;
        if (val.above || val.left) s2["!outline"] = { above: val.above, left: val.left };
        break;
      case 137:
        if (!wb.Views) wb.Views = [{}];
        if (!wb.Views[0]) wb.Views[0] = {};
        if (val.RTL) wb.Views[0].RTL = true;
        break;
      case 485:
        break;
      case 64:
      /* 'BrtDVal' */
      case 1053:
        break;
      case 151:
        break;
      case 152:
      /* 'BrtSel' */
      case 175:
      /* 'BrtAFilterDateGroupItem' */
      case 644:
      /* 'BrtActiveX' */
      case 625:
      /* 'BrtBigName' */
      case 562:
      /* 'BrtBkHim' */
      case 396:
      /* 'BrtBrk' */
      case 1112:
      /* 'BrtCFIcon' */
      case 1146:
      /* 'BrtCFRuleExt' */
      case 471:
      /* 'BrtCFVO' */
      case 1050:
      /* 'BrtCFVO14' */
      case 649:
      /* 'BrtCellIgnoreEC' */
      case 1105:
      /* 'BrtCellIgnoreEC14' */
      case 589:
      /* 'BrtCellSmartTagProperty' */
      case 607:
      /* 'BrtCellWatch' */
      case 564:
      /* 'BrtColor' */
      case 1055:
      /* 'BrtColor14' */
      case 168:
      /* 'BrtColorFilter' */
      case 174:
      /* 'BrtCustomFilter' */
      case 1180:
      /* 'BrtCustomFilter14' */
      case 499:
      /* 'BrtDRef' */
      case 507:
      /* 'BrtDXF' */
      case 550:
      /* 'BrtDrawing' */
      case 171:
      /* 'BrtDynamicFilter' */
      case 167:
      /* 'BrtFilter' */
      case 1177:
      /* 'BrtFilter14' */
      case 169:
      /* 'BrtIconFilter' */
      case 1181:
      /* 'BrtIconFilter14' */
      case 551:
      /* 'BrtLegacyDrawing' */
      case 552:
      /* 'BrtLegacyDrawingHF' */
      case 661:
      /* 'BrtListPart' */
      case 639:
      /* 'BrtOleObject' */
      case 478:
      /* 'BrtPageSetup' */
      case 537:
      /* 'BrtPhoneticInfo' */
      case 477:
      /* 'BrtPrintOptions' */
      case 536:
      /* 'BrtRangeProtection' */
      case 1103:
      /* 'BrtRangeProtection14' */
      case 680:
      /* 'BrtRangeProtectionIso' */
      case 1104:
      /* 'BrtRangeProtectionIso14' */
      case 1024:
      /* 'BrtRwDescent' */
      case 663:
      /* 'BrtSheetCalcProp' */
      case 535:
      /* 'BrtSheetProtection' */
      case 678:
      /* 'BrtSheetProtectionIso' */
      case 504:
      /* 'BrtSlc' */
      case 1043:
      /* 'BrtSparkline' */
      case 428:
      /* 'BrtTable' */
      case 170:
      /* 'BrtTop10Filter' */
      case 3072:
      /* 'BrtUid' */
      case 50:
      /* 'BrtValueMeta' */
      case 2070:
      /* 'BrtWebExtension' */
      case 1045:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        pass = true;
        break;
      case 38:
        pass = false;
        break;
      default:
        if (RR.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  delete opts.supbooks;
  delete opts["!row"];
  if (!s2["!ref"] && (refguess.s.r < 2e6 || ref && (ref.e.r > 0 || ref.e.c > 0 || ref.s.r > 0 || ref.s.c > 0))) s2["!ref"] = encode_range(ref || refguess);
  if (opts.sheetRows && s2["!ref"]) {
    var tmpref = safe_decode_range(s2["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s2["!fullref"] = s2["!ref"];
      s2["!ref"] = encode_range(tmpref);
    }
  }
  if (merges.length > 0) s2["!merges"] = merges;
  if (colinfo.length > 0) s2["!cols"] = colinfo;
  if (rowinfo.length > 0) s2["!rows"] = rowinfo;
  return s2;
}
function parse_Cache(data) {
  var col = [];
  var num = data.match(/^<c:numCache>/);
  var f2;
  (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(pt2) {
    var q2 = pt2.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    if (!q2) return;
    col[+q2[1]] = num ? +q2[2] : q2[2];
  });
  var nf = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  (data.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(F2) {
    f2 = F2.replace(/<.*?>/g, "");
  });
  return [col, nf, f2];
}
function parse_chart(data, name, opts, rels, wb, csheet) {
  var cs = csheet || { "!type": "chart" };
  if (!data) return csheet;
  var C2 = 0, R2 = 0, col = "A";
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc) {
    var cache = parse_Cache(nc);
    refguess.s.r = refguess.s.c = 0;
    refguess.e.c = C2;
    col = encode_col(C2);
    cache[0].forEach(function(n2, i2) {
      cs[col + encode_row(i2)] = { t: "n", v: n2, z: cache[1] };
      R2 = i2;
    });
    if (refguess.e.r < R2) refguess.e.r = R2;
    ++C2;
  });
  if (C2 > 0) cs["!ref"] = encode_range(refguess);
  return cs;
}
function parse_cs_xml(data, opts, idx, rels, wb) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s2 = { "!type": "chart", "!drawel": null, "!rel": "" };
  var m2;
  var sheetPr = data.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s2, wb, idx);
  if (m2 = data.match(/drawing r:id="(.*?)"/)) s2["!rel"] = m2[1];
  if (rels["!id"][s2["!rel"]]) s2["!drawel"] = rels["!id"][s2["!rel"]];
  return s2;
}
function parse_BrtCsProp(data, length) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
function parse_cs_bin(data, opts, idx, rels, wb) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s2 = { "!type": "chart", "!drawel": null, "!rel": "" };
  var pass = false;
  recordhopper(data, function cs_parse(val, R2, RT) {
    switch (RT) {
      case 550:
        s2["!rel"] = val;
        break;
      case 651:
        if (!wb.Sheets[idx]) wb.Sheets[idx] = {};
        if (val.name) wb.Sheets[idx].CodeName = val.name;
        break;
      case 562:
      /* 'BrtBkHim' */
      case 652:
      /* 'BrtCsPageSetup' */
      case 669:
      /* 'BrtCsProtection' */
      case 679:
      /* 'BrtCsProtectionIso' */
      case 551:
      /* 'BrtLegacyDrawing' */
      case 552:
      /* 'BrtLegacyDrawingHF' */
      case 476:
      /* 'BrtMargins' */
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R2.T > 0) ;
        else if (R2.T < 0) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  if (rels["!id"][s2["!rel"]]) s2["!drawel"] = rels["!id"][s2["!rel"]];
  return s2;
}
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
var WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", true, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", false, "bool"],
  ["showHorizontalScroll", true, "bool"],
  ["showSheetTabs", true, "bool"],
  ["showVerticalScroll", true, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
];
var SheetDef = [
  //['state', 'visible']
];
var CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(target, defaults2) {
  for (var j2 = 0; j2 != target.length; ++j2) {
    var w2 = target[j2];
    for (var i2 = 0; i2 != defaults2.length; ++i2) {
      var z2 = defaults2[i2];
      if (w2[z2[0]] == null) w2[z2[0]] = z2[1];
      else switch (z2[2]) {
        case "bool":
          if (typeof w2[z2[0]] == "string") w2[z2[0]] = parsexmlbool(w2[z2[0]]);
          break;
        case "int":
          if (typeof w2[z2[0]] == "string") w2[z2[0]] = parseInt(w2[z2[0]], 10);
          break;
      }
    }
  }
}
function push_defaults(target, defaults2) {
  for (var i2 = 0; i2 != defaults2.length; ++i2) {
    var z2 = defaults2[i2];
    if (target[z2[0]] == null) target[z2[0]] = z2[1];
    else switch (z2[2]) {
      case "bool":
        if (typeof target[z2[0]] == "string") target[z2[0]] = parsexmlbool(target[z2[0]]);
        break;
      case "int":
        if (typeof target[z2[0]] == "string") target[z2[0]] = parseInt(target[z2[0]], 10);
        break;
    }
  }
}
function parse_wb_defaults(wb) {
  push_defaults(wb.WBProps, WBPropsDef);
  push_defaults(wb.CalcPr, CalcPrDef);
  push_defaults_array(wb.WBView, WBViewDef);
  push_defaults_array(wb.Sheets, SheetDef);
  _ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904);
}
var badchars = /* @__PURE__ */ "][*?/\\".split("");
function check_ws_name(n2, safe) {
  if (n2.length > 31) {
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var _good = true;
  badchars.forEach(function(c2) {
    if (n2.indexOf(c2) == -1) return;
    throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
  });
  return _good;
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(data, opts) {
  if (!data) throw new Error("Could not find file");
  var wb = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  );
  var pass = false, xmlns = "xmlns";
  var dname = {}, dnstart = 0;
  data.replace(tagregex, function xml_wb(x2, idx) {
    var y2 = parsexmltag(x2);
    switch (strip_ns(y2[0])) {
      case "<?xml":
        break;
      /* 18.2.27 workbook CT_Workbook 1 */
      case "<workbook":
        if (x2.match(wbnsregex)) xmlns = "xmlns" + x2.match(/<(\w+):/)[1];
        wb.xmlns = y2[xmlns];
        break;
      case "</workbook>":
        break;
      /* 18.2.13 fileVersion CT_FileVersion ? */
      case "<fileVersion":
        delete y2[0];
        wb.AppVersion = y2;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      /* 18.2.12 fileSharing CT_FileSharing ? */
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      /* 18.2.28 workbookPr CT_WorkbookPr ? */
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(w2) {
          if (y2[w2[0]] == null) return;
          switch (w2[2]) {
            case "bool":
              wb.WBProps[w2[0]] = parsexmlbool(y2[w2[0]]);
              break;
            case "int":
              wb.WBProps[w2[0]] = parseInt(y2[w2[0]], 10);
              break;
            default:
              wb.WBProps[w2[0]] = y2[w2[0]];
          }
        });
        if (y2.codeName) wb.WBProps.CodeName = utf8read(y2.codeName);
        break;
      case "</workbookPr>":
        break;
      /* 18.2.29 workbookProtection CT_WorkbookProtection ? */
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      /* 18.2.1  bookViews CT_BookViews ? */
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      /* 18.2.30   workbookView CT_BookView + */
      case "<workbookView":
      case "<workbookView/>":
        delete y2[0];
        wb.WBView.push(y2);
        break;
      case "</workbookView>":
        break;
      /* 18.2.20 sheets CT_Sheets 1 */
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      // aggregate sheet
      /* 18.2.19   sheet CT_Sheet + */
      case "<sheet":
        switch (y2.state) {
          case "hidden":
            y2.Hidden = 1;
            break;
          case "veryHidden":
            y2.Hidden = 2;
            break;
          default:
            y2.Hidden = 0;
        }
        delete y2.state;
        y2.name = unescapexml(utf8read(y2.name));
        delete y2[0];
        wb.Sheets.push(y2);
        break;
      case "</sheet>":
        break;
      /* 18.2.15 functionGroups CT_FunctionGroups ? */
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      /* 18.2.14   functionGroup CT_FunctionGroup + */
      case "<functionGroup":
        break;
      /* 18.2.9  externalReferences CT_ExternalReferences ? */
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      /* 18.2.8    externalReference CT_ExternalReference + */
      case "<externalReference":
        break;
      /* 18.2.6  definedNames CT_DefinedNames ? */
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        pass = true;
        break;
      case "</definedNames>":
        pass = false;
        break;
      /* 18.2.5    definedName CT_DefinedName + */
      case "<definedName":
        {
          dname = {};
          dname.Name = utf8read(y2.name);
          if (y2.comment) dname.Comment = y2.comment;
          if (y2.localSheetId) dname.Sheet = +y2.localSheetId;
          if (parsexmlbool(y2.hidden || "0")) dname.Hidden = true;
          dnstart = idx + x2.length;
        }
        break;
      case "</definedName>":
        {
          dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
          wb.Names.push(dname);
        }
        break;
      case "<definedName/>":
        break;
      /* 18.2.2  calcPr CT_CalcPr ? */
      case "<calcPr":
        delete y2[0];
        wb.CalcPr = y2;
        break;
      case "<calcPr/>":
        delete y2[0];
        wb.CalcPr = y2;
        break;
      case "</calcPr>":
        break;
      /* 18.2.16 oleSize CT_OleSize ? (ref required) */
      case "<oleSize":
        break;
      /* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      /* 18.2.3  customWorkbookView CT_CustomWorkbookView + */
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      /* 18.2.18 pivotCaches CT_PivotCaches ? */
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      /* 18.2.17 pivotCache CT_PivotCache ? */
      case "<pivotCache":
        break;
      /* 18.2.21 smartTagPr CT_SmartTagPr ? */
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      /* 18.2.23 smartTagTypes CT_SmartTagTypes ? */
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      /* 18.2.22 smartTagType CT_SmartTagType ? */
      case "<smartTagType":
        break;
      /* 18.2.24 webPublishing CT_WebPublishing ? */
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      /* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      /* 18.2.26 webPublishObjects CT_WebPublishObjects ? */
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      /* 18.2.25 webPublishObject CT_WebPublishObject ? */
      case "<webPublishObject":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        pass = true;
        break;
      //TODO: check with versions of excel
      case "</ext>":
        pass = false;
        break;
      /* Others */
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      /* TODO */
      case "<revisionPtr":
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y2[0] + " in workbook");
    }
    return x2;
  });
  if (XMLNS_main.indexOf(wb.xmlns) === -1) throw new Error("Unknown Namespace: " + wb.xmlns);
  parse_wb_defaults(wb);
  return wb;
}
function parse_BrtBundleSh(data, length) {
  var z2 = {};
  z2.Hidden = data.read_shift(4);
  z2.iTabID = data.read_shift(4);
  z2.strRelID = parse_RelID(data);
  z2.name = parse_XLWideString(data);
  return z2;
}
function parse_BrtWbProp(data, length) {
  var o2 = {};
  var flags = data.read_shift(4);
  o2.defaultThemeVersion = data.read_shift(4);
  var strName = length > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0) o2.CodeName = strName;
  o2.autoCompressPictures = !!(flags & 65536);
  o2.backupFile = !!(flags & 64);
  o2.checkCompatibility = !!(flags & 4096);
  o2.date1904 = !!(flags & 1);
  o2.filterPrivacy = !!(flags & 8);
  o2.hidePivotFieldList = !!(flags & 1024);
  o2.promptedSolutions = !!(flags & 16);
  o2.publishItems = !!(flags & 2048);
  o2.refreshAllConnections = !!(flags & 262144);
  o2.saveExternalLinkValues = !!(flags & 128);
  o2.showBorderUnselectedTables = !!(flags & 4);
  o2.showInkAnnotation = !!(flags & 32);
  o2.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o2.showPivotChartFilter = !!(flags & 32768);
  o2.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o2;
}
function parse_BrtFRTArchID$(data, length) {
  var o2 = {};
  data.read_shift(4);
  o2.ArchID = data.read_shift(4);
  data.l += length - 8;
  return o2;
}
function parse_BrtName(data, length, opts) {
  var end = data.l + length;
  data.l += 4;
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  var comment = parse_XLNullableWideString(data);
  data.l = end;
  var out = { Name: name, Ptg: formula };
  if (itab < 268435455) out.Sheet = itab;
  if (comment) out.Comment = comment;
  return out;
}
function parse_wb_bin(data, opts) {
  var wb = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
  var state = [];
  var pass = false;
  if (!opts) opts = {};
  opts.biff = 12;
  var Names = [];
  var supbooks = [[]];
  supbooks.SheetNames = [];
  supbooks.XTI = [];
  XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
  recordhopper(data, function hopper_wb(val, R2, RT) {
    switch (RT) {
      case 156:
        supbooks.SheetNames.push(val.name);
        wb.Sheets.push(val);
        break;
      case 153:
        wb.WBProps = val;
        break;
      case 39:
        if (val.Sheet != null) opts.SID = val.Sheet;
        val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
        delete opts.SID;
        delete val.Ptg;
        Names.push(val);
        break;
      case 1036:
        break;
      case 357:
      /* 'BrtSupSelf' */
      case 358:
      /* 'BrtSupSame' */
      case 355:
      /* 'BrtSupBookSrc' */
      case 667:
        if (!supbooks[0].length) supbooks[0] = [RT, val];
        else supbooks.push([RT, val]);
        supbooks[supbooks.length - 1].XTI = [];
        break;
      case 362:
        if (supbooks.length === 0) {
          supbooks[0] = [];
          supbooks[0].XTI = [];
        }
        supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
        supbooks.XTI = supbooks.XTI.concat(val);
        break;
      case 361:
        break;
      case 2071:
      /* 'BrtAbsPath15' */
      case 158:
      /* 'BrtBookView' */
      case 143:
      /* 'BrtBeginBundleShs' */
      case 664:
      /* 'BrtBeginFnGroup' */
      case 353:
        break;
      /* case 'BrtModelTimeGroupingCalcCol' */
      case 3072:
      /* 'BrtUid' */
      case 3073:
      /* 'BrtRevisionPtr' */
      case 534:
      /* 'BrtBookProtection' */
      case 677:
      /* 'BrtBookProtectionIso' */
      case 157:
      /* 'BrtCalcProp' */
      case 610:
      /* 'BrtCrashRecErr' */
      case 2050:
      /* 'BrtDecoupledPivotCacheID' */
      case 155:
      /* 'BrtFileRecover' */
      case 548:
      /* 'BrtFileSharing' */
      case 676:
      /* 'BrtFileSharingIso' */
      case 128:
      /* 'BrtFileVersion' */
      case 665:
      /* 'BrtFnGroup' */
      case 2128:
      /* 'BrtModelRelationship' */
      case 2125:
      /* 'BrtModelTable' */
      case 549:
      /* 'BrtOleSize' */
      case 2053:
      /* 'BrtPivotTableRef' */
      case 596:
      /* 'BrtSmartTagType' */
      case 2076:
      /* 'BrtTableSlicerCacheID' */
      case 2075:
      /* 'BrtTableSlicerCacheIDs' */
      case 2082:
      /* 'BrtTimelineCachePivotCacheID' */
      case 397:
      /* 'BrtUserBookView' */
      case 154:
      /* 'BrtWbFactoid' */
      case 1117:
      /* 'BrtWbProp14' */
      case 553:
      /* 'BrtWebOpt' */
      case 2091:
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      case 16:
        break;
      default:
        if (R2.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  parse_wb_defaults(wb);
  wb.Names = Names;
  wb.supbooks = supbooks;
  return wb;
}
function parse_wb(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_wb_bin(data, opts);
  return parse_wb_xml(data, opts);
}
function parse_ws(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ws_bin(data, opts, idx, rels, wb, themes, styles);
  return parse_ws_xml(data, opts, idx, rels, wb, themes, styles);
}
function parse_cs(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_cs_bin(data, opts, idx, rels, wb);
  return parse_cs_xml(data, opts, idx, rels, wb);
}
function parse_ms(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ms_bin();
  return parse_ms_xml();
}
function parse_ds(data, name, idx, opts, rels, wb, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ds_bin();
  return parse_ds_xml();
}
function parse_sty(data, name, themes, opts) {
  if (name.slice(-4) === ".bin") return parse_sty_bin(data, themes, opts);
  return parse_sty_xml(data, themes, opts);
}
function parse_theme(data, name, opts) {
  return parse_theme_xml(data, opts);
}
function parse_sst(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_sst_bin(data, opts);
  return parse_sst_xml(data, opts);
}
function parse_cmnt(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_comments_bin(data, opts);
  return parse_comments_xml(data, opts);
}
function parse_cc(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_cc_bin(data);
  return parse_cc_xml(data);
}
function parse_xlink(data, rel, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlink_bin(data, rel, name, opts);
  return parse_xlink_xml();
}
function parse_xlmeta(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlmeta_bin(data, name, opts);
  return parse_xlmeta_xml(data, name, opts);
}
var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(tag, skip_root) {
  var words = tag.split(/\s+/);
  var z2 = [];
  z2[0] = words[0];
  if (words.length === 1) return z2;
  var m2 = tag.match(attregexg2), y2, j2, w2, i2;
  if (m2) for (i2 = 0; i2 != m2.length; ++i2) {
    y2 = m2[i2].match(attregex2);
    if ((j2 = y2[1].indexOf(":")) === -1) z2[y2[1]] = y2[2].slice(1, y2[2].length - 1);
    else {
      if (y2[1].slice(0, 6) === "xmlns:") w2 = "xmlns" + y2[1].slice(6);
      else w2 = y2[1].slice(j2 + 1);
      z2[w2] = y2[2].slice(1, y2[2].length - 1);
    }
  }
  return z2;
}
function xlml_parsexmltagobj(tag) {
  var words = tag.split(/\s+/);
  var z2 = {};
  if (words.length === 1) return z2;
  var m2 = tag.match(attregexg2), y2, j2, w2, i2;
  if (m2) for (i2 = 0; i2 != m2.length; ++i2) {
    y2 = m2[i2].match(attregex2);
    if ((j2 = y2[1].indexOf(":")) === -1) z2[y2[1]] = y2[2].slice(1, y2[2].length - 1);
    else {
      if (y2[1].slice(0, 6) === "xmlns:") w2 = "xmlns" + y2[1].slice(6);
      else w2 = y2[1].slice(j2 + 1);
      z2[w2] = y2[2].slice(1, y2[2].length - 1);
    }
  }
  return z2;
}
var XLMLFormatMap;
function xlml_format(format, value) {
  var fmt = XLMLFormatMap[format] || unescapexml(format);
  if (fmt === "General") return SSF_general(value);
  return SSF_format(fmt, value);
}
function xlml_set_custprop(Custprops, key, cp, val) {
  var oval = val;
  switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      oval = parsexmlbool(val);
      break;
    case "i2":
    case "int":
      oval = parseInt(val, 10);
      break;
    case "r4":
    case "float":
      oval = parseFloat(val);
      break;
    case "date":
    case "dateTime.tz":
      oval = parseDate(val);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + cp[0]);
  }
  Custprops[unescapexml(key)] = oval;
}
function safe_format_xlml(cell, nf, o2) {
  if (cell.t === "z") return;
  if (!o2 || o2.cellText !== false) try {
    if (cell.t === "e") {
      cell.w = cell.w || BErr[cell.v];
    } else if (nf === "General") {
      if (cell.t === "n") {
        if ((cell.v | 0) === cell.v) cell.w = cell.v.toString(10);
        else cell.w = SSF_general_num(cell.v);
      } else cell.w = SSF_general(cell.v);
    } else cell.w = xlml_format(nf || "General", cell.v);
  } catch (e2) {
    if (o2.WTF) throw e2;
  }
  try {
    var z2 = XLMLFormatMap[nf] || nf || "General";
    if (o2.cellNF) cell.z = z2;
    if (o2.cellDates && cell.t == "n" && fmt_is_date(z2)) {
      var _d = SSF_parse_date_code(cell.v);
      if (_d) {
        cell.t = "d";
        cell.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
      }
    }
  } catch (e2) {
    if (o2.WTF) throw e2;
  }
}
function process_style_xlml(styles, stag, opts) {
  if (opts.cellStyles) {
    if (stag.Interior) {
      var I2 = stag.Interior;
      if (I2.Pattern) I2.patternType = XLMLPatternTypeMap[I2.Pattern] || I2.Pattern;
    }
  }
  styles[stag.ID] = stag;
}
function parse_xlml_data(xml2, ss, data, cell, base, styles, csty, row, arrayf, o2) {
  var nf = "General", sid = cell.StyleID, S2 = {};
  o2 = o2 || {};
  var interiors = [];
  var i2 = 0;
  if (sid === void 0 && row) sid = row.StyleID;
  if (sid === void 0 && csty) sid = csty.StyleID;
  while (styles[sid] !== void 0) {
    if (styles[sid].nf) nf = styles[sid].nf;
    if (styles[sid].Interior) interiors.push(styles[sid].Interior);
    if (!styles[sid].Parent) break;
    sid = styles[sid].Parent;
  }
  switch (data.Type) {
    case "Boolean":
      cell.t = "b";
      cell.v = parsexmlbool(xml2);
      break;
    case "String":
      cell.t = "s";
      cell.r = xlml_fixstr(unescapexml(xml2));
      cell.v = xml2.indexOf("<") > -1 ? unescapexml(ss || xml2).replace(/<.*?>/g, "") : cell.r;
      break;
    case "DateTime":
      if (xml2.slice(-1) != "Z") xml2 += "Z";
      cell.v = (parseDate(xml2) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
      if (cell.v !== cell.v) cell.v = unescapexml(xml2);
      else if (cell.v < 60) cell.v = cell.v - 1;
      if (!nf || nf == "General") nf = "yyyy-mm-dd";
    /* falls through */
    case "Number":
      if (cell.v === void 0) cell.v = +xml2;
      if (!cell.t) cell.t = "n";
      break;
    case "Error":
      cell.t = "e";
      cell.v = RBErr[xml2];
      if (o2.cellText !== false) cell.w = xml2;
      break;
    default:
      if (xml2 == "" && ss == "") {
        cell.t = "z";
      } else {
        cell.t = "s";
        cell.v = xlml_fixstr(ss || xml2);
      }
      break;
  }
  safe_format_xlml(cell, nf, o2);
  if (o2.cellFormula !== false) {
    if (cell.Formula) {
      var fstr = unescapexml(cell.Formula);
      if (fstr.charCodeAt(0) == 61) fstr = fstr.slice(1);
      cell.f = rc_to_a1(fstr, base);
      delete cell.Formula;
      if (cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);
      else if (cell.ArrayRange) {
        cell.F = rc_to_a1(cell.ArrayRange, base);
        arrayf.push([safe_decode_range(cell.F), cell.F]);
      }
    } else {
      for (i2 = 0; i2 < arrayf.length; ++i2)
        if (base.r >= arrayf[i2][0].s.r && base.r <= arrayf[i2][0].e.r) {
          if (base.c >= arrayf[i2][0].s.c && base.c <= arrayf[i2][0].e.c)
            cell.F = arrayf[i2][1];
        }
    }
  }
  if (o2.cellStyles) {
    interiors.forEach(function(x2) {
      if (!S2.patternType && x2.patternType) S2.patternType = x2.patternType;
    });
    cell.s = S2;
  }
  if (cell.StyleID !== void 0) cell.ixfe = cell.StyleID;
}
function xlml_clean_comment(comment) {
  comment.t = comment.v || "";
  comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  comment.v = comment.w = comment.ixfe = void 0;
}
function parse_xlml_xml(d2, _opts) {
  var opts = _opts || {};
  make_ssf();
  var str = debom(xlml_normalize(d2));
  if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
    str = utf8read(str);
  }
  var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
  opening = opening.replace(/".*?"/g, "");
  if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
    var _o = dup(opts);
    _o.type = "string";
    return PRN.to_workbook(str, _o);
  }
  if (opening.indexOf("<?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
    if (opening.indexOf("<" + tag) >= 0) ishtml = true;
  });
  if (ishtml) return html_to_workbook(str, opts);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "Fixed": table_fmt[2],
    "Standard": table_fmt[4],
    "Percent": table_fmt[10],
    "Scientific": table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var Rn;
  var state = [], tmp;
  var sheets = {}, sheetnames = [], cursheet = opts.dense ? [] : {}, sheetname = "";
  var cell = {}, row = {};
  var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
  var c2 = 0, r2 = 0;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var styles = {}, stag = {};
  var ss = "", fidx = 0;
  var merges = [];
  var Props = {}, Custprops = {}, pidx = 0, cp = [];
  var comments = [], comment = {};
  var cstys = [], csty, seencol = false;
  var arrayf = [];
  var rowinfo = [], rowobj = {}, cc = 0, rr = 0;
  var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "");
  var raw_Rn3 = "";
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
    case "data":
      if (raw_Rn3 == "data") {
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        break;
      }
      if (state[state.length - 1][1]) break;
      if (Rn[1] === "/") parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
      "comment" ? comment : cell, { c: c2, r: r2 }, styles, cstys[c2], row, arrayf, opts);
      else {
        ss = "";
        dtag = xlml_parsexmltag(Rn[0]);
        didx = Rn.index + Rn[0].length;
      }
      break;
    case "cell":
      if (Rn[1] === "/") {
        if (comments.length > 0) cell.c = comments;
        if ((!opts.sheetRows || opts.sheetRows > r2) && cell.v !== void 0) {
          if (opts.dense) {
            if (!cursheet[r2]) cursheet[r2] = [];
            cursheet[r2][c2] = cell;
          } else cursheet[encode_col(c2) + encode_row(r2)] = cell;
        }
        if (cell.HRef) {
          cell.l = { Target: unescapexml(cell.HRef) };
          if (cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;
          delete cell.HRef;
          delete cell.HRefScreenTip;
        }
        if (cell.MergeAcross || cell.MergeDown) {
          cc = c2 + (parseInt(cell.MergeAcross, 10) | 0);
          rr = r2 + (parseInt(cell.MergeDown, 10) | 0);
          merges.push({ s: { c: c2, r: r2 }, e: { c: cc, r: rr } });
        }
        if (!opts.sheetStubs) {
          if (cell.MergeAcross) c2 = cc + 1;
          else ++c2;
        } else if (cell.MergeAcross || cell.MergeDown) {
          for (var cma = c2; cma <= cc; ++cma) {
            for (var cmd = r2; cmd <= rr; ++cmd) {
              if (cma > c2 || cmd > r2) {
                if (opts.dense) {
                  if (!cursheet[cmd]) cursheet[cmd] = [];
                  cursheet[cmd][cma] = { t: "z" };
                } else cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
              }
            }
          }
          c2 = cc + 1;
        } else ++c2;
      } else {
        cell = xlml_parsexmltagobj(Rn[0]);
        if (cell.Index) c2 = +cell.Index - 1;
        if (c2 < refguess.s.c) refguess.s.c = c2;
        if (c2 > refguess.e.c) refguess.e.c = c2;
        if (Rn[0].slice(-2) === "/>") ++c2;
        comments = [];
      }
      break;
    case "row":
      if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
        if (r2 < refguess.s.r) refguess.s.r = r2;
        if (r2 > refguess.e.r) refguess.e.r = r2;
        if (Rn[0].slice(-2) === "/>") {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index) r2 = +row.Index - 1;
        }
        c2 = 0;
        ++r2;
      } else {
        row = xlml_parsexmltag(Rn[0]);
        if (row.Index) r2 = +row.Index - 1;
        rowobj = {};
        if (row.AutoFitHeight == "0" || row.Height) {
          rowobj.hpx = parseInt(row.Height, 10);
          rowobj.hpt = px2pt(rowobj.hpx);
          rowinfo[r2] = rowobj;
        }
        if (row.Hidden == "1") {
          rowobj.hidden = true;
          rowinfo[r2] = rowobj;
        }
      }
      break;
    case "worksheet":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        sheetnames.push(sheetname);
        if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
          cursheet["!ref"] = encode_range(refguess);
          if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
            cursheet["!fullref"] = cursheet["!ref"];
            refguess.e.r = opts.sheetRows - 1;
            cursheet["!ref"] = encode_range(refguess);
          }
        }
        if (merges.length) cursheet["!merges"] = merges;
        if (cstys.length > 0) cursheet["!cols"] = cstys;
        if (rowinfo.length > 0) cursheet["!rows"] = rowinfo;
        sheets[sheetname] = cursheet;
      } else {
        refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        r2 = c2 = 0;
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        sheetname = unescapexml(tmp.Name);
        cursheet = opts.dense ? [] : {};
        merges = [];
        arrayf = [];
        rowinfo = [];
        wsprops = { name: sheetname, Hidden: 0 };
        Workbook.Sheets.push(wsprops);
      }
      break;
    case "table":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].slice(-2) == "/>") break;
      else {
        state.push([Rn[3], false]);
        cstys = [];
        seencol = false;
      }
      break;
    case "style":
      if (Rn[1] === "/") process_style_xlml(styles, stag, opts);
      else stag = xlml_parsexmltag(Rn[0]);
      break;
    case "numberformat":
      stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
      if (XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];
      for (var ssfidx = 0; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == stag.nf) break;
      if (ssfidx == 392) {
        for (ssfidx = 57; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == null) {
          SSF_load(stag.nf, ssfidx);
          break;
        }
      }
      break;
    case "column":
      if (state[state.length - 1][0] !== /*'Table'*/
      "table") break;
      csty = xlml_parsexmltag(Rn[0]);
      if (csty.Hidden) {
        csty.hidden = true;
        delete csty.Hidden;
      }
      if (csty.Width) csty.wpx = parseInt(csty.Width, 10);
      if (!seencol && csty.wpx > 10) {
        seencol = true;
        MDW = DEF_MDW;
        for (var _col = 0; _col < cstys.length; ++_col) if (cstys[_col]) process_col(cstys[_col]);
      }
      if (seencol) process_col(csty);
      cstys[csty.Index - 1 || cstys.length] = csty;
      for (var i2 = 0; i2 < +csty.Span; ++i2) cstys[cstys.length] = dup(csty);
      break;
    case "namedrange":
      if (Rn[1] === "/") break;
      if (!Workbook.Names) Workbook.Names = [];
      var _NamedRange = parsexmltag(Rn[0]);
      var _DefinedName = {
        Name: _NamedRange.Name,
        Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
      };
      if (Workbook.Sheets.length > 0) _DefinedName.Sheet = Workbook.Sheets.length - 1;
      Workbook.Names.push(_DefinedName);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") ss += str.slice(fidx, Rn.index);
      else fidx = Rn.index + Rn[0].length;
      break;
    case "interior":
      if (!opts.cellStyles) break;
      stag.Interior = xlml_parsexmltag(Rn[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
      else pidx = Rn.index + Rn[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else state.push([Rn[3], false]);
      break;
    case "comment":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        xlml_clean_comment(comment);
        comments.push(comment);
      } else {
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        comment = { a: tmp.Author };
      }
      break;
    case "autofilter":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        var AutoFilter = xlml_parsexmltag(Rn[0]);
        cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
        state.push([Rn[3], true]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else {
        if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      }
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    //case 'data' /*case 'data'*/:
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "null":
      break;
    default:
      if (state.length == 0 && Rn[3] == "document") return parse_fods(str, opts);
      if (state.length == 0 && Rn[3] == "uof") return parse_fods(str, opts);
      var seen = true;
      switch (state[state.length - 1][0]) {
        /* OfficeDocumentSettings */
        case "officedocumentsettings":
          switch (Rn[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              seen = false;
          }
          break;
        /* ComponentOptions */
        case "componentoptions":
          switch (Rn[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              seen = false;
          }
          break;
        /* ExcelWorkbook */
        case "excelworkbook":
          switch (Rn[3]) {
            case "date1904":
              Workbook.WBProps.date1904 = true;
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              seen = false;
          }
          break;
        /* WorkbookOptions */
        case "workbookoptions":
          switch (Rn[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              seen = false;
          }
          break;
        /* WorksheetOptions */
        case "worksheetoptions":
          switch (Rn[3]) {
            case "visible":
              if (Rn[0].slice(-2) === "/>") ;
              else if (Rn[1] === "/") switch (str.slice(pidx, Rn.index)) {
                case "SheetHidden":
                  wsprops.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  wsprops.Hidden = 2;
                  break;
              }
              else pidx = Rn.index + Rn[0].length;
              break;
            case "header":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
              break;
            case "footer":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
              break;
            case "pagemargins":
              var pagemargins = parsexmltag(Rn[0]);
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+pagemargins.Top)) cursheet["!margins"].top = +pagemargins.Top;
              if (!isNaN(+pagemargins.Left)) cursheet["!margins"].left = +pagemargins.Left;
              if (!isNaN(+pagemargins.Right)) cursheet["!margins"].right = +pagemargins.Right;
              if (!isNaN(+pagemargins.Bottom)) cursheet["!margins"].bottom = +pagemargins.Bottom;
              break;
            case "displayrighttoleft":
              if (!Workbook.Views) Workbook.Views = [];
              if (!Workbook.Views[0]) Workbook.Views[0] = {};
              Workbook.Views[0].RTL = true;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].above = true;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].left = true;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              seen = false;
          }
          break;
        /* PivotTable */
        case "pivottable":
        case "pivotcache":
          switch (Rn[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              seen = false;
          }
          break;
        /* PageBreaks */
        case "pagebreaks":
          switch (Rn[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              seen = false;
          }
          break;
        /* AutoFilter */
        case "autofilter":
          switch (Rn[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              seen = false;
          }
          break;
        /* QueryTable */
        case "querytable":
          switch (Rn[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              seen = false;
          }
          break;
        case "datavalidation":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              seen = false;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              seen = false;
          }
          break;
        /* MapInfo (schema) */
        case "mapinfo":
        case "schema":
        case "data":
          switch (Rn[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            /* These are from xsd (XML Schema Definition) */
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              seen = false;
          }
          break;
        /* SmartTags (can be anything) */
        case "smarttags":
          break;
        default:
          seen = false;
          break;
      }
      if (seen) break;
      if (Rn[3].match(/!\[CDATA/)) break;
      if (!state[state.length - 1][1]) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
      if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
        else {
          cp = Rn;
          pidx = Rn.index + Rn[0].length;
        }
        break;
      }
      if (opts.WTF) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
  }
  var out = {};
  if (!opts.bookSheets && !opts.bookProps) out.Sheets = sheets;
  out.SheetNames = sheetnames;
  out.Workbook = Workbook;
  out.SSF = dup(table_fmt);
  out.Props = Props;
  out.Custprops = Custprops;
  return out;
}
function parse_xlml(data, opts) {
  fix_read_opts(opts = opts || {});
  switch (opts.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(data), opts);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(data, opts);
    case "array":
      return parse_xlml_xml(a2s(data), opts);
  }
}
function parse_compobj(obj) {
  var v2 = {};
  var o2 = obj.content;
  o2.l = 28;
  v2.AnsiUserType = o2.read_shift(0, "lpstr-ansi");
  v2.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o2);
  if (o2.length - o2.l <= 4) return v2;
  var m2 = o2.read_shift(4);
  if (m2 == 0 || m2 > 40) return v2;
  o2.l -= 4;
  v2.Reserved1 = o2.read_shift(0, "lpstr-ansi");
  if (o2.length - o2.l <= 4) return v2;
  m2 = o2.read_shift(4);
  if (m2 !== 1907505652) return v2;
  v2.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o2);
  m2 = o2.read_shift(4);
  if (m2 == 0 || m2 > 40) return v2;
  o2.l -= 4;
  v2.Reserved2 = o2.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(RecordType, R2, blob, length, opts) {
  var l2 = length;
  var bufs = [];
  var d2 = blob.slice(blob.l, blob.l + l2);
  if (opts && opts.enc && opts.enc.insitu && d2.length > 0) switch (RecordType) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      opts.enc.insitu(d2);
  }
  bufs.push(d2);
  blob.l += l2;
  var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
  var start = 0;
  while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
    l2 = __readUInt16LE(blob, blob.l + 2);
    start = blob.l + 4;
    if (nextrt == 2066) start += 4;
    else if (nextrt == 2165 || nextrt == 2175) {
      start += 12;
    }
    d2 = blob.slice(start, blob.l + 4 + l2);
    bufs.push(d2);
    blob.l += 4 + l2;
    next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
  }
  var b2 = bconcat(bufs);
  prep_blob(b2, 0);
  var ll = 0;
  b2.lens = [];
  for (var j2 = 0; j2 < bufs.length; ++j2) {
    b2.lens.push(ll);
    ll += bufs[j2].length;
  }
  if (b2.length < length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b2.length + " < " + length;
  return R2.f(b2, b2.length, opts);
}
function safe_format_xf(p2, opts, date1904) {
  if (p2.t === "z") return;
  if (!p2.XF) return;
  var fmtid = 0;
  try {
    fmtid = p2.z || p2.XF.numFmtId || 0;
    if (opts.cellNF) p2.z = table_fmt[fmtid];
  } catch (e2) {
    if (opts.WTF) throw e2;
  }
  if (!opts || opts.cellText !== false) try {
    if (p2.t === "e") {
      p2.w = p2.w || BErr[p2.v];
    } else if (fmtid === 0 || fmtid == "General") {
      if (p2.t === "n") {
        if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
        else p2.w = SSF_general_num(p2.v);
      } else p2.w = SSF_general(p2.v);
    } else p2.w = SSF_format(fmtid, p2.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
  } catch (e2) {
    if (opts.WTF) throw e2;
  }
  if (opts.cellDates && fmtid && p2.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
    var _d = SSF_parse_date_code(p2.v);
    if (_d) {
      p2.t = "d";
      p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
    }
  }
}
function make_cell(val, ixfe, t3) {
  return { v: val, ixfe, t: t3 };
}
function parse_workbook(blob, options) {
  var wb = { opts: {} };
  var Sheets = {};
  var out = options.dense ? [] : {};
  var Directory = {};
  var range = {};
  var last_formula = null;
  var sst = [];
  var cur_sheet = "";
  var Preamble = {};
  var lastcell, last_cell = "", cc, cmnt, rngC, rngR;
  var sharedf = {};
  var arrayf = [];
  var temp_val;
  var country;
  var XFs = [];
  var palette = [];
  var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
  var get_rgb = function getrgb(icv) {
    if (icv < 8) return XLSIcv[icv];
    if (icv < 64) return palette[icv - 8] || XLSIcv[icv];
    return XLSIcv[icv];
  };
  var process_cell_style = function pcs(cell, line, options2) {
    var xfd = line.XF.data;
    if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles) return;
    line.s = {};
    line.s.patternType = xfd.patternType;
    var t3;
    if (t3 = rgb2Hex(get_rgb(xfd.icvFore))) {
      line.s.fgColor = { rgb: t3 };
    }
    if (t3 = rgb2Hex(get_rgb(xfd.icvBack))) {
      line.s.bgColor = { rgb: t3 };
    }
  };
  var addcell = function addcell2(cell, line, options2) {
    if (file_depth > 1) return;
    if (options2.sheetRows && cell.r >= options2.sheetRows) return;
    if (options2.cellStyles && line.XF && line.XF.data) process_cell_style(cell, line, options2);
    delete line.ixfe;
    delete line.XF;
    lastcell = cell;
    last_cell = encode_cell(cell);
    if (!range || !range.s || !range.e) range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    if (cell.r < range.s.r) range.s.r = cell.r;
    if (cell.c < range.s.c) range.s.c = cell.c;
    if (cell.r + 1 > range.e.r) range.e.r = cell.r + 1;
    if (cell.c + 1 > range.e.c) range.e.c = cell.c + 1;
    if (options2.cellFormula && line.f) {
      for (var afi = 0; afi < arrayf.length; ++afi) {
        if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r) continue;
        if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r) continue;
        line.F = encode_range(arrayf[afi][0]);
        if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;
        if (line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
        break;
      }
    }
    {
      if (options2.dense) {
        if (!out[cell.r]) out[cell.r] = [];
        out[cell.r][cell.c] = line;
      } else out[last_cell] = line;
    }
  };
  var opts = {
    enc: false,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf,
    // shared formulae by address
    arrayf,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!options && !!options.cellStyles,
    WTF: !!options && !!options.wtf
  };
  if (options.password) opts.password = options.password;
  var themes;
  var merges = [];
  var objects = [];
  var colinfo = [], rowinfo = [];
  var seencol = false;
  var supbooks = [];
  supbooks.SheetNames = opts.snames;
  supbooks.sharedf = opts.sharedf;
  supbooks.arrayf = opts.arrayf;
  supbooks.names = [];
  supbooks.XTI = [];
  var last_RT = 0;
  var file_depth = 0;
  var BIFF2Fmt = 0, BIFF2FmtTable = [];
  var FilterDatabases = [];
  var last_lbl;
  opts.codepage = 1200;
  set_cp(1200);
  var seen_codepage = false;
  while (blob.l < blob.length - 1) {
    var s2 = blob.l;
    var RecordType = blob.read_shift(2);
    if (RecordType === 0 && last_RT === 10) break;
    var length = blob.l === blob.length ? 0 : blob.read_shift(2);
    var R2 = XLSRecordEnum[RecordType];
    if (R2 && R2.f) {
      if (options.bookSheets) {
        if (last_RT === 133 && RecordType !== 133) break;
      }
      last_RT = RecordType;
      if (R2.r === 2 || R2.r == 12) {
        var rt2 = blob.read_shift(2);
        length -= 2;
        if (!opts.enc && rt2 !== RecordType && ((rt2 & 255) << 8 | rt2 >> 8) !== RecordType) throw new Error("rt mismatch: " + rt2 + "!=" + RecordType);
        if (R2.r == 12) {
          blob.l += 10;
          length -= 10;
        }
      }
      var val = {};
      if (RecordType === 10) val = /*::(*/
      R2.f(blob, length, opts);
      else val = /*::(*/
      slurp(RecordType, R2, blob, length, opts);
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1) continue;
      switch (RecordType) {
        case 34:
          wb.opts.Date1904 = Workbook.WBProps.date1904 = val;
          break;
        case 134:
          wb.opts.WriteProtect = true;
          break;
        case 47:
          if (!opts.enc) blob.l = 0;
          opts.enc = val;
          if (!options.password) throw new Error("File is password-protected");
          if (val.valid == null) throw new Error("Encryption scheme unsupported");
          if (!val.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          opts.lastuser = val;
          break;
        case 66:
          var cpval = Number(val);
          switch (cpval) {
            case 21010:
              cpval = 1200;
              break;
            case 32768:
              cpval = 1e4;
              break;
            case 32769:
              cpval = 1252;
              break;
          }
          set_cp(opts.codepage = cpval);
          seen_codepage = true;
          break;
        case 317:
          opts.rrtabid = val;
          break;
        case 25:
          opts.winlocked = val;
          break;
        case 439:
          wb.opts["RefreshAll"] = val;
          break;
        case 12:
          wb.opts["CalcCount"] = val;
          break;
        case 16:
          wb.opts["CalcDelta"] = val;
          break;
        case 17:
          wb.opts["CalcIter"] = val;
          break;
        case 13:
          wb.opts["CalcMode"] = val;
          break;
        case 14:
          wb.opts["CalcPrecision"] = val;
          break;
        case 95:
          wb.opts["CalcSaveRecalc"] = val;
          break;
        case 15:
          opts.CalcRefMode = val;
          break;
        // TODO: implement R1C1
        case 2211:
          wb.opts.FullCalc = val;
          break;
        case 129:
          if (val.fDialog) out["!type"] = "dialog";
          if (!val.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;
          if (!val.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;
          break;
        // TODO
        case 224:
          XFs.push(val);
          break;
        case 430:
          supbooks.push([val]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          supbooks[supbooks.length - 1].push(val);
          break;
        case 24:
        case 536:
          last_lbl = {
            Name: val.Name,
            Ref: stringify_formula(val.rgce, range, null, supbooks, opts)
          };
          if (val.itab > 0) last_lbl.Sheet = val.itab - 1;
          supbooks.names.push(last_lbl);
          if (!supbooks[0]) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].push(val);
          if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
            if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
              FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
          }
          break;
        case 22:
          opts.ExternCount = val;
          break;
        case 23:
          if (supbooks.length == 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
          supbooks.XTI = supbooks.XTI.concat(val);
          break;
        case 2196:
          if (opts.biff < 8) break;
          if (last_lbl != null) last_lbl.Comment = val[1];
          break;
        case 18:
          out["!protect"] = val;
          break;
        /* for sheet or book */
        case 19:
          if (val !== 0 && opts.WTF) console.error("Password verifier: " + val);
          break;
        case 133:
          {
            Directory[val.pos] = val;
            opts.snames.push(val.name);
          }
          break;
        case 10:
          {
            if (--file_depth) break;
            if (range.e) {
              if (range.e.r > 0 && range.e.c > 0) {
                range.e.r--;
                range.e.c--;
                out["!ref"] = encode_range(range);
                if (options.sheetRows && options.sheetRows <= range.e.r) {
                  var tmpri = range.e.r;
                  range.e.r = options.sheetRows - 1;
                  out["!fullref"] = out["!ref"];
                  out["!ref"] = encode_range(range);
                  range.e.r = tmpri;
                }
                range.e.r++;
                range.e.c++;
              }
              if (merges.length > 0) out["!merges"] = merges;
              if (objects.length > 0) out["!objects"] = objects;
              if (colinfo.length > 0) out["!cols"] = colinfo;
              if (rowinfo.length > 0) out["!rows"] = rowinfo;
              Workbook.Sheets.push(wsprops);
            }
            if (cur_sheet === "") Preamble = out;
            else Sheets[cur_sheet] = out;
            out = options.dense ? [] : {};
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (opts.biff === 8) opts.biff = {
              /*::[*/
              9: 2,
              /*::[*/
              521: 3,
              /*::[*/
              1033: 4
            }[RecordType] || {
              /*::[*/
              512: 2,
              /*::[*/
              768: 3,
              /*::[*/
              1024: 4,
              /*::[*/
              1280: 5,
              /*::[*/
              1536: 8,
              /*::[*/
              2: 2,
              /*::[*/
              7: 2
            }[val.BIFFVer] || 8;
            opts.biffguess = val.BIFFVer == 0;
            if (val.BIFFVer == 0 && val.dt == 4096) {
              opts.biff = 5;
              seen_codepage = true;
              set_cp(opts.codepage = 28591);
            }
            if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16) opts.biff = 2;
            if (file_depth++) break;
            out = options.dense ? [] : {};
            if (opts.biff < 8 && !seen_codepage) {
              seen_codepage = true;
              set_cp(opts.codepage = options.codepage || 1252);
            }
            if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
              if (cur_sheet === "") cur_sheet = "Sheet1";
              range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var fakebs8 = { pos: blob.l - length, name: cur_sheet };
              Directory[fakebs8.pos] = fakebs8;
              opts.snames.push(cur_sheet);
            } else cur_sheet = (Directory[s2] || { name: "" }).name;
            if (val.dt == 32) out["!type"] = "chart";
            if (val.dt == 64) out["!type"] = "macro";
            merges = [];
            objects = [];
            opts.arrayf = arrayf = [];
            colinfo = [];
            rowinfo = [];
            seencol = false;
            wsprops = { Hidden: (Directory[s2] || { hs: 0 }).hs, name: cur_sheet };
          }
          break;
        case 515:
        case 3:
        case 2:
          {
            if (out["!type"] == "chart") {
              if (options.dense ? (out[val.r] || [])[val.c] : out[encode_cell({ c: val.c, r: val.r })]) ++val.c;
            }
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 5:
        case 517:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 638:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 189:
          {
            for (var j2 = val.c; j2 <= val.C; ++j2) {
              var ixfe = val.rkrec[j2 - val.c][0];
              temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j2 - val.c][1], t: "n" };
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: j2, r: val.r }, temp_val, options);
            }
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (val.val == "String") {
              last_formula = val;
              break;
            }
            temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
            temp_val.XF = XFs[temp_val.ixfe];
            if (options.cellFormula) {
              var _f = val.formula;
              if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                var _fe = encode_cell({ r: _fr, c: _fc });
                if (sharedf[_fe]) temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                else temp_val.F = ((options.dense ? (out[_fr] || [])[_fc] : out[_fe]) || {}).F;
              } else temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
            }
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell(val.cell, temp_val, options);
            last_formula = val;
          }
          break;
        case 7:
        case 519:
          {
            if (last_formula) {
              last_formula.val = val;
              temp_val = make_cell(val, last_formula.cell.ixfe, "s");
              temp_val.XF = XFs[temp_val.ixfe];
              if (options.cellFormula) {
                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell(last_formula.cell, temp_val, options);
              last_formula = null;
            } else throw new Error("String record expects Formula");
          }
          break;
        case 33:
        case 545:
          {
            arrayf.push(val);
            var _arraystart = encode_cell(val[0].s);
            cc = options.dense ? (out[val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
            if (options.cellFormula && cc) {
              if (!last_formula) break;
              if (!_arraystart || !cc) break;
              cc.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
              cc.F = encode_range(val[0]);
            }
          }
          break;
        case 1212:
          {
            if (!options.cellFormula) break;
            if (last_cell) {
              if (!last_formula) break;
              sharedf[encode_cell(last_formula.cell)] = val[0];
              cc = options.dense ? (out[last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
              (cc || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
            }
          }
          break;
        case 253:
          temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
          if (sst[val.isst].h) temp_val.h = sst[val.isst].h;
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 513:
          if (options.sheetStubs) {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 190:
          if (options.sheetStubs) {
            for (var _j = val.c; _j <= val.C; ++_j) {
              var _ixfe = val.ixfe[_j - val.c];
              temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb.opts.Date1904);
              addcell({ c: _j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 214:
        case 516:
        case 4:
          temp_val = make_cell(val.val, val.ixfe, "s");
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 0:
        case 512:
          {
            if (file_depth === 1) range = val;
          }
          break;
        case 252:
          {
            sst = val;
          }
          break;
        case 1054:
          {
            if (opts.biff == 4) {
              BIFF2FmtTable[BIFF2Fmt++] = val[1];
              for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx) if (table_fmt[b4idx] == val[1]) break;
              if (b4idx >= 163) SSF_load(val[1], BIFF2Fmt + 163);
            } else SSF_load(val[1], val[0]);
          }
          break;
        case 30:
          {
            BIFF2FmtTable[BIFF2Fmt++] = val;
            for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx) if (table_fmt[b2idx] == val) break;
            if (b2idx >= 163) SSF_load(val, BIFF2Fmt + 163);
          }
          break;
        case 229:
          merges = merges.concat(val);
          break;
        case 93:
          objects[val.cmo[0]] = opts.lastobj = val;
          break;
        case 438:
          opts.lastobj.TxO = val;
          break;
        case 127:
          opts.lastobj.ImData = val;
          break;
        case 440:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc) cc.l = val[1];
              }
          }
          break;
        case 2048:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc && cc.l) cc.l.Tooltip = val[1];
              }
          }
          break;
        case 28:
          {
            if (opts.biff <= 5 && opts.biff >= 2) break;
            cc = options.dense ? (out[val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
            var noteobj = objects[val[2]];
            if (!cc) {
              if (options.dense) {
                if (!out[val[0].r]) out[val[0].r] = [];
                cc = out[val[0].r][val[0].c] = { t: "z" };
              } else {
                cc = out[encode_cell(val[0])] = { t: "z" };
              }
              range.e.r = Math.max(range.e.r, val[0].r);
              range.s.r = Math.min(range.s.r, val[0].r);
              range.e.c = Math.max(range.e.c, val[0].c);
              range.s.c = Math.min(range.s.c, val[0].c);
            }
            if (!cc.c) cc.c = [];
            cmnt = { a: val[1], t: noteobj.TxO.t };
            cc.c.push(cmnt);
          }
          break;
        case 2173:
          update_xfext(XFs[val.ixfe], val.ext);
          break;
        case 125:
          {
            if (!opts.cellStyles) break;
            while (val.e >= val.s) {
              colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
              if (!seencol) {
                seencol = true;
                find_mdw_colw(val.w / 256);
              }
              process_col(colinfo[val.e + 1]);
            }
          }
          break;
        case 520:
          {
            var rowobj = {};
            if (val.level != null) {
              rowinfo[val.r] = rowobj;
              rowobj.level = val.level;
            }
            if (val.hidden) {
              rowinfo[val.r] = rowobj;
              rowobj.hidden = true;
            }
            if (val.hpt) {
              rowinfo[val.r] = rowobj;
              rowobj.hpt = val.hpt;
              rowobj.hpx = pt2px(val.hpt);
            }
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
          break;
        case 161:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"].header = val.header;
          out["!margins"].footer = val.footer;
          break;
        case 574:
          if (val.RTL) Workbook.Views[0].RTL = true;
          break;
        case 146:
          palette = val;
          break;
        case 2198:
          themes = val;
          break;
        case 140:
          country = val;
          break;
        case 442:
          {
            if (!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook";
            else wsprops.CodeName = val || wsprops.name;
          }
          break;
      }
    } else {
      if (!R2) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
      blob.l += length;
    }
  }
  wb.SheetNames = keys(Directory).sort(function(a2, b2) {
    return Number(a2) - Number(b2);
  }).map(function(x2) {
    return Directory[x2].name;
  });
  if (!options.bookSheets) wb.Sheets = Sheets;
  if (!wb.SheetNames.length && Preamble["!ref"]) {
    wb.SheetNames.push("Sheet1");
    if (wb.Sheets) wb.Sheets["Sheet1"] = Preamble;
  } else wb.Preamble = Preamble;
  if (wb.Sheets) FilterDatabases.forEach(function(r2, i2) {
    wb.Sheets[wb.SheetNames[i2]]["!autofilter"] = r2;
  });
  wb.Strings = sst;
  wb.SSF = dup(table_fmt);
  if (opts.enc) wb.Encryption = opts.enc;
  if (themes) wb.Themes = themes;
  wb.Metadata = {};
  if (country !== void 0) wb.Metadata.Country = country;
  if (supbooks.names.length > 0) Workbook.Names = supbooks.names;
  wb.Workbook = Workbook;
  return wb;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(cfb, props, o2) {
  var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
  if (DSI && DSI.size > 0) try {
    var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
    for (var d2 in DocSummary) props[d2] = DocSummary[d2];
  } catch (e2) {
    if (o2.WTF) throw e2;
  }
  var SI = CFB.find(cfb, "/!SummaryInformation");
  if (SI && SI.size > 0) try {
    var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
    for (var s2 in Summary) if (props[s2] == null) props[s2] = Summary[s2];
  } catch (e2) {
    if (o2.WTF) throw e2;
  }
  if (props.HeadingPairs && props.TitlesOfParts) {
    load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o2);
    delete props.HeadingPairs;
    delete props.TitlesOfParts;
  }
}
function parse_xlscfb(cfb, options) {
  if (!options) options = {};
  fix_read_opts(options);
  reset_cp();
  if (options.codepage) set_ansi(options.codepage);
  var CompObj, WB;
  if (cfb.FullPaths) {
    if (CFB.find(cfb, "/encryption")) throw new Error("File is password-protected");
    CompObj = CFB.find(cfb, "!CompObj");
    WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
  } else {
    switch (options.type) {
      case "base64":
        cfb = s2a(Base64_decode(cfb));
        break;
      case "binary":
        cfb = s2a(cfb);
        break;
      case "buffer":
        break;
      case "array":
        if (!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb);
        break;
    }
    prep_blob(cfb, 0);
    WB = { content: cfb };
  }
  var WorkbookP;
  var _data;
  if (CompObj) parse_compobj(CompObj);
  if (options.bookProps && !options.bookSheets) WorkbookP = {};
  else {
    var T2 = has_buf ? "buffer" : "array";
    if (WB && WB.content) WorkbookP = parse_workbook(WB.content, options);
    else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T2, options));
    else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T2, options));
    else if ((_data = CFB.find(cfb, "MN0")) && _data.content) throw new Error("Unsupported Works 4 for Mac file");
    else throw new Error("Cannot find Workbook stream");
    if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir")) WorkbookP.vbaraw = make_vba_xls(cfb);
  }
  var props = {};
  if (cfb.FullPaths) parse_xls_props(
    /*::((*/
    cfb,
    props,
    options
  );
  WorkbookP.Props = WorkbookP.Custprops = props;
  if (options.bookFiles) WorkbookP.cfb = cfb;
  return WorkbookP;
}
var XLSBRecordEnum = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
var XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: parse_String
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /*::[*/
  29282: {}
};
function write_biff_rec(ba, type, payload, length) {
  var t3 = type;
  if (isNaN(t3)) return;
  var len = (payload || []).length || 0;
  var o2 = ba.next(4);
  o2.write_shift(2, t3);
  o2.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  ) ba.push(payload);
}
function html_to_sheet(str, _opts) {
  var opts = _opts || {};
  var ws = opts.dense ? [] : {};
  str = str.replace(/<!--.*?-->/g, "");
  var mtch = str.match(/<table/i);
  if (!mtch) throw new Error("Invalid HTML: could not find <table>");
  var mtch2 = str.match(/<\/table/i);
  var i2 = mtch.index, j2 = mtch2 && mtch2.index || str.length;
  var rows = split_regex(str.slice(i2, j2), /(:?<tr[^>]*>)/i, "<tr>");
  var R2 = -1, C2 = 0, RS = 0, CS = 0;
  var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
  var merges = [];
  for (i2 = 0; i2 < rows.length; ++i2) {
    var row = rows[i2].trim();
    var hd = row.slice(0, 3).toLowerCase();
    if (hd == "<tr") {
      ++R2;
      if (opts.sheetRows && opts.sheetRows <= R2) {
        --R2;
        break;
      }
      C2 = 0;
      continue;
    }
    if (hd != "<td" && hd != "<th") continue;
    var cells = row.split(/<\/t[dh]>/i);
    for (j2 = 0; j2 < cells.length; ++j2) {
      var cell = cells[j2].trim();
      if (!cell.match(/<t[dh]/i)) continue;
      var m2 = cell, cc = 0;
      while (m2.charAt(0) == "<" && (cc = m2.indexOf(">")) > -1) m2 = m2.slice(cc + 1);
      for (var midx = 0; midx < merges.length; ++midx) {
        var _merge = merges[midx];
        if (_merge.s.c == C2 && _merge.s.r < R2 && R2 <= _merge.e.r) {
          C2 = _merge.e.c + 1;
          midx = -1;
        }
      }
      var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
      CS = tag.colspan ? +tag.colspan : 1;
      if ((RS = +tag.rowspan) > 1 || CS > 1) merges.push({ s: { r: R2, c: C2 }, e: { r: R2 + (RS || 1) - 1, c: C2 + CS - 1 } });
      var _t2 = tag.t || tag["data-t"] || "";
      if (!m2.length) {
        C2 += CS;
        continue;
      }
      m2 = htmldecode(m2);
      if (range.s.r > R2) range.s.r = R2;
      if (range.e.r < R2) range.e.r = R2;
      if (range.s.c > C2) range.s.c = C2;
      if (range.e.c < C2) range.e.c = C2;
      if (!m2.length) {
        C2 += CS;
        continue;
      }
      var o2 = { t: "s", v: m2 };
      if (opts.raw || !m2.trim().length || _t2 == "s") ;
      else if (m2 === "TRUE") o2 = { t: "b", v: true };
      else if (m2 === "FALSE") o2 = { t: "b", v: false };
      else if (!isNaN(fuzzynum(m2))) o2 = { t: "n", v: fuzzynum(m2) };
      else if (!isNaN(fuzzydate(m2).getDate())) {
        o2 = { t: "d", v: parseDate(m2) };
        if (!opts.cellDates) o2 = { t: "n", v: datenum(o2.v) };
        o2.z = opts.dateNF || table_fmt[14];
      }
      if (opts.dense) {
        if (!ws[R2]) ws[R2] = [];
        ws[R2][C2] = o2;
      } else ws[encode_cell({ r: R2, c: C2 })] = o2;
      C2 += CS;
    }
  }
  ws["!ref"] = encode_range(range);
  if (merges.length) ws["!merges"] = merges;
  return ws;
}
function html_to_workbook(str, opts) {
  var mtch = str.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (mtch.length == 1) return sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
  var wb = book_new();
  mtch.forEach(function(s2, idx) {
    book_append_sheet(wb, html_to_sheet(s2, opts), "Sheet" + (idx + 1));
  });
  return wb;
}
function parse_text_p(text2) {
  var fixed = text2.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
    return Array(parseInt($1, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
  var v2 = unescapexml(fixed.replace(/<[^>]*>/g, ""));
  return [v2];
}
var number_formats_ods = {
  /* ods name: [short ssf fmt, long ssf fmt] */
  day: ["d", "dd"],
  month: ["m", "mm"],
  year: ["y", "yy"],
  hours: ["h", "hh"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  "am-pm": ["A/P", "AM/PM"],
  "day-of-week": ["ddd", "dddd"],
  era: ["e", "ee"],
  /* there is no native representation of LO "Q" format */
  quarter: ["\\Qm", 'm\\"th quarter"']
};
function parse_content_xml(d2, _opts) {
  var opts = _opts || {};
  var str = xlml_normalize(d2);
  var state = [], tmp;
  var tag;
  var NFtag = { name: "" }, NF = "", pidx = 0;
  var sheetag;
  var rowtag;
  var Sheets = {}, SheetNames = [];
  var ws = opts.dense ? [] : {};
  var Rn, q2;
  var ctag = { value: "" };
  var textp = "", textpidx = 0;
  var textR = [];
  var R2 = -1, C2 = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
  var row_ol = 0;
  var number_format_map = {};
  var merges = [], mrange = {}, mR = 0, mC = 0;
  var rowinfo = [], rowpeat = 1, colpeat = 1;
  var arrayf = [];
  var WB = { Names: [] };
  var atag = {};
  var _Ref = ["", ""];
  var comments = [], comment = {};
  var creator = "", creatoridx = 0;
  var isstub = false, intable = false;
  var i2 = 0;
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
    case "table":
    case "å·¥ä½è¡¨":
      if (Rn[1] === "/") {
        if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws["!ref"] = encode_range(range);
        else ws["!ref"] = "A1:A1";
        if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
          ws["!fullref"] = ws["!ref"];
          range.e.r = opts.sheetRows - 1;
          ws["!ref"] = encode_range(range);
        }
        if (merges.length) ws["!merges"] = merges;
        if (rowinfo.length) ws["!rows"] = rowinfo;
        sheetag.name = sheetag["åç§°"] || sheetag.name;
        if (typeof JSON !== "undefined") JSON.stringify(sheetag);
        SheetNames.push(sheetag.name);
        Sheets[sheetag.name] = ws;
        intable = false;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        sheetag = parsexmltag(Rn[0], false);
        R2 = C2 = -1;
        range.s.r = range.s.c = 1e7;
        range.e.r = range.e.c = 0;
        ws = opts.dense ? [] : {};
        merges = [];
        rowinfo = [];
        intable = true;
      }
      break;
    case "table-row-group":
      if (Rn[1] === "/") --row_ol;
      else ++row_ol;
      break;
    case "table-row":
    case "è¡":
      if (Rn[1] === "/") {
        R2 += rowpeat;
        rowpeat = 1;
        break;
      }
      rowtag = parsexmltag(Rn[0], false);
      if (rowtag["è¡å·"]) R2 = rowtag["è¡å·"] - 1;
      else if (R2 == -1) R2 = 0;
      rowpeat = +rowtag["number-rows-repeated"] || 1;
      if (rowpeat < 10) {
        for (i2 = 0; i2 < rowpeat; ++i2) if (row_ol > 0) rowinfo[R2 + i2] = { level: row_ol };
      }
      C2 = -1;
      break;
    case "covered-table-cell":
      if (Rn[1] !== "/") ++C2;
      if (opts.sheetStubs) {
        if (opts.dense) {
          if (!ws[R2]) ws[R2] = [];
          ws[R2][C2] = { t: "z" };
        } else ws[encode_cell({ r: R2, c: C2 })] = { t: "z" };
      }
      textp = "";
      textR = [];
      break;
    /* stub */
    case "table-cell":
    case "æ°æ®":
      if (Rn[0].charAt(Rn[0].length - 2) === "/") {
        ++C2;
        ctag = parsexmltag(Rn[0], false);
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        q2 = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (ctag.formula && opts.cellFormula != false) q2.f = ods_to_csf_formula(unescapexml(ctag.formula));
        if ((ctag["æ°æ®ç±»å"] || ctag["value-type"]) == "string") {
          q2.t = "s";
          q2.v = unescapexml(ctag["string-value"] || "");
          if (opts.dense) {
            if (!ws[R2]) ws[R2] = [];
            ws[R2][C2] = q2;
          } else {
            ws[encode_cell({ r: R2, c: C2 })] = q2;
          }
        }
        C2 += colpeat - 1;
      } else if (Rn[1] !== "/") {
        ++C2;
        textp = "";
        textpidx = 0;
        textR = [];
        colpeat = 1;
        var rptR = rowpeat ? R2 + rowpeat - 1 : R2;
        if (C2 > range.e.c) range.e.c = C2;
        if (C2 < range.s.c) range.s.c = C2;
        if (R2 < range.s.r) range.s.r = R2;
        if (rptR > range.e.r) range.e.r = rptR;
        ctag = parsexmltag(Rn[0], false);
        comments = [];
        comment = {};
        q2 = {
          t: ctag["æ°æ®ç±»å"] || ctag["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (opts.cellFormula) {
          if (ctag.formula) ctag.formula = unescapexml(ctag.formula);
          if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
            mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
            mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
            mrange = { s: { r: R2, c: C2 }, e: { r: R2 + mR - 1, c: C2 + mC - 1 } };
            q2.F = encode_range(mrange);
            arrayf.push([mrange, q2.F]);
          }
          if (ctag.formula) q2.f = ods_to_csf_formula(ctag.formula);
          else for (i2 = 0; i2 < arrayf.length; ++i2)
            if (R2 >= arrayf[i2][0].s.r && R2 <= arrayf[i2][0].e.r) {
              if (C2 >= arrayf[i2][0].s.c && C2 <= arrayf[i2][0].e.c)
                q2.F = arrayf[i2][1];
            }
        }
        if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
          mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
          mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
          mrange = { s: { r: R2, c: C2 }, e: { r: R2 + mR - 1, c: C2 + mC - 1 } };
          merges.push(mrange);
        }
        if (ctag["number-columns-repeated"]) colpeat = parseInt(ctag["number-columns-repeated"], 10);
        switch (q2.t) {
          case "boolean":
            q2.t = "b";
            q2.v = parsexmlbool(ctag["boolean-value"]);
            break;
          case "float":
            q2.t = "n";
            q2.v = parseFloat(ctag.value);
            break;
          case "percentage":
            q2.t = "n";
            q2.v = parseFloat(ctag.value);
            break;
          case "currency":
            q2.t = "n";
            q2.v = parseFloat(ctag.value);
            break;
          case "date":
            q2.t = "d";
            q2.v = parseDate(ctag["date-value"]);
            if (!opts.cellDates) {
              q2.t = "n";
              q2.v = datenum(q2.v);
            }
            q2.z = "m/d/yy";
            break;
          case "time":
            q2.t = "n";
            q2.v = parse_isodur(ctag["time-value"]) / 86400;
            if (opts.cellDates) {
              q2.t = "d";
              q2.v = numdate(q2.v);
            }
            q2.z = "HH:MM:SS";
            break;
          case "number":
            q2.t = "n";
            q2.v = parseFloat(ctag["æ°æ®æ°å¼"]);
            break;
          default:
            if (q2.t === "string" || q2.t === "text" || !q2.t) {
              q2.t = "s";
              if (ctag["string-value"] != null) {
                textp = unescapexml(ctag["string-value"]);
                textR = [];
              }
            } else throw new Error("Unsupported value type " + q2.t);
        }
      } else {
        isstub = false;
        if (q2.t === "s") {
          q2.v = textp || "";
          if (textR.length) q2.R = textR;
          isstub = textpidx == 0;
        }
        if (atag.Target) q2.l = atag;
        if (comments.length > 0) {
          q2.c = comments;
          comments = [];
        }
        if (textp && opts.cellText !== false) q2.w = textp;
        if (isstub) {
          q2.t = "z";
          delete q2.v;
        }
        if (!isstub || opts.sheetStubs) {
          if (!(opts.sheetRows && opts.sheetRows <= R2)) {
            for (var rpt = 0; rpt < rowpeat; ++rpt) {
              colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
              if (opts.dense) {
                if (!ws[R2 + rpt]) ws[R2 + rpt] = [];
                ws[R2 + rpt][C2] = rpt == 0 ? q2 : dup(q2);
                while (--colpeat > 0) ws[R2 + rpt][C2 + colpeat] = dup(q2);
              } else {
                ws[encode_cell({ r: R2 + rpt, c: C2 })] = q2;
                while (--colpeat > 0) ws[encode_cell({ r: R2 + rpt, c: C2 + colpeat })] = dup(q2);
              }
              if (range.e.c <= C2) range.e.c = C2;
            }
          }
        }
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        C2 += colpeat - 1;
        colpeat = 0;
        q2 = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        };
        textp = "";
        textR = [];
      }
      atag = {};
      break;
    // 9.1.4 <table:table-cell>
    /* pure state */
    case "document":
    // TODO: <office:document> is the root for FODS
    case "document-content":
    case "çµå­è¡¨æ ¼ææ¡£":
    // 3.1.3.2 <office:document-content>
    case "spreadsheet":
    case "ä¸»ä½":
    // 3.7 <office:spreadsheet>
    case "scripts":
    // 3.12 <office:scripts>
    case "styles":
    // TODO <office:styles>
    case "font-face-decls":
    // 3.14 <office:font-face-decls>
    case "master-styles":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "annotation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
        comment.t = textp;
        if (textR.length) comment.R = textR;
        comment.a = creator;
        comments.push(comment);
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        state.push([Rn[3], false]);
      }
      creator = "";
      creatoridx = 0;
      textp = "";
      textpidx = 0;
      textR = [];
      break;
    case "creator":
      if (Rn[1] === "/") {
        creator = str.slice(creatoridx, Rn.index);
      } else creatoridx = Rn.index + Rn[0].length;
      break;
    /* ignore state */
    case "meta":
    case "åæ°æ®":
    // TODO: <office:meta> <uof:åæ°æ®> FODS/UOF
    case "settings":
    // TODO: <office:settings>
    case "config-item-set":
    // TODO: <office:config-item-set>
    case "config-item-map-indexed":
    // TODO: <office:config-item-map-indexed>
    case "config-item-map-entry":
    // TODO: <office:config-item-map-entry>
    case "config-item-map-named":
    // TODO: <office:config-item-map-entry>
    case "shapes":
    // 9.2.8 <table:shapes>
    case "frame":
    // 10.4.2 <draw:frame>
    case "text-box":
    // 10.4.3 <draw:text-box>
    case "image":
    // 10.4.4 <draw:image>
    case "data-pilot-tables":
    // 9.6.2 <table:data-pilot-tables>
    case "list-style":
    // 16.30 <text:list-style>
    case "form":
    // 13.13 <form:form>
    case "dde-links":
    // 9.8 <table:dde-links>
    case "event-listeners":
    // TODO
    case "chart":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], false]);
      textp = "";
      textpidx = 0;
      textR = [];
      break;
    case "scientific-number":
      break;
    case "currency-symbol":
      break;
    case "currency-style":
      break;
    case "number-style":
    // 16.27.2 <number:number-style>
    case "percentage-style":
    // 16.27.9 <number:percentage-style>
    case "date-style":
    // 16.27.10 <number:date-style>
    case "time-style":
      if (Rn[1] === "/") {
        number_format_map[NFtag.name] = NF;
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        NF = "";
        NFtag = parsexmltag(Rn[0], false);
        state.push([Rn[3], true]);
      }
      break;
    case "script":
      break;
    // 3.13 <office:script>
    case "libraries":
      break;
    // TODO: <ooo:libraries>
    case "automatic-styles":
      break;
    // 3.15.3 <office:automatic-styles>
    case "default-style":
    // TODO: <style:default-style>
    case "page-layout":
      break;
    // TODO: <style:page-layout>
    case "style":
      break;
    case "map":
      break;
    // 16.3 <style:map>
    case "font-face":
      break;
    // 16.21 <style:font-face>
    case "paragraph-properties":
      break;
    // 17.6 <style:paragraph-properties>
    case "table-properties":
      break;
    // 17.15 <style:table-properties>
    case "table-column-properties":
      break;
    // 17.16 <style:table-column-properties>
    case "table-row-properties":
      break;
    // 17.17 <style:table-row-properties>
    case "table-cell-properties":
      break;
    // 17.18 <style:table-cell-properties>
    case "number":
      switch (state[state.length - 1][0]) {
        case "time-style":
        case "date-style":
          tag = parsexmltag(Rn[0], false);
          NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "fraction":
      break;
    // TODO 16.27.6 <number:fraction>
    case "day":
    // 16.27.11 <number:day>
    case "month":
    // 16.27.12 <number:month>
    case "year":
    // 16.27.13 <number:year>
    case "era":
    // 16.27.14 <number:era>
    case "day-of-week":
    // 16.27.15 <number:day-of-week>
    case "week-of-year":
    // 16.27.16 <number:week-of-year>
    case "quarter":
    // 16.27.17 <number:quarter>
    case "hours":
    // 16.27.19 <number:hours>
    case "minutes":
    // 16.27.20 <number:minutes>
    case "seconds":
    // 16.27.21 <number:seconds>
    case "am-pm":
      switch (state[state.length - 1][0]) {
        case "time-style":
        case "date-style":
          tag = parsexmltag(Rn[0], false);
          NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "boolean-style":
      break;
    // 16.27.23 <number:boolean-style>
    case "boolean":
      break;
    // 16.27.24 <number:boolean>
    case "text-style":
      break;
    // 16.27.25 <number:text-style>
    case "text":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") switch (state[state.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          NF += str.slice(pidx, Rn.index);
          break;
      }
      else pidx = Rn.index + Rn[0].length;
      break;
    case "named-range":
      tag = parsexmltag(Rn[0], false);
      _Ref = ods_to_csf_3D(tag["cell-range-address"]);
      var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
      if (intable) nrange.Sheet = SheetNames.length;
      WB.Names.push(nrange);
      break;
    case "text-content":
      break;
    // 16.27.27 <number:text-content>
    case "text-properties":
      break;
    // 16.27.27 <style:text-properties>
    case "embedded-text":
      break;
    // 16.27.4 <number:embedded-text>
    case "body":
    case "çµå­è¡¨æ ¼":
      break;
    // 3.3 16.9.6 19.726.3
    case "forms":
      break;
    // 12.25.2 13.2
    case "table-column":
      break;
    // 9.1.6 <table:table-column>
    case "table-header-rows":
      break;
    // 9.1.7 <table:table-header-rows>
    case "table-rows":
      break;
    // 9.1.12 <table:table-rows>
    /* TODO: outline levels */
    case "table-column-group":
      break;
    // 9.1.10 <table:table-column-group>
    case "table-header-columns":
      break;
    // 9.1.11 <table:table-header-columns>
    case "table-columns":
      break;
    // 9.1.12 <table:table-columns>
    case "null-date":
      break;
    // 9.4.2 <table:null-date> TODO: date1904
    case "graphic-properties":
      break;
    // 17.21 <style:graphic-properties>
    case "calculation-settings":
      break;
    // 9.4.1 <table:calculation-settings>
    case "named-expressions":
      break;
    // 9.4.11 <table:named-expressions>
    case "label-range":
      break;
    // 9.4.9 <table:label-range>
    case "label-ranges":
      break;
    // 9.4.10 <table:label-ranges>
    case "named-expression":
      break;
    // 9.4.13 <table:named-expression>
    case "sort":
      break;
    // 9.4.19 <table:sort>
    case "sort-by":
      break;
    // 9.4.20 <table:sort-by>
    case "sort-groups":
      break;
    // 9.4.22 <table:sort-groups>
    case "tab":
      break;
    // 6.1.4 <text:tab>
    case "line-break":
      break;
    // 6.1.5 <text:line-break>
    case "span":
      break;
    // 6.1.7 <text:span>
    case "p":
    case "ææ¬ä¸²":
      if (["master-styles"].indexOf(state[state.length - 1][0]) > -1) break;
      if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
        var ptp = parse_text_p(str.slice(textpidx, Rn.index));
        textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
      } else {
        parsexmltag(Rn[0], false);
        textpidx = Rn.index + Rn[0].length;
      }
      break;
    // <text:p>
    case "s":
      break;
    // <text:s>
    case "database-range":
      if (Rn[1] === "/") break;
      try {
        _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
        Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
      } catch (e2) {
      }
      break;
    case "date":
      break;
    // <*:date>
    case "object":
      break;
    // 10.4.6.2 <draw:object>
    case "title":
    case "æ é¢":
      break;
    // <*:title> OR <uof:æ é¢>
    case "desc":
      break;
    // <*:desc>
    case "binary-data":
      break;
    // 10.4.5 TODO: b64 blob
    /* 9.2 Advanced Tables */
    case "table-source":
      break;
    // 9.2.6
    case "scenario":
      break;
    // 9.2.6
    case "iteration":
      break;
    // 9.4.3 <table:iteration>
    case "content-validations":
      break;
    // 9.4.4 <table:
    case "content-validation":
      break;
    // 9.4.5 <table:
    case "help-message":
      break;
    // 9.4.6 <table:
    case "error-message":
      break;
    // 9.4.7 <table:
    case "database-ranges":
      break;
    // 9.4.14 <table:database-ranges>
    case "filter":
      break;
    // 9.5.2 <table:filter>
    case "filter-and":
      break;
    // 9.5.3 <table:filter-and>
    case "filter-or":
      break;
    // 9.5.4 <table:filter-or>
    case "filter-condition":
      break;
    // 9.5.5 <table:filter-condition>
    case "list-level-style-bullet":
      break;
    // 16.31 <text:
    case "list-level-style-number":
      break;
    // 16.32 <text:
    case "list-level-properties":
      break;
    // 17.19 <style:
    /* 7.3 Document Fields */
    case "sender-firstname":
    // 7.3.6.2
    case "sender-lastname":
    // 7.3.6.3
    case "sender-initials":
    // 7.3.6.4
    case "sender-title":
    // 7.3.6.5
    case "sender-position":
    // 7.3.6.6
    case "sender-email":
    // 7.3.6.7
    case "sender-phone-private":
    // 7.3.6.8
    case "sender-fax":
    // 7.3.6.9
    case "sender-company":
    // 7.3.6.10
    case "sender-phone-work":
    // 7.3.6.11
    case "sender-street":
    // 7.3.6.12
    case "sender-city":
    // 7.3.6.13
    case "sender-postal-code":
    // 7.3.6.14
    case "sender-country":
    // 7.3.6.15
    case "sender-state-or-province":
    // 7.3.6.16
    case "author-name":
    // 7.3.7.1
    case "author-initials":
    // 7.3.7.2
    case "chapter":
    // 7.3.8
    case "file-name":
    // 7.3.9
    case "template-name":
    // 7.3.9
    case "sheet-name":
      break;
    case "event-listener":
      break;
    /* TODO: FODS Properties */
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    /* TODO: FODS Config */
    case "config-item":
      break;
    /* TODO: style tokens */
    case "page-number":
      break;
    // TODO <text:page-number>
    case "page-count":
      break;
    // TODO <text:page-count>
    case "time":
      break;
    // TODO <text:time>
    /* 9.3 Advanced Table Cells */
    case "cell-range-source":
      break;
    // 9.3.1 <table:
    case "detective":
      break;
    // 9.3.2 <table:
    case "operation":
      break;
    // 9.3.3 <table:
    case "highlighted-range":
      break;
    // 9.3.4 <table:
    /* 9.6 Data Pilot Tables <table: */
    case "data-pilot-table":
    // 9.6.3
    case "source-cell-range":
    // 9.6.5
    case "source-service":
    // 9.6.6
    case "data-pilot-field":
    // 9.6.7
    case "data-pilot-level":
    // 9.6.8
    case "data-pilot-subtotals":
    // 9.6.9
    case "data-pilot-subtotal":
    // 9.6.10
    case "data-pilot-members":
    // 9.6.11
    case "data-pilot-member":
    // 9.6.12
    case "data-pilot-display-info":
    // 9.6.13
    case "data-pilot-sort-info":
    // 9.6.14
    case "data-pilot-layout-info":
    // 9.6.15
    case "data-pilot-field-reference":
    // 9.6.16
    case "data-pilot-groups":
    // 9.6.17
    case "data-pilot-group":
    // 9.6.18
    case "data-pilot-group-member":
      break;
    /* 10.3 Drawing Shapes */
    case "rect":
      break;
    /* 14.6 DDE Connections */
    case "dde-connection-decls":
    // 14.6.2 <text:
    case "dde-connection-decl":
    // 14.6.3 <text:
    case "dde-link":
    // 14.6.4 <table:
    case "dde-source":
      break;
    case "properties":
      break;
    // 13.7 <form:properties>
    case "property":
      break;
    // 13.8 <form:property>
    case "a":
      if (Rn[1] !== "/") {
        atag = parsexmltag(Rn[0], false);
        if (!atag.href) break;
        atag.Target = unescapexml(atag.href);
        delete atag.href;
        if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
          _Ref = ods_to_csf_3D(atag.Target.slice(1));
          atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
        } else if (atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);
      }
      break;
    /* non-standard */
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    // <table:
    case "office-document-common-attrs":
      break;
    // bare
    default:
      switch (Rn[2]) {
        case "dc:":
        // TODO: properties
        case "calcext:":
        // ignore undocumented extensions
        case "loext:":
        // ignore undocumented extensions
        case "ooo:":
        // ignore undocumented extensions
        case "chartooo:":
        // ignore undocumented extensions
        case "draw:":
        // TODO: drawing
        case "style:":
        // TODO: styles
        case "chart:":
        // TODO: charts
        case "form:":
        // TODO: forms
        case "uof:":
        // TODO: uof
        case "è¡¨:":
        // TODO: uof
        case "å­:":
          break;
        default:
          if (opts.WTF) throw new Error(Rn);
      }
  }
  var out = {
    Sheets,
    SheetNames,
    Workbook: WB
  };
  if (opts.bookSheets) delete /*::(*/
  out.Sheets;
  return out;
}
function parse_ods(zip, opts) {
  opts = opts || {};
  if (safegetzipfile(zip, "META-INF/manifest.xml")) parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
  var content2 = getzipstr(zip, "content.xml");
  if (!content2) throw new Error("Missing content.xml in ODS / UOF file");
  var wb = parse_content_xml(utf8read(content2), opts);
  if (safegetzipfile(zip, "meta.xml")) wb.Props = parse_core_props(getzipdata(zip, "meta.xml"));
  return wb;
}
function parse_fods(data, opts) {
  return parse_content_xml(data, opts);
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function u8str(u82) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u82) : utf8read(a2s(u82));
}
function u8concat(u8a) {
  var len = u8a.reduce(function(acc, x2) {
    return acc + x2.length;
  }, 0);
  var out = new Uint8Array(len);
  var off = 0;
  u8a.forEach(function(u82) {
    out.set(u82, off);
    off += u82.length;
  });
  return out;
}
function popcnt(x2) {
  x2 -= x2 >> 1 & 1431655765;
  x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
  return (x2 + (x2 >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(buf, offset) {
  var exp = (buf[offset + 15] & 127) << 7 | buf[offset + 14] >> 1;
  var mantissa = buf[offset + 14] & 1;
  for (var j2 = offset + 13; j2 >= offset; --j2)
    mantissa = mantissa * 256 + buf[j2];
  return (buf[offset + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
}
function parse_varint49(buf, ptr) {
  var l2 = ptr ? ptr[0] : 0;
  var usz = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      usz |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 28);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 35);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 42);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
    }
  if (ptr)
    ptr[0] = l2;
  return usz;
}
function varint_to_i32(buf) {
  var l2 = 0, i322 = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      i322 |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      i322 |= (buf[l2] & 127) << 28;
    }
  return i322;
}
function parse_shallow(buf) {
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var off = ptr[0];
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = Math.floor(num / 8);
    var len = 0;
    var res;
    if (num == 0)
      break;
    switch (type) {
      case 0:
        {
          var l2 = ptr[0];
          while (buf[ptr[0]++] >= 128)
            ;
          res = buf.slice(l2, ptr[0]);
        }
        break;
      case 5:
        len = 4;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 1:
        len = 8;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 2:
        len = parse_varint49(buf, ptr);
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v2 = { data: res, type };
    if (out[num] == null)
      out[num] = [v2];
    else
      out[num].push(v2);
  }
  return out;
}
function mappa(data, cb) {
  return (data == null ? void 0 : data.map(function(d2) {
    return cb(d2.data);
  })) || [];
}
function parse_iwa_file(buf) {
  var _a2;
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
    ptr[0] += len;
    var res = {
      id: varint_to_i32(ai[1][0].data),
      messages: []
    };
    ai[2].forEach(function(b2) {
      var mi = parse_shallow(b2.data);
      var fl2 = varint_to_i32(mi[3][0].data);
      res.messages.push({
        meta: mi,
        data: buf.slice(ptr[0], ptr[0] + fl2)
      });
      ptr[0] += fl2;
    });
    if ((_a2 = ai[3]) == null ? void 0 : _a2[0])
      res.merge = varint_to_i32(ai[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = [0];
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  while (ptr[0] < buf.length) {
    var tag = buf[ptr[0]] & 3;
    if (tag == 0) {
      var len = buf[ptr[0]++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c2 = len - 59;
        len = buf[ptr[0]];
        if (c2 > 1)
          len |= buf[ptr[0] + 1] << 8;
        if (c2 > 2)
          len |= buf[ptr[0] + 2] << 16;
        if (c2 > 3)
          len |= buf[ptr[0] + 3] << 24;
        len >>>= 0;
        len++;
        ptr[0] += c2;
      }
      chunks.push(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      continue;
    } else {
      var offset = 0, length = 0;
      if (tag == 1) {
        length = (buf[ptr[0]] >> 2 & 7) + 4;
        offset = (buf[ptr[0]++] & 224) << 3;
        offset |= buf[ptr[0]++];
      } else {
        length = (buf[ptr[0]++] >> 2) + 1;
        if (tag == 2) {
          offset = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
          ptr[0] += 2;
        } else {
          offset = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
          ptr[0] += 4;
        }
      }
      chunks = [u8concat(chunks)];
      if (offset == 0)
        throw new Error("Invalid offset 0");
      if (offset > chunks[0].length)
        throw new Error("Invalid offset beyond length");
      if (length >= offset) {
        chunks.push(chunks[0].slice(-offset));
        length -= offset;
        while (length >= chunks[chunks.length - 1].length) {
          chunks.push(chunks[chunks.length - 1]);
          length -= chunks[chunks.length - 1].length;
        }
      }
      chunks.push(chunks[0].slice(-offset, -offset + length));
    }
  }
  var o2 = u8concat(chunks);
  if (o2.length != usz)
    throw new Error("Unexpected length: ".concat(o2.length, " != ").concat(usz));
  return o2;
}
function decompress_iwa_file(buf) {
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var t3 = buf[l2++];
    var len = buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16;
    l2 += 3;
    out.push(parse_snappy_chunk(t3, buf.slice(l2, l2 + len)));
    l2 += len;
  }
  if (l2 !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return u8concat(out);
}
function parse_old_storage(buf, sst, rsst, v2) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(4, true);
  var data_offset = (v2 > 1 ? 12 : 8) + popcnt(flags & (v2 > 1 ? 3470 : 398)) * 4;
  var ridx = -1, sidx = -1, ieee = NaN, dt2 = new Date(2001, 0, 1);
  if (flags & 512) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  data_offset += popcnt(flags & (v2 > 1 ? 12288 : 4096)) * 4;
  if (flags & 16) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 32) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 64) {
    dt2.setTime(dt2.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  var ret;
  switch (buf[2]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: ieee };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt2 };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else if (sidx > -1)
          ret = { t: "s", v: sst[sidx] };
        else if (!isNaN(ieee))
          ret = { t: "n", v: ieee };
        else
          throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
      }
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
  }
  return ret;
}
function parse_new_storage(buf, sst, rsst) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(8, true);
  var data_offset = 12;
  var ridx = -1, sidx = -1, d128 = NaN, ieee = NaN, dt2 = new Date(2001, 0, 1);
  if (flags & 1) {
    d128 = readDecimal128LE(buf, data_offset);
    data_offset += 16;
  }
  if (flags & 2) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 4) {
    dt2.setTime(dt2.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  if (flags & 8) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 16) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  var ret;
  switch (buf[1]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: d128 };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt2 };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else
          throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
      }
      break;
    case 10:
      ret = { t: "n", v: d128 };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
  }
  return ret;
}
function parse_cell_storage(buf, sst, rsst) {
  switch (buf[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
      return parse_old_storage(buf, sst, rsst, buf[0]);
    case 5:
      return parse_new_storage(buf, sst, rsst);
    default:
      throw new Error("Unsupported payload version ".concat(buf[0]));
  }
}
function parse_TSP_Reference(buf) {
  var pb = parse_shallow(buf);
  return parse_varint49(pb[1][0].data);
}
function parse_TST_TableDataList(M2, root) {
  var pb = parse_shallow(root.data);
  var type = varint_to_i32(pb[1][0].data);
  var entries2 = pb[3];
  var data = [];
  (entries2 || []).forEach(function(entry) {
    var le2 = parse_shallow(entry.data);
    var key = varint_to_i32(le2[1][0].data) >>> 0;
    switch (type) {
      case 1:
        data[key] = u8str(le2[3][0].data);
        break;
      case 8:
        {
          var rt2 = M2[parse_TSP_Reference(le2[9][0].data)][0];
          var rtp = parse_shallow(rt2.data);
          var rtpref = M2[parse_TSP_Reference(rtp[1][0].data)][0];
          var mtype = varint_to_i32(rtpref.meta[1][0].data);
          if (mtype != 2001)
            throw new Error("2000 unexpected reference to ".concat(mtype));
          var tswpsa = parse_shallow(rtpref.data);
          data[key] = tswpsa[3].map(function(x2) {
            return u8str(x2.data);
          }).join("");
        }
        break;
    }
  });
  return data;
}
function parse_TST_TileRowInfo(u82, type) {
  var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  var pb = parse_shallow(u82);
  var R2 = varint_to_i32(pb[1][0].data) >>> 0;
  var cnt = varint_to_i32(pb[2][0].data) >>> 0;
  var wide_offsets = ((_b2 = (_a2 = pb[8]) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.data) && varint_to_i32(pb[8][0].data) > 0 || false;
  var used_storage_u8, used_storage;
  if (((_d = (_c = pb[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type != 0) {
    used_storage_u8 = (_f = (_e2 = pb[7]) == null ? void 0 : _e2[0]) == null ? void 0 : _f.data;
    used_storage = (_h = (_g = pb[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
  } else if (((_j = (_i = pb[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
    used_storage_u8 = (_l = (_k = pb[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
    used_storage = (_n = (_m = pb[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
  } else
    throw "NUMBERS Tile missing ".concat(type, " cell storage");
  var width = wide_offsets ? 4 : 1;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);
  var offsets = [];
  for (var C2 = 0; C2 < used_storage_u8.length / 2; ++C2) {
    var off = used_storage_offsets.getUint16(C2 * 2, true);
    if (off < 65535)
      offsets.push([C2, off]);
  }
  if (offsets.length != cnt)
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
  var cells = [];
  for (C2 = 0; C2 < offsets.length - 1; ++C2)
    cells[offsets[C2][0]] = used_storage.subarray(offsets[C2][1] * width, offsets[C2 + 1][1] * width);
  if (offsets.length >= 1)
    cells[offsets[offsets.length - 1][0]] = used_storage.subarray(offsets[offsets.length - 1][1] * width);
  return { R: R2, cells };
}
function parse_TST_Tile(M2, root) {
  var _a2;
  var pb = parse_shallow(root.data);
  var storage = ((_a2 = pb == null ? void 0 : pb[7]) == null ? void 0 : _a2[0]) ? varint_to_i32(pb[7][0].data) >>> 0 > 0 ? 1 : 0 : -1;
  var ri = mappa(pb[5], function(u82) {
    return parse_TST_TileRowInfo(u82, storage);
  });
  return {
    nrows: varint_to_i32(pb[4][0].data) >>> 0,
    data: ri.reduce(function(acc, x2) {
      if (!acc[x2.R])
        acc[x2.R] = [];
      x2.cells.forEach(function(cell, C2) {
        if (acc[x2.R][C2])
          throw new Error("Duplicate cell r=".concat(x2.R, " c=").concat(C2));
        acc[x2.R][C2] = cell;
      });
      return acc;
    }, [])
  };
}
function parse_TST_TableModelArchive(M2, root, ws) {
  var _a2;
  var pb = parse_shallow(root.data);
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  range.e.r = (varint_to_i32(pb[6][0].data) >>> 0) - 1;
  if (range.e.r < 0)
    throw new Error("Invalid row varint ".concat(pb[6][0].data));
  range.e.c = (varint_to_i32(pb[7][0].data) >>> 0) - 1;
  if (range.e.c < 0)
    throw new Error("Invalid col varint ".concat(pb[7][0].data));
  ws["!ref"] = encode_range(range);
  var store = parse_shallow(pb[4][0].data);
  var sst = parse_TST_TableDataList(M2, M2[parse_TSP_Reference(store[4][0].data)][0]);
  var rsst = ((_a2 = store[17]) == null ? void 0 : _a2[0]) ? parse_TST_TableDataList(M2, M2[parse_TSP_Reference(store[17][0].data)][0]) : [];
  var tile = parse_shallow(store[3][0].data);
  var _R = 0;
  tile[1].forEach(function(t3) {
    var tl = parse_shallow(t3.data);
    var ref = M2[parse_TSP_Reference(tl[2][0].data)][0];
    var mtype = varint_to_i32(ref.meta[1][0].data);
    if (mtype != 6002)
      throw new Error("6001 unexpected reference to ".concat(mtype));
    var _tile = parse_TST_Tile(M2, ref);
    _tile.data.forEach(function(row, R2) {
      row.forEach(function(buf, C2) {
        var addr = encode_cell({ r: _R + R2, c: C2 });
        var res = parse_cell_storage(buf, sst, rsst);
        if (res)
          ws[addr] = res;
      });
    });
    _R += _tile.nrows;
  });
}
function parse_TST_TableInfoArchive(M2, root) {
  var pb = parse_shallow(root.data);
  var out = { "!ref": "A1" };
  var tableref = M2[parse_TSP_Reference(pb[2][0].data)];
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);
  if (mtype != 6001)
    throw new Error("6000 unexpected reference to ".concat(mtype));
  parse_TST_TableModelArchive(M2, tableref[0], out);
  return out;
}
function parse_TN_SheetArchive(M2, root) {
  var _a2;
  var pb = parse_shallow(root.data);
  var out = {
    name: ((_a2 = pb[1]) == null ? void 0 : _a2[0]) ? u8str(pb[1][0].data) : "",
    sheets: []
  };
  var shapeoffs = mappa(pb[2], parse_TSP_Reference);
  shapeoffs.forEach(function(off) {
    M2[off].forEach(function(m2) {
      var mtype = varint_to_i32(m2.meta[1][0].data);
      if (mtype == 6e3)
        out.sheets.push(parse_TST_TableInfoArchive(M2, m2));
    });
  });
  return out;
}
function parse_TN_DocumentArchive(M2, root) {
  var out = book_new();
  var pb = parse_shallow(root.data);
  var sheetoffs = mappa(pb[1], parse_TSP_Reference);
  sheetoffs.forEach(function(off) {
    M2[off].forEach(function(m2) {
      var mtype = varint_to_i32(m2.meta[1][0].data);
      if (mtype == 2) {
        var root2 = parse_TN_SheetArchive(M2, m2);
        root2.sheets.forEach(function(sheet, idx) {
          book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);
        });
      }
    });
  });
  if (out.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return out;
}
function parse_numbers_iwa(cfb) {
  var _a2, _b2, _c, _d;
  var M2 = {}, indices = [];
  cfb.FullPaths.forEach(function(p2) {
    if (p2.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  });
  cfb.FileIndex.forEach(function(s2) {
    if (!s2.name.match(/\.iwa$/))
      return;
    var o2;
    try {
      o2 = decompress_iwa_file(s2.content);
    } catch (e2) {
      return console.log("?? " + s2.content.length + " " + (e2.message || e2));
    }
    var packets;
    try {
      packets = parse_iwa_file(o2);
    } catch (e2) {
      return console.log("## " + (e2.message || e2));
    }
    packets.forEach(function(packet) {
      M2[packet.id] = packet.messages;
      indices.push(packet.id);
    });
  });
  if (!indices.length)
    throw new Error("File has no messages");
  var docroot = ((_d = (_c = (_b2 = (_a2 = M2 == null ? void 0 : M2[1]) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.meta) == null ? void 0 : _c[1]) == null ? void 0 : _d[0].data) && varint_to_i32(M2[1][0].meta[1][0].data) == 1 && M2[1][0];
  if (!docroot)
    indices.forEach(function(idx) {
      M2[idx].forEach(function(iwam) {
        var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
        if (mtype == 1) {
          if (!docroot)
            docroot = iwam;
          else
            throw new Error("Document has multiple roots");
        }
      });
    });
  if (!docroot)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(M2, docroot);
}
function fix_opts_func(defaults2) {
  return function fix_opts(opts) {
    for (var i2 = 0; i2 != defaults2.length; ++i2) {
      var d2 = defaults2[i2];
      if (opts[d2[0]] === void 0) opts[d2[0]] = d2[1];
      if (d2[2] === "n") opts[d2[0]] = Number(opts[d2[0]]);
    }
  };
}
function fix_read_opts(opts) {
  fix_opts_func([
    ["cellNF", false],
    /* emit cell number format string as .z */
    ["cellHTML", true],
    /* emit html string as .h */
    ["cellFormula", true],
    /* emit formulae as .f */
    ["cellStyles", false],
    /* emits style/theme as .s */
    ["cellText", true],
    /* emit formatted text as .w */
    ["cellDates", false],
    /* emit date cells with type `d` */
    ["sheetStubs", false],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", false],
    /* parse calculation chains */
    ["bookSheets", false],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", false],
    /* only try to get properties (no Sheets) */
    ["bookFiles", false],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", false],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function get_sheet_type(n2) {
  if (RELS.WS.indexOf(n2) > -1) return "sheet";
  if (n2 == RELS.CS) return "chart";
  if (n2 == RELS.DS) return "dialog";
  if (n2 == RELS.MS) return "macro";
  return n2 && n2.length ? n2 : "sheet";
}
function safe_parse_wbrels(wbrels, sheets) {
  if (!wbrels) return 0;
  try {
    wbrels = sheets.map(function pwbr(w2) {
      if (!w2.id) w2.id = w2.strRelID;
      return [w2.name, wbrels["!id"][w2.id].Target, get_sheet_type(wbrels["!id"][w2.id].Type)];
    });
  } catch (e2) {
    return null;
  }
  return !wbrels || wbrels.length === 0 ? null : wbrels;
}
function safe_parse_sheet(zip, path2, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb, themes, styles) {
  try {
    sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path2);
    var data = getzipdata(zip, path2);
    var _ws;
    switch (stype) {
      case "sheet":
        _ws = parse_ws(data, path2, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "chart":
        _ws = parse_cs(data, path2, idx, opts, sheetRels[sheet], wb, themes, styles);
        if (!_ws || !_ws["!drawel"]) break;
        var dfile = resolve_path(_ws["!drawel"].Target, path2);
        var drelsp = get_rels_path(dfile);
        var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
        var chartp = resolve_path(draw, dfile);
        var crelsp = get_rels_path(chartp);
        _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb, _ws);
        break;
      case "macro":
        _ws = parse_ms(data, path2, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      case "dialog":
        _ws = parse_ds(data, path2, idx, opts, sheetRels[sheet], wb, themes, styles);
        break;
      default:
        throw new Error("Unrecognized sheet type " + stype);
    }
    sheets[sheet] = _ws;
    var tcomments = [];
    if (sheetRels && sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n2) {
      var dfile2 = "";
      if (sheetRels[sheet][n2].Type == RELS.CMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n2].Target, path2);
        var comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
        if (!comments || !comments.length) return;
        sheet_insert_comments(_ws, comments, false);
      }
      if (sheetRels[sheet][n2].Type == RELS.TCMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n2].Target, path2);
        tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
      }
    });
    if (tcomments && tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);
  } catch (e2) {
    if (opts.WTF) throw e2;
  }
}
function strip_front_slash(x2) {
  return x2.charAt(0) == "/" ? x2.slice(1) : x2;
}
function parse_zip(zip, opts) {
  make_ssf();
  opts = opts || {};
  fix_read_opts(opts);
  if (safegetzipfile(zip, "META-INF/manifest.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "objectdata.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "Index/Document.iwa")) {
    if (typeof Uint8Array == "undefined") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa != "undefined") {
      if (zip.FileIndex) return parse_numbers_iwa(zip);
      var _zip = CFB.utils.cfb_new();
      zipentries(zip).forEach(function(e2) {
        zip_add_file(_zip, e2, getzipbin(zip, e2));
      });
      return parse_numbers_iwa(_zip);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(zip, "[Content_Types].xml")) {
    if (safegetzipfile(zip, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(zip, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
    throw new Error("Unsupported ZIP file");
  }
  var entries2 = zipentries(zip);
  var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
  var xlsb = false;
  var sheets, binname;
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.xml";
    if (getzipdata(zip, binname, true)) dir.workbooks.push(binname);
  }
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.bin";
    if (!getzipdata(zip, binname, true)) throw new Error("Could not find workbook");
    dir.workbooks.push(binname);
    xlsb = true;
  }
  if (dir.workbooks[0].slice(-3) == "bin") xlsb = true;
  var themes = {};
  var styles = {};
  if (!opts.bookSheets && !opts.bookProps) {
    strs = [];
    if (dir.sst) try {
      strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
    } catch (e2) {
      if (opts.WTF) throw e2;
    }
    if (opts.cellStyles && dir.themes.length) themes = parse_theme(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", dir.themes[0], opts);
    if (dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
  }
  dir.links.map(function(link) {
    try {
      var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
      return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
    } catch (e2) {
    }
  });
  var wb = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
  var props = {}, propdata = "";
  if (dir.coreprops.length) {
    propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
    if (propdata) props = parse_core_props(propdata);
    if (dir.extprops.length !== 0) {
      propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
      if (propdata) parse_ext_props(propdata, props, opts);
    }
  }
  var custprops = {};
  if (!opts.bookSheets || opts.bookProps) {
    if (dir.custprops.length !== 0) {
      propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
      if (propdata) custprops = parse_cust_props(propdata, opts);
    }
  }
  var out = {};
  if (opts.bookSheets || opts.bookProps) {
    if (wb.Sheets) sheets = wb.Sheets.map(function pluck(x2) {
      return x2.name;
    });
    else if (props.Worksheets && props.SheetNames.length > 0) sheets = props.SheetNames;
    if (opts.bookProps) {
      out.Props = props;
      out.Custprops = custprops;
    }
    if (opts.bookSheets && typeof sheets !== "undefined") out.SheetNames = sheets;
    if (opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
  }
  sheets = {};
  var deps = {};
  if (opts.bookDeps && dir.calcchain) deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
  var i2 = 0;
  var sheetRels = {};
  var path2, relsPath;
  {
    var wbsheets = wb.Sheets;
    props.Worksheets = wbsheets.length;
    props.SheetNames = [];
    for (var j2 = 0; j2 != wbsheets.length; ++j2) {
      props.SheetNames[j2] = wbsheets[j2].name;
    }
  }
  var wbext = xlsb ? "bin" : "xml";
  var wbrelsi = dir.workbooks[0].lastIndexOf("/");
  var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
  if (!safegetzipfile(zip, wbrelsfile)) wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
  var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
  if ((dir.metadata || []).length >= 1) {
    opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
  }
  if ((dir.people || []).length >= 1) {
    opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
  }
  if (wbrels) wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
  var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
  wsloop: for (i2 = 0; i2 != props.Worksheets; ++i2) {
    var stype = "sheet";
    if (wbrels && wbrels[i2]) {
      path2 = "xl/" + wbrels[i2][1].replace(/[\/]?xl\//, "");
      if (!safegetzipfile(zip, path2)) path2 = wbrels[i2][1];
      if (!safegetzipfile(zip, path2)) path2 = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i2][1];
      stype = wbrels[i2][2];
    } else {
      path2 = "xl/worksheets/sheet" + (i2 + 1 - nmode) + "." + wbext;
      path2 = path2.replace(/sheet0\./, "sheet.");
    }
    relsPath = path2.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
    if (opts && opts.sheets != null) switch (typeof opts.sheets) {
      case "number":
        if (i2 != opts.sheets) continue wsloop;
        break;
      case "string":
        if (props.SheetNames[i2].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop;
        break;
      default:
        if (Array.isArray && Array.isArray(opts.sheets)) {
          var snjseen = false;
          for (var snj = 0; snj != opts.sheets.length; ++snj) {
            if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i2) snjseen = 1;
            if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i2].toLowerCase()) snjseen = 1;
          }
          if (!snjseen) continue wsloop;
        }
    }
    safe_parse_sheet(zip, path2, relsPath, props.SheetNames[i2], i2, sheetRels, sheets, stype, opts, wb, themes, styles);
  }
  out = {
    Directory: dir,
    Workbook: wb,
    Props: props,
    Custprops: custprops,
    Deps: deps,
    Sheets: sheets,
    SheetNames: props.SheetNames,
    Strings: strs,
    Styles: styles,
    Themes: themes,
    SSF: dup(table_fmt)
  };
  if (opts && opts.bookFiles) {
    if (zip.files) {
      out.keys = entries2;
      out.files = zip.files;
    } else {
      out.keys = [];
      out.files = {};
      zip.FullPaths.forEach(function(p2, idx) {
        p2 = p2.replace(/^Root Entry[\/]/, "");
        out.keys.push(p2);
        out.files[p2] = zip.FileIndex[idx];
      });
    }
  }
  if (opts && opts.bookVBA) {
    if (dir.vba.length > 0) out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
    else if (dir.defaults && dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
  }
  return out;
}
function parse_xlsxcfb(cfb, _opts) {
  var opts = _opts || {};
  var f2 = "Workbook", data = CFB.find(cfb, f2);
  try {
    f2 = "/!DataSpaces/Version";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    parse_DataSpaceVersionInfo(data.content);
    f2 = "/!DataSpaces/DataSpaceMap";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    var dsm = parse_DataSpaceMap(data.content);
    if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + f2);
    f2 = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    var seds = parse_DataSpaceDefinition(data.content);
    if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + f2);
    f2 = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    parse_Primary(data.content);
  } catch (e2) {
  }
  f2 = "/EncryptionInfo";
  data = CFB.find(cfb, f2);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
  var einfo = parse_EncryptionInfo(data.content);
  f2 = "/EncryptedPackage";
  data = CFB.find(cfb, f2);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
  if (einfo[0] == 4 && typeof decrypt_agile !== "undefined") return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
  if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined") return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
  throw new Error("File is password-protected");
}
function firstbyte(f2, o2) {
  var x2 = "";
  switch ((o2 || {}).type || "base64") {
    case "buffer":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    case "base64":
      x2 = Base64_decode(f2.slice(0, 12));
      break;
    case "binary":
      x2 = f2;
      break;
    case "array":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    default:
      throw new Error("Unrecognized type " + (o2 && o2.type || "undefined"));
  }
  return [x2.charCodeAt(0), x2.charCodeAt(1), x2.charCodeAt(2), x2.charCodeAt(3), x2.charCodeAt(4), x2.charCodeAt(5), x2.charCodeAt(6), x2.charCodeAt(7)];
}
function read_cfb(cfb, opts) {
  if (CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);
  return parse_xlscfb(cfb, opts);
}
function read_zip(data, opts) {
  var zip, d2 = data;
  var o2 = opts || {};
  if (!o2.type) o2.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  zip = zip_read(d2, o2);
  return parse_zip(zip, o2);
}
function read_plaintext(data, o2) {
  var i2 = 0;
  main: while (i2 < data.length) switch (data.charCodeAt(i2)) {
    case 10:
    case 13:
    case 32:
      ++i2;
      break;
    case 60:
      return parse_xlml(data.slice(i2), o2);
    default:
      break main;
  }
  return PRN.to_workbook(data, o2);
}
function read_plaintext_raw(data, o2) {
  var str = "", bytes = firstbyte(data, o2);
  switch (o2.type) {
    case "base64":
      str = Base64_decode(data);
      break;
    case "binary":
      str = data;
      break;
    case "buffer":
      str = data.toString("binary");
      break;
    case "array":
      str = cc2str(data);
      break;
    default:
      throw new Error("Unrecognized type " + o2.type);
  }
  if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str);
  o2.type = "binary";
  return read_plaintext(str, o2);
}
function read_utf16(data, o2) {
  var d2 = data;
  if (o2.type == "base64") d2 = Base64_decode(d2);
  d2 = $cptable.utils.decode(1200, d2.slice(2), "str");
  o2.type = "binary";
  return read_plaintext(d2, o2);
}
function bstrify(data) {
  return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
}
function read_prn(data, d2, o2, str) {
  if (str) {
    o2.type = "string";
    return PRN.to_workbook(data, o2);
  }
  return PRN.to_workbook(d2, o2);
}
function readSync(data, opts) {
  reset_cp();
  var o2 = opts || {};
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o2 = dup(o2), o2.type = "array", o2));
  if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o2.type) o2.type = typeof Deno !== "undefined" ? "buffer" : "array";
  var d2 = data, n2 = [0, 0, 0, 0], str = false;
  if (o2.cellStyles) {
    o2.cellNF = true;
    o2.sheetStubs = true;
  }
  _ssfopts = {};
  if (o2.dateNF) _ssfopts.dateNF = o2.dateNF;
  if (!o2.type) o2.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  if (o2.type == "file") {
    o2.type = has_buf ? "buffer" : "binary";
    d2 = read_binary(data);
    if (typeof Uint8Array !== "undefined" && !has_buf) o2.type = "array";
  }
  if (o2.type == "string") {
    str = true;
    o2.type = "binary";
    o2.codepage = 65001;
    d2 = bstrify(data);
  }
  if (o2.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
    var ab = new ArrayBuffer(3), vu = new Uint8Array(ab);
    vu.foo = "bar";
    if (!vu.foo) {
      o2 = dup(o2);
      o2.type = "array";
      return readSync(ab2a(d2), o2);
    }
  }
  switch ((n2 = firstbyte(d2, o2))[0]) {
    case 208:
      if (n2[1] === 207 && n2[2] === 17 && n2[3] === 224 && n2[4] === 161 && n2[5] === 177 && n2[6] === 26 && n2[7] === 225) return read_cfb(CFB.read(d2, o2), o2);
      break;
    case 9:
      if (n2[1] <= 8) return parse_xlscfb(d2, o2);
      break;
    case 60:
      return parse_xlml(d2, o2);
    case 73:
      if (n2[1] === 73 && n2[2] === 42 && n2[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (n2[1] === 68) return read_wb_ID(d2, o2);
      break;
    case 84:
      if (n2[1] === 65 && n2[2] === 66 && n2[3] === 76) return DIF.to_workbook(d2, o2);
      break;
    case 80:
      return n2[1] === 75 && n2[2] < 9 && n2[3] < 9 ? read_zip(d2, o2) : read_prn(data, d2, o2, str);
    case 239:
      return n2[3] === 60 ? parse_xlml(d2, o2) : read_prn(data, d2, o2, str);
    case 255:
      if (n2[1] === 254) {
        return read_utf16(d2, o2);
      } else if (n2[1] === 0 && n2[2] === 2 && n2[3] === 0) return WK_.to_workbook(d2, o2);
      break;
    case 0:
      if (n2[1] === 0) {
        if (n2[2] >= 2 && n2[3] === 0) return WK_.to_workbook(d2, o2);
        if (n2[2] === 0 && (n2[3] === 8 || n2[3] === 9)) return WK_.to_workbook(d2, o2);
      }
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(d2, o2);
    case 123:
      if (n2[1] === 92 && n2[2] === 114 && n2[3] === 116) return RTF.to_workbook(d2, o2);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(d2, o2);
    case 137:
      if (n2[1] === 80 && n2[2] === 78 && n2[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
  }
  if (DBF_SUPPORTED_VERSIONS.indexOf(n2[0]) > -1 && n2[2] <= 12 && n2[3] <= 31) return DBF.to_workbook(d2, o2);
  return read_prn(data, d2, o2, str);
}
function make_json_row(sheet, r2, R2, cols, header, hdr, dense, o2) {
  var rr = encode_row(R2);
  var defval = o2.defval, raw = o2.raw || !Object.prototype.hasOwnProperty.call(o2, "raw");
  var isempty = true;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty) try {
      Object.defineProperty(row, "__rowNum__", { value: R2, enumerable: false });
    } catch (e2) {
      row.__rowNum__ = R2;
    }
    else row.__rowNum__ = R2;
  }
  if (!dense || sheet[R2]) for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    var val = dense ? sheet[R2][C2] : sheet[cols[C2] + rr];
    if (val === void 0 || val.t === void 0) {
      if (defval === void 0) continue;
      if (hdr[C2] != null) {
        row[hdr[C2]] = defval;
      }
      continue;
    }
    var v2 = val.v;
    switch (val.t) {
      case "z":
        if (v2 == null) break;
        continue;
      case "e":
        v2 = v2 == 0 ? null : void 0;
        break;
      case "s":
      case "d":
      case "b":
      case "n":
        break;
      default:
        throw new Error("unrecognized type " + val.t);
    }
    if (hdr[C2] != null) {
      if (v2 == null) {
        if (val.t == "e" && v2 === null) row[hdr[C2]] = null;
        else if (defval !== void 0) row[hdr[C2]] = defval;
        else if (raw && v2 === null) row[hdr[C2]] = null;
        else continue;
      } else {
        row[hdr[C2]] = raw && (val.t !== "n" || val.t === "n" && o2.rawNumbers !== false) ? v2 : format_cell(val, v2, o2);
      }
      if (v2 != null) isempty = false;
    }
  }
  return { row, isempty };
}
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null) return [];
  var val = { t: "n", v: 0 }, header = 0, offset = 1, hdr = [], v2 = 0, vv = "";
  var r2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o2 = opts || {};
  var range = o2.range != null ? o2.range : sheet["!ref"];
  if (o2.header === 1) header = 1;
  else if (o2.header === "A") header = 2;
  else if (Array.isArray(o2.header)) header = 3;
  else if (o2.header == null) header = 0;
  switch (typeof range) {
    case "string":
      r2 = safe_decode_range(range);
      break;
    case "number":
      r2 = safe_decode_range(sheet["!ref"]);
      r2.s.r = range;
      break;
    default:
      r2 = range;
  }
  if (header > 0) offset = 0;
  var rr = encode_row(r2.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = Array.isArray(sheet);
  var R2 = r2.s.r, C2 = 0;
  var header_cnt = {};
  if (dense && !sheet[R2]) sheet[R2] = [];
  var colinfo = o2.skipHidden && sheet["!cols"] || [];
  var rowinfo = o2.skipHidden && sheet["!rows"] || [];
  for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    if ((colinfo[C2] || {}).hidden) continue;
    cols[C2] = encode_col(C2);
    val = dense ? sheet[R2][C2] : sheet[cols[C2] + rr];
    switch (header) {
      case 1:
        hdr[C2] = C2 - r2.s.c;
        break;
      case 2:
        hdr[C2] = cols[C2];
        break;
      case 3:
        hdr[C2] = o2.header[C2 - r2.s.c];
        break;
      default:
        if (val == null) val = { w: "__EMPTY", t: "s" };
        vv = v2 = format_cell(val, null, o2);
        counter = header_cnt[v2] || 0;
        if (!counter) header_cnt[v2] = 1;
        else {
          do {
            vv = v2 + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v2] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C2] = vv;
    }
  }
  for (R2 = r2.s.r + offset; R2 <= r2.e.r; ++R2) {
    if ((rowinfo[R2] || {}).hidden) continue;
    var row = make_json_row(sheet, r2, R2, cols, header, hdr, dense, o2);
    if (row.isempty === false || (header === 1 ? o2.blankrows !== false : !!o2.blankrows)) out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
function book_new() {
  return { SheetNames: [], Sheets: {} };
}
function book_append_sheet(wb, ws, name, roll) {
  var i2 = 1;
  if (!name) {
    for (; i2 <= 65535; ++i2, name = void 0) if (wb.SheetNames.indexOf(name = "Sheet" + i2) == -1) break;
  }
  if (!name || wb.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (roll && wb.SheetNames.indexOf(name) >= 0) {
    var m2 = name.match(/(^.*?)(\d+)$/);
    i2 = m2 && +m2[2] || 0;
    var root = m2 && m2[1] || name;
    for (++i2; i2 <= 65535; ++i2) if (wb.SheetNames.indexOf(name = root + i2) == -1) break;
  }
  check_ws_name(name);
  if (wb.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
  wb.SheetNames.push(name);
  wb.Sheets[name] = ws;
  return name;
}
var utils = {
  sheet_to_json
};
var papaparse_min$1 = { exports: {} };
/* @license
Papa Parse
v5.4.1
https://github.com/mholt/PapaParse
License: MIT
*/
var papaparse_min = papaparse_min$1.exports;
var hasRequiredPapaparse_min;
function requirePapaparse_min() {
  if (hasRequiredPapaparse_min) return papaparse_min$1.exports;
  hasRequiredPapaparse_min = 1;
  (function(module, exports) {
    !(function(e2, t3) {
      module.exports = t3();
    })(papaparse_min, function s2() {
      var f2 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f2 ? f2 : {};
      var n2 = !f2.document && !!f2.postMessage, o2 = f2.IS_PAPA_WORKER || false, a2 = {}, u2 = 0, b2 = { parse: function(e2, t3) {
        var r3 = (t3 = t3 || {}).dynamicTyping || false;
        J2(r3) && (t3.dynamicTypingFunction = r3, r3 = {});
        if (t3.dynamicTyping = r3, t3.transform = !!J2(t3.transform) && t3.transform, t3.worker && b2.WORKERS_SUPPORTED) {
          var i2 = (function() {
            if (!b2.WORKERS_SUPPORTED) return false;
            var e3 = (r4 = f2.URL || f2.webkitURL || null, i3 = s2.toString(), b2.BLOB_URL || (b2.BLOB_URL = r4.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i3, ")();"], { type: "text/javascript" })))), t4 = new f2.Worker(e3);
            var r4, i3;
            return t4.onmessage = _2, t4.id = u2++, a2[t4.id] = t4;
          })();
          return i2.userStep = t3.step, i2.userChunk = t3.chunk, i2.userComplete = t3.complete, i2.userError = t3.error, t3.step = J2(t3.step), t3.chunk = J2(t3.chunk), t3.complete = J2(t3.complete), t3.error = J2(t3.error), delete t3.worker, void i2.postMessage({ input: e2, config: t3, workerId: i2.id });
        }
        var n3 = null;
        b2.NODE_STREAM_INPUT, "string" == typeof e2 ? (e2 = (function(e3) {
          if (65279 === e3.charCodeAt(0)) return e3.slice(1);
          return e3;
        })(e2), n3 = t3.download ? new l2(t3) : new p2(t3)) : true === e2.readable && J2(e2.read) && J2(e2.on) ? n3 = new g2(t3) : (f2.File && e2 instanceof File || e2 instanceof Object) && (n3 = new c2(t3));
        return n3.stream(e2);
      }, unparse: function(e2, t3) {
        var n3 = false, _3 = true, m3 = ",", y3 = "\r\n", s3 = '"', a3 = s3 + s3, r3 = false, i2 = null, o3 = false;
        !(function() {
          if ("object" != typeof t3) return;
          "string" != typeof t3.delimiter || b2.BAD_DELIMITERS.filter(function(e3) {
            return -1 !== t3.delimiter.indexOf(e3);
          }).length || (m3 = t3.delimiter);
          ("boolean" == typeof t3.quotes || "function" == typeof t3.quotes || Array.isArray(t3.quotes)) && (n3 = t3.quotes);
          "boolean" != typeof t3.skipEmptyLines && "string" != typeof t3.skipEmptyLines || (r3 = t3.skipEmptyLines);
          "string" == typeof t3.newline && (y3 = t3.newline);
          "string" == typeof t3.quoteChar && (s3 = t3.quoteChar);
          "boolean" == typeof t3.header && (_3 = t3.header);
          if (Array.isArray(t3.columns)) {
            if (0 === t3.columns.length) throw new Error("Option columns is empty");
            i2 = t3.columns;
          }
          void 0 !== t3.escapeChar && (a3 = t3.escapeChar + s3);
          ("boolean" == typeof t3.escapeFormulae || t3.escapeFormulae instanceof RegExp) && (o3 = t3.escapeFormulae instanceof RegExp ? t3.escapeFormulae : /^[=+\-@\t\r].*$/);
        })();
        var u3 = new RegExp(Q2(s3), "g");
        "string" == typeof e2 && (e2 = JSON.parse(e2));
        if (Array.isArray(e2)) {
          if (!e2.length || Array.isArray(e2[0])) return h3(null, e2, r3);
          if ("object" == typeof e2[0]) return h3(i2 || Object.keys(e2[0]), e2, r3);
        } else if ("object" == typeof e2) return "string" == typeof e2.data && (e2.data = JSON.parse(e2.data)), Array.isArray(e2.data) && (e2.fields || (e2.fields = e2.meta && e2.meta.fields || i2), e2.fields || (e2.fields = Array.isArray(e2.data[0]) ? e2.fields : "object" == typeof e2.data[0] ? Object.keys(e2.data[0]) : []), Array.isArray(e2.data[0]) || "object" == typeof e2.data[0] || (e2.data = [e2.data])), h3(e2.fields || [], e2.data || [], r3);
        throw new Error("Unable to serialize unrecognized input");
        function h3(e3, t4, r4) {
          var i3 = "";
          "string" == typeof e3 && (e3 = JSON.parse(e3)), "string" == typeof t4 && (t4 = JSON.parse(t4));
          var n4 = Array.isArray(e3) && 0 < e3.length, s4 = !Array.isArray(t4[0]);
          if (n4 && _3) {
            for (var a4 = 0; a4 < e3.length; a4++) 0 < a4 && (i3 += m3), i3 += v3(e3[a4], a4);
            0 < t4.length && (i3 += y3);
          }
          for (var o4 = 0; o4 < t4.length; o4++) {
            var u4 = n4 ? e3.length : t4[o4].length, h4 = false, f3 = n4 ? 0 === Object.keys(t4[o4]).length : 0 === t4[o4].length;
            if (r4 && !n4 && (h4 = "greedy" === r4 ? "" === t4[o4].join("").trim() : 1 === t4[o4].length && 0 === t4[o4][0].length), "greedy" === r4 && n4) {
              for (var d3 = [], l3 = 0; l3 < u4; l3++) {
                var c3 = s4 ? e3[l3] : l3;
                d3.push(t4[o4][c3]);
              }
              h4 = "" === d3.join("").trim();
            }
            if (!h4) {
              for (var p3 = 0; p3 < u4; p3++) {
                0 < p3 && !f3 && (i3 += m3);
                var g3 = n4 && s4 ? e3[p3] : p3;
                i3 += v3(t4[o4][g3], p3);
              }
              o4 < t4.length - 1 && (!r4 || 0 < u4 && !f3) && (i3 += y3);
            }
          }
          return i3;
        }
        function v3(e3, t4) {
          if (null == e3) return "";
          if (e3.constructor === Date) return JSON.stringify(e3).slice(1, 25);
          var r4 = false;
          o3 && "string" == typeof e3 && o3.test(e3) && (e3 = "'" + e3, r4 = true);
          var i3 = e3.toString().replace(u3, a3);
          return (r4 = r4 || true === n3 || "function" == typeof n3 && n3(e3, t4) || Array.isArray(n3) && n3[t4] || (function(e4, t5) {
            for (var r5 = 0; r5 < t5.length; r5++) if (-1 < e4.indexOf(t5[r5])) return true;
            return false;
          })(i3, b2.BAD_DELIMITERS) || -1 < i3.indexOf(m3) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s3 + i3 + s3 : i3;
        }
      } };
      if (b2.RECORD_SEP = String.fromCharCode(30), b2.UNIT_SEP = String.fromCharCode(31), b2.BYTE_ORDER_MARK = "\uFEFF", b2.BAD_DELIMITERS = ["\r", "\n", '"', b2.BYTE_ORDER_MARK], b2.WORKERS_SUPPORTED = !n2 && !!f2.Worker, b2.NODE_STREAM_INPUT = 1, b2.LocalChunkSize = 10485760, b2.RemoteChunkSize = 5242880, b2.DefaultDelimiter = ",", b2.Parser = E2, b2.ParserHandle = r2, b2.NetworkStreamer = l2, b2.FileStreamer = c2, b2.StringStreamer = p2, b2.ReadableStreamStreamer = g2, f2.jQuery) {
        var d2 = f2.jQuery;
        d2.fn.parse = function(o3) {
          var r3 = o3.config || {}, u3 = [];
          return this.each(function(e3) {
            if (!("INPUT" === d2(this).prop("tagName").toUpperCase() && "file" === d2(this).attr("type").toLowerCase() && f2.FileReader) || !this.files || 0 === this.files.length) return true;
            for (var t3 = 0; t3 < this.files.length; t3++) u3.push({ file: this.files[t3], inputElem: this, instanceConfig: d2.extend({}, r3) });
          }), e2(), this;
          function e2() {
            if (0 !== u3.length) {
              var e3, t3, r4, i2, n3 = u3[0];
              if (J2(o3.before)) {
                var s3 = o3.before(n3.file, n3.inputElem);
                if ("object" == typeof s3) {
                  if ("abort" === s3.action) return e3 = "AbortError", t3 = n3.file, r4 = n3.inputElem, i2 = s3.reason, void (J2(o3.error) && o3.error({ name: e3 }, t3, r4, i2));
                  if ("skip" === s3.action) return void h3();
                  "object" == typeof s3.config && (n3.instanceConfig = d2.extend(n3.instanceConfig, s3.config));
                } else if ("skip" === s3) return void h3();
              }
              var a3 = n3.instanceConfig.complete;
              n3.instanceConfig.complete = function(e4) {
                J2(a3) && a3(e4, n3.file, n3.inputElem), h3();
              }, b2.parse(n3.file, n3.instanceConfig);
            } else J2(o3.complete) && o3.complete();
          }
          function h3() {
            u3.splice(0, 1), e2();
          }
        };
      }
      function h2(e2) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, (function(e3) {
          var t3 = w2(e3);
          t3.chunkSize = parseInt(t3.chunkSize), e3.step || e3.chunk || (t3.chunkSize = null);
          this._handle = new r2(t3), (this._handle.streamer = this)._config = t3;
        }).call(this, e2), this.parseChunk = function(e3, t3) {
          if (this.isFirstChunk && J2(this._config.beforeFirstChunk)) {
            var r3 = this._config.beforeFirstChunk(e3);
            void 0 !== r3 && (e3 = r3);
          }
          this.isFirstChunk = false, this._halted = false;
          var i2 = this._partialLine + e3;
          this._partialLine = "";
          var n3 = this._handle.parse(i2, this._baseIndex, !this._finished);
          if (!this._handle.paused() && !this._handle.aborted()) {
            var s3 = n3.meta.cursor;
            this._finished || (this._partialLine = i2.substring(s3 - this._baseIndex), this._baseIndex = s3), n3 && n3.data && (this._rowCount += n3.data.length);
            var a3 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
            if (o2) f2.postMessage({ results: n3, workerId: b2.WORKER_ID, finished: a3 });
            else if (J2(this._config.chunk) && !t3) {
              if (this._config.chunk(n3, this._handle), this._handle.paused() || this._handle.aborted()) return void (this._halted = true);
              n3 = void 0, this._completeResults = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n3.data), this._completeResults.errors = this._completeResults.errors.concat(n3.errors), this._completeResults.meta = n3.meta), this._completed || !a3 || !J2(this._config.complete) || n3 && n3.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a3 || n3 && n3.meta.paused || this._nextChunk(), n3;
          }
          this._halted = true;
        }, this._sendError = function(e3) {
          J2(this._config.error) ? this._config.error(e3) : o2 && this._config.error && f2.postMessage({ workerId: b2.WORKER_ID, error: e3, finished: false });
        };
      }
      function l2(e2) {
        var i2;
        (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.RemoteChunkSize), h2.call(this, e2), this._nextChunk = n2 ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e3) {
          this._input = e3, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished) this._chunkLoaded();
          else {
            if (i2 = new XMLHttpRequest(), this._config.withCredentials && (i2.withCredentials = this._config.withCredentials), n2 || (i2.onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)), i2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n2), this._config.downloadRequestHeaders) {
              var e3 = this._config.downloadRequestHeaders;
              for (var t3 in e3) i2.setRequestHeader(t3, e3[t3]);
            }
            if (this._config.chunkSize) {
              var r3 = this._start + this._config.chunkSize - 1;
              i2.setRequestHeader("Range", "bytes=" + this._start + "-" + r3);
            }
            try {
              i2.send(this._config.downloadRequestBody);
            } catch (e4) {
              this._chunkError(e4.message);
            }
            n2 && 0 === i2.status && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          4 === i2.readyState && (i2.status < 200 || 400 <= i2.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i2.responseText.length, this._finished = !this._config.chunkSize || this._start >= (function(e3) {
            var t3 = e3.getResponseHeader("Content-Range");
            if (null === t3) return -1;
            return parseInt(t3.substring(t3.lastIndexOf("/") + 1));
          })(i2), this.parseChunk(i2.responseText)));
        }, this._chunkError = function(e3) {
          var t3 = i2.statusText || e3;
          this._sendError(new Error(t3));
        };
      }
      function c2(e2) {
        var i2, n3;
        (e2 = e2 || {}).chunkSize || (e2.chunkSize = b2.LocalChunkSize), h2.call(this, e2);
        var s3 = "undefined" != typeof FileReader;
        this.stream = function(e3) {
          this._input = e3, n3 = e3.slice || e3.webkitSlice || e3.mozSlice, s3 ? ((i2 = new FileReader()).onload = v2(this._chunkLoaded, this), i2.onerror = v2(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e3 = this._input;
          if (this._config.chunkSize) {
            var t3 = Math.min(this._start + this._config.chunkSize, this._input.size);
            e3 = n3.call(e3, this._start, t3);
          }
          var r3 = i2.readAsText(e3, this._config.encoding);
          s3 || this._chunkLoaded({ target: { result: r3 } });
        }, this._chunkLoaded = function(e3) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e3.target.result);
        }, this._chunkError = function() {
          this._sendError(i2.error);
        };
      }
      function p2(e2) {
        var r3;
        h2.call(this, e2 = e2 || {}), this.stream = function(e3) {
          return r3 = e3, this._nextChunk();
        }, this._nextChunk = function() {
          if (!this._finished) {
            var e3, t3 = this._config.chunkSize;
            return t3 ? (e3 = r3.substring(0, t3), r3 = r3.substring(t3)) : (e3 = r3, r3 = ""), this._finished = !r3, this.parseChunk(e3);
          }
        };
      }
      function g2(e2) {
        h2.call(this, e2 = e2 || {});
        var t3 = [], r3 = true, i2 = false;
        this.pause = function() {
          h2.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          h2.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e3) {
          this._input = e3, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          i2 && 1 === t3.length && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t3.length ? this.parseChunk(t3.shift()) : r3 = true;
        }, this._streamData = v2(function(e3) {
          try {
            t3.push("string" == typeof e3 ? e3 : e3.toString(this._config.encoding)), r3 && (r3 = false, this._checkIsFinished(), this.parseChunk(t3.shift()));
          } catch (e4) {
            this._streamError(e4);
          }
        }, this), this._streamError = v2(function(e3) {
          this._streamCleanUp(), this._sendError(e3);
        }, this), this._streamEnd = v2(function() {
          this._streamCleanUp(), i2 = true, this._streamData("");
        }, this), this._streamCleanUp = v2(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function r2(m3) {
        var a3, o3, u3, i2 = Math.pow(2, 53), n3 = -i2, s3 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t3 = this, r3 = 0, f3 = 0, d3 = false, e2 = false, l3 = [], c3 = { data: [], errors: [], meta: {} };
        if (J2(m3.step)) {
          var p3 = m3.step;
          m3.step = function(e3) {
            if (c3 = e3, _3()) g3();
            else {
              if (g3(), 0 === c3.data.length) return;
              r3 += e3.data.length, m3.preview && r3 > m3.preview ? o3.abort() : (c3.data = c3.data[0], p3(c3, t3));
            }
          };
        }
        function y3(e3) {
          return "greedy" === m3.skipEmptyLines ? "" === e3.join("").trim() : 1 === e3.length && 0 === e3[0].length;
        }
        function g3() {
          return c3 && u3 && (k2("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b2.DefaultDelimiter + "'"), u3 = false), m3.skipEmptyLines && (c3.data = c3.data.filter(function(e3) {
            return !y3(e3);
          })), _3() && (function() {
            if (!c3) return;
            function e3(e4, t5) {
              J2(m3.transformHeader) && (e4 = m3.transformHeader(e4, t5)), l3.push(e4);
            }
            if (Array.isArray(c3.data[0])) {
              for (var t4 = 0; _3() && t4 < c3.data.length; t4++) c3.data[t4].forEach(e3);
              c3.data.splice(0, 1);
            } else c3.data.forEach(e3);
          })(), (function() {
            if (!c3 || !m3.header && !m3.dynamicTyping && !m3.transform) return c3;
            function e3(e4, t5) {
              var r4, i3 = m3.header ? {} : [];
              for (r4 = 0; r4 < e4.length; r4++) {
                var n4 = r4, s4 = e4[r4];
                m3.header && (n4 = r4 >= l3.length ? "__parsed_extra" : l3[r4]), m3.transform && (s4 = m3.transform(s4, n4)), s4 = v3(n4, s4), "__parsed_extra" === n4 ? (i3[n4] = i3[n4] || [], i3[n4].push(s4)) : i3[n4] = s4;
              }
              return m3.header && (r4 > l3.length ? k2("FieldMismatch", "TooManyFields", "Too many fields: expected " + l3.length + " fields but parsed " + r4, f3 + t5) : r4 < l3.length && k2("FieldMismatch", "TooFewFields", "Too few fields: expected " + l3.length + " fields but parsed " + r4, f3 + t5)), i3;
            }
            var t4 = 1;
            !c3.data.length || Array.isArray(c3.data[0]) ? (c3.data = c3.data.map(e3), t4 = c3.data.length) : c3.data = e3(c3.data, 0);
            m3.header && c3.meta && (c3.meta.fields = l3);
            return f3 += t4, c3;
          })();
        }
        function _3() {
          return m3.header && 0 === l3.length;
        }
        function v3(e3, t4) {
          return r4 = e3, m3.dynamicTypingFunction && void 0 === m3.dynamicTyping[r4] && (m3.dynamicTyping[r4] = m3.dynamicTypingFunction(r4)), true === (m3.dynamicTyping[r4] || m3.dynamicTyping) ? "true" === t4 || "TRUE" === t4 || "false" !== t4 && "FALSE" !== t4 && ((function(e4) {
            if (s3.test(e4)) {
              var t5 = parseFloat(e4);
              if (n3 < t5 && t5 < i2) return true;
            }
            return false;
          })(t4) ? parseFloat(t4) : h3.test(t4) ? new Date(t4) : "" === t4 ? null : t4) : t4;
          var r4;
        }
        function k2(e3, t4, r4, i3) {
          var n4 = { type: e3, code: t4, message: r4 };
          void 0 !== i3 && (n4.row = i3), c3.errors.push(n4);
        }
        this.parse = function(e3, t4, r4) {
          var i3 = m3.quoteChar || '"';
          if (m3.newline || (m3.newline = (function(e4, t5) {
            e4 = e4.substring(0, 1048576);
            var r5 = new RegExp(Q2(t5) + "([^]*?)" + Q2(t5), "gm"), i4 = (e4 = e4.replace(r5, "")).split("\r"), n5 = e4.split("\n"), s5 = 1 < n5.length && n5[0].length < i4[0].length;
            if (1 === i4.length || s5) return "\n";
            for (var a4 = 0, o4 = 0; o4 < i4.length; o4++) "\n" === i4[o4][0] && a4++;
            return a4 >= i4.length / 2 ? "\r\n" : "\r";
          })(e3, i3)), u3 = false, m3.delimiter) J2(m3.delimiter) && (m3.delimiter = m3.delimiter(e3), c3.meta.delimiter = m3.delimiter);
          else {
            var n4 = (function(e4, t5, r5, i4, n5) {
              var s5, a4, o4, u4;
              n5 = n5 || [",", "	", "|", ";", b2.RECORD_SEP, b2.UNIT_SEP];
              for (var h4 = 0; h4 < n5.length; h4++) {
                var f4 = n5[h4], d4 = 0, l4 = 0, c4 = 0;
                o4 = void 0;
                for (var p4 = new E2({ comments: i4, delimiter: f4, newline: t5, preview: 10 }).parse(e4), g4 = 0; g4 < p4.data.length; g4++) if (r5 && y3(p4.data[g4])) c4++;
                else {
                  var _4 = p4.data[g4].length;
                  l4 += _4, void 0 !== o4 ? 0 < _4 && (d4 += Math.abs(_4 - o4), o4 = _4) : o4 = _4;
                }
                0 < p4.data.length && (l4 /= p4.data.length - c4), (void 0 === a4 || d4 <= a4) && (void 0 === u4 || u4 < l4) && 1.99 < l4 && (a4 = d4, s5 = f4, u4 = l4);
              }
              return { successful: !!(m3.delimiter = s5), bestDelimiter: s5 };
            })(e3, m3.newline, m3.skipEmptyLines, m3.comments, m3.delimitersToGuess);
            n4.successful ? m3.delimiter = n4.bestDelimiter : (u3 = true, m3.delimiter = b2.DefaultDelimiter), c3.meta.delimiter = m3.delimiter;
          }
          var s4 = w2(m3);
          return m3.preview && m3.header && s4.preview++, a3 = e3, o3 = new E2(s4), c3 = o3.parse(a3, t4, r4), g3(), d3 ? { meta: { paused: true } } : c3 || { meta: { paused: false } };
        }, this.paused = function() {
          return d3;
        }, this.pause = function() {
          d3 = true, o3.abort(), a3 = J2(m3.chunk) ? "" : a3.substring(o3.getCharIndex());
        }, this.resume = function() {
          t3.streamer._halted ? (d3 = false, t3.streamer.parseChunk(a3, true)) : setTimeout(t3.resume, 3);
        }, this.aborted = function() {
          return e2;
        }, this.abort = function() {
          e2 = true, o3.abort(), c3.meta.aborted = true, J2(m3.complete) && m3.complete(c3), a3 = "";
        };
      }
      function Q2(e2) {
        return e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E2(j2) {
        var z2, M2 = (j2 = j2 || {}).delimiter, P2 = j2.newline, U2 = j2.comments, q2 = j2.step, N2 = j2.preview, B3 = j2.fastMode, K2 = z2 = void 0 === j2.quoteChar || null === j2.quoteChar ? '"' : j2.quoteChar;
        if (void 0 !== j2.escapeChar && (K2 = j2.escapeChar), ("string" != typeof M2 || -1 < b2.BAD_DELIMITERS.indexOf(M2)) && (M2 = ","), U2 === M2) throw new Error("Comment character same as delimiter");
        true === U2 ? U2 = "#" : ("string" != typeof U2 || -1 < b2.BAD_DELIMITERS.indexOf(U2)) && (U2 = false), "\n" !== P2 && "\r" !== P2 && "\r\n" !== P2 && (P2 = "\n");
        var W2 = 0, H4 = false;
        this.parse = function(i2, t3, r3) {
          if ("string" != typeof i2) throw new Error("Input must be a string");
          var n3 = i2.length, e2 = M2.length, s3 = P2.length, a3 = U2.length, o3 = J2(q2), u3 = [], h3 = [], f3 = [], d3 = W2 = 0;
          if (!i2) return L2();
          if (j2.header && !t3) {
            var l3 = i2.split(P2)[0].split(M2), c3 = [], p3 = {}, g3 = false;
            for (var _3 in l3) {
              var m3 = l3[_3];
              J2(j2.transformHeader) && (m3 = j2.transformHeader(m3, _3));
              var y3 = m3, v3 = p3[m3] || 0;
              for (0 < v3 && (g3 = true, y3 = m3 + "_" + v3), p3[m3] = v3 + 1; c3.includes(y3); ) y3 = y3 + "_" + v3;
              c3.push(y3);
            }
            if (g3) {
              var k2 = i2.split(P2);
              k2[0] = c3.join(M2), i2 = k2.join(P2);
            }
          }
          if (B3 || false !== B3 && -1 === i2.indexOf(z2)) {
            for (var b3 = i2.split(P2), E3 = 0; E3 < b3.length; E3++) {
              if (f3 = b3[E3], W2 += f3.length, E3 !== b3.length - 1) W2 += P2.length;
              else if (r3) return L2();
              if (!U2 || f3.substring(0, a3) !== U2) {
                if (o3) {
                  if (u3 = [], I2(f3.split(M2)), F2(), H4) return L2();
                } else I2(f3.split(M2));
                if (N2 && N2 <= E3) return u3 = u3.slice(0, N2), L2(true);
              }
            }
            return L2();
          }
          for (var w3 = i2.indexOf(M2, W2), R2 = i2.indexOf(P2, W2), C2 = new RegExp(Q2(K2) + Q2(z2), "g"), S2 = i2.indexOf(z2, W2); ; ) if (i2[W2] !== z2) if (U2 && 0 === f3.length && i2.substring(W2, W2 + a3) === U2) {
            if (-1 === R2) return L2();
            W2 = R2 + s3, R2 = i2.indexOf(P2, W2), w3 = i2.indexOf(M2, W2);
          } else if (-1 !== w3 && (w3 < R2 || -1 === R2)) f3.push(i2.substring(W2, w3)), W2 = w3 + e2, w3 = i2.indexOf(M2, W2);
          else {
            if (-1 === R2) break;
            if (f3.push(i2.substring(W2, R2)), D2(R2 + s3), o3 && (F2(), H4)) return L2();
            if (N2 && u3.length >= N2) return L2(true);
          }
          else for (S2 = W2, W2++; ; ) {
            if (-1 === (S2 = i2.indexOf(z2, S2 + 1))) return r3 || h3.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u3.length, index: W2 }), T2();
            if (S2 === n3 - 1) return T2(i2.substring(W2, S2).replace(C2, z2));
            if (z2 !== K2 || i2[S2 + 1] !== K2) {
              if (z2 === K2 || 0 === S2 || i2[S2 - 1] !== K2) {
                -1 !== w3 && w3 < S2 + 1 && (w3 = i2.indexOf(M2, S2 + 1)), -1 !== R2 && R2 < S2 + 1 && (R2 = i2.indexOf(P2, S2 + 1));
                var O2 = A2(-1 === R2 ? w3 : Math.min(w3, R2));
                if (i2.substr(S2 + 1 + O2, e2) === M2) {
                  f3.push(i2.substring(W2, S2).replace(C2, z2)), i2[W2 = S2 + 1 + O2 + e2] !== z2 && (S2 = i2.indexOf(z2, W2)), w3 = i2.indexOf(M2, W2), R2 = i2.indexOf(P2, W2);
                  break;
                }
                var x2 = A2(R2);
                if (i2.substring(S2 + 1 + x2, S2 + 1 + x2 + s3) === P2) {
                  if (f3.push(i2.substring(W2, S2).replace(C2, z2)), D2(S2 + 1 + x2 + s3), w3 = i2.indexOf(M2, W2), S2 = i2.indexOf(z2, W2), o3 && (F2(), H4)) return L2();
                  if (N2 && u3.length >= N2) return L2(true);
                  break;
                }
                h3.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u3.length, index: W2 }), S2++;
              }
            } else S2++;
          }
          return T2();
          function I2(e3) {
            u3.push(e3), d3 = W2;
          }
          function A2(e3) {
            var t4 = 0;
            if (-1 !== e3) {
              var r4 = i2.substring(S2 + 1, e3);
              r4 && "" === r4.trim() && (t4 = r4.length);
            }
            return t4;
          }
          function T2(e3) {
            return r3 || (void 0 === e3 && (e3 = i2.substring(W2)), f3.push(e3), W2 = n3, I2(f3), o3 && F2()), L2();
          }
          function D2(e3) {
            W2 = e3, I2(f3), f3 = [], R2 = i2.indexOf(P2, W2);
          }
          function L2(e3) {
            return { data: u3, errors: h3, meta: { delimiter: M2, linebreak: P2, aborted: H4, truncated: !!e3, cursor: d3 + (t3 || 0) } };
          }
          function F2() {
            q2(L2()), u3 = [], h3 = [];
          }
        }, this.abort = function() {
          H4 = true;
        }, this.getCharIndex = function() {
          return W2;
        };
      }
      function _2(e2) {
        var t3 = e2.data, r3 = a2[t3.workerId], i2 = false;
        if (t3.error) r3.userError(t3.error, t3.file);
        else if (t3.results && t3.results.data) {
          var n3 = { abort: function() {
            i2 = true, m2(t3.workerId, { data: [], errors: [], meta: { aborted: true } });
          }, pause: y2, resume: y2 };
          if (J2(r3.userStep)) {
            for (var s3 = 0; s3 < t3.results.data.length && (r3.userStep({ data: t3.results.data[s3], errors: t3.results.errors, meta: t3.results.meta }, n3), !i2); s3++) ;
            delete t3.results;
          } else J2(r3.userChunk) && (r3.userChunk(t3.results, n3, t3.file), delete t3.results);
        }
        t3.finished && !i2 && m2(t3.workerId, t3.results);
      }
      function m2(e2, t3) {
        var r3 = a2[e2];
        J2(r3.userComplete) && r3.userComplete(t3), r3.terminate(), delete a2[e2];
      }
      function y2() {
        throw new Error("Not implemented.");
      }
      function w2(e2) {
        if ("object" != typeof e2 || null === e2) return e2;
        var t3 = Array.isArray(e2) ? [] : {};
        for (var r3 in e2) t3[r3] = w2(e2[r3]);
        return t3;
      }
      function v2(e2, t3) {
        return function() {
          e2.apply(t3, arguments);
        };
      }
      function J2(e2) {
        return "function" == typeof e2;
      }
      return o2 && (f2.onmessage = function(e2) {
        var t3 = e2.data;
        void 0 === b2.WORKER_ID && t3 && (b2.WORKER_ID = t3.workerId);
        if ("string" == typeof t3.input) f2.postMessage({ workerId: b2.WORKER_ID, results: b2.parse(t3.input, t3.config), finished: true });
        else if (f2.File && t3.input instanceof File || t3.input instanceof Object) {
          var r3 = b2.parse(t3.input, t3.config);
          r3 && f2.postMessage({ workerId: b2.WORKER_ID, results: r3, finished: true });
        }
      }), (l2.prototype = Object.create(h2.prototype)).constructor = l2, (c2.prototype = Object.create(h2.prototype)).constructor = c2, (p2.prototype = Object.create(p2.prototype)).constructor = p2, (g2.prototype = Object.create(h2.prototype)).constructor = g2, b2;
    });
  })(papaparse_min$1);
  return papaparse_min$1.exports;
}
var papaparse_minExports = requirePapaparse_min();
const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparse_minExports);
function _typeof$1(o2) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof$1(o2);
}
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b2 = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b2[i2] = start += 1 << eb[i2 - 1];
  }
  var r2 = new i32(b2[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
      r2[j2] = j2 - b2[i2] << 5 | i2;
    }
  }
  return { b: b2, r: r2 };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), revfd = _b.r;
var rev = new u16(32768);
for (var i$6 = 0; i$6 < 32768; ++i$6) {
  var x$1 = (i$6 & 43690) >> 1 | (i$6 & 21845) << 1;
  x$1 = (x$1 & 52428) >> 2 | (x$1 & 13107) << 2;
  x$1 = (x$1 & 61680) >> 4 | (x$1 & 3855) << 4;
  rev[i$6] = ((x$1 & 65280) >> 8 | (x$1 & 255) << 8) >> 1;
}
var hMap = (function(cd, mb, r2) {
  var s2 = cd.length;
  var i2 = 0;
  var l2 = new u16(mb);
  for (; i2 < s2; ++i2) {
    if (cd[i2])
      ++l2[cd[i2] - 1];
  }
  var le2 = new u16(mb);
  for (i2 = 1; i2 < mb; ++i2) {
    le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
  }
  var co;
  if (r2) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v2 = le2[cd[i2] - 1]++ << r_1;
        for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
          co[rev[v2] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le2[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
});
var flt = new u8(288);
for (var i$6 = 0; i$6 < 144; ++i$6)
  flt[i$6] = 8;
for (var i$6 = 144; i$6 < 256; ++i$6)
  flt[i$6] = 9;
for (var i$6 = 256; i$6 < 280; ++i$6)
  flt[i$6] = 7;
for (var i$6 = 280; i$6 < 288; ++i$6)
  flt[i$6] = 8;
var fdt = new u8(32);
for (var i$6 = 0; i$6 < 32; ++i$6)
  fdt[i$6] = 5;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var shft = function(p2) {
  return (p2 + 7) / 8 | 0;
};
var slc = function(v2, s2, e2) {
  if (e2 == null || e2 > v2.length)
    e2 = v2.length;
  return new u8(v2.subarray(s2, e2));
};
var wbits = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
};
var wbits16 = function(d2, p2, v2) {
  v2 <<= p2 & 7;
  var o2 = p2 / 8 | 0;
  d2[o2] |= v2;
  d2[o2 + 1] |= v2 >> 8;
  d2[o2 + 2] |= v2 >> 16;
};
var hTree = function(d2, mb) {
  var t3 = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t3.push({ s: i2, f: d2[i2] });
  }
  var s2 = t3.length;
  var t22 = t3.slice();
  if (!s2)
    return { t: et$1, l: 0 };
  if (s2 == 1) {
    var v2 = new u8(t3[0].s + 1);
    v2[t3[0].s] = 1;
    return { t: v2, l: 1 };
  }
  t3.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  t3.push({ s: -1, f: 25001 });
  var l2 = t3[0], r2 = t3[1], i0 = 0, i1 = 1, i22 = 2;
  t3[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  while (i1 != s2 - 1) {
    l2 = t3[t3[i0].f < t3[i22].f ? i0++ : i22++];
    r2 = t3[i0 != i1 && t3[i0].f < t3[i22].f ? i0++ : i22++];
    t3[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
  }
  var maxSym = t22[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t22[i2].s > maxSym)
      maxSym = t22[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t3[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt2 = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t22.sort(function(a2, b2) {
      return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t22[i2].s;
      if (tr[i2_1] > mb) {
        dt2 += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt2 >>= lft;
    while (dt2 > 0) {
      var i2_2 = t22[i2].s;
      if (tr[i2_2] < mb)
        dt2 -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt2; --i2) {
      var i2_3 = t22[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt2;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n2, l2, d2) {
  return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
};
var lc = function(c2) {
  var s2 = c2.length;
  while (s2 && !c2[--s2])
    ;
  var cl = new u16(++s2);
  var cli = 0, cln = c2[0], cls = 1;
  var w2 = function(v2) {
    cl[cli++] = v2;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c2[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w2(32754);
        if (cls > 2) {
          w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w2(cln), --cls;
        for (; cls > 6; cls -= 6)
          w2(8304);
        if (cls > 2)
          w2(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w2(cln);
      cls = 1;
      cln = c2[i2];
    }
  }
  return { c: cl.subarray(0, cli), n: s2 };
};
var clen = function(cf, cl) {
  var l2 = 0;
  for (var i2 = 0; i2 < cl.length; ++i2)
    l2 += cf[i2] * cl[i2];
  return l2;
};
var wfblk = function(out, pos, dat) {
  var s2 = dat.length;
  var o2 = shft(pos + 2);
  out[o2] = s2 & 255;
  out[o2 + 1] = s2 >> 8;
  out[o2 + 2] = out[o2] ^ 255;
  out[o2 + 3] = out[o2 + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2)
    out[o2 + i2 + 4] = dat[i2];
  return (o2 + 4 + s2) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
  wbits(out, p2++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2)
    ++lcfreq[lclt[i2] & 31];
  for (var i2 = 0; i2 < lcdt.length; ++i2)
    ++lcfreq[lcdt[i2] & 31];
  var _e2 = hTree(lcfreq, 7), lct = _e2.t, mlcb = _e2.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p2, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p2, nlc - 257);
    wbits(out, p2 + 5, ndc - 1);
    wbits(out, p2 + 10, nlcc - 4);
    p2 += 14;
    for (var i2 = 0; i2 < nlcc; ++i2)
      wbits(out, p2 + 3 * i2, lct[clim[i2]]);
    p2 += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it2 = 0; it2 < 2; ++it2) {
      var clct = lcts[it2];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p2, llm[len]), p2 += lct[len];
        if (len > 15)
          wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    var sym = syms[i2];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
      if (len > 7)
        wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
      var dst = sym & 31;
      wbits16(out, p2, dm[dst]), p2 += dl[dst];
      if (dst > 3)
        wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
    } else {
      wbits16(out, p2, lm[sym]), p2 += ll[sym];
    }
  }
  wbits16(out, p2, lm[256]);
  return p2 + ll[256];
};
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et$1 = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st2) {
  var s2 = st2.z || dat.length;
  var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
  var w2 = o2.subarray(pre, o2.length - post);
  var lst = st2.l;
  var pos = (st2.r || 0) & 7;
  if (lvl) {
    if (pos)
      w2[0] = st2.r >> 3;
    var opt = deo[lvl - 1];
    var n2 = opt >> 13, c2 = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
    for (; i2 + 2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j2 = 0; j2 < 286; ++j2)
            lf[j2] = 0;
          for (var j2 = 0; j2 < 30; ++j2)
            df[j2] = 0;
        }
        var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n2, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                ;
              if (nl > l2) {
                l2 = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j2 = 0; j2 < mmd; ++j2) {
                  var ti = i2 - dif + j2 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
          var lin = revfl[l2] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l2;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
      syms[li++] = dat[i2];
      ++lf[dat[i2]];
    }
    pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst) {
      st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
      pos -= 7;
      st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
    }
  } else {
    for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
      var e2 = i2 + 65535;
      if (e2 >= s2) {
        w2[pos / 8 | 0] = lst;
        e2 = s2;
      }
      pos = wfblk(w2, pos + 1, dat.subarray(i2, e2));
    }
    st2.i = s2;
  }
  return slc(o2, 0, pre + shft(pos) + post);
};
var adler = function() {
  var a2 = 1, b2 = 0;
  return {
    p: function(d2) {
      var n2 = a2, m2 = b2;
      var l2 = d2.length | 0;
      for (var i2 = 0; i2 != l2; ) {
        var e2 = Math.min(i2 + 2655, l2);
        for (; i2 < e2; ++i2)
          m2 += n2 += d2[i2];
        n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
      }
      a2 = n2, b2 = m2;
    },
    d: function() {
      a2 %= 65521, b2 %= 65521;
      return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
    }
  };
};
var dopt = function(dat, opt, pre, post, st2) {
  if (!st2) {
    st2 = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st2.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
};
var wbytes = function(d2, b2, v2) {
  for (; v2; ++b2)
    d2[b2] = v2, v2 >>>= 8;
};
var zlh = function(c2, o2) {
  var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
  c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
  if (o2.dictionary) {
    var h2 = adler();
    h2.p(o2.dictionary);
    wbytes(c2, 2, h2.d());
  }
};
function zlibSync(data, opts) {
  if (!opts)
    opts = {};
  var a2 = adler();
  a2.p(data);
  var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
  return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et$1, { stream: true });
  tds = 1;
} catch (e2) {
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _iterableToArrayLimit(r2, l2) {
  var t3 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t3) {
    var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i2 = (t3 = t3.call(r2)).next, 0 === l2) ;
      else for (; !(f2 = (e2 = i2.call(t3)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t3["return"] && (u2 = t3["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o2) throw n2;
      }
    }
    return a2;
  }
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
  return n2;
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t3 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t3 && r2.constructor && (t3 = r2.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(r2) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
function decode$2(bytes, encoding = "utf8") {
  const decoder = new TextDecoder(encoding);
  return decoder.decode(bytes);
}
const encoder = new TextEncoder();
function encode(str) {
  return encoder.encode(str);
}
const defaultByteLength = 1024 * 8;
const hostBigEndian = (() => {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !((view[0] = 1) & array[0]);
})();
const typedArrays = {
  int8: globalThis.Int8Array,
  uint8: globalThis.Uint8Array,
  int16: globalThis.Int16Array,
  uint16: globalThis.Uint16Array,
  int32: globalThis.Int32Array,
  uint32: globalThis.Uint32Array,
  uint64: globalThis.BigUint64Array,
  int64: globalThis.BigInt64Array,
  float32: globalThis.Float32Array,
  float64: globalThis.Float64Array
};
class IOBuffer {
  /**
   * Reference to the internal ArrayBuffer object.
   */
  buffer;
  /**
   * Byte length of the internal ArrayBuffer.
   */
  byteLength;
  /**
   * Byte offset of the internal ArrayBuffer.
   */
  byteOffset;
  /**
   * Byte length of the internal ArrayBuffer.
   */
  length;
  /**
   * The current offset of the buffer's pointer.
   */
  offset;
  lastWrittenByte;
  littleEndian;
  _data;
  _mark;
  _marks;
  /**
   * Create a new IOBuffer.
   * @param data - The data to construct the IOBuffer with.
   * If data is a number, it will be the new buffer's length<br>
   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
   * @param options - An object for the options.
   * @returns A new IOBuffer instance.
   */
  constructor(data = defaultByteLength, options = {}) {
    let dataIsGiven = false;
    if (typeof data === "number") {
      data = new ArrayBuffer(data);
    } else {
      dataIsGiven = true;
      this.lastWrittenByte = data.byteLength;
    }
    const offset = options.offset ? options.offset >>> 0 : 0;
    const byteLength = data.byteLength - offset;
    let dvOffset = offset;
    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
      if (data.byteLength !== data.buffer.byteLength) {
        dvOffset = data.byteOffset + offset;
      }
      data = data.buffer;
    }
    if (dataIsGiven) {
      this.lastWrittenByte = byteLength;
    } else {
      this.lastWrittenByte = 0;
    }
    this.buffer = data;
    this.length = byteLength;
    this.byteLength = byteLength;
    this.byteOffset = dvOffset;
    this.offset = 0;
    this.littleEndian = true;
    this._data = new DataView(this.buffer, dvOffset, byteLength);
    this._mark = 0;
    this._marks = [];
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more
   * bytes after the offset.
   * @param byteLength - The needed memory in bytes.
   * @returns `true` if there is sufficient space and `false` otherwise.
   */
  available(byteLength = 1) {
    return this.offset + byteLength <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte
   * values.
   * @returns `true` if little-endian mode is used, `false` otherwise.
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setLittleEndian() {
    this.littleEndian = true;
    return this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values.
   * @returns `true` if big-endian mode is used, `false` otherwise.
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values.
   * @returns This.
   */
  setBigEndian() {
    this.littleEndian = false;
    return this;
  }
  /**
   * Move the pointer n bytes forward.
   * @param n - Number of bytes to skip.
   * @returns This.
   */
  skip(n2 = 1) {
    this.offset += n2;
    return this;
  }
  /**
   * Move the pointer n bytes backward.
   * @param n - Number of bytes to move back.
   * @returns This.
   */
  back(n2 = 1) {
    this.offset -= n2;
    return this;
  }
  /**
   * Move the pointer to the given offset.
   * @param offset - The offset to move to.
   * @returns This.
   */
  seek(offset) {
    this.offset = offset;
    return this;
  }
  /**
   * Store the current pointer offset.
   * @see {@link IOBuffer#reset}
   * @returns This.
   */
  mark() {
    this._mark = this.offset;
    return this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark.
   * @see {@link IOBuffer#mark}
   * @returns This.
   */
  reset() {
    this.offset = this._mark;
    return this;
  }
  /**
   * Push the current pointer offset to the mark stack.
   * @see {@link IOBuffer#popMark}
   * @returns This.
   */
  pushMark() {
    this._marks.push(this.offset);
    return this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current
   * pointer offset to the popped value.
   * @see {@link IOBuffer#pushMark}
   * @returns This.
   */
  popMark() {
    const offset = this._marks.pop();
    if (offset === void 0) {
      throw new Error("Mark stack empty");
    }
    this.seek(offset);
    return this;
  }
  /**
   * Move the pointer offset back to 0.
   * @returns This.
   */
  rewind() {
    this.offset = 0;
    return this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at
   * the current pointer offset.
   * If the buffer's memory is insufficient, this method will create a new
   * buffer (a copy) with a length that is twice (byteLength + current offset).
   * @param byteLength - The needed memory in bytes.
   * @returns This.
   */
  ensureAvailable(byteLength = 1) {
    if (!this.available(byteLength)) {
      const lengthNeeded = this.offset + byteLength;
      const newLength = lengthNeeded * 2;
      const newArray = new Uint8Array(newLength);
      newArray.set(new Uint8Array(this.buffer));
      this.buffer = newArray.buffer;
      this.length = newLength;
      this.byteLength = newLength;
      this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise.
   * Moves pointer forward by one byte.
   * @returns The read boolean.
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
   * @returns The read byte.
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}.
   * @returns The read byte.
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read `n` bytes and move pointer forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The read bytes.
   */
  readBytes(n2 = 1) {
    return this.readArray(n2, "uint8");
  }
  /**
   * Creates an array of corresponding to the type `type` and size `size`.
   * For example type `uint8` will create a `Uint8Array`.
   * @param size - size of the resulting array
   * @param type - number type of elements to read
   * @returns The read array.
   */
  readArray(size, type) {
    const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
    const offset = this.byteOffset + this.offset;
    const slice = this.buffer.slice(offset, offset + bytes);
    if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
      const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
      slice2.reverse();
      const returnArray2 = new typedArrays[type](slice2.buffer);
      this.offset += bytes;
      returnArray2.reverse();
      return returnArray2;
    }
    const returnArray = new typedArrays[type](slice);
    this.offset += bytes;
    return returnArray;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readInt16() {
    const value = this._data.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
   * @returns The read value.
   */
  readUint16() {
    const value = this._data.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readInt32() {
    const value = this._data.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readUint32() {
    const value = this._data.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit floating number and move pointer forward by 4 bytes.
   * @returns The read value.
   */
  readFloat32() {
    const value = this._data.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 64-bit floating number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readFloat64() {
    const value = this._data.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigInt64() {
    const value = this._data.getBigInt64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
   * @returns The read value.
   */
  readBigUint64() {
    const value = this._data.getBigUint64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read a 1-byte ASCII character and move pointer forward by 1 byte.
   * @returns The read character.
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
   * @param n - Number of characters to read.
   * @returns The read characters.
   */
  readChars(n2 = 1) {
    let result = "";
    for (let i2 = 0; i2 < n2; i2++) {
      result += this.readChar();
    }
    return result;
  }
  /**
   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
   * forward by `n` bytes.
   * @param n - Number of bytes to read.
   * @returns The decoded string.
   */
  readUtf8(n2 = 1) {
    return decode$2(this.readBytes(n2));
  }
  /**
   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
   * forward by `n` bytes.
   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
   * @param n - Number of bytes to read.
   * @param encoding - The encoding to use. Default is 'utf8'.
   * @returns The decoded string.
   */
  decodeText(n2 = 1, encoding = "utf8") {
    return decode$2(this.readBytes(n2), encoding);
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
   * forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeBoolean(value) {
    this.writeUint8(value ? 255 : 0);
    return this;
  }
  /**
   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt8(value) {
    this.ensureAvailable(1);
    this._data.setInt8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
   * byte.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint8(value) {
    this.ensureAvailable(1);
    this._data.setUint8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * An alias for {@link IOBuffer#writeUint8}.
   * @param value - The value to write.
   * @returns This.
   */
  writeByte(value) {
    return this.writeUint8(value);
  }
  /**
   * Write all elements of `bytes` as uint8 values and move pointer forward by
   * `bytes.length` bytes.
   * @param bytes - The array of bytes to write.
   * @returns This.
   */
  writeBytes(bytes) {
    this.ensureAvailable(bytes.length);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      this._data.setUint8(this.offset++, bytes[i2]);
    }
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 16-bit signed integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt16(value) {
    this.ensureAvailable(2);
    this._data.setInt16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint16(value) {
    this.ensureAvailable(2);
    this._data.setUint16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit signed integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeInt32(value) {
    this.ensureAvailable(4);
    this._data.setInt32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeUint32(value) {
    this.ensureAvailable(4);
    this._data.setUint32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 32-bit floating number and move pointer forward by 4
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat32(value) {
    this.ensureAvailable(4);
    this._data.setFloat32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit floating number and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeFloat64(value) {
    this.ensureAvailable(8);
    this._data.setFloat64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit signed bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigInt64(value) {
    this.ensureAvailable(8);
    this._data.setBigInt64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
   * bytes.
   * @param value - The value to write.
   * @returns This.
   */
  writeBigUint64(value) {
    this.ensureAvailable(8);
    this._data.setBigUint64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write the charCode of `str`'s first character as an 8-bit unsigned integer
   * and move pointer forward by 1 byte.
   * @param str - The character to write.
   * @returns This.
   */
  writeChar(str) {
    return this.writeUint8(str.charCodeAt(0));
  }
  /**
   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
   * and move pointer forward by `str.length` bytes.
   * @param str - The characters to write.
   * @returns This.
   */
  writeChars(str) {
    for (let i2 = 0; i2 < str.length; i2++) {
      this.writeUint8(str.charCodeAt(i2));
    }
    return this;
  }
  /**
   * UTF-8 encode and write `str` to the current pointer offset and move pointer
   * forward according to the encoded length.
   * @param str - The string to write.
   * @returns This.
   */
  writeUtf8(str) {
    return this.writeBytes(encode(str));
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   * @returns A new Uint8Array view.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
  }
  /**
   *  Get the total number of bytes written so far, regardless of the current offset.
   * @returns - Total number of bytes.
   */
  getWrittenByteLength() {
    return this.lastWrittenByte - this.byteOffset;
  }
  /**
   * Update the last written byte offset
   * @private
   */
  _updateLastWrittenByte() {
    if (this.offset > this.lastWrittenByte) {
      this.lastWrittenByte = this.offset;
    }
  }
}
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
const adler32 = (adler2, buf, len, pos) => {
  let s1 = adler2 & 65535 | 0, s2 = adler2 >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2e3 ? 2e3 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c2, table = [];
  for (var n2 = 0; n2 < 256; n2++) {
    c2 = n2;
    for (var k2 = 0; k2 < 8; k2++) {
      c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
    }
    table[n2] = c2;
  }
  return table;
};
const crcTable$1 = new Uint32Array(makeTable());
const crc32 = (crc2, buf, len, pos) => {
  const t3 = crcTable$1;
  const end = pos + len;
  crc2 ^= -1;
  for (let i2 = pos; i2 < end; i2++) {
    crc2 = crc2 >>> 8 ^ t3[(crc2 ^ buf[i2]) & 255];
  }
  return crc2 ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q2 = 0; q2 < 256; q2++) {
  _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c2 = str.charCodeAt(m_pos);
    if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c2 < 128) {
      buf[i2++] = c2;
    } else if (c2 < 2048) {
      buf[i2++] = 192 | c2 >>> 6;
      buf[i2++] = 128 | c2 & 63;
    } else if (c2 < 65536) {
      buf[i2++] = 224 | c2 >>> 12;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    } else {
      buf[i2++] = 240 | c2 >>> 18;
      buf[i2++] = 128 | c2 >>> 12 & 63;
      buf[i2++] = 128 | c2 >>> 6 & 63;
      buf[i2++] = 128 | c2 & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    let c2 = buf[i2++];
    if (c2 < 128) {
      utf16buf[out++] = c2;
      continue;
    }
    let c_len = _utf8len[c2];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c2 = c2 << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c2 < 65536) {
      utf16buf[out++] = c2;
    } else {
      c2 -= 65536;
      utf16buf[out++] = 55296 | c2 >> 10 & 1023;
      utf16buf[out++] = 56320 | c2 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const BAD$1 = 16209;
const TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill2;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill2 = 1 << curr;
    min = fill2;
    do {
      fill2 -= incr;
      table[next + (huff >> drop) + fill2] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill2 !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
const HEAD = 16180;
const FLAGS = 16181;
const TIME = 16182;
const OS = 16183;
const EXLEN = 16184;
const EXTRA = 16185;
const NAME = 16186;
const COMMENT = 16187;
const HCRC = 16188;
const DICTID = 16189;
const DICT = 16190;
const TYPE = 16191;
const TYPEDO = 16192;
const STORED = 16193;
const COPY_ = 16194;
const COPY = 16195;
const TABLE = 16196;
const LENLENS = 16197;
const CODELENS = 16198;
const LEN_ = 16199;
const LEN = 16200;
const LENEXT = 16201;
const DIST = 16202;
const DISTEXT = 16203;
const MATCH = 16204;
const LIT = 16205;
const CHECK = 16206;
const LENGTH = 16207;
const DONE = 16208;
const BAD = 16209;
const MEM = 16210;
const SYNC = 16211;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const MAX_WBITS = 15;
const DEF_WBITS = MAX_WBITS;
const zswap32 = (q2) => {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
const inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
const inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        /* falls through */
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
const inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2
};
const { Inflate, inflate } = inflate_1$1;
var Inflate_1 = Inflate;
var inflate_1 = inflate;
const crcTable = [];
for (let n2 = 0; n2 < 256; n2++) {
  let c2 = n2;
  for (let k2 = 0; k2 < 8; k2++) {
    if (c2 & 1) {
      c2 = 3988292384 ^ c2 >>> 1;
    } else {
      c2 = c2 >>> 1;
    }
  }
  crcTable[n2] = c2;
}
const initialCrc = 4294967295;
function updateCrc(currentCrc, data, length) {
  let c2 = currentCrc;
  for (let n2 = 0; n2 < length; n2++) {
    c2 = crcTable[(c2 ^ data[n2]) & 255] ^ c2 >>> 8;
  }
  return c2;
}
function crc(data, length) {
  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
}
function checkCrc(buffer, crcLength, chunkName) {
  const expectedCrc = buffer.readUint32();
  const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength);
  if (actualCrc !== expectedCrc) {
    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
  }
}
function unfilterNone(currentLine, newLine, bytesPerLine) {
  for (let i2 = 0; i2 < bytesPerLine; i2++) {
    newLine[i2] = currentLine[i2];
  }
}
function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  for (; i2 < bytesPerPixel; i2++) {
    newLine[i2] = currentLine[i2];
  }
  for (; i2 < bytesPerLine; i2++) {
    newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
  }
}
function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2];
    }
  } else {
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
    }
  }
}
function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2];
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] >> 1) & 255;
    }
  } else {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2] + (prevLine[i2] >> 1) & 255;
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] + prevLine[i2] >> 1) & 255;
    }
  }
}
function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
  let i2 = 0;
  if (prevLine.length === 0) {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2];
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
    }
  } else {
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + paethPredictor(newLine[i2 - bytesPerPixel], prevLine[i2], prevLine[i2 - bytesPerPixel]) & 255;
    }
  }
}
function paethPredictor(a2, b2, c2) {
  const p2 = a2 + b2 - c2;
  const pa = Math.abs(p2 - a2);
  const pb = Math.abs(p2 - b2);
  const pc = Math.abs(p2 - c2);
  if (pa <= pb && pa <= pc)
    return a2;
  else if (pb <= pc)
    return b2;
  else
    return c2;
}
function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
  switch (filterType) {
    case 0:
      unfilterNone(currentLine, newLine, passLineBytes);
      break;
    case 1:
      unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
      break;
    case 2:
      unfilterUp(currentLine, newLine, prevLine, passLineBytes);
      break;
    case 3:
      unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    case 4:
      unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      break;
    default:
      throw new Error(`Unsupported filter: ${filterType}`);
  }
}
const uint16$1 = new Uint16Array([255]);
const uint8$1 = new Uint8Array(uint16$1.buffer);
const osIsLittleEndian$1 = uint8$1[0] === 255;
function decodeInterlaceAdam7(params) {
  const { data, width, height, channels, depth } = params;
  const passes = [
    { x: 0, y: 0, xStep: 8, yStep: 8 },
    // Pass 1
    { x: 4, y: 0, xStep: 8, yStep: 8 },
    // Pass 2
    { x: 0, y: 4, xStep: 4, yStep: 8 },
    // Pass 3
    { x: 2, y: 0, xStep: 4, yStep: 4 },
    // Pass 4
    { x: 0, y: 2, xStep: 2, yStep: 4 },
    // Pass 5
    { x: 1, y: 0, xStep: 2, yStep: 2 },
    // Pass 6
    { x: 0, y: 1, xStep: 1, yStep: 2 }
    // Pass 7
  ];
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const resultData = new Uint8Array(height * width * bytesPerPixel);
  let offset = 0;
  for (let passIndex = 0; passIndex < 7; passIndex++) {
    const pass = passes[passIndex];
    const passWidth = Math.ceil((width - pass.x) / pass.xStep);
    const passHeight = Math.ceil((height - pass.y) / pass.yStep);
    if (passWidth <= 0 || passHeight <= 0)
      continue;
    const passLineBytes = passWidth * bytesPerPixel;
    const prevLine = new Uint8Array(passLineBytes);
    for (let y2 = 0; y2 < passHeight; y2++) {
      const filterType = data[offset++];
      const currentLine = data.subarray(offset, offset + passLineBytes);
      offset += passLineBytes;
      const newLine = new Uint8Array(passLineBytes);
      applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
      prevLine.set(newLine);
      for (let x2 = 0; x2 < passWidth; x2++) {
        const outputX = pass.x + x2 * pass.xStep;
        const outputY = pass.y + y2 * pass.yStep;
        if (outputX >= width || outputY >= height)
          continue;
        for (let i2 = 0; i2 < bytesPerPixel; i2++) {
          resultData[(outputY * width + outputX) * bytesPerPixel + i2] = newLine[x2 * bytesPerPixel + i2];
        }
      }
    }
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(resultData.buffer);
    if (osIsLittleEndian$1) {
      for (let k2 = 0; k2 < uint16Data.length; k2++) {
        uint16Data[k2] = swap16$1(uint16Data[k2]);
      }
    }
    return uint16Data;
  } else {
    return resultData;
  }
}
function swap16$1(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
const uint16 = new Uint16Array([255]);
const uint8 = new Uint8Array(uint16.buffer);
const osIsLittleEndian = uint8[0] === 255;
const empty = new Uint8Array(0);
function decodeInterlaceNull(params) {
  const { data, width, height, channels, depth } = params;
  const bytesPerPixel = Math.ceil(depth / 8) * channels;
  const bytesPerLine = Math.ceil(depth / 8 * channels * width);
  const newData = new Uint8Array(height * bytesPerLine);
  let prevLine = empty;
  let offset = 0;
  let currentLine;
  let newLine;
  for (let i2 = 0; i2 < height; i2++) {
    currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
    newLine = newData.subarray(i2 * bytesPerLine, (i2 + 1) * bytesPerLine);
    switch (data[offset]) {
      case 0:
        unfilterNone(currentLine, newLine, bytesPerLine);
        break;
      case 1:
        unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
        break;
      case 2:
        unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
        break;
      case 3:
        unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      case 4:
        unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
        break;
      default:
        throw new Error(`Unsupported filter: ${data[offset]}`);
    }
    prevLine = newLine;
    offset += bytesPerLine + 1;
  }
  if (depth === 16) {
    const uint16Data = new Uint16Array(newData.buffer);
    if (osIsLittleEndian) {
      for (let k2 = 0; k2 < uint16Data.length; k2++) {
        uint16Data[k2] = swap16(uint16Data[k2]);
      }
    }
    return uint16Data;
  } else {
    return newData;
  }
}
function swap16(val) {
  return (val & 255) << 8 | val >> 8 & 255;
}
const pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
function checkSignature(buffer) {
  if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {
    throw new Error("wrong PNG signature");
  }
}
function hasPngSignature(array) {
  if (array.length < pngSignature.length) {
    return false;
  }
  for (let i2 = 0; i2 < pngSignature.length; i2++) {
    if (array[i2] !== pngSignature[i2]) {
      return false;
    }
  }
  return true;
}
const textChunkName = "tEXt";
const NULL$1 = 0;
const latin1Decoder = new TextDecoder("latin1");
function validateKeyword(keyword) {
  validateLatin1(keyword);
  if (keyword.length === 0 || keyword.length > 79) {
    throw new Error("keyword length must be between 1 and 79");
  }
}
const latin1Regex = /^[\u0000-\u00FF]*$/;
function validateLatin1(text2) {
  if (!latin1Regex.test(text2)) {
    throw new Error("invalid latin1 text");
  }
}
function decodetEXt(text2, buffer, length) {
  const keyword = readKeyword(buffer);
  text2[keyword] = readLatin1(buffer, length - keyword.length - 1);
}
function readKeyword(buffer) {
  buffer.mark();
  while (buffer.readByte() !== NULL$1) {
  }
  const end = buffer.offset;
  buffer.reset();
  const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));
  buffer.skip(1);
  validateKeyword(keyword);
  return keyword;
}
function readLatin1(buffer, length) {
  return latin1Decoder.decode(buffer.readBytes(length));
}
const ColorType = {
  UNKNOWN: -1,
  GREYSCALE: 0,
  TRUECOLOUR: 2,
  INDEXED_COLOUR: 3,
  GREYSCALE_ALPHA: 4,
  TRUECOLOUR_ALPHA: 6
};
const CompressionMethod = {
  UNKNOWN: -1,
  DEFLATE: 0
};
const FilterMethod = {
  UNKNOWN: -1,
  ADAPTIVE: 0
};
const InterlaceMethod = {
  UNKNOWN: -1,
  NO_INTERLACE: 0,
  ADAM7: 1
};
const DisposeOpType = {
  NONE: 0,
  BACKGROUND: 1,
  PREVIOUS: 2
};
const BlendOpType = {
  SOURCE: 0,
  OVER: 1
};
class PngDecoder extends IOBuffer {
  _checkCrc;
  _inflator;
  _png;
  _apng;
  _end;
  _hasPalette;
  _palette;
  _hasTransparency;
  _transparency;
  _compressionMethod;
  _filterMethod;
  _interlaceMethod;
  _colorType;
  _isAnimated;
  _numberOfFrames;
  _numberOfPlays;
  _frames;
  _writingDataChunks;
  constructor(data, options = {}) {
    super(data);
    const { checkCrc: checkCrc2 = false } = options;
    this._checkCrc = checkCrc2;
    this._inflator = new Inflate_1();
    this._png = {
      width: -1,
      height: -1,
      channels: -1,
      data: new Uint8Array(0),
      depth: 1,
      text: {}
    };
    this._apng = {
      width: -1,
      height: -1,
      channels: -1,
      depth: 1,
      numberOfFrames: 1,
      numberOfPlays: 0,
      text: {},
      frames: []
    };
    this._end = false;
    this._hasPalette = false;
    this._palette = [];
    this._hasTransparency = false;
    this._transparency = new Uint16Array(0);
    this._compressionMethod = CompressionMethod.UNKNOWN;
    this._filterMethod = FilterMethod.UNKNOWN;
    this._interlaceMethod = InterlaceMethod.UNKNOWN;
    this._colorType = ColorType.UNKNOWN;
    this._isAnimated = false;
    this._numberOfFrames = 1;
    this._numberOfPlays = 0;
    this._frames = [];
    this._writingDataChunks = false;
    this.setBigEndian();
  }
  decode() {
    checkSignature(this);
    while (!this._end) {
      const length = this.readUint32();
      const type = this.readChars(4);
      this.decodeChunk(length, type);
    }
    this.decodeImage();
    return this._png;
  }
  decodeApng() {
    checkSignature(this);
    while (!this._end) {
      const length = this.readUint32();
      const type = this.readChars(4);
      this.decodeApngChunk(length, type);
    }
    this.decodeApngImage();
    return this._apng;
  }
  // https://www.w3.org/TR/PNG/#5Chunk-layout
  decodeChunk(length, type) {
    const offset = this.offset;
    switch (type) {
      // 11.2 Critical chunks
      case "IHDR":
        this.decodeIHDR();
        break;
      case "PLTE":
        this.decodePLTE(length);
        break;
      case "IDAT":
        this.decodeIDAT(length);
        break;
      case "IEND":
        this._end = true;
        break;
      // 11.3 Ancillary chunks
      case "tRNS":
        this.decodetRNS(length);
        break;
      case "iCCP":
        this.decodeiCCP(length);
        break;
      case textChunkName:
        decodetEXt(this._png.text, this, length);
        break;
      case "pHYs":
        this.decodepHYs();
        break;
      default:
        this.skip(length);
        break;
    }
    if (this.offset - offset !== length) {
      throw new Error(`Length mismatch while decoding chunk ${type}`);
    }
    if (this._checkCrc) {
      checkCrc(this, length + 4, type);
    } else {
      this.skip(4);
    }
  }
  decodeApngChunk(length, type) {
    const offset = this.offset;
    if (type !== "fdAT" && type !== "IDAT" && this._writingDataChunks) {
      this.pushDataToFrame();
    }
    switch (type) {
      case "acTL":
        this.decodeACTL();
        break;
      case "fcTL":
        this.decodeFCTL();
        break;
      case "fdAT":
        this.decodeFDAT(length);
        break;
      default:
        this.decodeChunk(length, type);
        this.offset = offset + length;
        break;
    }
    if (this.offset - offset !== length) {
      throw new Error(`Length mismatch while decoding chunk ${type}`);
    }
    if (this._checkCrc) {
      checkCrc(this, length + 4, type);
    } else {
      this.skip(4);
    }
  }
  // https://www.w3.org/TR/PNG/#11IHDR
  decodeIHDR() {
    const image2 = this._png;
    image2.width = this.readUint32();
    image2.height = this.readUint32();
    image2.depth = checkBitDepth(this.readUint8());
    const colorType = this.readUint8();
    this._colorType = colorType;
    let channels;
    switch (colorType) {
      case ColorType.GREYSCALE:
        channels = 1;
        break;
      case ColorType.TRUECOLOUR:
        channels = 3;
        break;
      case ColorType.INDEXED_COLOUR:
        channels = 1;
        break;
      case ColorType.GREYSCALE_ALPHA:
        channels = 2;
        break;
      case ColorType.TRUECOLOUR_ALPHA:
        channels = 4;
        break;
      // Kept for exhaustiveness.
      // eslint-disable-next-line unicorn/no-useless-switch-case
      case ColorType.UNKNOWN:
      default:
        throw new Error(`Unknown color type: ${colorType}`);
    }
    this._png.channels = channels;
    this._compressionMethod = this.readUint8();
    if (this._compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
    }
    this._filterMethod = this.readUint8();
    this._interlaceMethod = this.readUint8();
  }
  decodeACTL() {
    this._numberOfFrames = this.readUint32();
    this._numberOfPlays = this.readUint32();
    this._isAnimated = true;
  }
  decodeFCTL() {
    const image2 = {
      sequenceNumber: this.readUint32(),
      width: this.readUint32(),
      height: this.readUint32(),
      xOffset: this.readUint32(),
      yOffset: this.readUint32(),
      delayNumber: this.readUint16(),
      delayDenominator: this.readUint16(),
      disposeOp: this.readUint8(),
      blendOp: this.readUint8(),
      data: new Uint8Array(0)
    };
    this._frames.push(image2);
  }
  // https://www.w3.org/TR/PNG/#11PLTE
  decodePLTE(length) {
    if (length % 3 !== 0) {
      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
    }
    const l2 = length / 3;
    this._hasPalette = true;
    const palette = [];
    this._palette = palette;
    for (let i2 = 0; i2 < l2; i2++) {
      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
    }
  }
  // https://www.w3.org/TR/PNG/#11IDAT
  decodeIDAT(length) {
    this._writingDataChunks = true;
    const dataLength = length;
    const dataOffset = this.offset + this.byteOffset;
    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    this.skip(length);
  }
  decodeFDAT(length) {
    this._writingDataChunks = true;
    let dataLength = length;
    let dataOffset = this.offset + this.byteOffset;
    dataOffset += 4;
    dataLength -= 4;
    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    this.skip(length);
  }
  // https://www.w3.org/TR/PNG/#11tRNS
  decodetRNS(length) {
    switch (this._colorType) {
      case ColorType.GREYSCALE:
      case ColorType.TRUECOLOUR: {
        if (length % 2 !== 0) {
          throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
        }
        if (length / 2 > this._png.width * this._png.height) {
          throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
        }
        this._hasTransparency = true;
        this._transparency = new Uint16Array(length / 2);
        for (let i2 = 0; i2 < length / 2; i2++) {
          this._transparency[i2] = this.readUint16();
        }
        break;
      }
      case ColorType.INDEXED_COLOUR: {
        if (length > this._palette.length) {
          throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
        }
        let i2 = 0;
        for (; i2 < length; i2++) {
          const alpha = this.readByte();
          this._palette[i2].push(alpha);
        }
        for (; i2 < this._palette.length; i2++) {
          this._palette[i2].push(255);
        }
        break;
      }
      // Kept for exhaustiveness.
      /* eslint-disable unicorn/no-useless-switch-case */
      case ColorType.UNKNOWN:
      case ColorType.GREYSCALE_ALPHA:
      case ColorType.TRUECOLOUR_ALPHA:
      default: {
        throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
      }
    }
  }
  // https://www.w3.org/TR/PNG/#11iCCP
  decodeiCCP(length) {
    const name = readKeyword(this);
    const compressionMethod = this.readUint8();
    if (compressionMethod !== CompressionMethod.DEFLATE) {
      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
    }
    const compressedProfile = this.readBytes(length - name.length - 2);
    this._png.iccEmbeddedProfile = {
      name,
      profile: inflate_1(compressedProfile)
    };
  }
  // https://www.w3.org/TR/PNG/#11pHYs
  decodepHYs() {
    const ppuX = this.readUint32();
    const ppuY = this.readUint32();
    const unitSpecifier = this.readByte();
    this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
  }
  decodeApngImage() {
    this._apng.width = this._png.width;
    this._apng.height = this._png.height;
    this._apng.channels = this._png.channels;
    this._apng.depth = this._png.depth;
    this._apng.numberOfFrames = this._numberOfFrames;
    this._apng.numberOfPlays = this._numberOfPlays;
    this._apng.text = this._png.text;
    this._apng.resolution = this._png.resolution;
    for (let i2 = 0; i2 < this._numberOfFrames; i2++) {
      const newFrame = {
        sequenceNumber: this._frames[i2].sequenceNumber,
        delayNumber: this._frames[i2].delayNumber,
        delayDenominator: this._frames[i2].delayDenominator,
        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
      };
      const frame = this._frames.at(i2);
      if (frame) {
        frame.data = decodeInterlaceNull({
          data: frame.data,
          width: frame.width,
          height: frame.height,
          channels: this._apng.channels,
          depth: this._apng.depth
        });
        if (this._hasPalette) {
          this._apng.palette = this._palette;
        }
        if (this._hasTransparency) {
          this._apng.transparency = this._transparency;
        }
        if (i2 === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {
          newFrame.data = frame.data;
        } else {
          const prevFrame = this._apng.frames.at(i2 - 1);
          this.disposeFrame(frame, prevFrame, newFrame);
          this.addFrameDataToCanvas(newFrame, frame);
        }
        this._apng.frames.push(newFrame);
      }
    }
    return this._apng;
  }
  disposeFrame(frame, prevFrame, imageFrame) {
    switch (frame.disposeOp) {
      case DisposeOpType.NONE:
        break;
      case DisposeOpType.BACKGROUND:
        for (let row = 0; row < this._png.height; row++) {
          for (let col = 0; col < this._png.width; col++) {
            const index2 = (row * frame.width + col) * this._png.channels;
            for (let channel = 0; channel < this._png.channels; channel++) {
              imageFrame.data[index2 + channel] = 0;
            }
          }
        }
        break;
      case DisposeOpType.PREVIOUS:
        imageFrame.data.set(prevFrame.data);
        break;
      default:
        throw new Error("Unknown disposeOp");
    }
  }
  addFrameDataToCanvas(imageFrame, frame) {
    const maxValue = 1 << this._png.depth;
    const calculatePixelIndices = (row, col) => {
      const index2 = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;
      const frameIndex = (row * frame.width + col) * this._png.channels;
      return { index: index2, frameIndex };
    };
    switch (frame.blendOp) {
      case BlendOpType.SOURCE:
        for (let row = 0; row < frame.height; row++) {
          for (let col = 0; col < frame.width; col++) {
            const { index: index2, frameIndex } = calculatePixelIndices(row, col);
            for (let channel = 0; channel < this._png.channels; channel++) {
              imageFrame.data[index2 + channel] = frame.data[frameIndex + channel];
            }
          }
        }
        break;
      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
      case BlendOpType.OVER:
        for (let row = 0; row < frame.height; row++) {
          for (let col = 0; col < frame.width; col++) {
            const { index: index2, frameIndex } = calculatePixelIndices(row, col);
            for (let channel = 0; channel < this._png.channels; channel++) {
              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];
              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index2 + channel]);
              imageFrame.data[index2 + channel] += value;
            }
          }
        }
        break;
      default:
        throw new Error("Unknown blendOp");
    }
  }
  decodeImage() {
    if (this._inflator.err) {
      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
    }
    const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;
    if (this._filterMethod !== FilterMethod.ADAPTIVE) {
      throw new Error(`Filter method ${this._filterMethod} not supported`);
    }
    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
      this._png.data = decodeInterlaceNull({
        data,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
      this._png.data = decodeInterlaceAdam7({
        data,
        width: this._png.width,
        height: this._png.height,
        channels: this._png.channels,
        depth: this._png.depth
      });
    } else {
      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
    }
    if (this._hasPalette) {
      this._png.palette = this._palette;
    }
    if (this._hasTransparency) {
      this._png.transparency = this._transparency;
    }
  }
  pushDataToFrame() {
    const result = this._inflator.result;
    const lastFrame = this._frames.at(-1);
    if (lastFrame) {
      lastFrame.data = result;
    } else {
      this._frames.push({
        sequenceNumber: 0,
        width: this._png.width,
        height: this._png.height,
        xOffset: 0,
        yOffset: 0,
        delayNumber: 0,
        delayDenominator: 0,
        disposeOp: DisposeOpType.NONE,
        blendOp: BlendOpType.SOURCE,
        data: result
      });
    }
    this._inflator = new Inflate_1();
    this._writingDataChunks = false;
  }
}
function checkBitDepth(value) {
  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
    throw new Error(`invalid bit depth: ${value}`);
  }
  return value;
}
var ResolutionUnitSpecifier;
(function(ResolutionUnitSpecifier2) {
  ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
  ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
})(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));
function decodePng(data, options) {
  const decoder = new PngDecoder(data, options);
  return decoder.decode();
}
/** @license
 *
 * jsPDF - PDF Document creation from JavaScript
 * Version 3.0.3 Built on 2025-09-18T08:03:54.261Z
 *                      CommitID 00000000
 *
 * Copyright (c) 2010-2025 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
 *               2015-2025 yWorks GmbH, http://www.yworks.com
 *               2015-2025 Lukas HollÃ¤nder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
 *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
 *               2010 Aaron Spike, https://github.com/acspike
 *               2012 Willow Systems Corporation, https://github.com/willowsystems
 *               2012 Pablo Hess, https://github.com/pablohess
 *               2012 Florian Jenett, https://github.com/fjenett
 *               2013 Warren Weckesser, https://github.com/warrenweckesser
 *               2013 Youssef Beddad, https://github.com/lifof
 *               2013 Lee Driscoll, https://github.com/lsdriscoll
 *               2013 Stefan Slonevskiy, https://github.com/stefslon
 *               2013 Jeremy Morel, https://github.com/jmorel
 *               2013 Christoph Hartmann, https://github.com/chris-rock
 *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
 *               2014 James Makes, https://github.com/dollaruw
 *               2014 Diego Casorran, https://github.com/diegocr
 *               2014 Steven Spungin, https://github.com/Flamenco
 *               2014 Kenneth Glassey, https://github.com/Gavvers
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Contributor(s):
 *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
 *    kim3er, mfo, alnorth, Flamenco
 */
var i$5 = /* @__PURE__ */ (function() {
  return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
})();
function a$2() {
  i$5.console && "function" == typeof i$5.console.log && i$5.console.log.apply(i$5.console, arguments);
}
var o$1 = { log: a$2, warn: function(t3) {
  i$5.console && ("function" == typeof i$5.console.warn ? i$5.console.warn.apply(i$5.console, arguments) : a$2.call(null, arguments));
}, error: function(t3) {
  i$5.console && ("function" == typeof i$5.console.error ? i$5.console.error.apply(i$5.console, arguments) : a$2(t3));
} };
function s$1(t3, e2, n2) {
  var r2 = new XMLHttpRequest();
  r2.open("GET", t3), r2.responseType = "blob", r2.onload = function() {
    l$1(r2.response, e2, n2);
  }, r2.onerror = function() {
    o$1.error("could not download file");
  }, r2.send();
}
function u$2(t3) {
  var e2 = new XMLHttpRequest();
  e2.open("HEAD", t3, false);
  try {
    e2.send();
  } catch (n2) {
  }
  return e2.status >= 200 && e2.status <= 299;
}
function c$2(t3) {
  try {
    t3.dispatchEvent(new MouseEvent("click"));
  } catch (n2) {
    var e2 = document.createEvent("MouseEvents");
    e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t3.dispatchEvent(e2);
  }
}
var l$1 = i$5.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof$1(window)) || window !== i$5 ? function() {
} : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t3, e2, n2) {
  var r2 = i$5.URL || i$5.webkitURL, a2 = document.createElement("a");
  e2 = e2 || t3.name || "download", a2.download = e2, a2.rel = "noopener", "string" == typeof t3 ? (a2.href = t3, a2.origin !== location.origin ? u$2(a2.href) ? s$1(t3, e2, n2) : c$2(a2, a2.target = "_blank") : c$2(a2)) : (a2.href = r2.createObjectURL(t3), setTimeout(function() {
    r2.revokeObjectURL(a2.href);
  }, 4e4), setTimeout(function() {
    c$2(a2);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(e2, n2, r2) {
  if (n2 = n2 || e2.name || "download", "string" == typeof e2) if (u$2(e2)) s$1(e2, n2, r2);
  else {
    var i2 = document.createElement("a");
    i2.href = e2, i2.target = "_blank", setTimeout(function() {
      c$2(i2);
    });
  }
  else navigator.msSaveOrOpenBlob((function(e3, n3) {
    return void 0 === n3 ? n3 = { autoBom: false } : "object" !== _typeof$1(n3) && (o$1.warn("Deprecated: Expected third argument to be a object"), n3 = { autoBom: !n3 }), n3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
  })(e2, r2), n2);
} : function(e2, n2, r2, a2) {
  if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e2) return s$1(e2, n2, r2);
  var o2 = "application/octet-stream" === e2.type, u2 = /constructor/i.test(i$5.HTMLElement) || i$5.safari, c2 = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((c2 || o2 && u2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof$1(FileReader))) {
    var l2 = new FileReader();
    l2.onloadend = function() {
      var t3 = l2.result;
      t3 = c2 ? t3 : t3.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t3 : location = t3, a2 = null;
    }, l2.readAsDataURL(e2);
  } else {
    var h2 = i$5.URL || i$5.webkitURL, f2 = h2.createObjectURL(e2);
    a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
      h2.revokeObjectURL(f2);
    }, 4e4);
  }
});
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */
function h$1(t3) {
  var e2;
  t3 = t3 || "", this.ok = false, "#" == t3.charAt(0) && (t3 = t3.substr(1, 6)), t3 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t3 = (t3 = t3.replace(/ /g, "")).toLowerCase()] || t3;
  for (var n2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t4) {
    return [parseInt(t4[1]), parseInt(t4[2]), parseInt(t4[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t4) {
    return [parseInt(t4[1], 16), parseInt(t4[2], 16), parseInt(t4[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t4) {
    return [parseInt(t4[1] + t4[1], 16), parseInt(t4[2] + t4[2], 16), parseInt(t4[3] + t4[3], 16)];
  } }], r2 = 0; r2 < n2.length; r2++) {
    var i2 = n2[r2].re, a2 = n2[r2].process, o2 = i2.exec(t3);
    o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var t4 = this.r.toString(16), e3 = this.g.toString(16), n3 = this.b.toString(16);
    return 1 == t4.length && (t4 = "0" + t4), 1 == e3.length && (e3 = "0" + e3), 1 == n3.length && (n3 = "0" + n3), "#" + t4 + e3 + n3;
  };
}
var f$2 = i$5.atob.bind(i$5), d = i$5.btoa.bind(i$5);
/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */
function p$1(t3, e2) {
  var n2 = t3[0], r2 = t3[1], i2 = t3[2], a2 = t3[3];
  n2 = m$2(n2, r2, i2, a2, e2[0], 7, -680876936), a2 = m$2(a2, n2, r2, i2, e2[1], 12, -389564586), i2 = m$2(i2, a2, n2, r2, e2[2], 17, 606105819), r2 = m$2(r2, i2, a2, n2, e2[3], 22, -1044525330), n2 = m$2(n2, r2, i2, a2, e2[4], 7, -176418897), a2 = m$2(a2, n2, r2, i2, e2[5], 12, 1200080426), i2 = m$2(i2, a2, n2, r2, e2[6], 17, -1473231341), r2 = m$2(r2, i2, a2, n2, e2[7], 22, -45705983), n2 = m$2(n2, r2, i2, a2, e2[8], 7, 1770035416), a2 = m$2(a2, n2, r2, i2, e2[9], 12, -1958414417), i2 = m$2(i2, a2, n2, r2, e2[10], 17, -42063), r2 = m$2(r2, i2, a2, n2, e2[11], 22, -1990404162), n2 = m$2(n2, r2, i2, a2, e2[12], 7, 1804603682), a2 = m$2(a2, n2, r2, i2, e2[13], 12, -40341101), i2 = m$2(i2, a2, n2, r2, e2[14], 17, -1502002290), n2 = v$1(n2, r2 = m$2(r2, i2, a2, n2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = v$1(a2, n2, r2, i2, e2[6], 9, -1069501632), i2 = v$1(i2, a2, n2, r2, e2[11], 14, 643717713), r2 = v$1(r2, i2, a2, n2, e2[0], 20, -373897302), n2 = v$1(n2, r2, i2, a2, e2[5], 5, -701558691), a2 = v$1(a2, n2, r2, i2, e2[10], 9, 38016083), i2 = v$1(i2, a2, n2, r2, e2[15], 14, -660478335), r2 = v$1(r2, i2, a2, n2, e2[4], 20, -405537848), n2 = v$1(n2, r2, i2, a2, e2[9], 5, 568446438), a2 = v$1(a2, n2, r2, i2, e2[14], 9, -1019803690), i2 = v$1(i2, a2, n2, r2, e2[3], 14, -187363961), r2 = v$1(r2, i2, a2, n2, e2[8], 20, 1163531501), n2 = v$1(n2, r2, i2, a2, e2[13], 5, -1444681467), a2 = v$1(a2, n2, r2, i2, e2[2], 9, -51403784), i2 = v$1(i2, a2, n2, r2, e2[7], 14, 1735328473), n2 = b(n2, r2 = v$1(r2, i2, a2, n2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = b(a2, n2, r2, i2, e2[8], 11, -2022574463), i2 = b(i2, a2, n2, r2, e2[11], 16, 1839030562), r2 = b(r2, i2, a2, n2, e2[14], 23, -35309556), n2 = b(n2, r2, i2, a2, e2[1], 4, -1530992060), a2 = b(a2, n2, r2, i2, e2[4], 11, 1272893353), i2 = b(i2, a2, n2, r2, e2[7], 16, -155497632), r2 = b(r2, i2, a2, n2, e2[10], 23, -1094730640), n2 = b(n2, r2, i2, a2, e2[13], 4, 681279174), a2 = b(a2, n2, r2, i2, e2[0], 11, -358537222), i2 = b(i2, a2, n2, r2, e2[3], 16, -722521979), r2 = b(r2, i2, a2, n2, e2[6], 23, 76029189), n2 = b(n2, r2, i2, a2, e2[9], 4, -640364487), a2 = b(a2, n2, r2, i2, e2[12], 11, -421815835), i2 = b(i2, a2, n2, r2, e2[15], 16, 530742520), n2 = y$1(n2, r2 = b(r2, i2, a2, n2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = y$1(a2, n2, r2, i2, e2[7], 10, 1126891415), i2 = y$1(i2, a2, n2, r2, e2[14], 15, -1416354905), r2 = y$1(r2, i2, a2, n2, e2[5], 21, -57434055), n2 = y$1(n2, r2, i2, a2, e2[12], 6, 1700485571), a2 = y$1(a2, n2, r2, i2, e2[3], 10, -1894986606), i2 = y$1(i2, a2, n2, r2, e2[10], 15, -1051523), r2 = y$1(r2, i2, a2, n2, e2[1], 21, -2054922799), n2 = y$1(n2, r2, i2, a2, e2[8], 6, 1873313359), a2 = y$1(a2, n2, r2, i2, e2[15], 10, -30611744), i2 = y$1(i2, a2, n2, r2, e2[6], 15, -1560198380), r2 = y$1(r2, i2, a2, n2, e2[13], 21, 1309151649), n2 = y$1(n2, r2, i2, a2, e2[4], 6, -145523070), a2 = y$1(a2, n2, r2, i2, e2[11], 10, -1120210379), i2 = y$1(i2, a2, n2, r2, e2[2], 15, 718787259), r2 = y$1(r2, i2, a2, n2, e2[9], 21, -343485551), t3[0] = P(n2, t3[0]), t3[1] = P(r2, t3[1]), t3[2] = P(i2, t3[2]), t3[3] = P(a2, t3[3]);
}
function g(t3, e2, n2, r2, i2, a2) {
  return e2 = P(P(e2, t3), P(r2, a2)), P(e2 << i2 | e2 >>> 32 - i2, n2);
}
function m$2(t3, e2, n2, r2, i2, a2, o2) {
  return g(e2 & n2 | ~e2 & r2, t3, e2, i2, a2, o2);
}
function v$1(t3, e2, n2, r2, i2, a2, o2) {
  return g(e2 & r2 | n2 & ~r2, t3, e2, i2, a2, o2);
}
function b(t3, e2, n2, r2, i2, a2, o2) {
  return g(e2 ^ n2 ^ r2, t3, e2, i2, a2, o2);
}
function y$1(t3, e2, n2, r2, i2, a2, o2) {
  return g(n2 ^ (e2 | ~r2), t3, e2, i2, a2, o2);
}
function w(t3) {
  var e2, n2 = t3.length, r2 = [1732584193, -271733879, -1732584194, 271733878];
  for (e2 = 64; e2 <= t3.length; e2 += 64) p$1(r2, N$1(t3.substring(e2 - 64, e2)));
  t3 = t3.substring(e2 - 64);
  var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e2 = 0; e2 < t3.length; e2++) i2[e2 >> 2] |= t3.charCodeAt(e2) << (e2 % 4 << 3);
  if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55) for (p$1(r2, i2), e2 = 0; e2 < 16; e2++) i2[e2] = 0;
  return i2[14] = 8 * n2, p$1(r2, i2), r2;
}
function N$1(t3) {
  var e2, n2 = [];
  for (e2 = 0; e2 < 64; e2 += 4) n2[e2 >> 2] = t3.charCodeAt(e2) + (t3.charCodeAt(e2 + 1) << 8) + (t3.charCodeAt(e2 + 2) << 16) + (t3.charCodeAt(e2 + 3) << 24);
  return n2;
}
var L$1 = "0123456789abcdef".split("");
function x(t3) {
  for (var e2 = "", n2 = 0; n2 < 4; n2++) e2 += L$1[t3 >> 8 * n2 + 4 & 15] + L$1[t3 >> 8 * n2 & 15];
  return e2;
}
function A$1(t3) {
  return String.fromCharCode(255 & t3, (65280 & t3) >> 8, (16711680 & t3) >> 16, (4278190080 & t3) >> 24);
}
function S(t3) {
  return w(t3).map(A$1).join("");
}
var _$1 = "5d41402abc4b2a76b9719d911017c592" != (function(t3) {
  for (var e2 = 0; e2 < t3.length; e2++) t3[e2] = x(t3[e2]);
  return t3.join("");
})(w("hello"));
function P(t3, e2) {
  if (_$1) {
    var n2 = (65535 & t3) + (65535 & e2);
    return (t3 >> 16) + (e2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
  }
  return t3 + e2 & 4294967295;
}
/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */
function k(t3, e2) {
  var n2, r2, i2, a2;
  if (t3 !== n2) {
    for (var o2 = (i2 = t3, a2 = 1 + (256 / t3.length | 0), new Array(a2 + 1).join(i2)), s2 = [], u2 = 0; u2 < 256; u2++) s2[u2] = u2;
    var c2 = 0;
    for (u2 = 0; u2 < 256; u2++) {
      var l2 = s2[u2];
      c2 = (c2 + l2 + o2.charCodeAt(u2)) % 256, s2[u2] = s2[c2], s2[c2] = l2;
    }
    n2 = t3, r2 = s2;
  } else s2 = r2;
  var h2 = e2.length, f2 = 0, d2 = 0, p2 = "";
  for (u2 = 0; u2 < h2; u2++) d2 = (d2 + (l2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = l2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e2.charCodeAt(u2) ^ o2);
  return p2;
}
/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */
var F$1 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function I(t3, e2, n2, r2) {
  this.v = 1, this.r = 2;
  var i2 = 192;
  t3.forEach(function(t4) {
    if (void 0 !== F$1.perm) throw new Error("Invalid permission: " + t4);
    i2 += F$1[t4];
  }), this.padding = "(Â¿N^NuÂAd\0NVÃ¿Ãº\b..\0Â¶Ãh>Â/\fÂ©Ã¾dSiz";
  var a2 = (e2 + this.padding).substr(0, 32), o2 = (n2 + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = S(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r2)).substr(0, 5), this.U = k(this.encryptionKey, this.padding);
}
function j(t3) {
  if (/[^\u0000-\u00ff]/.test(t3)) throw new Error("Invalid PDF Name Object: " + t3 + ", Only accept ASCII characters.");
  for (var e2 = "", n2 = t3.length, r2 = 0; r2 < n2; r2++) {
    var i2 = t3.charCodeAt(r2);
    e2 += i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126 ? "#" + ("0" + i2.toString(16)).slice(-2) : t3[r2];
  }
  return e2;
}
function C(e2) {
  if ("object" !== _typeof$1(e2)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var n2 = {};
  this.subscribe = function(t3, e3, r2) {
    if (r2 = r2 || false, "string" != typeof t3 || "function" != typeof e3 || "boolean" != typeof r2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    n2.hasOwnProperty(t3) || (n2[t3] = {});
    var i2 = Math.random().toString(35);
    return n2[t3][i2] = [e3, !!r2], i2;
  }, this.unsubscribe = function(t3) {
    for (var e3 in n2) if (n2[e3][t3]) return delete n2[e3][t3], 0 === Object.keys(n2[e3]).length && delete n2[e3], true;
    return false;
  }, this.publish = function(t3) {
    if (n2.hasOwnProperty(t3)) {
      var r2 = Array.prototype.slice.call(arguments, 1), a2 = [];
      for (var s2 in n2[t3]) {
        var u2 = n2[t3][s2];
        try {
          u2[0].apply(e2, r2);
        } catch (c2) {
          i$5.console && o$1.error("jsPDF PubSub Error", c2.message, c2);
        }
        u2[1] && a2.push(s2);
      }
      a2.length && a2.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return n2;
  };
}
function O$1(t3) {
  if (!(this instanceof O$1)) return new O$1(t3);
  var e2 = "opacity,stroke-opacity".split(",");
  for (var n2 in t3) t3.hasOwnProperty(n2) && e2.indexOf(n2) >= 0 && (this[n2] = t3[n2]);
  this.id = "", this.objectNumber = -1;
}
function B(t3, e2) {
  this.gState = t3, this.matrix = e2, this.id = "", this.objectNumber = -1;
}
function M(t3, e2, n2, r2, i2) {
  if (!(this instanceof M)) return new M(t3, e2, n2, r2, i2);
  this.type = "axial" === t3 ? 2 : 3, this.coords = e2, this.colors = n2, B.call(this, r2, i2);
}
function q(t3, e2, n2, r2, i2) {
  if (!(this instanceof q)) return new q(t3, e2, n2, r2, i2);
  this.boundingBox = t3, this.xStep = e2, this.yStep = n2, this.stream = "", this.cloneIndex = 0, B.call(this, r2, i2);
}
function E$1(e2) {
  var n2, r2 = "string" == typeof arguments[0] ? arguments[0] : "p", a2 = arguments[1], s2 = arguments[2], u2 = arguments[3], c2 = [], f2 = 1, p2 = 16, g2 = "S", m2 = null;
  "object" === _typeof$1(e2 = e2 || {}) && (r2 = e2.orientation, a2 = e2.unit || a2, s2 = e2.format || s2, u2 = e2.compress || e2.compressPdf || u2, null !== (m2 = e2.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), f2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (n2 = e2.precision), void 0 !== e2.floatPrecision && (p2 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), c2 = e2.filters || (true === u2 ? ["FlateEncode"] : c2), a2 = a2 || "mm", r2 = ("" + (r2 || "P")).toLowerCase();
  var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
  y2.__private__.PubSub = C;
  var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
    return w2;
  };
  y2.__private__.setPdfVersion = function(t3) {
    w2 = t3;
  };
  var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  y2.__private__.getPageFormats = function() {
    return L2;
  };
  var x2 = y2.__private__.getPageFormat = function(t3) {
    return L2[t3];
  };
  s2 = s2 || "a4";
  var A2 = "compat", S2 = "advanced", _2 = A2;
  function P2() {
    this.saveGraphicsState(), lt2(new Wt2(St, 0, 0, -St, 0, _n() * St).toString() + " cm"), this.setFontSize(this.getFontSize() / St), g2 = "n", _2 = S2;
  }
  function k2() {
    this.restoreGraphicsState(), g2 = "S", _2 = A2;
  }
  var F2 = y2.__private__.combineFontStyleAndFontWeight = function(t3, e3) {
    if ("bold" == t3 && "normal" == e3 || "bold" == t3 && 400 == e3 || "normal" == t3 && "italic" == e3 || "bold" == t3 && "italic" == e3) throw new Error("Invalid Combination of fontweight and fontstyle");
    return e3 && (t3 = 400 == e3 || "normal" === e3 ? "italic" === t3 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t3 ? (700 == e3 ? "bold" : e3) + "" + t3 : "bold"), t3;
  };
  y2.advancedAPI = function(t3) {
    var e3 = _2 === A2;
    return e3 && P2.call(this), "function" != typeof t3 || (t3(this), e3 && k2.call(this)), this;
  }, y2.compatAPI = function(t3) {
    var e3 = _2 === S2;
    return e3 && k2.call(this), "function" != typeof t3 || (t3(this), e3 && P2.call(this)), this;
  }, y2.isAdvancedAPI = function() {
    return _2 === S2;
  };
  var B3, R2 = function(t3) {
    if (_2 !== S2) throw new Error(t3 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t3, e3) {
    var r3 = n2 || e3;
    if (isNaN(t3) || isNaN(r3)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return t3.toFixed(r3).replace(/0+$/, "");
  };
  B3 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, p2);
  } : "smart" === p2 ? function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, t3 > -1 && t3 < 1 ? 16 : 5);
  } : function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return D2(t3, 16);
  };
  var T2 = y2.f2 = y2.__private__.f2 = function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f2");
    return D2(t3, 2);
  }, z2 = y2.__private__.f3 = function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.f3");
    return D2(t3, 3);
  }, U2 = y2.scale = y2.__private__.scale = function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.scale");
    return _2 === A2 ? t3 * St : _2 === S2 ? t3 : void 0;
  }, H4 = function(t3) {
    return U2((function(t4) {
      return _2 === A2 ? _n() - t4 : _2 === S2 ? t4 : void 0;
    })(t3));
  };
  y2.__private__.setPrecision = y2.setPrecision = function(t3) {
    "number" == typeof parseInt(t3, 10) && (n2 = parseInt(t3, 10));
  };
  var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
    return V2;
  }, Y2 = y2.__private__.setFileId = function(t3) {
    return V2 = void 0 !== t3 && /^[a-fA-F0-9]{32}$/.test(t3) ? t3.toUpperCase() : V2.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), null !== m2 && (je2 = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
  };
  y2.setFileId = function(t3) {
    return Y2(t3), this;
  }, y2.getFileId = function() {
    return G2();
  };
  var J2 = y2.__private__.convertDateToPDFDate = function(t3) {
    var e3 = t3.getTimezoneOffset(), n3 = e3 < 0 ? "+" : "-", r3 = Math.floor(Math.abs(e3 / 60)), i2 = Math.abs(e3 % 60), a3 = [n3, Q2(r3), "'", Q2(i2), "'"].join("");
    return ["D:", t3.getFullYear(), Q2(t3.getMonth() + 1), Q2(t3.getDate()), Q2(t3.getHours()), Q2(t3.getMinutes()), Q2(t3.getSeconds()), a3].join("");
  }, X2 = y2.__private__.convertPDFDateToDate = function(t3) {
    var e3 = parseInt(t3.substr(2, 4), 10), n3 = parseInt(t3.substr(6, 2), 10) - 1, r3 = parseInt(t3.substr(8, 2), 10), i2 = parseInt(t3.substr(10, 2), 10), a3 = parseInt(t3.substr(12, 2), 10), o2 = parseInt(t3.substr(14, 2), 10);
    return new Date(e3, n3, r3, i2, a3, o2, 0);
  }, K2 = y2.__private__.setCreationDate = function(t3) {
    var e3;
    if (void 0 === t3 && (t3 = /* @__PURE__ */ new Date()), t3 instanceof Date) e3 = J2(t3);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t3)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      e3 = t3;
    }
    return W2 = e3;
  }, Z2 = y2.__private__.getCreationDate = function(t3) {
    var e3 = W2;
    return "jsDate" === t3 && (e3 = X2(W2)), e3;
  };
  y2.setCreationDate = function(t3) {
    return K2(t3), this;
  }, y2.getCreationDate = function(t3) {
    return Z2(t3);
  };
  var $2, Q2 = y2.__private__.padd2 = function(t3) {
    return ("0" + parseInt(t3)).slice(-2);
  }, tt2 = y2.__private__.padd2Hex = function(t3) {
    return ("00" + (t3 = t3.toString())).substr(t3.length);
  }, et2 = 0, nt2 = [], rt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ut2 = rt2;
  y2.__private__.setCustomOutputDestination = function(t3) {
    st2 = true, ut2 = t3;
  };
  var ct2 = function(t3) {
    st2 || (ut2 = t3);
  };
  y2.__private__.resetCustomOutputDestination = function() {
    st2 = false, ut2 = rt2;
  };
  var lt2 = y2.__private__.out = function(t3) {
    return t3 = t3.toString(), it2 += t3.length + 1, ut2.push(t3), ut2;
  }, ht2 = y2.__private__.write = function(t3) {
    return lt2(1 === arguments.length ? t3.toString() : Array.prototype.join.call(arguments, " "));
  }, ft2 = y2.__private__.getArrayBuffer = function(t3) {
    for (var e3 = t3.length, n3 = new ArrayBuffer(e3), r3 = new Uint8Array(n3); e3--; ) r3[e3] = t3.charCodeAt(e3);
    return n3;
  }, dt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  y2.__private__.getStandardFonts = function() {
    return dt2;
  };
  var pt2 = e2.fontSize || 16;
  y2.__private__.setFontSize = y2.setFontSize = function(t3) {
    return pt2 = _2 === S2 ? t3 / St : t3, this;
  };
  var gt2, mt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
    return _2 === A2 ? pt2 : pt2 * St;
  }, vt2 = e2.R2L || false;
  y2.__private__.setR2L = y2.setR2L = function(t3) {
    return vt2 = t3, this;
  }, y2.__private__.getR2L = y2.getR2L = function() {
    return vt2;
  };
  var bt2, yt2 = y2.__private__.setZoomMode = function(t3) {
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t3)) gt2 = t3;
    else if (isNaN(t3)) {
      if (-1 === [void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(t3)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t3 + '" is not recognized.');
      gt2 = t3;
    } else gt2 = parseInt(t3, 10);
  };
  y2.__private__.getZoomMode = function() {
    return gt2;
  };
  var wt2, Nt2 = y2.__private__.setPageMode = function(t3) {
    if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t3)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t3 + '" is not recognized.');
    bt2 = t3;
  };
  y2.__private__.getPageMode = function() {
    return bt2;
  };
  var Lt2 = y2.__private__.setLayoutMode = function(t3) {
    if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t3)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t3 + '" is not recognized.');
    wt2 = t3;
  };
  y2.__private__.getLayoutMode = function() {
    return wt2;
  }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t3, e3, n3) {
    return yt2(t3), Lt2(e3), Nt2(n3), this;
  };
  var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
  y2.__private__.getDocumentProperty = function(t3) {
    if (-1 === Object.keys(xt2).indexOf(t3)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return xt2[t3];
  }, y2.__private__.getDocumentProperties = function() {
    return xt2;
  }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t3) {
    for (var e3 in xt2) xt2.hasOwnProperty(e3) && t3[e3] && (xt2[e3] = t3[e3]);
    return this;
  }, y2.__private__.setDocumentProperty = function(t3, e3) {
    if (-1 === Object.keys(xt2).indexOf(t3)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return xt2[t3] = e3;
  };
  var At2, St, _t2, Pt2, kt2, Ft2 = {}, It2 = {}, jt2 = [], Ct2 = {}, Ot2 = {}, Bt2 = {}, Mt2 = {}, qt2 = null, Et2 = 0, Rt2 = [], Dt2 = new C(y2), Tt2 = e2.hotfixes || [], zt2 = {}, Ut2 = {}, Ht2 = [], Wt2 = function t3(e3, n3, r3, i2, a3, o2) {
    if (!(this instanceof t3)) return new t3(e3, n3, r3, i2, a3, o2);
    isNaN(e3) && (e3 = 1), isNaN(n3) && (n3 = 0), isNaN(r3) && (r3 = 0), isNaN(i2) && (i2 = 1), isNaN(a3) && (a3 = 0), isNaN(o2) && (o2 = 0), this._matrix = [e3, n3, r3, i2, a3, o2];
  };
  Object.defineProperty(Wt2.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Wt2.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Wt2.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Wt2.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Wt2.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Wt2.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Wt2.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(t3) {
    this._matrix[0] = t3;
  } }), Object.defineProperty(Wt2.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(t3) {
    this._matrix[1] = t3;
  } }), Object.defineProperty(Wt2.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(t3) {
    this._matrix[2] = t3;
  } }), Object.defineProperty(Wt2.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(t3) {
    this._matrix[3] = t3;
  } }), Object.defineProperty(Wt2.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(t3) {
    this._matrix[4] = t3;
  } }), Object.defineProperty(Wt2.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(t3) {
    this._matrix[5] = t3;
  } }), Object.defineProperty(Wt2.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Wt2.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Wt2.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Wt2.prototype, "isIdentity", { get: function() {
    return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
  } }), Wt2.prototype.join = function(t3) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(B3).join(t3);
  }, Wt2.prototype.multiply = function(t3) {
    var e3 = t3.sx * this.sx + t3.shy * this.shx, n3 = t3.sx * this.shy + t3.shy * this.sy, r3 = t3.shx * this.sx + t3.sy * this.shx, i2 = t3.shx * this.shy + t3.sy * this.sy, a3 = t3.tx * this.sx + t3.ty * this.shx + this.tx, o2 = t3.tx * this.shy + t3.ty * this.sy + this.ty;
    return new Wt2(e3, n3, r3, i2, a3, o2);
  }, Wt2.prototype.decompose = function() {
    var t3 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty, o2 = Math.sqrt(t3 * t3 + e3 * e3), s3 = (t3 /= o2) * n3 + (e3 /= o2) * r3;
    n3 -= t3 * s3, r3 -= e3 * s3;
    var u3 = Math.sqrt(n3 * n3 + r3 * r3);
    return s3 /= u3, t3 * (r3 /= u3) < e3 * (n3 /= u3) && (t3 = -t3, e3 = -e3, s3 = -s3, o2 = -o2), { scale: new Wt2(o2, 0, 0, u3, 0, 0), translate: new Wt2(1, 0, 0, 1, i2, a3), rotate: new Wt2(t3, e3, -e3, t3, 0, 0), skew: new Wt2(1, 0, s3, 1, 0, 0) };
  }, Wt2.prototype.toString = function(t3) {
    return this.join(" ");
  }, Wt2.prototype.inversed = function() {
    var t3 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty, o2 = 1 / (t3 * r3 - e3 * n3), s3 = r3 * o2, u3 = -e3 * o2, c3 = -n3 * o2, l2 = t3 * o2;
    return new Wt2(s3, u3, c3, l2, -s3 * i2 - c3 * a3, -u3 * i2 - l2 * a3);
  }, Wt2.prototype.applyToPoint = function(t3) {
    var e3 = t3.x * this.sx + t3.y * this.shx + this.tx, n3 = t3.x * this.shy + t3.y * this.sy + this.ty;
    return new gn(e3, n3);
  }, Wt2.prototype.applyToRectangle = function(t3) {
    var e3 = this.applyToPoint(t3), n3 = this.applyToPoint(new gn(t3.x + t3.w, t3.y + t3.h));
    return new mn(e3.x, e3.y, n3.x - e3.x, n3.y - e3.y);
  }, Wt2.prototype.clone = function() {
    var t3 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty;
    return new Wt2(t3, e3, n3, r3, i2, a3);
  }, y2.Matrix = Wt2;
  var Vt2 = y2.matrixMult = function(t3, e3) {
    return e3.multiply(t3);
  }, Gt2 = new Wt2(1, 0, 0, 1, 0, 0);
  y2.unitMatrix = y2.identityMatrix = Gt2;
  var Yt2 = function(t3, e3) {
    if (!Ot2[t3]) {
      var n3 = (e3 instanceof M ? "Sh" : "P") + (Object.keys(Ct2).length + 1).toString(10);
      e3.id = n3, Ot2[t3] = n3, Ct2[n3] = e3, Dt2.publish("addPattern", e3);
    }
  };
  y2.ShadingPattern = M, y2.TilingPattern = q, y2.addShadingPattern = function(t3, e3) {
    return R2("addShadingPattern()"), Yt2(t3, e3), this;
  }, y2.beginTilingPattern = function(t3) {
    R2("beginTilingPattern()"), bn(t3.boundingBox[0], t3.boundingBox[1], t3.boundingBox[2] - t3.boundingBox[0], t3.boundingBox[3] - t3.boundingBox[1], t3.matrix);
  }, y2.endTilingPattern = function(t3, e3) {
    R2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Yt2(t3, e3), Dt2.publish("endTilingPattern", e3), Ht2.pop().restore();
  };
  var Jt2, Xt2 = y2.__private__.newObject = function() {
    var t3 = Kt2();
    return Zt2(t3, true), t3;
  }, Kt2 = y2.__private__.newObjectDeferred = function() {
    return et2++, nt2[et2] = function() {
      return it2;
    }, et2;
  }, Zt2 = function(t3, e3) {
    return e3 = "boolean" == typeof e3 && e3, nt2[t3] = it2, e3 && lt2(t3 + " 0 obj"), t3;
  }, $t2 = y2.__private__.newAdditionalObject = function() {
    var t3 = { objId: Kt2(), content: "" };
    return at2.push(t3), t3;
  }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t3) {
    var e3 = t3.split(" ");
    if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) 5 !== e3.length || "k" !== e3[4] && "K" !== e3[4] || (e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"]);
    else {
      var n3 = parseFloat(e3[0]);
      e3 = [n3, n3, n3, "r"];
    }
    for (var r3 = "#", i2 = 0; i2 < 3; i2++) r3 += ("0" + Math.floor(255 * parseFloat(e3[i2])).toString(16)).slice(-2);
    return r3;
  }, ne2 = y2.__private__.encodeColorString = function(e3) {
    var n3;
    "string" == typeof e3 && (e3 = { ch1: e3 });
    var r3 = e3.ch1, i2 = e3.ch2, a3 = e3.ch3, o2 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if ("string" == typeof r3 && "#" !== r3.charAt(0)) {
      var u3 = new h$1(r3);
      if (u3.ok) r3 = u3.toHex();
      else if (!/^\d*\.?\d*$/.test(r3)) throw new Error('Invalid color "' + r3 + '" passed to jsPDF.encodeColorString.');
    }
    if ("string" == typeof r3 && /^#[0-9A-Fa-f]{3}$/.test(r3) && (r3 = "#" + r3[1] + r3[1] + r3[2] + r3[2] + r3[3] + r3[3]), "string" == typeof r3 && /^#[0-9A-Fa-f]{6}$/.test(r3)) {
      var c3 = parseInt(r3.substr(1), 16);
      r3 = c3 >> 16 & 255, i2 = c3 >> 8 & 255, a3 = 255 & c3;
    }
    if (void 0 === i2 || void 0 === o2 && r3 === i2 && i2 === a3) n3 = "string" == typeof r3 ? r3 + " " + s3[0] : 2 === e3.precision ? T2(r3 / 255) + " " + s3[0] : z2(r3 / 255) + " " + s3[0];
    else if (void 0 === o2 || "object" === _typeof$1(o2)) {
      if (o2 && !isNaN(o2.a) && 0 === o2.a) return ["1.", "1.", "1.", s3[1]].join(" ");
      n3 = "string" == typeof r3 ? [r3, i2, a3, s3[1]].join(" ") : 2 === e3.precision ? [T2(r3 / 255), T2(i2 / 255), T2(a3 / 255), s3[1]].join(" ") : [z2(r3 / 255), z2(i2 / 255), z2(a3 / 255), s3[1]].join(" ");
    } else n3 = "string" == typeof r3 ? [r3, i2, a3, o2, s3[2]].join(" ") : 2 === e3.precision ? [T2(r3), T2(i2), T2(a3), T2(o2), s3[2]].join(" ") : [z2(r3), z2(i2), z2(a3), z2(o2), s3[2]].join(" ");
    return n3;
  }, re2 = y2.__private__.getFilters = function() {
    return c2;
  }, ie2 = y2.__private__.putStream = function(t3) {
    var e3 = (t3 = t3 || {}).data || "", n3 = t3.filters || re2(), r3 = t3.alreadyAppliedFilters || [], i2 = t3.addLength1 || false, a3 = e3.length, o2 = t3.objectId, s3 = function(t4) {
      return t4;
    };
    if (null !== m2 && void 0 === o2) throw new Error("ObjectId must be passed to putStream for file encryption");
    null !== m2 && (s3 = je2.encryptor(o2, 0));
    var u3 = {};
    true === n3 && (n3 = ["FlateEncode"]);
    var c3 = t3.additionalKeyValues || [], l2 = (u3 = void 0 !== E$1.API.processDataByFilters ? E$1.API.processDataByFilters(e3, n3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(r3) ? r3.join(" ") : r3.toString());
    if (0 !== u3.data.length && (c3.push({ key: "Length", value: u3.data.length }), true === i2 && c3.push({ key: "Length1", value: a3 })), 0 != l2.length) if (l2.split("/").length - 1 == 1) c3.push({ key: "Filter", value: l2 });
    else {
      c3.push({ key: "Filter", value: "[" + l2 + "]" });
      for (var h2 = 0; h2 < c3.length; h2 += 1) if ("DecodeParms" === c3[h2].key) {
        for (var f3 = [], d2 = 0; d2 < u3.reverseChain.split("/").length - 1; d2 += 1) f3.push("null");
        f3.push(c3[h2].value), c3[h2].value = "[" + f3.join(" ") + "]";
      }
    }
    lt2("<<");
    for (var p3 = 0; p3 < c3.length; p3++) lt2("/" + c3[p3].key + " " + c3[p3].value);
    lt2(">>"), 0 !== u3.data.length && (lt2("stream"), lt2(s3(u3.data)), lt2("endstream"));
  }, ae2 = y2.__private__.putPage = function(t3) {
    var e3 = t3.number, n3 = t3.data, r3 = t3.objId, i2 = t3.contentsObjId;
    Zt2(r3, true), lt2("<</Type /Page"), lt2("/Parent " + t3.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t3.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(B3(t3.mediaBox.bottomLeftX)) + " " + parseFloat(B3(t3.mediaBox.bottomLeftY)) + " " + B3(t3.mediaBox.topRightX) + " " + B3(t3.mediaBox.topRightY) + "]"), null !== t3.cropBox && lt2("/CropBox [" + B3(t3.cropBox.bottomLeftX) + " " + B3(t3.cropBox.bottomLeftY) + " " + B3(t3.cropBox.topRightX) + " " + B3(t3.cropBox.topRightY) + "]"), null !== t3.bleedBox && lt2("/BleedBox [" + B3(t3.bleedBox.bottomLeftX) + " " + B3(t3.bleedBox.bottomLeftY) + " " + B3(t3.bleedBox.topRightX) + " " + B3(t3.bleedBox.topRightY) + "]"), null !== t3.trimBox && lt2("/TrimBox [" + B3(t3.trimBox.bottomLeftX) + " " + B3(t3.trimBox.bottomLeftY) + " " + B3(t3.trimBox.topRightX) + " " + B3(t3.trimBox.topRightY) + "]"), null !== t3.artBox && lt2("/ArtBox [" + B3(t3.artBox.bottomLeftX) + " " + B3(t3.artBox.bottomLeftY) + " " + B3(t3.artBox.topRightX) + " " + B3(t3.artBox.topRightY) + "]"), "number" == typeof t3.userUnit && 1 !== t3.userUnit && lt2("/UserUnit " + t3.userUnit), Dt2.publish("putPage", { objId: r3, pageContext: Rt2[e3], pageNumber: e3, page: n3 }), lt2("/Contents " + i2 + " 0 R"), lt2(">>"), lt2("endobj");
    var a3 = n3.join("\n");
    return _2 === S2 && (a3 += "\nQ"), Zt2(i2, true), ie2({ data: a3, filters: re2(), objectId: i2 }), lt2("endobj"), r3;
  }, oe2 = y2.__private__.putPages = function() {
    var t3, e3, n3 = [];
    for (t3 = 1; t3 <= Et2; t3++) Rt2[t3].objId = Kt2(), Rt2[t3].contentsObjId = Kt2();
    for (t3 = 1; t3 <= Et2; t3++) n3.push(ae2({ number: t3, data: ot2[t3], objId: Rt2[t3].objId, contentsObjId: Rt2[t3].contentsObjId, mediaBox: Rt2[t3].mediaBox, cropBox: Rt2[t3].cropBox, bleedBox: Rt2[t3].bleedBox, trimBox: Rt2[t3].trimBox, artBox: Rt2[t3].artBox, userUnit: Rt2[t3].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
    Zt2(Qt2, true), lt2("<</Type /Pages");
    var r3 = "/Kids [";
    for (e3 = 0; e3 < Et2; e3++) r3 += n3[e3] + " 0 R ";
    lt2(r3 + "]"), lt2("/Count " + Et2), lt2(">>"), lt2("endobj"), Dt2.publish("postPutPages");
  }, se2 = function(t3) {
    Dt2.publish("putFont", { font: t3, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t3.isAlreadyPutted && (t3.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + j(t3.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t3.encoding && lt2("/Encoding /" + t3.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
  }, ue2 = function(t3) {
    t3.objectNumber = Xt2();
    var e3 = [];
    e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [B3(t3.x), B3(t3.y), B3(t3.x + t3.width), B3(t3.y + t3.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" });
    var n3 = t3.pages[1].join("\n");
    ie2({ data: n3, additionalKeyValues: e3, objectId: t3.objectNumber }), lt2("endobj");
  }, ce2 = function(t3, e3) {
    e3 || (e3 = 21);
    var n3 = Xt2(), r3 = (function(t4, e4) {
      var n4, r4 = [], i3 = 1 / (e4 - 1);
      for (n4 = 0; n4 < 1; n4 += i3) r4.push(n4);
      if (r4.push(1), 0 != t4[0].offset) {
        var a4 = { offset: 0, color: t4[0].color };
        t4.unshift(a4);
      }
      if (1 != t4[t4.length - 1].offset) {
        var o2 = { offset: 1, color: t4[t4.length - 1].color };
        t4.push(o2);
      }
      for (var s3 = "", u3 = 0, c3 = 0; c3 < r4.length; c3++) {
        for (n4 = r4[c3]; n4 > t4[u3 + 1].offset; ) u3++;
        var l2 = t4[u3].offset, h2 = (n4 - l2) / (t4[u3 + 1].offset - l2), f3 = t4[u3].color, d2 = t4[u3 + 1].color;
        s3 += tt2(Math.round((1 - h2) * f3[0] + h2 * d2[0]).toString(16)) + tt2(Math.round((1 - h2) * f3[1] + h2 * d2[1]).toString(16)) + tt2(Math.round((1 - h2) * f3[2] + h2 * d2[2]).toString(16));
      }
      return s3.trim();
    })(t3.colors, e3), i2 = [];
    i2.push({ key: "FunctionType", value: "0" }), i2.push({ key: "Domain", value: "[0.0 1.0]" }), i2.push({ key: "Size", value: "[" + e3 + "]" }), i2.push({ key: "BitsPerSample", value: "8" }), i2.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i2.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: r3, additionalKeyValues: i2, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: n3 }), lt2("endobj"), t3.objectNumber = Xt2(), lt2("<< /ShadingType " + t3.type), lt2("/ColorSpace /DeviceRGB");
    var a3 = "/Coords [" + B3(parseFloat(t3.coords[0])) + " " + B3(parseFloat(t3.coords[1])) + " ";
    2 === t3.type ? a3 += B3(parseFloat(t3.coords[2])) + " " + B3(parseFloat(t3.coords[3])) : a3 += B3(parseFloat(t3.coords[2])) + " " + B3(parseFloat(t3.coords[3])) + " " + B3(parseFloat(t3.coords[4])) + " " + B3(parseFloat(t3.coords[5])), lt2(a3 += "]"), t3.matrix && lt2("/Matrix [" + t3.matrix.toString() + "]"), lt2("/Function " + n3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
  }, le2 = function(t3, e3) {
    var n3 = Kt2(), r3 = Xt2();
    e3.push({ resourcesOid: n3, objectOid: r3 }), t3.objectNumber = r3;
    var i2 = [];
    i2.push({ key: "Type", value: "/Pattern" }), i2.push({ key: "PatternType", value: "1" }), i2.push({ key: "PaintType", value: "1" }), i2.push({ key: "TilingType", value: "1" }), i2.push({ key: "BBox", value: "[" + t3.boundingBox.map(B3).join(" ") + "]" }), i2.push({ key: "XStep", value: B3(t3.xStep) }), i2.push({ key: "YStep", value: B3(t3.yStep) }), i2.push({ key: "Resources", value: n3 + " 0 R" }), t3.matrix && i2.push({ key: "Matrix", value: "[" + t3.matrix.toString() + "]" }), ie2({ data: t3.stream, additionalKeyValues: i2, objectId: t3.objectNumber }), lt2("endobj");
  }, he2 = function(t3) {
    for (var e3 in t3.objectNumber = Xt2(), lt2("<<"), t3) switch (e3) {
      case "opacity":
        lt2("/ca " + T2(t3[e3]));
        break;
      case "stroke-opacity":
        lt2("/CA " + T2(t3[e3]));
    }
    lt2(">>"), lt2("endobj");
  }, fe2 = function(t3) {
    Zt2(t3.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), (function() {
      for (var t4 in lt2("/Font <<"), Ft2) Ft2.hasOwnProperty(t4) && (false === v2 || true === v2 && b2.hasOwnProperty(t4)) && lt2("/" + t4 + " " + Ft2[t4].objectNumber + " 0 R");
      lt2(">>");
    })(), (function() {
      if (Object.keys(Ct2).length > 0) {
        for (var t4 in lt2("/Shading <<"), Ct2) Ct2.hasOwnProperty(t4) && Ct2[t4] instanceof M && Ct2[t4].objectNumber >= 0 && lt2("/" + t4 + " " + Ct2[t4].objectNumber + " 0 R");
        Dt2.publish("putShadingPatternDict"), lt2(">>");
      }
    })(), (function(t4) {
      if (Object.keys(Ct2).length > 0) {
        for (var e3 in lt2("/Pattern <<"), Ct2) Ct2.hasOwnProperty(e3) && Ct2[e3] instanceof y2.TilingPattern && Ct2[e3].objectNumber >= 0 && Ct2[e3].objectNumber < t4 && lt2("/" + e3 + " " + Ct2[e3].objectNumber + " 0 R");
        Dt2.publish("putTilingPatternDict"), lt2(">>");
      }
    })(t3.objectOid), (function() {
      if (Object.keys(Bt2).length > 0) {
        var t4;
        for (t4 in lt2("/ExtGState <<"), Bt2) Bt2.hasOwnProperty(t4) && Bt2[t4].objectNumber >= 0 && lt2("/" + t4 + " " + Bt2[t4].objectNumber + " 0 R");
        Dt2.publish("putGStateDict"), lt2(">>");
      }
    })(), (function() {
      for (var t4 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t4) && zt2[t4].objectNumber >= 0 && lt2("/" + t4 + " " + zt2[t4].objectNumber + " 0 R");
      Dt2.publish("putXobjectDict"), lt2(">>");
    })(), lt2(">>"), lt2("endobj");
  }, de2 = function(t3) {
    It2[t3.fontName] = It2[t3.fontName] || {}, It2[t3.fontName][t3.fontStyle] = t3.id;
  }, pe2 = function(t3, e3, n3, r3, i2) {
    var a3 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t3, fontName: e3, fontStyle: n3, encoding: r3, isStandardFont: i2 || false, metadata: {} };
    return Dt2.publish("addFont", { font: a3, instance: this }), Ft2[a3.id] = a3, de2(a3), a3.id;
  }, ge2 = y2.__private__.pdfEscape = y2.pdfEscape = function(t3, e3) {
    return (function(t4, e4) {
      var n3, r3, i2, a3, o2, s3, u3, c3, l2;
      if (i2 = (e4 = e4 || {}).sourceEncoding || "Unicode", o2 = e4.outputEncoding, (e4.autoencode || o2) && Ft2[At2].metadata && Ft2[At2].metadata[i2] && Ft2[At2].metadata[i2].encoding && (a3 = Ft2[At2].metadata[i2].encoding, !o2 && Ft2[At2].encoding && (o2 = Ft2[At2].encoding), !o2 && a3.codePages && (o2 = a3.codePages[0]), "string" == typeof o2 && (o2 = a3[o2]), o2)) {
        for (u3 = false, s3 = [], n3 = 0, r3 = t4.length; n3 < r3; n3++) (c3 = o2[t4.charCodeAt(n3)]) ? s3.push(String.fromCharCode(c3)) : s3.push(t4[n3]), s3[n3].charCodeAt(0) >> 8 && (u3 = true);
        t4 = s3.join("");
      }
      for (n3 = t4.length; void 0 === u3 && 0 !== n3; ) t4.charCodeAt(n3 - 1) >> 8 && (u3 = true), n3--;
      if (!u3) return t4;
      for (s3 = e4.noBOM ? [] : [254, 255], n3 = 0, r3 = t4.length; n3 < r3; n3++) {
        if ((l2 = (c3 = t4.charCodeAt(n3)) >> 8) >> 8) throw new Error("Character at position " + n3 + " of string '" + t4 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
        s3.push(l2), s3.push(c3 - (l2 << 8));
      }
      return String.fromCharCode.apply(void 0, s3);
    })(t3, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, me2 = y2.__private__.beginPage = function(t3) {
    ot2[++Et2] = [], Rt2[Et2] = { objId: 0, contentsObjId: 0, userUnit: Number(f2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t3[0]), topRightY: Number(t3[1]) } }, ye2(Et2), ct2(ot2[$2]);
  }, ve2 = function(t3, e3) {
    var n3, i2, a3;
    switch (r2 = e3 || r2, "string" == typeof t3 && (n3 = x2(t3.toLowerCase()), Array.isArray(n3) && (i2 = n3[0], a3 = n3[1])), Array.isArray(t3) && (i2 = t3[0] * St, a3 = t3[1] * St), isNaN(i2) && (i2 = s2[0], a3 = s2[1]), (i2 > 14400 || a3 > 14400) && (o$1.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), i2 = Math.min(14400, i2), a3 = Math.min(14400, a3)), s2 = [i2, a3], r2.substr(0, 1)) {
      case "l":
        a3 > i2 && (s2 = [a3, i2]);
        break;
      case "p":
        i2 > a3 && (s2 = [a3, i2]);
    }
    me2(s2), Ze(Xe), lt2(on), 0 !== fn && lt2(fn + " J"), 0 !== dn && lt2(dn + " j"), Dt2.publish("addPage", { pageNumber: Et2 });
  }, be2 = function(t3) {
    t3 > 0 && t3 <= Et2 && (ot2.splice(t3, 1), Rt2.splice(t3, 1), Et2--, $2 > Et2 && ($2 = Et2), this.setPage($2));
  }, ye2 = function(t3) {
    t3 > 0 && t3 <= Et2 && ($2 = t3);
  }, we2 = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
    return ot2.length - 1;
  }, Ne2 = function(t3, e3, n3) {
    var r3, i2 = void 0;
    return n3 = n3 || {}, t3 = void 0 !== t3 ? t3 : Ft2[At2].fontName, e3 = void 0 !== e3 ? e3 : Ft2[At2].fontStyle, r3 = t3.toLowerCase(), void 0 !== It2[r3] && void 0 !== It2[r3][e3] ? i2 = It2[r3][e3] : void 0 !== It2[t3] && void 0 !== It2[t3][e3] ? i2 = It2[t3][e3] : false === n3.disableWarning && o$1.warn("Unable to look up font label for font '" + t3 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i2 || n3.noFallback || null == (i2 = It2.times[e3]) && (i2 = It2.times.normal), i2;
  }, Le2 = y2.__private__.putInfo = function() {
    var t3 = Xt2(), e3 = function(t4) {
      return t4;
    };
    for (var n3 in null !== m2 && (e3 = je2.encryptor(t3, 0)), lt2("<<"), lt2("/Producer (" + ge2(e3("jsPDF " + E$1.version)) + ")"), xt2) xt2.hasOwnProperty(n3) && xt2[n3] && lt2("/" + n3.substr(0, 1).toUpperCase() + n3.substr(1) + " (" + ge2(e3(xt2[n3])) + ")");
    lt2("/CreationDate (" + ge2(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
  }, xe2 = y2.__private__.putCatalog = function(t3) {
    var e3 = (t3 = t3 || {}).rootDictionaryObjId || Qt2;
    switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), gt2 || (gt2 = "fullwidth"), gt2) {
      case "fullwidth":
        lt2("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        lt2("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        lt2("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        lt2("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var n3 = "" + gt2;
        "%" === n3.substr(n3.length - 1) && (gt2 = parseInt(gt2) / 100), "number" == typeof gt2 && lt2("/OpenAction [3 0 R /XYZ null null " + T2(gt2) + "]");
    }
    switch (wt2 || (wt2 = "continuous"), wt2) {
      case "continuous":
        lt2("/PageLayout /OneColumn");
        break;
      case "single":
        lt2("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        lt2("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        lt2("/PageLayout /TwoColumnRight");
    }
    bt2 && lt2("/PageMode /" + bt2), Dt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
  }, Ae2 = y2.__private__.putTrailer = function() {
    lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + je2.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
  }, Se2 = y2.__private__.putHeader = function() {
    lt2("%PDF-" + w2), lt2("%ÂºÃÂ¬Ã ");
  }, _e2 = y2.__private__.putXRef = function() {
    var t3 = "0000000000";
    lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
    for (var e3 = 1; e3 <= et2; e3++) "function" == typeof nt2[e3] ? lt2((t3 + nt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== nt2[e3] ? lt2((t3 + nt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
  }, Pe2 = y2.__private__.buildDocument = function() {
    var t3;
    et2 = 0, it2 = 0, rt2 = [], nt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2(), ct2(rt2), Dt2.publish("buildDocument"), Se2(), oe2(), (function() {
      Dt2.publish("putAdditionalObjects");
      for (var t4 = 0; t4 < at2.length; t4++) {
        var e4 = at2[t4];
        Zt2(e4.objId, true), lt2(e4.content), lt2("endobj");
      }
      Dt2.publish("postPutAdditionalObjects");
    })(), t3 = [], (function() {
      for (var t4 in Ft2) Ft2.hasOwnProperty(t4) && (false === v2 || true === v2 && b2.hasOwnProperty(t4)) && se2(Ft2[t4]);
    })(), (function() {
      var t4;
      for (t4 in Bt2) Bt2.hasOwnProperty(t4) && he2(Bt2[t4]);
    })(), (function() {
      for (var t4 in zt2) zt2.hasOwnProperty(t4) && ue2(zt2[t4]);
    })(), (function(t4) {
      var e4;
      for (e4 in Ct2) Ct2.hasOwnProperty(e4) && (Ct2[e4] instanceof M ? ce2(Ct2[e4]) : Ct2[e4] instanceof q && le2(Ct2[e4], t4));
    })(t3), Dt2.publish("putResources"), t3.forEach(fe2), fe2({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Dt2.publish("postPutResources"), null !== m2 && (je2.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + je2.v), lt2("/R " + je2.r), lt2("/U <" + je2.toHexString(je2.U) + ">"), lt2("/O <" + je2.toHexString(je2.O) + ">"), lt2("/P " + je2.P), lt2(">>"), lt2("endobj")), Le2(), xe2();
    var e3 = it2;
    return _e2(), Ae2(), lt2("startxref"), lt2("" + e3), lt2("%%EOF"), ct2(ot2[$2]), rt2.join("\n");
  }, ke2 = y2.__private__.getBlob = function(t3) {
    return new Blob([ft2(t3)], { type: "application/pdf" });
  }, Fe2 = y2.output = y2.__private__.output = (Jt2 = function(t3, e3) {
    switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t3) {
      case void 0:
        return Pe2();
      case "save":
        y2.save(e3.filename);
        break;
      case "arraybuffer":
        return ft2(Pe2());
      case "blob":
        return ke2(Pe2());
      case "bloburi":
      case "bloburl":
        if (void 0 !== i$5.URL && "function" == typeof i$5.URL.createObjectURL) return i$5.URL && i$5.URL.createObjectURL(ke2(Pe2())) || void 0;
        o$1.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var n3 = "", r3 = Pe2();
        try {
          n3 = d(r3);
        } catch (m3) {
          n3 = d(unescape(encodeURIComponent(r3)));
        }
        return "data:application/pdf;filename=" + e3.filename + ";base64," + n3;
      case "pdfobjectnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(i$5)) {
          var a3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          e3.pdfObjectUrl && (a3 = e3.pdfObjectUrl, s3 = "");
          var u3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + a3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", c3 = i$5.open();
          return null !== c3 && c3.document.write(u3), c3;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if ("[object Window]" === Object.prototype.toString.call(i$5)) {
          var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', h2 = i$5.open();
          if (null !== h2) {
            h2.document.write(l2);
            var f3 = this;
            h2.document.documentElement.querySelector("#pdfViewer").onload = function() {
              h2.document.title = e3.filename, h2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(f3.output("bloburl"));
            };
          }
          return h2;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if ("[object Window]" !== Object.prototype.toString.call(i$5)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = i$5.open();
        if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari) return g3;
        break;
      case "datauri":
      case "dataurl":
        return i$5.document.location.href = this.output("datauristring", e3);
      default:
        return null;
    }
  }, Jt2.foo = function() {
    try {
      return Jt2.apply(this, arguments);
    } catch (n3) {
      var t3 = n3.stack || "";
      ~t3.indexOf(" at ") && (t3 = t3.split(" at ")[1]);
      var e3 = "Error in function " + t3.split("\n")[0].split("<")[0] + ": " + n3.message;
      if (!i$5.console) throw new Error(e3);
      i$5.console.error(e3, n3), i$5.alert && alert(e3);
    }
  }, Jt2.foo.bar = Jt2, Jt2.foo), Ie2 = function(t3) {
    return true === Array.isArray(Tt2) && Tt2.indexOf(t3) > -1;
  };
  switch (a2) {
    case "pt":
      St = 1;
      break;
    case "mm":
      St = 72 / 25.4;
      break;
    case "cm":
      St = 72 / 2.54;
      break;
    case "in":
      St = 72;
      break;
    case "px":
      St = 1 == Ie2("px_scaling") ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      St = 12;
      break;
    case "ex":
      St = 6;
      break;
    default:
      if ("number" != typeof a2) throw new Error("Invalid unit: " + a2);
      St = a2;
  }
  var je2 = null;
  K2(), Y2();
  var Ce = y2.__private__.getPageInfo = y2.getPageInfo = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: Rt2[t3].objId, pageNumber: t3, pageContext: Rt2[t3] };
  }, Oe = y2.__private__.getPageInfoByObjId = function(t3) {
    if (isNaN(t3) || t3 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var e3 in Rt2) if (Rt2[e3].objId === t3) break;
    return Ce(e3);
  }, Be = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
    return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
  };
  y2.addPage = function() {
    return ve2.apply(this, arguments), this;
  }, y2.setPage = function() {
    return ye2.apply(this, arguments), ct2.call(this, ot2[$2]), this;
  }, y2.insertPage = function(t3) {
    return this.addPage(), this.movePage($2, t3), this;
  }, y2.movePage = function(t3, e3) {
    var n3, r3;
    if (t3 > e3) {
      n3 = ot2[t3], r3 = Rt2[t3];
      for (var i2 = t3; i2 > e3; i2--) ot2[i2] = ot2[i2 - 1], Rt2[i2] = Rt2[i2 - 1];
      ot2[e3] = n3, Rt2[e3] = r3, this.setPage(e3);
    } else if (t3 < e3) {
      n3 = ot2[t3], r3 = Rt2[t3];
      for (var a3 = t3; a3 < e3; a3++) ot2[a3] = ot2[a3 + 1], Rt2[a3] = Rt2[a3 + 1];
      ot2[e3] = n3, Rt2[e3] = r3, this.setPage(e3);
    }
    return this;
  }, y2.deletePage = function() {
    return be2.apply(this, arguments), this;
  }, y2.__private__.text = y2.text = function(e3, n3, r3, i2, a3) {
    var o2, s3, u3, c3, l2, h2, f3, d2, p3, g3 = (i2 = i2 || {}).scope || this;
    if ("number" == typeof e3 && "number" == typeof n3 && ("string" == typeof r3 || Array.isArray(r3))) {
      var m3 = r3;
      r3 = n3, n3 = e3, e3 = m3;
    }
    if (arguments[3] instanceof Wt2 == 0 ? (u3 = arguments[4], c3 = arguments[5], "object" === _typeof$1(f3 = arguments[3]) && null !== f3 || ("string" == typeof u3 && (c3 = u3, u3 = null), "string" == typeof f3 && (c3 = f3, f3 = null), "number" == typeof f3 && (u3 = f3, f3 = null), i2 = { flags: f3, angle: u3, align: c3 })) : (R2("The transform parameter of text() with a Matrix value"), p3 = a3), isNaN(n3) || isNaN(r3) || null == e3) throw new Error("Invalid arguments passed to jsPDF.text");
    if (0 === e3.length) return g3;
    var v3, y3 = "", w3 = "number" == typeof i2.lineHeightFactor ? i2.lineHeightFactor : Je, N3 = g3.internal.scaleFactor;
    function L3(t3) {
      return t3 = t3.split("	").join(Array(i2.TabLen || 9).join(" ")), ge2(t3, f3);
    }
    function x3(t3) {
      for (var e4, n4 = t3.concat(), r4 = [], i3 = n4.length; i3--; ) "string" == typeof (e4 = n4.shift()) ? r4.push(e4) : Array.isArray(t3) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? r4.push(e4[0]) : r4.push([e4[0], e4[1], e4[2]]);
      return r4;
    }
    function A3(t3, e4) {
      var n4;
      if ("string" == typeof t3) n4 = e4(t3)[0];
      else if (Array.isArray(t3)) {
        for (var r4, i3, a4 = t3.concat(), o3 = [], s4 = a4.length; s4--; ) "string" == typeof (r4 = a4.shift()) ? o3.push(e4(r4)[0]) : Array.isArray(r4) && "string" == typeof r4[0] && (i3 = e4(r4[0], r4[1], r4[2]), o3.push([i3[0], i3[1], i3[2]]));
        n4 = o3;
      }
      return n4;
    }
    var P3 = false, k3 = true;
    if ("string" == typeof e3) P3 = true;
    else if (Array.isArray(e3)) {
      var F3 = e3.concat();
      s3 = [];
      for (var I2, j2 = F3.length; j2--; ) ("string" != typeof (I2 = F3.shift()) || Array.isArray(I2) && "string" != typeof I2[0]) && (k3 = false);
      P3 = k3;
    }
    if (false === P3) throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
    "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
    var C2 = pt2 / g3.internal.scaleFactor, O2 = C2 * (w3 - 1);
    switch (i2.baseline) {
      case "bottom":
        r3 -= O2;
        break;
      case "top":
        r3 += C2 - O2;
        break;
      case "hanging":
        r3 += C2 - 2 * O2;
        break;
      case "middle":
        r3 += C2 / 2 - O2;
    }
    if ((h2 = i2.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, h2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t3, e4) {
      return t3.concat(g3.splitTextToSize(e4, h2));
    }, []))), o2 = { text: e3, x: n3, y: r3, options: i2, mutex: { pdfEscape: ge2, activeFontKey: At2, fonts: Ft2, activeFontSize: pt2 } }, Dt2.publish("preProcessText", o2), e3 = o2.text, u3 = (i2 = o2.options).angle, p3 instanceof Wt2 == 0 && u3 && "number" == typeof u3) {
      u3 *= Math.PI / 180, 0 === i2.rotationDirection && (u3 = -u3), _2 === S2 && (u3 = -u3);
      var M2 = Math.cos(u3), q2 = Math.sin(u3);
      p3 = new Wt2(M2, q2, -q2, M2, 0, 0);
    } else u3 && u3 instanceof Wt2 && (p3 = u3);
    _2 !== S2 || p3 || (p3 = Gt2), void 0 !== (l2 = i2.charSpace || ln2) && (y3 += B3(U2(l2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d2 = i2.horizontalScale) && (y3 += B3(100 * d2) + " Tz\n"), i2.lang;
    var E2 = -1, D3 = void 0 !== i2.renderingMode ? i2.renderingMode : i2.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
    switch (D3) {
      case 0:
      case false:
      case "fill":
        E2 = 0;
        break;
      case 1:
      case true:
      case "stroke":
        E2 = 1;
        break;
      case 2:
      case "fillThenStroke":
        E2 = 2;
        break;
      case 3:
      case "invisible":
        E2 = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        E2 = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        E2 = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        E2 = 6;
        break;
      case 7:
      case "addToPathForClipping":
        E2 = 7;
    }
    var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
    -1 !== E2 ? y3 += E2 + " Tr\n" : -1 !== z3 && (y3 += "0 Tr\n"), -1 !== E2 && (T3.usedRenderingMode = E2), c3 = i2.align || "left";
    var H5, W3 = pt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[At2];
    l2 = i2.charSpace || ln2, h2 = i2.maxWidth || 0, f3 = Object.assign({ autoencode: true, noBOM: true }, i2.flags);
    var Y3 = [], J3 = function(t3) {
      return g3.getStringUnitWidth(t3, { font: G3, charSpace: l2, fontSize: pt2, doKerning: false }) * pt2 / N3;
    };
    if ("[object Array]" === Object.prototype.toString.call(e3)) {
      var X3;
      s3 = x3(e3), "left" !== c3 && (H5 = s3.map(J3));
      var K3, Z3 = 0;
      if ("right" === c3) {
        n3 -= H5[0], e3 = [], j2 = s3.length;
        for (var $3 = 0; $3 < j2; $3++) 0 === $3 ? (K3 = en(n3), X3 = nn(r3)) : (K3 = U2(Z3 - H5[$3]), X3 = -W3), e3.push([s3[$3], K3, X3]), Z3 = H5[$3];
      } else if ("center" === c3) {
        n3 -= H5[0] / 2, e3 = [], j2 = s3.length;
        for (var Q3 = 0; Q3 < j2; Q3++) 0 === Q3 ? (K3 = en(n3), X3 = nn(r3)) : (K3 = U2((Z3 - H5[Q3]) / 2), X3 = -W3), e3.push([s3[Q3], K3, X3]), Z3 = H5[Q3];
      } else if ("left" === c3) {
        e3 = [], j2 = s3.length;
        for (var tt3 = 0; tt3 < j2; tt3++) e3.push(s3[tt3]);
      } else if ("justify" === c3 && "Identity-H" === G3.encoding) {
        e3 = [], j2 = s3.length, h2 = 0 !== h2 ? h2 : V3;
        for (var et3 = 0, nt3 = 0; nt3 < j2; nt3++) if (X3 = 0 === nt3 ? nn(r3) : -W3, K3 = 0 === nt3 ? en(n3) : et3, nt3 < j2 - 1) {
          var rt3 = U2((h2 - H5[nt3]) / (s3[nt3].split(" ").length - 1)), it3 = s3[nt3].split(" ");
          e3.push([it3[0] + " ", K3, X3]), et3 = 0;
          for (var at3 = 1; at3 < it3.length; at3++) {
            var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N3 + rt3;
            at3 == it3.length - 1 ? e3.push([it3[at3], ot3, 0]) : e3.push([it3[at3] + " ", ot3, 0]), et3 -= ot3;
          }
        } else e3.push([s3[nt3], K3, X3]);
        e3.push(["", et3, 0]);
      } else {
        if ("justify" !== c3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (e3 = [], j2 = s3.length, h2 = 0 !== h2 ? h2 : V3, nt3 = 0; nt3 < j2; nt3++) {
          X3 = 0 === nt3 ? nn(r3) : -W3, K3 = 0 === nt3 ? en(n3) : 0;
          var st3 = s3[nt3].split(" ").length - 1, ut3 = st3 > 0 ? (h2 - H5[nt3]) / st3 : 0;
          nt3 < j2 - 1 ? Y3.push(B3(U2(ut3))) : Y3.push(0), e3.push([s3[nt3], K3, X3]);
        }
      }
    }
    true === ("boolean" == typeof i2.R2L ? i2.R2L : vt2) && (e3 = A3(e3, function(t3, e4, n4) {
      return [t3.split("").reverse().join(""), e4, n4];
    })), o2 = { text: e3, x: n3, y: r3, options: i2, mutex: { pdfEscape: ge2, activeFontKey: At2, fonts: Ft2, activeFontSize: pt2 } }, Dt2.publish("postProcessText", o2), e3 = o2.text, v3 = o2.mutex.isHex || false;
    var ct3 = Ft2[At2].encoding;
    "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e3 = A3(e3, function(t3, e4, n4) {
      return [L3(t3), e4, n4];
    })), s3 = x3(e3), e3 = [];
    for (var ht3, ft3, dt3, gt3 = Array.isArray(s3[0]) ? 1 : 0, mt3 = "", bt3 = function(t3, e4, n4) {
      var r4 = "";
      return n4 instanceof Wt2 ? (n4 = "number" == typeof i2.angle ? Vt2(n4, new Wt2(1, 0, 0, 1, t3, e4)) : Vt2(new Wt2(1, 0, 0, 1, t3, e4), n4), _2 === S2 && (n4 = Vt2(new Wt2(1, 0, 0, -1, 0, 0), n4)), r4 = n4.join(" ") + " Tm\n") : r4 = B3(t3) + " " + B3(e4) + " Td\n", r4;
    }, yt3 = 0; yt3 < s3.length; yt3++) {
      switch (mt3 = "", gt3) {
        case 1:
          dt3 = (v3 ? "<" : "(") + s3[yt3][0] + (v3 ? ">" : ")"), ht3 = parseFloat(s3[yt3][1]), ft3 = parseFloat(s3[yt3][2]);
          break;
        case 0:
          dt3 = (v3 ? "<" : "(") + s3[yt3] + (v3 ? ">" : ")"), ht3 = en(n3), ft3 = nn(r3);
      }
      void 0 !== Y3 && void 0 !== Y3[yt3] && (mt3 = Y3[yt3] + " Tw\n"), 0 === yt3 ? e3.push(mt3 + bt3(ht3, ft3, p3) + dt3) : 0 === gt3 ? e3.push(mt3 + dt3) : 1 === gt3 && e3.push(mt3 + bt3(ht3, ft3, p3) + dt3);
    }
    e3 = 0 === gt3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
    var wt3 = "BT\n/";
    return wt3 += At2 + " " + pt2 + " Tf\n", wt3 += B3(pt2 * w3) + " TL\n", wt3 += un + "\n", wt3 += y3, wt3 += e3, lt2(wt3 += "ET"), b2[At2] = true, g3;
  };
  var Me = y2.__private__.clip = y2.clip = function(t3) {
    return lt2("evenodd" === t3 ? "W*" : "W"), this;
  };
  y2.clipEvenOdd = function() {
    return Me("evenodd");
  }, y2.__private__.discardPath = y2.discardPath = function() {
    return lt2("n"), this;
  };
  var qe = y2.__private__.isValidStyle = function(t3) {
    var e3 = false;
    return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t3) && (e3 = true), e3;
  };
  y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t3) {
    return qe(t3) && (g2 = t3), this;
  };
  var Ee = y2.__private__.getStyle = y2.getStyle = function(t3) {
    var e3 = g2;
    switch (t3) {
      case "D":
      case "S":
        e3 = "S";
        break;
      case "F":
        e3 = "f";
        break;
      case "FD":
      case "DF":
        e3 = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        e3 = t3;
    }
    return e3;
  }, Re = y2.close = function() {
    return lt2("h"), this;
  };
  y2.stroke = function() {
    return lt2("S"), this;
  }, y2.fill = function(t3) {
    return De("f", t3), this;
  }, y2.fillEvenOdd = function(t3) {
    return De("f*", t3), this;
  }, y2.fillStroke = function(t3) {
    return De("B", t3), this;
  }, y2.fillStrokeEvenOdd = function(t3) {
    return De("B*", t3), this;
  };
  var De = function(e3, n3) {
    "object" === _typeof$1(n3) ? Ue(n3, e3) : lt2(e3);
  }, Te = function(t3) {
    null === t3 || _2 === S2 && void 0 === t3 || (t3 = Ee(t3), lt2(t3));
  };
  function ze(t3, e3, n3, r3, i2) {
    var a3 = new q(e3 || this.boundingBox, n3 || this.xStep, r3 || this.yStep, this.gState, i2 || this.matrix);
    a3.stream = this.stream;
    var o2 = t3 + "$$" + this.cloneIndex++ + "$$";
    return Yt2(o2, a3), a3;
  }
  var Ue = function(t3, e3) {
    var n3 = Ot2[t3.key], r3 = Ct2[n3];
    if (r3 instanceof M) lt2("q"), lt2(He(e3)), r3.gState && y2.setGState(r3.gState), lt2(t3.matrix.toString() + " cm"), lt2("/" + n3 + " sh"), lt2("Q");
    else if (r3 instanceof q) {
      var i2 = new Wt2(1, 0, 0, -1, 0, _n());
      t3.matrix && (i2 = i2.multiply(t3.matrix || Gt2), n3 = ze.call(r3, t3.key, t3.boundingBox, t3.xStep, t3.yStep, i2).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + n3 + " scn"), r3.gState && y2.setGState(r3.gState), lt2(e3), lt2("Q");
    }
  }, He = function(t3) {
    switch (t3) {
      case "f":
      case "F":
      case "n":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
      case "S":
        return "W S";
      case "B*":
        return "W* S";
    }
  }, We = y2.moveTo = function(t3, e3) {
    return lt2(B3(U2(t3)) + " " + B3(H4(e3)) + " m"), this;
  }, Ve = y2.lineTo = function(t3, e3) {
    return lt2(B3(U2(t3)) + " " + B3(H4(e3)) + " l"), this;
  }, Ge = y2.curveTo = function(t3, e3, n3, r3, i2, a3) {
    return lt2([B3(U2(t3)), B3(H4(e3)), B3(U2(n3)), B3(H4(r3)), B3(U2(i2)), B3(H4(a3)), "c"].join(" ")), this;
  };
  y2.__private__.line = y2.line = function(t3, e3, n3, r3, i2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.line");
    return _2 === A2 ? this.lines([[n3 - t3, r3 - e3]], t3, e3, [1, 1], i2 || "S") : this.lines([[n3 - t3, r3 - e3]], t3, e3, [1, 1]).stroke();
  }, y2.__private__.lines = y2.lines = function(t3, e3, n3, r3, i2, a3) {
    var o2, s3, u3, c3, l2, h2, f3, d2, p3, g3, m3, v3;
    if ("number" == typeof t3 && (v3 = n3, n3 = e3, e3 = t3, t3 = v3), r3 = r3 || [1, 1], a3 = a3 || false, isNaN(e3) || isNaN(n3) || !Array.isArray(t3) || !Array.isArray(r3) || !qe(i2) || "boolean" != typeof a3) throw new Error("Invalid arguments passed to jsPDF.lines");
    for (We(e3, n3), o2 = r3[0], s3 = r3[1], c3 = t3.length, g3 = e3, m3 = n3, u3 = 0; u3 < c3; u3++) 2 === (l2 = t3[u3]).length ? (g3 = l2[0] * o2 + g3, m3 = l2[1] * s3 + m3, Ve(g3, m3)) : (h2 = l2[0] * o2 + g3, f3 = l2[1] * s3 + m3, d2 = l2[2] * o2 + g3, p3 = l2[3] * s3 + m3, g3 = l2[4] * o2 + g3, m3 = l2[5] * s3 + m3, Ge(h2, f3, d2, p3, g3, m3));
    return a3 && Re(), Te(i2), this;
  }, y2.path = function(t3) {
    for (var e3 = 0; e3 < t3.length; e3++) {
      var n3 = t3[e3], r3 = n3.c;
      switch (n3.op) {
        case "m":
          We(r3[0], r3[1]);
          break;
        case "l":
          Ve(r3[0], r3[1]);
          break;
        case "c":
          Ge.apply(this, r3);
          break;
        case "h":
          Re();
      }
    }
    return this;
  }, y2.__private__.rect = y2.rect = function(t3, e3, n3, r3, i2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return _2 === A2 && (r3 = -r3), lt2([B3(U2(t3)), B3(H4(e3)), B3(U2(n3)), B3(U2(r3)), "re"].join(" ")), Te(i2), this;
  }, y2.__private__.triangle = y2.triangle = function(t3, e3, n3, r3, i2, a3, o2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i2) || isNaN(a3) || !qe(o2)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[n3 - t3, r3 - e3], [i2 - n3, a3 - r3], [t3 - i2, e3 - a3]], t3, e3, [1, 1], o2, true), this;
  }, y2.__private__.roundedRect = y2.roundedRect = function(t3, e3, n3, r3, i2, a3, o2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i2) || isNaN(a3) || !qe(o2)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var s3 = 4 / 3 * (Math.SQRT2 - 1);
    return i2 = Math.min(i2, 0.5 * n3), a3 = Math.min(a3, 0.5 * r3), this.lines([[n3 - 2 * i2, 0], [i2 * s3, 0, i2, a3 - a3 * s3, i2, a3], [0, r3 - 2 * a3], [0, a3 * s3, -i2 * s3, a3, -i2, a3], [2 * i2 - n3, 0], [-i2 * s3, 0, -i2, -a3 * s3, -i2, -a3], [0, 2 * a3 - r3], [0, -a3 * s3, i2 * s3, -a3, i2, -a3]], t3 + i2, e3, [1, 1], o2, true), this;
  }, y2.__private__.ellipse = y2.ellipse = function(t3, e3, n3, r3, i2) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var a3 = 4 / 3 * (Math.SQRT2 - 1) * n3, o2 = 4 / 3 * (Math.SQRT2 - 1) * r3;
    return We(t3 + n3, e3), Ge(t3 + n3, e3 - o2, t3 + a3, e3 - r3, t3, e3 - r3), Ge(t3 - a3, e3 - r3, t3 - n3, e3 - o2, t3 - n3, e3), Ge(t3 - n3, e3 + o2, t3 - a3, e3 + r3, t3, e3 + r3), Ge(t3 + a3, e3 + r3, t3 + n3, e3 + o2, t3 + n3, e3), Te(i2), this;
  }, y2.__private__.circle = y2.circle = function(t3, e3, n3, r3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || !qe(r3)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(t3, e3, n3, n3, r3);
  }, y2.setFont = function(t3, e3, n3) {
    return n3 && (e3 = F2(e3, n3)), At2 = Ne2(t3, e3, { disableWarning: false }), this;
  };
  var Ye = y2.__private__.getFont = y2.getFont = function() {
    return Ft2[Ne2.apply(y2, arguments)];
  };
  y2.__private__.getFontList = y2.getFontList = function() {
    var t3, e3, n3 = {};
    for (t3 in It2) if (It2.hasOwnProperty(t3)) for (e3 in n3[t3] = [], It2[t3]) It2[t3].hasOwnProperty(e3) && n3[t3].push(e3);
    return n3;
  }, y2.addFont = function(t3, e3, n3, r3, i2) {
    var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && -1 !== a3.indexOf(arguments[3]) ? i2 = arguments[3] : arguments[3] && -1 == a3.indexOf(arguments[3]) && (n3 = F2(n3, r3)), pe2.call(this, t3, e3, n3, i2 = i2 || "Identity-H");
  };
  var Je, Xe = e2.lineWidth || 0.200025, Ke = y2.__private__.getLineWidth = y2.getLineWidth = function() {
    return Xe;
  }, Ze = y2.__private__.setLineWidth = y2.setLineWidth = function(t3) {
    return Xe = t3, lt2(B3(U2(t3)) + " w"), this;
  };
  y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t3, e3) {
    if (t3 = t3 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t3)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return t3 = t3.map(function(t4) {
      return B3(U2(t4));
    }).join(" "), e3 = B3(U2(e3)), lt2("[" + t3 + "] " + e3 + " d"), this;
  };
  var $e = y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return pt2 * Je;
  };
  y2.__private__.getLineHeight = y2.getLineHeight = function() {
    return pt2 * Je;
  };
  var Qe = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t3) {
    return "number" == typeof (t3 = t3 || 1.15) && (Je = t3), this;
  }, tn = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
    return Je;
  };
  Qe(e2.lineHeight);
  var en = y2.__private__.getHorizontalCoordinate = function(t3) {
    return U2(t3);
  }, nn = y2.__private__.getVerticalCoordinate = function(t3) {
    return _2 === S2 ? t3 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t3);
  }, rn = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t3) {
    return B3(en(t3));
  }, an = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t3) {
    return B3(nn(t3));
  }, on = e2.strokeColor || "0 G";
  y2.__private__.getStrokeColor = y2.getDrawColor = function() {
    return ee2(on);
  }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t3, e3, n3, r3) {
    return on = ne2({ ch1: t3, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "draw", precision: 2 }), lt2(on), this;
  };
  var sn = e2.fillColor || "0 g";
  y2.__private__.getFillColor = y2.getFillColor = function() {
    return ee2(sn);
  }, y2.__private__.setFillColor = y2.setFillColor = function(t3, e3, n3, r3) {
    return sn = ne2({ ch1: t3, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "fill", precision: 2 }), lt2(sn), this;
  };
  var un = e2.textColor || "0 g", cn = y2.__private__.getTextColor = y2.getTextColor = function() {
    return ee2(un);
  };
  y2.__private__.setTextColor = y2.setTextColor = function(t3, e3, n3, r3) {
    return un = ne2({ ch1: t3, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "text", precision: 3 }), this;
  };
  var ln2 = e2.charSpace, hn = y2.__private__.getCharSpace = y2.getCharSpace = function() {
    return parseFloat(ln2 || 0);
  };
  y2.__private__.setCharSpace = y2.setCharSpace = function(t3) {
    if (isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return ln2 = t3, this;
  };
  var fn = 0;
  y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (void 0 === e3) throw new Error("Line cap style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return fn = e3, lt2(e3 + " J"), this;
  };
  var dn = 0;
  y2.__private__.setLineJoin = y2.setLineJoin = function(t3) {
    var e3 = y2.CapJoinStyles[t3];
    if (void 0 === e3) throw new Error("Line join style of '" + t3 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return dn = e3, lt2(e3 + " j"), this;
  }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t3) {
    if (t3 = t3 || 0, isNaN(t3)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return lt2(B3(U2(t3)) + " M"), this;
  }, y2.GState = O$1, y2.setGState = function(t3) {
    (t3 = "string" == typeof t3 ? Bt2[Mt2[t3]] : pn(null, t3)).equals(qt2) || (lt2("/" + t3.id + " gs"), qt2 = t3);
  };
  var pn = function(t3, e3) {
    if (!t3 || !Mt2[t3]) {
      var n3 = false;
      for (var r3 in Bt2) if (Bt2.hasOwnProperty(r3) && Bt2[r3].equals(e3)) {
        n3 = true;
        break;
      }
      if (n3) e3 = Bt2[r3];
      else {
        var i2 = "GS" + (Object.keys(Bt2).length + 1).toString(10);
        Bt2[i2] = e3, e3.id = i2;
      }
      return t3 && (Mt2[t3] = e3.id), Dt2.publish("addGState", e3), e3;
    }
  };
  y2.addGState = function(t3, e3) {
    return pn(t3, e3), this;
  }, y2.saveGraphicsState = function() {
    return lt2("q"), jt2.push({ key: At2, size: pt2, color: un }), this;
  }, y2.restoreGraphicsState = function() {
    lt2("Q");
    var t3 = jt2.pop();
    return At2 = t3.key, pt2 = t3.size, un = t3.color, qt2 = null, this;
  }, y2.setCurrentTransformationMatrix = function(t3) {
    return lt2(t3.toString() + " cm"), this;
  }, y2.comment = function(t3) {
    return lt2("#" + t3), this;
  };
  var gn = function(t3, e3) {
    var n3 = t3 || 0;
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      isNaN(t4) || (n3 = parseFloat(t4));
    } });
    var r3 = e3 || 0;
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      isNaN(t4) || (r3 = parseFloat(t4));
    } });
    var i2 = "pt";
    return Object.defineProperty(this, "type", { enumerable: true, get: function() {
      return i2;
    }, set: function(t4) {
      i2 = t4.toString();
    } }), this;
  }, mn = function(t3, e3, n3, r3) {
    gn.call(this, t3, e3), this.type = "rect";
    var i2 = n3 || 0;
    Object.defineProperty(this, "w", { enumerable: true, get: function() {
      return i2;
    }, set: function(t4) {
      isNaN(t4) || (i2 = parseFloat(t4));
    } });
    var a3 = r3 || 0;
    return Object.defineProperty(this, "h", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      isNaN(t4) || (a3 = parseFloat(t4));
    } }), this;
  }, vn = function() {
    this.page = Et2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = _t2, this.y = Pt2, this.matrix = kt2, this.width = wn($2), this.height = Ln($2), this.outputDestination = ut2, this.id = "", this.objectNumber = -1;
  };
  vn.prototype.restore = function() {
    Et2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, _t2 = this.x, Pt2 = this.y, kt2 = this.matrix, Nn($2, this.width), xn($2, this.height), ut2 = this.outputDestination;
  };
  var bn = function(t3, e3, n3, r3, i2) {
    Ht2.push(new vn()), Et2 = $2 = 0, ot2 = [], _t2 = t3, Pt2 = e3, kt2 = i2, me2([n3, r3]);
  };
  for (var yn in y2.beginFormObject = function(t3, e3, n3, r3, i2) {
    return bn(t3, e3, n3, r3, i2), this;
  }, y2.endFormObject = function(t3) {
    return (function(t4) {
      if (Ut2[t4]) Ht2.pop().restore();
      else {
        var e3 = new vn(), n3 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
        e3.id = n3, Ut2[t4] = n3, zt2[n3] = e3, Dt2.publish("addFormObject", e3), Ht2.pop().restore();
      }
    })(t3), this;
  }, y2.doFormObject = function(t3, e3) {
    var n3 = zt2[Ut2[t3]];
    return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + n3.id + " Do"), lt2("Q"), this;
  }, y2.getFormObject = function(t3) {
    var e3 = zt2[Ut2[t3]];
    return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
  }, y2.save = function(t3, e3) {
    return t3 = t3 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l$1(ke2(Pe2()), t3), "function" == typeof l$1.unload && i$5.setTimeout && setTimeout(l$1.unload, 911), this) : new Promise(function(e4, n3) {
      try {
        var r3 = l$1(ke2(Pe2()), t3);
        "function" == typeof l$1.unload && i$5.setTimeout && setTimeout(l$1.unload, 911), e4(r3);
      } catch (a3) {
        n3(a3.message);
      }
    });
  }, E$1.API) E$1.API.hasOwnProperty(yn) && ("events" === yn && E$1.API.events.length ? (function(t3, e3) {
    var n3, r3, i2;
    for (i2 = e3.length - 1; -1 !== i2; i2--) n3 = e3[i2][0], r3 = e3[i2][1], t3.subscribe.apply(t3, [n3].concat("function" == typeof r3 ? [r3] : r3));
  })(Dt2, E$1.API.events) : y2[yn] = E$1.API[yn]);
  function wn(t3) {
    return Rt2[t3].mediaBox.topRightX - Rt2[t3].mediaBox.bottomLeftX;
  }
  function Nn(t3, e3) {
    Rt2[t3].mediaBox.topRightX = e3 + Rt2[t3].mediaBox.bottomLeftX;
  }
  function Ln(t3) {
    return Rt2[t3].mediaBox.topRightY - Rt2[t3].mediaBox.bottomLeftY;
  }
  function xn(t3, e3) {
    Rt2[t3].mediaBox.topRightY = e3 + Rt2[t3].mediaBox.bottomLeftY;
  }
  var An = y2.getPageWidth = function(t3) {
    return wn(t3 = t3 || $2) / St;
  }, Sn = y2.setPageWidth = function(t3, e3) {
    Nn(t3, e3 * St);
  }, _n = y2.getPageHeight = function(t3) {
    return Ln(t3 = t3 || $2) / St;
  }, Pn = y2.setPageHeight = function(t3, e3) {
    xn(t3, e3 * St);
  };
  return y2.internal = { pdfEscape: ge2, getStyle: Ee, getFont: Ye, getFontSize: mt2, getCharSpace: hn, getTextColor: cn, getLineHeight: $e, getLineHeightFactor: tn, getLineWidth: Ke, write: ht2, getHorizontalCoordinate: en, getVerticalCoordinate: nn, getCoordinateString: rn, getVerticalCoordinateString: an, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: re2, putStream: ie2, events: Dt2, scaleFactor: St, pageSize: { getWidth: function() {
    return An($2);
  }, setWidth: function(t3) {
    Sn($2, t3);
  }, getHeight: function() {
    return _n($2);
  }, setHeight: function(t3) {
    Pn($2, t3);
  } }, encryptionOptions: m2, encryption: je2, getEncryptor: function(t3) {
    return null !== m2 ? je2.encryptor(t3, 0) : function(t4) {
      return t4;
    };
  }, output: Fe2, getNumberOfPages: we2, pages: ot2, out: lt2, f2: T2, f3: z2, getPageInfo: Ce, getPageInfoByObjId: Oe, getCurrentPageInfo: Be, getPDFVersion: N2, Point: gn, Rectangle: mn, Matrix: Wt2, hasHotfix: Ie2 }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
    return An($2);
  }, set: function(t3) {
    Sn($2, t3);
  }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
    return _n($2);
  }, set: function(t3) {
    Pn($2, t3);
  }, enumerable: true, configurable: true }), (function(t3) {
    for (var e3 = 0, n3 = dt2.length; e3 < n3; e3++) {
      var r3 = pe2.call(this, t3[e3][0], t3[e3][1], t3[e3][2], dt2[e3][3], true);
      false === v2 && (b2[r3] = true);
      var i2 = t3[e3][0].split("-");
      de2({ id: r3, fontName: i2[0], fontStyle: i2[1] || "" });
    }
    Dt2.publish("addFonts", { fonts: Ft2, dictionary: It2 });
  }).call(y2, dt2), At2 = "F1", ve2(s2, r2), Dt2.publish("initialized"), y2;
}
I.prototype.lsbFirstWord = function(t3) {
  return String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, t3 >> 24 & 255);
}, I.prototype.toHexString = function(t3) {
  return t3.split("").map(function(t4) {
    return ("0" + (255 & t4.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, I.prototype.hexToBytes = function(t3) {
  for (var e2 = [], n2 = 0; n2 < t3.length; n2 += 2) e2.push(String.fromCharCode(parseInt(t3.substr(n2, 2), 16)));
  return e2.join("");
}, I.prototype.processOwnerPassword = function(t3, e2) {
  return k(S(e2).substr(0, 5), t3);
}, I.prototype.encryptor = function(t3, e2) {
  var n2 = S(this.encryptionKey + String.fromCharCode(255 & t3, t3 >> 8 & 255, t3 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
  return function(t4) {
    return k(n2, t4);
  };
}, O$1.prototype.equals = function(e2) {
  var n2, r2 = "id,objectNumber,equals";
  if (!e2 || _typeof$1(e2) !== _typeof$1(this)) return false;
  var i2 = 0;
  for (n2 in this) if (!(r2.indexOf(n2) >= 0)) {
    if (this.hasOwnProperty(n2) && !e2.hasOwnProperty(n2)) return false;
    if (this[n2] !== e2[n2]) return false;
    i2++;
  }
  for (n2 in e2) e2.hasOwnProperty(n2) && r2.indexOf(n2) < 0 && i2--;
  return 0 === i2;
}, E$1.API = { events: [] }, E$1.version = "3.0.3";
var R = E$1.API, D = 1, T$2 = function(t3) {
  return t3.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, z$1 = function(t3) {
  return t3.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, U$1 = function(t3) {
  return t3.toFixed(2);
}, H = function(t3) {
  return t3.toFixed(5);
};
R.__acroform__ = {};
var W = function(t3, e2) {
  t3.prototype = Object.create(e2.prototype), t3.prototype.constructor = t3;
}, V$1 = function(t3) {
  return t3 * D;
}, G = function(t3) {
  var e2 = new ct(), n2 = xt.internal.getHeight(t3) || 0, r2 = xt.internal.getWidth(t3) || 0;
  return e2.BBox = [0, 0, Number(U$1(r2)), Number(U$1(n2))], e2;
}, Y = R.__acroform__.setBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return t3 | 1 << e2;
}, J = R.__acroform__.clearBit = function(t3, e2) {
  if (t3 = t3 || 0, e2 = e2 || 0, isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return t3 & ~(1 << e2);
}, X = R.__acroform__.getBit = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return t3 & 1 << e2 ? 1 : 0;
}, K = R.__acroform__.getBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return X(t3, e2 - 1);
}, Z$1 = R.__acroform__.setBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return Y(t3, e2 - 1);
}, $$1 = R.__acroform__.clearBitForPdf = function(t3, e2) {
  if (isNaN(t3) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return J(t3, e2 - 1);
}, Q = R.__acroform__.calculateCoordinates = function(t3, e2) {
  var n2 = e2.internal.getHorizontalCoordinate, r2 = e2.internal.getVerticalCoordinate, i2 = t3[0], a2 = t3[1], o2 = t3[2], s2 = t3[3], u2 = {};
  return u2.lowerLeft_X = n2(i2) || 0, u2.lowerLeft_Y = r2(a2 + s2) || 0, u2.upperRight_X = n2(i2 + o2) || 0, u2.upperRight_Y = r2(a2) || 0, [Number(U$1(u2.lowerLeft_X)), Number(U$1(u2.lowerLeft_Y)), Number(U$1(u2.upperRight_X)), Number(U$1(u2.upperRight_Y))];
}, tt = function(t3) {
  if (t3.appearanceStreamContent) return t3.appearanceStreamContent;
  if (t3.V || t3.DV) {
    var e2 = [], n2 = t3._V || t3.DV, r2 = et(t3, n2), i2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id;
    e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t3.scope.__private__.encodeColorString(t3.color)), e2.push("/" + i2 + " " + U$1(r2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(r2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
    var a2 = G(t3);
    return a2.scope = t3.scope, a2.stream = e2.join("\n"), a2;
  }
}, et = function(t3, e2) {
  var n2 = 0 === t3.fontSize ? t3.maxFontSize : t3.fontSize, r2 = { text: "", fontSize: "" }, i2 = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
  i2 = t3.multiline ? i2.map(function(t4) {
    return t4.split("\n");
  }) : i2.map(function(t4) {
    return [t4];
  });
  var a2 = n2, o2 = xt.internal.getHeight(t3) || 0;
  o2 = o2 < 0 ? -o2 : o2;
  var s2 = xt.internal.getWidth(t3) || 0;
  s2 = s2 < 0 ? -s2 : s2;
  var u2 = function(e3, n3, r3) {
    if (e3 + 1 < i2.length) {
      var a3 = n3 + " " + i2[e3 + 1][0];
      return nt(a3, t3, r3).width <= s2 - 4;
    }
    return false;
  };
  a2++;
  t: for (; a2 > 0; ) {
    e2 = "", a2--;
    var c2, l2, h2 = nt("3", t3, a2).height, f2 = t3.multiline ? o2 - a2 : (o2 - h2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
    if (a2 <= 0) {
      e2 = "(...) Tj\n", e2 += "% Width of Text: " + nt(e2, t3, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
      break;
    }
    for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++) if (i2.hasOwnProperty(y2)) {
      var w2 = false;
      if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
        if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
        v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
      } else {
        v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
        var N2 = parseInt(y2), L2 = u2(N2, v2, a2), x2 = y2 >= i2.length - 1;
        if (L2 && !x2) {
          v2 += " ", m2 = 0;
          continue;
        }
        if (L2 || x2) {
          if (x2) g2 = N2;
          else if (t3.multiline && (h2 + 2) * (b2 + 2) + 2 > o2) continue t;
        } else {
          if (!t3.multiline) continue t;
          if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
          g2 = N2;
        }
      }
      for (var A2 = "", S2 = p2; S2 <= g2; S2++) {
        var _2 = i2[S2];
        if (t3.multiline) {
          if (S2 === g2) {
            A2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
            continue;
          }
          if (S2 === p2) {
            A2 += _2[_2.length - 1] + " ";
            continue;
          }
        }
        A2 += _2[0] + " ";
      }
      switch (A2 = " " == A2.substr(A2.length - 1) ? A2.substr(0, A2.length - 1) : A2, l2 = nt(A2, t3, a2).width, t3.textAlign) {
        case "right":
          c2 = s2 - l2 - 2;
          break;
        case "center":
          c2 = (s2 - l2) / 2;
          break;
        default:
          c2 = 2;
      }
      e2 += U$1(c2) + " " + U$1(d2) + " Td\n", e2 += "(" + T$2(A2) + ") Tj\n", e2 += -U$1(c2) + " 0 Td\n", d2 = -(a2 + 2), l2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
    }
    break;
  }
  return r2.text = e2, r2.fontSize = a2, r2;
}, nt = function(t3, e2, n2) {
  var r2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t3, { font: r2, fontSize: parseFloat(n2), charSpace: 0 }) * parseFloat(n2);
  return { height: e2.scope.getStringUnitWidth("3", { font: r2, fontSize: parseFloat(n2), charSpace: 0 }) * parseFloat(n2) * 1.5, width: i2 };
}, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, it = function(t3, e2) {
  var n2 = { type: "reference", object: t3 };
  void 0 === e2.internal.getPageInfo(t3.page).pageContext.annotations.find(function(t4) {
    return t4.type === n2.type && t4.object === n2.object;
  }) && e2.internal.getPageInfo(t3.page).pageContext.annotations.push(n2);
}, at = function(e2, n2) {
  if (n2.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
    if (ht.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new lt(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
      !(function(t3) {
        t3.internal.events.unsubscribe(t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t3.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t3.internal.acroformPlugin.printedOut = true;
      })(e2);
    }), e2.internal.events.subscribe("buildDocument", function() {
      !(function(t3) {
        t3.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var e3 = t3.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var n3 in e3) if (e3.hasOwnProperty(n3)) {
          var r2 = e3[n3];
          r2.objId = void 0, r2.hasAnnotation && it(r2, t3);
        }
      })(e2);
    }), e2.internal.events.subscribe("putCatalog", function() {
      !(function(t3) {
        if (void 0 === t3.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
        t3.internal.write("/AcroForm " + t3.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(e2);
    }), e2.internal.events.subscribe("postPutPages", function(n3) {
      !(function(e3, n4) {
        var r2 = !e3;
        for (var i2 in e3 || (n4.internal.newObjectDeferredBegin(n4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), n4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || n4.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e3.hasOwnProperty(i2)) {
          var a2 = e3[i2], o2 = [], s2 = a2.Rect;
          if (a2.Rect && (a2.Rect = Q(a2.Rect, n4)), n4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = xt.createDefaultAppearanceStream(a2), "object" === _typeof$1(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
            var u2 = tt(a2);
            o2.push({ key: "AP", value: "<</N " + u2 + ">>" }), n4.internal.acroformPlugin.xForms.push(u2);
          }
          if (a2.appearanceStreamContent) {
            var c2 = "";
            for (var l2 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(l2)) {
              var h2 = a2.appearanceStreamContent[l2];
              if (c2 += "/" + l2 + " ", c2 += "<<", Object.keys(h2).length >= 1 || Array.isArray(h2)) {
                for (var i2 in h2) if (h2.hasOwnProperty(i2)) {
                  var f2 = h2[i2];
                  "function" == typeof f2 && (f2 = f2.call(n4, a2)), c2 += "/" + i2 + " " + f2 + " ", n4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n4.internal.acroformPlugin.xForms.push(f2);
                }
              } else "function" == typeof (f2 = h2) && (f2 = f2.call(n4, a2)), c2 += "/" + i2 + " " + f2, n4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n4.internal.acroformPlugin.xForms.push(f2);
              c2 += ">>";
            }
            o2.push({ key: "AP", value: "<<\n" + c2 + ">>" });
          }
          n4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), n4.internal.out("endobj");
        }
        r2 && (function(e4, n5) {
          for (var r3 in e4) if (e4.hasOwnProperty(r3)) {
            var i3 = r3, a3 = e4[r3];
            n5.internal.newObjectDeferredBegin(a3.objId, true), "object" === _typeof$1(a3) && "function" == typeof a3.putStream && a3.putStream(), delete e4[i3];
          }
        })(n4.internal.acroformPlugin.xForms, n4);
      })(n3, e2);
    }), e2.internal.acroformPlugin.isInitialized = true;
  }
}, ot = R.__acroform__.arrayToPdfArray = function(e2, n2, r2) {
  var i2 = function(t3) {
    return t3;
  };
  if (Array.isArray(e2)) {
    for (var a2 = "[", o2 = 0; o2 < e2.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof$1(e2[o2])) {
      case "boolean":
      case "number":
      case "object":
        a2 += e2[o2].toString();
        break;
      case "string":
        "/" !== e2[o2].substr(0, 1) ? (void 0 !== n2 && r2 && (i2 = r2.internal.getEncryptor(n2)), a2 += "(" + T$2(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
    }
    return a2 + "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, st = function(t3, e2, n2) {
  var r2 = function(t4) {
    return t4;
  };
  return void 0 !== e2 && n2 && (r2 = n2.internal.getEncryptor(e2)), (t3 = t3 || "").toString(), "(" + T$2(r2(t3)) + ")";
}, ut = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (void 0 === this._objId) {
      if (void 0 === this.scope) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(t3) {
    this._objId = t3;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
};
ut.prototype.toString = function() {
  return this.objId + " 0 R";
}, ut.prototype.putStream = function() {
  var t3 = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t3, objectId: this.objId }), this.scope.internal.out("endobj");
}, ut.prototype.getKeyValueListForStream = function() {
  var t3 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t4) {
    return "content" != t4 && "appearanceStreamContent" != t4 && "scope" != t4 && "objId" != t4 && "_" != t4.substring(0, 1);
  });
  for (var n2 in e2) if (false === Object.getOwnPropertyDescriptor(this, e2[n2]).configurable) {
    var r2 = e2[n2], i2 = this[r2];
    i2 && (Array.isArray(i2) ? t3.push({ key: r2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ut ? (i2.scope = this.scope, t3.push({ key: r2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t3.push({ key: r2, value: i2 }));
  }
  return t3;
};
var ct = function() {
  ut.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
  var t3, e2 = [];
  Object.defineProperty(this, "BBox", { configurable: false, get: function() {
    return e2;
  }, set: function(t4) {
    e2 = t4;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
    t3 = e3.trim();
  }, get: function() {
    return t3 || null;
  } });
};
W(ct, ut);
var lt = function() {
  ut.call(this);
  var t3, e2 = [];
  Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
    return e2.length > 0 ? e2 : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
    return e2;
  } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
    if (t3) {
      var e3 = function(t4) {
        return t4;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + T$2(e3(t3)) + ")";
    }
  }, set: function(e3) {
    t3 = e3;
  } });
};
W(lt, ut);
var ht = function t() {
  ut.call(this);
  var e2 = 4;
  Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
    e2 = t3;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(e2, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.F = Z$1(e2, 3) : this.F = $$1(e2, 3);
  } });
  var n2 = 0;
  Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
    return n2;
  }, set: function(t3) {
    if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
    n2 = t3;
  } });
  var r2 = [];
  Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
    if (0 !== r2.length) return r2;
  }, set: function(t3) {
    r2 = void 0 !== t3 ? t3 : [];
  } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
    return !r2 || isNaN(r2[0]) ? 0 : r2[0];
  }, set: function(t3) {
    r2[0] = t3;
  } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
    return !r2 || isNaN(r2[1]) ? 0 : r2[1];
  }, set: function(t3) {
    r2[1] = t3;
  } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
    return !r2 || isNaN(r2[2]) ? 0 : r2[2];
  }, set: function(t3) {
    r2[2] = t3;
  } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
    return !r2 || isNaN(r2[3]) ? 0 : r2[3];
  }, set: function(t3) {
    r2[3] = t3;
  } });
  var i2 = "";
  Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
    return i2;
  }, set: function(t3) {
    switch (t3) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i2 = t3;
        break;
      default:
        throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
    }
  } });
  var a2 = null;
  Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
    if (!a2 || a2.length < 1) {
      if (this instanceof yt) return;
      a2 = "FieldObject" + t.FieldNum++;
    }
    var e3 = function(t3) {
      return t3;
    };
    return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + T$2(e3(a2)) + ")";
  }, set: function(t3) {
    a2 = t3.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
    return a2;
  }, set: function(t3) {
    a2 = t3;
  } });
  var o2 = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
    return o2;
  }, set: function(t3) {
    o2 = t3;
  } });
  var s2 = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
    return s2;
  }, set: function(t3) {
    s2 = t3;
  } });
  var u2 = 0;
  Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
    return u2;
  }, set: function(t3) {
    u2 = t3;
  } });
  var c2 = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
    return void 0 === c2 ? 50 / D : c2;
  }, set: function(t3) {
    c2 = t3;
  } });
  var l2 = "black";
  Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
    return l2;
  }, set: function(t3) {
    l2 = t3;
  } });
  var h2 = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
    if (!(!h2 || this instanceof yt || this instanceof Nt)) return st(h2, this.objId, this.scope);
  }, set: function(t3) {
    t3 = t3.toString(), h2 = t3;
  } });
  var f2 = null;
  Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
    if (f2) return this instanceof mt == 0 ? st(f2, this.objId, this.scope) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == 0 ? "(" === t3.substr(0, 1) ? z$1(t3.substr(1, t3.length - 2)) : z$1(t3) : t3;
  } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == 1 ? z$1(f2.substr(1, f2.length - 1)) : f2;
  }, set: function(t3) {
    t3 = t3.toString(), f2 = this instanceof mt == 1 ? "/" + t3 : t3;
  } });
  var d2 = null;
  Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
    if (d2) return d2;
  }, set: function(t3) {
    this.V = t3;
  } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
    if (d2) return this instanceof mt == 0 ? st(d2, this.objId, this.scope) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == 0 ? "(" === t3.substr(0, 1) ? z$1(t3.substr(1, t3.length - 2)) : z$1(t3) : t3;
  } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
    return this instanceof mt == 1 ? z$1(d2.substr(1, d2.length - 1)) : d2;
  }, set: function(t3) {
    t3 = t3.toString(), d2 = this instanceof mt == 1 ? "/" + t3 : t3;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var p2, g2 = false;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return g2;
  }, set: function(t3) {
    t3 = Boolean(t3), g2 = t3;
  } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
    if (p2) return p2;
  }, set: function(t3) {
    p2 = t3;
  } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 1));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 1) : this.Ff = $$1(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 2));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 2) : this.Ff = $$1(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 3));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 3) : this.Ff = $$1(this.Ff, 3);
  } });
  var m2 = null;
  Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
    if (null !== m2) return m2;
  }, set: function(t3) {
    if (-1 === [0, 1, 2].indexOf(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
    m2 = t3;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var t3;
    switch (m2) {
      case 0:
      default:
        t3 = "left";
        break;
      case 1:
        t3 = "center";
        break;
      case 2:
        t3 = "right";
    }
    return t3;
  }, configurable: true, enumerable: true, set: function(t3) {
    switch (t3) {
      case "right":
      case 2:
        m2 = 2;
        break;
      case "center":
      case 1:
        m2 = 1;
        break;
      default:
        m2 = 0;
    }
  } });
};
W(ht, ut);
var ft = function() {
  ht.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var t3 = 0;
  Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e3) {
    t3 = e3;
  } });
  var e2 = [];
  Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
    return ot(e2, this.objId, this.scope);
  }, set: function(t4) {
    var n2, r2;
    r2 = [], "string" == typeof (n2 = t4) && (r2 = (function(t5, e3, n3) {
      n3 || (n3 = 1);
      for (var r3, i2 = []; r3 = e3.exec(t5); ) i2.push(r3[n3]);
      return i2;
    })(n2, /\((.*?)\)/g)), e2 = r2;
  } }), this.getOptions = function() {
    return e2;
  }, this.setOptions = function(t4) {
    e2 = t4, this.sort && e2.sort();
  }, this.addOption = function(t4) {
    t4 = (t4 = t4 || "").toString(), e2.push(t4), this.sort && e2.sort();
  }, this.removeOption = function(t4, n2) {
    for (n2 = n2 || false, t4 = (t4 = t4 || "").toString(); -1 !== e2.indexOf(t4) && (e2.splice(e2.indexOf(t4), 1), false !== n2); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 18));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 18) : this.Ff = $$1(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 19));
  }, set: function(t4) {
    true === this.combo && (true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 19) : this.Ff = $$1(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 20));
  }, set: function(t4) {
    true === Boolean(t4) ? (this.Ff = Z$1(this.Ff, 20), e2.sort()) : this.Ff = $$1(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 22));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 22) : this.Ff = $$1(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 23) : this.Ff = $$1(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 27));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 27) : this.Ff = $$1(this.Ff, 27);
  } }), this.hasAppearanceStream = false;
};
W(ft, ht);
var dt = function() {
  ft.call(this), this.fontName = "helvetica", this.combo = false;
};
W(dt, ft);
var pt = function() {
  dt.call(this), this.combo = true;
};
W(pt, dt);
var gt = function() {
  pt.call(this), this.edit = true;
};
W(gt, pt);
var mt = function() {
  ht.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 15));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 15) : this.Ff = $$1(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 16));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 16) : this.Ff = $$1(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 17));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 17) : this.Ff = $$1(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 26));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 26) : this.Ff = $$1(this.Ff, 26);
  } });
  var e2, n2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    if (this.scope && (t3 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(n2).length) {
      var e3, r2 = [];
      for (e3 in r2.push("<<"), n2) r2.push("/" + e3 + " (" + T$2(t3(n2[e3])) + ")");
      return r2.push(">>"), r2.join("\n");
    }
  }, set: function(e3) {
    "object" === _typeof$1(e3) && (n2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return n2.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (n2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return e2.substr(1, e2.length - 1);
  }, set: function(t3) {
    e2 = "/" + t3;
  } });
};
W(mt, ht);
var vt = function() {
  mt.call(this), this.pushButton = true;
};
W(vt, mt);
var bt = function() {
  mt.call(this), this.radio = true, this.pushButton = false;
  var t3 = [];
  Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = void 0 !== e2 ? e2 : [];
  } });
};
W(bt, mt);
var yt = function() {
  var e2, n2;
  ht.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
    return e2;
  }, set: function(t3) {
    e2 = t3;
  } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
    return n2;
  }, set: function(t3) {
    n2 = t3;
  } });
  var r2, i2 = {};
  Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
    var t3 = function(t4) {
      return t4;
    };
    this.scope && (t3 = this.scope.internal.getEncryptor(this.objId));
    var e3, n3 = [];
    for (e3 in n3.push("<<"), i2) n3.push("/" + e3 + " (" + T$2(t3(i2[e3])) + ")");
    return n3.push(">>"), n3.join("\n");
  }, set: function(e3) {
    "object" === _typeof$1(e3) && (i2 = e3);
  } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
    return i2.CA || "";
  }, set: function(t3) {
    "string" == typeof t3 && (i2.CA = t3);
  } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
    return r2;
  }, set: function(t3) {
    r2 = t3;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
    return r2.substr(1, r2.length - 1);
  }, set: function(t3) {
    r2 = "/" + t3;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = xt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
W(yt, ht), bt.prototype.setAppearance = function(t3) {
  if (!("createAppearanceStream" in t3) || !("getCA" in t3)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e2 in this.Kids) if (this.Kids.hasOwnProperty(e2)) {
    var n2 = this.Kids[e2];
    n2.appearanceStreamContent = t3.createAppearanceStream(n2.optionName), n2.caption = t3.getCA();
  }
}, bt.prototype.createOption = function(t3) {
  var e2 = new yt();
  return e2.Parent = this, e2.optionName = t3, this.Kids.push(e2), At.call(this.scope, e2), e2;
};
var wt = function() {
  mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = xt.CheckBox.createAppearanceStream();
};
W(wt, mt);
var Nt = function() {
  ht.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 13));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 13) : this.Ff = $$1(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 21));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 21) : this.Ff = $$1(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 23));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 23) : this.Ff = $$1(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 24));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 24) : this.Ff = $$1(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 25));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 25) : this.Ff = $$1(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 26));
  }, set: function(t4) {
    true === Boolean(t4) ? this.Ff = Z$1(this.Ff, 26) : this.Ff = $$1(this.Ff, 26);
  } });
  var t3 = null;
  Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
    return t3;
  }, set: function(e2) {
    t3 = e2;
  } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
    return t3;
  }, set: function(e2) {
    Number.isInteger(e2) && (t3 = e2);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
    return this.V || this.DV;
  } });
};
W(Nt, ht);
var Lt = function() {
  Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
    return Boolean(K(this.Ff, 14));
  }, set: function(t3) {
    true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 14) : this.Ff = $$1(this.Ff, 14);
  } }), this.password = true;
};
W(Lt, Nt);
var xt = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: xt.CheckBox.YesNormal }, D: { On: xt.CheckBox.YesPushDown, Off: xt.CheckBox.OffPushDown } };
}, YesPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [], r2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, i2 = t3.scope.__private__.encodeColorString(t3.color), a2 = et(t3, t3.caption);
  return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t3)) + " " + U$1(xt.internal.getHeight(t3)) + " re"), n2.push("f"), n2.push("BMC"), n2.push("q"), n2.push("0 0 1 rg"), n2.push("/" + r2 + " " + U$1(a2.fontSize) + " Tf " + i2), n2.push("BT"), n2.push(a2.text), n2.push("ET"), n2.push("Q"), n2.push("EMC"), e2.stream = n2.join("\n"), e2;
}, YesNormal: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, r2 = t3.scope.__private__.encodeColorString(t3.color), i2 = [], a2 = xt.internal.getHeight(t3), o2 = xt.internal.getWidth(t3), s2 = et(t3, t3.caption);
  return i2.push("1 g"), i2.push("0 0 " + U$1(o2) + " " + U$1(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U$1(o2 - 1) + " " + U$1(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + n2 + " " + U$1(s2.fontSize) + " Tf " + r2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t3)) + " " + U$1(xt.internal.getHeight(t3)) + " re"), n2.push("f"), e2.stream = n2.join("\n"), e2;
} }, RadioButton: { Circle: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: xt.RadioButton.Circle.OffPushDown }, N: {} };
  return e2.N[t3] = xt.RadioButton.Circle.YesNormal, e2.D[t3] = xt.RadioButton.Circle.YesPushDown, e2;
}, getCA: function() {
  return "l";
}, YesNormal: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [], r2 = xt.internal.getWidth(t3) <= xt.internal.getHeight(t3) ? xt.internal.getWidth(t3) / 4 : xt.internal.getHeight(t3) / 4;
  r2 = Number((0.9 * r2).toFixed(5));
  var i2 = xt.internal.Bezier_C, a2 = Number((r2 * i2).toFixed(5));
  return n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t3) / 2) + " " + H(xt.internal.getHeight(t3) / 2) + " cm"), n2.push(r2 + " 0 m"), n2.push(r2 + " " + a2 + " " + a2 + " " + r2 + " 0 " + r2 + " c"), n2.push("-" + a2 + " " + r2 + " -" + r2 + " " + a2 + " -" + r2 + " 0 c"), n2.push("-" + r2 + " -" + a2 + " -" + a2 + " -" + r2 + " 0 -" + r2 + " c"), n2.push(a2 + " -" + r2 + " " + r2 + " -" + a2 + " " + r2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [], r2 = xt.internal.getWidth(t3) <= xt.internal.getHeight(t3) ? xt.internal.getWidth(t3) / 4 : xt.internal.getHeight(t3) / 4;
  r2 = Number((0.9 * r2).toFixed(5));
  var i2 = Number((2 * r2).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5)), o2 = Number((r2 * xt.internal.Bezier_C).toFixed(5));
  return n2.push("0.749023 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t3) / 2) + " " + H(xt.internal.getHeight(t3) / 2) + " cm"), n2.push(i2 + " 0 m"), n2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n2.push("f"), n2.push("Q"), n2.push("0 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t3) / 2) + " " + H(xt.internal.getHeight(t3) / 2) + " cm"), n2.push(r2 + " 0 m"), n2.push(r2 + " " + o2 + " " + o2 + " " + r2 + " 0 " + r2 + " c"), n2.push("-" + o2 + " " + r2 + " -" + r2 + " " + o2 + " -" + r2 + " 0 c"), n2.push("-" + r2 + " -" + o2 + " -" + o2 + " -" + r2 + " 0 -" + r2 + " c"), n2.push(o2 + " -" + r2 + " " + r2 + " -" + o2 + " " + r2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [], r2 = xt.internal.getWidth(t3) <= xt.internal.getHeight(t3) ? xt.internal.getWidth(t3) / 4 : xt.internal.getHeight(t3) / 4;
  r2 = Number((0.9 * r2).toFixed(5));
  var i2 = Number((2 * r2).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5));
  return n2.push("0.749023 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t3) / 2) + " " + H(xt.internal.getHeight(t3) / 2) + " cm"), n2.push(i2 + " 0 m"), n2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
} }, Cross: { createAppearanceStream: function(t3) {
  var e2 = { D: { Off: xt.RadioButton.Cross.OffPushDown }, N: {} };
  return e2.N[t3] = xt.RadioButton.Cross.YesNormal, e2.D[t3] = xt.RadioButton.Cross.YesPushDown, e2;
}, getCA: function() {
  return "8";
}, YesNormal: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [], r2 = xt.internal.calculateCross(t3);
  return n2.push("q"), n2.push("1 1 " + U$1(xt.internal.getWidth(t3) - 2) + " " + U$1(xt.internal.getHeight(t3) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U$1(r2.x1.x) + " " + U$1(r2.x1.y) + " m"), n2.push(U$1(r2.x2.x) + " " + U$1(r2.x2.y) + " l"), n2.push(U$1(r2.x4.x) + " " + U$1(r2.x4.y) + " m"), n2.push(U$1(r2.x3.x) + " " + U$1(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
}, YesPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = xt.internal.calculateCross(t3), r2 = [];
  return r2.push("0.749023 g"), r2.push("0 0 " + U$1(xt.internal.getWidth(t3)) + " " + U$1(xt.internal.getHeight(t3)) + " re"), r2.push("f"), r2.push("q"), r2.push("1 1 " + U$1(xt.internal.getWidth(t3) - 2) + " " + U$1(xt.internal.getHeight(t3) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U$1(n2.x1.x) + " " + U$1(n2.x1.y) + " m"), r2.push(U$1(n2.x2.x) + " " + U$1(n2.x2.y) + " l"), r2.push(U$1(n2.x4.x) + " " + U$1(n2.x4.y) + " m"), r2.push(U$1(n2.x3.x) + " " + U$1(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
}, OffPushDown: function(t3) {
  var e2 = G(t3);
  e2.scope = t3.scope;
  var n2 = [];
  return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t3)) + " " + U$1(xt.internal.getHeight(t3)) + " re"), n2.push("f"), e2.stream = n2.join("\n"), e2;
} } }, createDefaultAppearanceStream: function(t3) {
  var e2 = t3.scope.internal.getFont(t3.fontName, t3.fontStyle).id, n2 = t3.scope.__private__.encodeColorString(t3.color);
  return "/" + e2 + " " + t3.fontSize + " Tf " + n2;
} };
xt.internal = { Bezier_C: 0.551915024494, calculateCross: function(t3) {
  var e2 = xt.internal.getWidth(t3), n2 = xt.internal.getHeight(t3), r2 = Math.min(e2, n2);
  return { x1: { x: (e2 - r2) / 2, y: (n2 - r2) / 2 + r2 }, x2: { x: (e2 - r2) / 2 + r2, y: (n2 - r2) / 2 }, x3: { x: (e2 - r2) / 2, y: (n2 - r2) / 2 }, x4: { x: (e2 - r2) / 2 + r2, y: (n2 - r2) / 2 + r2 } };
} }, xt.internal.getWidth = function(e2) {
  var n2 = 0;
  return "object" === _typeof$1(e2) && (n2 = V$1(e2.Rect[2])), n2;
}, xt.internal.getHeight = function(e2) {
  var n2 = 0;
  return "object" === _typeof$1(e2) && (n2 = V$1(e2.Rect[3])), n2;
};
var At = R.addField = function(t3) {
  if (at(this, t3), !(t3 instanceof ht)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e2;
  return (e2 = t3).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t3.page = t3.scope.internal.getCurrentPageInfo().pageNumber, this;
};
R.AcroFormChoiceField = ft, R.AcroFormListBox = dt, R.AcroFormComboBox = pt, R.AcroFormEditBox = gt, R.AcroFormButton = mt, R.AcroFormPushButton = vt, R.AcroFormRadioButton = bt, R.AcroFormCheckBox = wt, R.AcroFormTextField = Nt, R.AcroFormPasswordField = Lt, R.AcroFormAppearance = xt, R.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: xt }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: xt };
E$1.AcroForm;
function _t(t3) {
  return t3.reduce(function(t4, e2, n2) {
    return t4[e2] = n2, t4;
  }, {});
}
!(function(e2) {
  var n2 = "addImage_";
  e2.__addimage__ = {};
  var r2 = "UNKNOWN", i2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, a2 = e2.__addimage__.getImageFileTypeByImageData = function(t3, e3) {
    var n3, a3, o3, s3, u3, c3 = r2;
    if ("RGBA" === (e3 = e3 || r2) || void 0 !== t3.data && t3.data instanceof Uint8ClampedArray && "height" in t3 && "width" in t3) return "RGBA";
    if (A2(t3)) for (u3 in i2) for (o3 = i2[u3], n3 = 0; n3 < o3.length; n3 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[n3].length; a3 += 1) if (void 0 !== o3[n3][a3] && o3[n3][a3] !== t3[a3]) {
        s3 = false;
        break;
      }
      if (true === s3) {
        c3 = u3;
        break;
      }
    }
    else for (u3 in i2) for (o3 = i2[u3], n3 = 0; n3 < o3.length; n3 += 1) {
      for (s3 = true, a3 = 0; a3 < o3[n3].length; a3 += 1) if (void 0 !== o3[n3][a3] && o3[n3][a3] !== t3.charCodeAt(a3)) {
        s3 = false;
        break;
      }
      if (true === s3) {
        c3 = u3;
        break;
      }
    }
    return c3 === r2 && e3 !== r2 && (c3 = e3), c3;
  }, o2 = function t3(e3) {
    for (var n3 = this.internal.write, r3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); ) i3.splice(i3.indexOf("FlateEncode"), 1);
    e3.objectId = this.internal.newObject();
    var a3 = [];
    if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === y2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === y2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency) && e3.transparency.length > 0) {
      for (var o3 = "", s3 = 0, u3 = e3.transparency.length; s3 < u3; s3++) o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
      a3.push({ key: "Mask", value: "[" + o3 + "]" });
    }
    void 0 !== e3.sMask && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
    var c3 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
    if (r3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: c3, objectId: e3.objectId }), n3("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
      var l3, h3 = null !== (l3 = e3.sMaskBitsPerComponent) && void 0 !== l3 ? l3 : e3.bitsPerComponent, f2 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: h3, data: e3.sMask };
      "filter" in e3 && (f2.decodeParameters = "/Predictor ".concat(e3.predictor, " /Colors 1 /BitsPerComponent ").concat(h3, " /Columns ").concat(e3.width), f2.filter = e3.filter), t3.call(this, f2);
    }
    if (e3.colorSpace === y2.INDEXED) {
      var d3 = this.internal.newObject();
      r3({ data: _2(new Uint8Array(e3.palette)), objectId: d3 }), n3("endobj");
    }
  }, s2 = function() {
    var t3 = this.internal.collections[n2 + "images"];
    for (var e3 in t3) o2.call(this, t3[e3]);
  }, u2 = function() {
    var t3, e3 = this.internal.collections[n2 + "images"], r3 = this.internal.write;
    for (var i3 in e3) r3("/I" + (t3 = e3[i3]).index, t3.objectId, "0", "R");
  }, c2 = function() {
    this.internal.collections[n2 + "images"] || (this.internal.collections[n2 + "images"] = {}, this.internal.events.subscribe("putResources", s2), this.internal.events.subscribe("putXobjectDict", u2));
  }, l2 = function() {
    var t3 = this.internal.collections[n2 + "images"];
    return c2.call(this), t3;
  }, h2 = function() {
    return Object.keys(this.internal.collections[n2 + "images"]).length;
  }, d2 = function(t3) {
    return "function" == typeof e2["process" + t3.toUpperCase()];
  }, p2 = function(e3) {
    return "object" === _typeof$1(e3) && 1 === e3.nodeType;
  }, g2 = function(t3, n3) {
    if ("IMG" === t3.nodeName && t3.hasAttribute("src")) {
      var r3 = "" + t3.getAttribute("src");
      if (0 === r3.indexOf("data:image/")) return f$2(unescape(r3).split("base64,").pop());
      var i3 = e2.loadFile(r3, true);
      if (void 0 !== i3) return i3;
    }
    if ("CANVAS" === t3.nodeName) {
      if (0 === t3.width || 0 === t3.height) throw new Error("Given canvas must have data. Canvas width: " + t3.width + ", height: " + t3.height);
      var a3;
      switch (n3) {
        case "PNG":
          a3 = "image/png";
          break;
        case "WEBP":
          a3 = "image/webp";
          break;
        default:
          a3 = "image/jpeg";
      }
      return f$2(t3.toDataURL(a3, 1).split("base64,").pop());
    }
  }, m2 = function(t3) {
    var e3 = this.internal.collections[n2 + "images"];
    if (e3) {
      for (var r3 in e3) if (t3 === e3[r3].alias) return e3[r3];
    }
  }, v2 = function(t3, e3, n3) {
    return t3 || e3 || (t3 = -96, e3 = -96), t3 < 0 && (t3 = -1 * n3.width * 72 / t3 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * n3.height * 72 / e3 / this.internal.scaleFactor), 0 === t3 && (t3 = e3 * n3.width / n3.height), 0 === e3 && (e3 = t3 * n3.height / n3.width), [t3, e3];
  }, b2 = function(t3, e3, n3, r3, i3, a3) {
    var o3 = v2.call(this, n3, r3, i3), s3 = this.internal.getCoordinateString, u3 = this.internal.getVerticalCoordinateString, c3 = l2.call(this);
    if (n3 = o3[0], r3 = o3[1], c3[i3.index] = i3, a3) {
      a3 *= Math.PI / 180;
      var h3 = Math.cos(a3), f2 = Math.sin(a3), d3 = function(t4) {
        return t4.toFixed(4);
      }, p3 = [d3(h3), d3(f2), d3(-1 * f2), d3(h3), 0, 0, "cm"];
    }
    this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t3), u3(e3 + r3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(n3), "0", "0", s3(r3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(n3), "0", "0", s3(r3), s3(t3), u3(e3 + r3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
  }, y2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var w2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, N2 = e2.__addimage__.sHashCode = function(t3) {
    var e3, n3, r3 = 0;
    if ("string" == typeof t3) for (n3 = t3.length, e3 = 0; e3 < n3; e3++) r3 = (r3 << 5) - r3 + t3.charCodeAt(e3), r3 |= 0;
    else if (A2(t3)) for (n3 = t3.byteLength / 2, e3 = 0; e3 < n3; e3++) r3 = (r3 << 5) - r3 + t3[e3], r3 |= 0;
    return r3;
  }, L2 = e2.__addimage__.validateStringAsBase64 = function(t3) {
    (t3 = t3 || "").toString().trim();
    var e3 = true;
    return 0 === t3.length && (e3 = false), t3.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t3.substr(0, t3.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t3.substr(-2)) && (e3 = false), e3;
  }, x2 = e2.__addimage__.extractImageFromDataUrl = function(t3) {
    if (null == t3) return null;
    if (!(t3 = t3.trim()).startsWith("data:")) return null;
    var e3 = t3.indexOf(",");
    return e3 < 0 ? null : t3.substring(0, e3).trim().endsWith("base64") ? t3.substring(e3 + 1) : null;
  };
  e2.__addimage__.isArrayBuffer = function(t3) {
    return t3 instanceof ArrayBuffer;
  };
  var A2 = e2.__addimage__.isArrayBufferView = function(t3) {
    return t3 instanceof Int8Array || t3 instanceof Uint8Array || t3 instanceof Uint8ClampedArray || t3 instanceof Int16Array || t3 instanceof Uint16Array || t3 instanceof Int32Array || t3 instanceof Uint32Array || t3 instanceof Float32Array || t3 instanceof Float64Array;
  }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t3) {
    for (var e3 = t3.length, n3 = new Uint8Array(e3), r3 = 0; r3 < e3; r3++) n3[r3] = t3.charCodeAt(r3);
    return n3;
  }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t3) {
    for (var e3 = "", n3 = A2(t3) ? t3 : new Uint8Array(t3), r3 = 0; r3 < n3.length; r3 += 8192) e3 += String.fromCharCode.apply(null, n3.subarray(r3, r3 + 8192));
    return e3;
  };
  e2.addImage = function() {
    var e3, n3, i3, a3, o3, s3, u3, l3, h3;
    if ("number" == typeof arguments[1] ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u3 = arguments[5], l3 = arguments[6], h3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u3 = arguments[6], l3 = arguments[7], h3 = arguments[8]), "object" === _typeof$1(e3 = arguments[0]) && !p2(e3) && "imageData" in e3) {
      var f2 = e3;
      e3 = f2.imageData, n3 = f2.format || n3 || r2, i3 = f2.x || i3 || 0, a3 = f2.y || a3 || 0, o3 = f2.w || f2.width || o3, s3 = f2.h || f2.height || s3, u3 = f2.alias || u3, l3 = f2.compression || l3, h3 = f2.rotation || f2.angle || h3;
    }
    var d3 = this.internal.getFilters();
    if (void 0 === l3 && -1 !== d3.indexOf("FlateEncode") && (l3 = "SLOW"), isNaN(i3) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    c2.call(this);
    var g3 = P2.call(this, e3, n3, u3, l3);
    return b2.call(this, i3, a3, o3, s3, g3, h3), this;
  };
  var P2 = function(t3, n3, i3, o3) {
    var s3, u3, c3;
    if ("string" == typeof t3 && a2(t3) === r2) {
      t3 = unescape(t3);
      var l3 = k2(t3, false);
      ("" !== l3 || void 0 !== (l3 = e2.loadFile(t3, true))) && (t3 = l3);
    }
    if (p2(t3) && (t3 = g2(t3, n3)), n3 = a2(t3, n3), !d2(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
    if ((null == (c3 = i3) || 0 === c3.length) && (i3 = (function(t4) {
      return "string" == typeof t4 || A2(t4) ? N2(t4) : A2(t4.data) ? N2(t4.data) : null;
    })(t3)), (s3 = m2.call(this, i3)) || (t3 instanceof Uint8Array || "RGBA" === n3 || (u3 = t3, t3 = S2(t3)), s3 = this["process" + n3.toUpperCase()](t3, h2.call(this), i3, (function(t4) {
      return t4 && "string" == typeof t4 && (t4 = t4.toUpperCase()), t4 in e2.image_compression ? t4 : w2.NONE;
    })(o3), u3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
    return s3;
  }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t3, e3) {
    e3 = "boolean" != typeof e3 || e3;
    var n3, r3 = "";
    if ("string" == typeof t3) {
      var i3;
      n3 = null !== (i3 = x2(t3)) && void 0 !== i3 ? i3 : t3;
      try {
        r3 = f$2(n3);
      } catch (a3) {
        if (e3) throw L2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + a3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return r3;
  };
  e2.getImageProperties = function(t3) {
    var n3, i3, o3 = "";
    if (p2(t3) && (t3 = g2(t3)), "string" == typeof t3 && a2(t3) === r2 && ("" === (o3 = k2(t3, false)) && (o3 = e2.loadFile(t3) || ""), t3 = o3), i3 = a2(t3), !d2(i3)) throw new Error("addImage does not support files of type '" + i3 + "', please ensure that a plugin for '" + i3 + "' support is added.");
    if (t3 instanceof Uint8Array || (t3 = S2(t3)), !(n3 = this["process" + i3.toUpperCase()](t3))) throw new Error("An unknown error occurred whilst processing the image");
    return n3.fileType = i3, n3;
  };
})(E$1.API), /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = function(t4) {
    if (void 0 !== t4 && "" != t4) return true;
  };
  E$1.API.events.push(["addPage", function(t4) {
    this.internal.getPageInfo(t4.pageNumber).pageContext.annotations = [];
  }]), t3.events.push(["putPage", function(t4) {
    for (var n2, r2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t4.objId), u2 = t4.pageContext.annotations, c2 = false, l2 = 0; l2 < u2.length && !c2; l2++) switch ((n2 = u2[l2]).type) {
      case "link":
        (e2(n2.options.url) || e2(n2.options.pageNumber)) && (c2 = true);
        break;
      case "reference":
      case "text":
      case "freetext":
        c2 = true;
    }
    if (0 != c2) {
      this.internal.write("/Annots [");
      for (var h2 = 0; h2 < u2.length; h2++) {
        n2 = u2[h2];
        var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t4.objId);
        switch (n2.type) {
          case "reference":
            this.internal.write(" " + n2.object.objId + " 0 R ");
            break;
          case "text":
            var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = n2.title || "Note";
            i2 = "<</Type /Annot /Subtype /Text " + (r2 = "/Rect [" + a2(n2.bounds.x) + " " + o2(n2.bounds.y + n2.bounds.h) + " " + a2(n2.bounds.x + n2.bounds.w) + " " + o2(n2.bounds.y) + "] ") + "/Contents (" + f2(m2(n2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
            var b2 = p2.objId + " 0 R";
            i2 = "<</Type /Annot /Subtype /Popup " + (r2 = "/Rect [" + a2(n2.bounds.x + 30) + " " + o2(n2.bounds.y + n2.bounds.h) + " " + a2(n2.bounds.x + n2.bounds.w + 30) + " " + o2(n2.bounds.y) + "] ") + " /Parent " + b2, n2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
            break;
          case "freetext":
            r2 = "/Rect [" + a2(n2.bounds.x) + " " + o2(n2.bounds.y) + " " + a2(n2.bounds.x + n2.bounds.w) + " " + o2(n2.bounds.y + n2.bounds.h) + "] ";
            var y2 = n2.color || "#000000";
            i2 = "<</Type /Annot /Subtype /FreeText " + r2 + "/Contents (" + f2(d2(n2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
            break;
          case "link":
            if (n2.options.name) {
              var w2 = this.annotations._nameMap[n2.options.name];
              n2.options.pageNumber = w2.page, n2.options.top = w2.y;
            } else n2.options.top || (n2.options.top = 0);
            if (r2 = "/Rect [" + n2.finalBounds.x + " " + n2.finalBounds.y + " " + n2.finalBounds.w + " " + n2.finalBounds.h + "] ", i2 = "", n2.options.url) i2 = "<</Type /Annot /Subtype /Link " + r2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(n2.options.url)) + ") >>";
            else if (n2.options.pageNumber) switch (i2 = "<</Type /Annot /Subtype /Link " + r2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n2.options.pageNumber).objId + " 0 R", n2.options.magFactor = n2.options.magFactor || "XYZ", n2.options.magFactor) {
              case "Fit":
                i2 += " /Fit]";
                break;
              case "FitH":
                i2 += " /FitH " + n2.options.top + "]";
                break;
              case "FitV":
                n2.options.left = n2.options.left || 0, i2 += " /FitV " + n2.options.left + "]";
                break;
              default:
                var N2 = o2(n2.options.top);
                n2.options.left = n2.options.left || 0, void 0 === n2.options.zoom && (n2.options.zoom = 0), i2 += " /XYZ " + n2.options.left + " " + N2 + " " + n2.options.zoom + "]";
            }
            "" != i2 && (i2 += " >>", this.internal.write(i2));
        }
      }
      this.internal.write("]");
    }
  }]), t3.createAnnotation = function(t4) {
    var e3 = this.internal.getCurrentPageInfo();
    switch (t4.type) {
      case "link":
        this.link(t4.bounds.x, t4.bounds.y, t4.bounds.w, t4.bounds.h, t4);
        break;
      case "text":
      case "freetext":
        e3.pageContext.annotations.push(t4);
    }
  }, t3.link = function(t4, e3, n2, r2, i2) {
    var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
    a2.pageContext.annotations.push({ finalBounds: { x: o2(t4), y: s2(e3), w: o2(t4 + n2), h: s2(e3 + r2) }, options: i2, type: "link" });
  }, t3.textWithLink = function(t4, e3, n2, r2) {
    var i2, a2, o2 = this.getTextWidth(t4), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (void 0 !== r2.maxWidth) {
      a2 = r2.maxWidth;
      var u2 = this.splitTextToSize(t4, a2).length;
      i2 = Math.ceil(s2 * u2);
    } else a2 = o2, i2 = s2;
    return this.text(t4, e3, n2, r2), n2 += 0.2 * s2, "center" === r2.align && (e3 -= o2 / 2), "right" === r2.align && (e3 -= o2), this.link(e3, n2 - s2, a2, i2, r2), o2;
  }, t3.getTextWidth = function(t4) {
    var e3 = this.internal.getFontSize();
    return this.getStringUnitWidth(t4) * e3 / this.internal.scaleFactor;
  };
})(E$1.API), /**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, n2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
  t3.__arabicParser__ = {};
  var a2 = t3.__arabicParser__.isInArabicSubstitutionA = function(t4) {
    return void 0 !== e2[t4.charCodeAt(0)];
  }, o2 = t3.__arabicParser__.isArabicLetter = function(t4) {
    return "string" == typeof t4 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t4);
  }, s2 = t3.__arabicParser__.isArabicEndLetter = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length <= 2;
  }, u2 = t3.__arabicParser__.isArabicAlfLetter = function(t4) {
    return o2(t4) && i2.indexOf(t4.charCodeAt(0)) >= 0;
  };
  t3.__arabicParser__.arabicLetterHasIsolatedForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 1;
  };
  var c2 = t3.__arabicParser__.arabicLetterHasFinalForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 2;
  };
  t3.__arabicParser__.arabicLetterHasInitialForm = function(t4) {
    return o2(t4) && a2(t4) && e2[t4.charCodeAt(0)].length >= 3;
  };
  var l2 = t3.__arabicParser__.arabicLetterHasMedialForm = function(t4) {
    return o2(t4) && a2(t4) && 4 == e2[t4.charCodeAt(0)].length;
  }, h2 = t3.__arabicParser__.resolveLigatures = function(t4) {
    var e3 = 0, r3 = n2, i3 = "", a3 = 0;
    for (e3 = 0; e3 < t4.length; e3 += 1) void 0 !== r3[t4.charCodeAt(e3)] ? (a3++, "number" == typeof (r3 = r3[t4.charCodeAt(e3)]) && (i3 += String.fromCharCode(r3), r3 = n2, a3 = 0), e3 === t4.length - 1 && (r3 = n2, i3 += t4.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (r3 = n2, i3 += t4.charAt(e3 - a3), e3 -= a3, a3 = 0);
    return i3;
  };
  t3.__arabicParser__.isArabicDiacritic = function(t4) {
    return void 0 !== t4 && void 0 !== r2[t4.charCodeAt(0)];
  };
  var f2 = t3.__arabicParser__.getCorrectForm = function(t4, e3, n3) {
    return o2(t4) ? false === a2(t4) ? -1 : !c2(t4) || !o2(e3) && !o2(n3) || !o2(n3) && s2(e3) || s2(t4) && !o2(e3) || s2(t4) && u2(e3) || s2(t4) && s2(e3) ? 0 : l2(t4) && o2(e3) && !s2(e3) && o2(n3) && c2(n3) ? 3 : s2(t4) || !o2(n3) ? 1 : 2 : -1;
  }, d2 = function(t4) {
    var n3 = 0, r3 = 0, i3 = 0, a3 = "", s3 = "", u3 = "", c3 = (t4 = t4 || "").split("\\s+"), l3 = [];
    for (n3 = 0; n3 < c3.length; n3 += 1) {
      for (l3.push(""), r3 = 0; r3 < c3[n3].length; r3 += 1) a3 = c3[n3][r3], s3 = c3[n3][r3 - 1], u3 = c3[n3][r3 + 1], o2(a3) ? (i3 = f2(a3, s3, u3), l3[n3] += -1 !== i3 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : l3[n3] += a3;
      l3[n3] = h2(l3[n3]);
    }
    return l3.join(" ");
  }, p2 = t3.__arabicParser__.processArabic = t3.processArabic = function() {
    var t4, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, n3 = [];
    if (Array.isArray(e3)) {
      var r3 = 0;
      for (n3 = [], r3 = 0; r3 < e3.length; r3 += 1) Array.isArray(e3[r3]) ? n3.push([d2(e3[r3][0]), e3[r3][1], e3[r3][2]]) : n3.push([d2(e3[r3])]);
      t4 = n3;
    } else t4 = d2(e3);
    return "string" == typeof arguments[0] ? t4 : (arguments[0].text = t4, arguments[0]);
  };
  t3.events.push(["preProcessText", p2]);
})(E$1.API), E$1.API.autoPrint = function(t3) {
  var e2;
  return (t3 = t3 || {}).variant = t3.variant || "non-conform", "javascript" === t3.variant ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
    e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    this.internal.out("/OpenAction " + e2 + " 0 R");
  })), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = function() {
    var t4 = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t4;
    }, set: function(e4) {
      t4 = e4;
    } });
    var e3 = 150;
    Object.defineProperty(this, "width", { get: function() {
      return e3;
    }, set: function(t5) {
      e3 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 150 : t5, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
    } });
    var n2 = 300;
    Object.defineProperty(this, "height", { get: function() {
      return n2;
    }, set: function(t5) {
      n2 = isNaN(t5) || false === Number.isInteger(t5) || t5 < 0 ? 300 : t5, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = n2 + 1);
    } });
    var r2 = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return r2;
    }, set: function(t5) {
      r2 = t5;
    } });
    var i2 = {};
    Object.defineProperty(this, "style", { get: function() {
      return i2;
    }, set: function(t5) {
      i2 = t5;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e2.prototype.getContext = function(t4, e3) {
    var n2;
    if ("2d" !== (t4 = t4 || "2d")) return null;
    for (n2 in e3) this.pdf.context2d.hasOwnProperty(n2) && (this.pdf.context2d[n2] = e3[n2]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e2.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, t3.events.push(["initialized", function() {
    this.canvas = new e2(), this.canvas.pdf = this;
  }]);
})(E$1.API), (function(e2) {
  var n2 = { left: 0, top: 0, bottom: 0, right: 0 }, r2 = false, i2 = function() {
    void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, n2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
  }, a2 = function() {
    this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
  }, o2 = function() {
    var t3 = arguments[0];
    Object.defineProperty(this, "x", { enumerable: true, get: function() {
      return t3;
    }, set: function(e4) {
      t3 = e4;
    } });
    var e3 = arguments[1];
    Object.defineProperty(this, "y", { enumerable: true, get: function() {
      return e3;
    }, set: function(t4) {
      e3 = t4;
    } });
    var n3 = arguments[2];
    Object.defineProperty(this, "width", { enumerable: true, get: function() {
      return n3;
    }, set: function(t4) {
      n3 = t4;
    } });
    var r3 = arguments[3];
    Object.defineProperty(this, "height", { enumerable: true, get: function() {
      return r3;
    }, set: function(t4) {
      r3 = t4;
    } });
    var i3 = arguments[4];
    Object.defineProperty(this, "text", { enumerable: true, get: function() {
      return i3;
    }, set: function(t4) {
      i3 = t4;
    } });
    var a3 = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
      return a3;
    }, set: function(t4) {
      a3 = t4;
    } });
    var o3 = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: true, get: function() {
      return o3;
    }, set: function(t4) {
      o3 = t4;
    } }), this;
  };
  o2.prototype.clone = function() {
    return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, o2.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, e2.setHeaderFunction = function(t3) {
    return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t3 ? t3 : void 0, this;
  }, e2.getTextDimensions = function(t3, e3) {
    i2.call(this);
    var n3 = (e3 = e3 || {}).fontSize || this.getFontSize(), r3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, u3 = 0, c2 = this;
    if (!Array.isArray(t3) && "string" != typeof t3) {
      if ("number" != typeof t3) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      t3 = String(t3);
    }
    var l2 = e3.maxWidth;
    l2 > 0 ? "string" == typeof t3 ? t3 = this.splitTextToSize(t3, l2) : "[object Array]" === Object.prototype.toString.call(t3) && (t3 = t3.reduce(function(t4, e4) {
      return t4.concat(c2.splitTextToSize(e4, l2));
    }, [])) : t3 = Array.isArray(t3) ? t3 : [t3];
    for (var h2 = 0; h2 < t3.length; h2++) o3 < (u3 = this.getStringUnitWidth(t3[h2], { font: r3 }) * n3) && (o3 = u3);
    return 0 !== o3 && (s3 = t3.length), { w: o3 /= a3, h: Math.max((s3 * n3 * this.getLineHeightFactor() - n3 * (this.getLineHeightFactor() - 1)) / a3, 0) };
  }, e2.cellAddPage = function() {
    i2.call(this), this.addPage();
    var t3 = this.internal.__cell__.margins || n2;
    return this.internal.__cell__.lastCell = new o2(t3.left, t3.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var s2 = e2.cell = function() {
    var t3;
    t3 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i2.call(this);
    var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || n2, u3 = this.internal.__cell__.tableHeaderRow, c2 = this.internal.__cell__.printHeaders;
    return void 0 !== e3.lineNumber && (e3.lineNumber === t3.lineNumber ? (t3.x = (e3.x || 0) + (e3.width || 0), t3.y = e3.y || 0) : e3.y + e3.height + t3.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t3.y = s3.top, c2 && u3 && (this.printHeaderRow(t3.lineNumber, true), t3.y += u3[0].height)) : t3.y = e3.y + e3.height || t3.y), void 0 !== t3.text[0] && (this.rect(t3.x, t3.y, t3.width, t3.height, true === r2 ? "FD" : void 0), "right" === t3.align ? this.text(t3.text, t3.x + t3.width - a3, t3.y + a3, { align: "right", baseline: "top" }) : "center" === t3.align ? this.text(t3.text, t3.x + t3.width / 2, t3.y + a3, { align: "center", baseline: "top", maxWidth: t3.width - a3 - a3 }) : this.text(t3.text, t3.x + a3, t3.y + a3, { align: "left", baseline: "top", maxWidth: t3.width - a3 - a3 })), this.internal.__cell__.lastCell = t3, this;
  };
  e2.table = function(e3, r3, c2, l2, h2) {
    if (i2.call(this), !c2) throw new Error("No data for PDF table.");
    var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], x2 = (h2 = h2 || {}).autoSize || false, A2 = false !== h2.printHeaders, S2 = h2.css && void 0 !== h2.css["font-size"] ? 16 * h2.css["font-size"] : h2.fontSize || 12, _2 = h2.margins || Object.assign({ width: this.getPageWidth() }, n2), P2 = "number" == typeof h2.padding ? h2.padding : 3, k2 = h2.headerBackgroundColor || "#c8c8c8", F2 = h2.headerTextColor || "#000";
    if (a2.call(this), this.internal.__cell__.printHeaders = A2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = F2, this.setFontSize(S2), null == l2) v2 = m2 = Object.keys(c2[0]), b2 = m2.map(function() {
      return "left";
    });
    else if (Array.isArray(l2) && "object" === _typeof$1(l2[0])) for (m2 = l2.map(function(t3) {
      return t3.name;
    }), v2 = l2.map(function(t3) {
      return t3.prompt || t3.name || "";
    }), b2 = l2.map(function(t3) {
      return t3.align || "left";
    }), f2 = 0; f2 < l2.length; f2 += 1) w2[l2[f2].name] = 0.7499990551181103 * l2[f2].width;
    else Array.isArray(l2) && "string" == typeof l2[0] && (v2 = m2 = l2, b2 = m2.map(function() {
      return "left";
    }));
    if (x2 || Array.isArray(l2) && "string" == typeof l2[0]) for (f2 = 0; f2 < m2.length; f2 += 1) {
      for (y2[g2 = m2[f2]] = c2.map(function(t3) {
        return t3[g2];
      }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1) N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
    }
    if (A2) {
      var I2 = {};
      for (f2 = 0; f2 < m2.length; f2 += 1) I2[m2[f2]] = {}, I2[m2[f2]].text = v2[f2], I2[m2[f2]].align = b2[f2];
      var j2 = u2.call(this, I2, w2);
      L2 = m2.map(function(t3) {
        return new o2(e3, r3, w2[t3], j2, I2[t3].text, void 0, I2[t3].align);
      }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
    }
    var C2 = l2.reduce(function(t3, e4) {
      return t3[e4.name] = e4.align, t3;
    }, {});
    for (f2 = 0; f2 < c2.length; f2 += 1) {
      "rowStart" in h2 && h2.rowStart instanceof Function && h2.rowStart({ row: f2, data: c2[f2] }, this);
      var O2 = u2.call(this, c2[f2], w2);
      for (p2 = 0; p2 < m2.length; p2 += 1) {
        var B3 = c2[f2][m2[p2]];
        "cellStart" in h2 && h2.cellStart instanceof Function && h2.cellStart({ row: f2, col: p2, data: B3 }, this), s2.call(this, new o2(e3, r3, w2[m2[p2]], O2, B3, f2 + 2, C2[m2[p2]]));
      }
    }
    return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = r3, this;
  };
  var u2 = function(t3, e3) {
    var n3 = this.internal.__cell__.padding, r3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
    return Object.keys(t3).map(function(r4) {
      var i4 = t3[r4];
      return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[r4] - n3 - n3);
    }, this).map(function(t4) {
      return this.getLineHeightFactor() * t4.length * r3 / i3 + n3 + n3;
    }, this).reduce(function(t4, e4) {
      return Math.max(t4, e4);
    }, 0);
  };
  e2.setTableHeaderRow = function(t3) {
    i2.call(this), this.internal.__cell__.tableHeaderRow = t3;
  }, e2.printHeaderRow = function(t3, e3) {
    if (i2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var n3;
    if (r2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
      var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var u3 = [], c2 = 0; c2 < this.internal.__cell__.tableHeaderRow.length; c2 += 1) {
      n3 = this.internal.__cell__.tableHeaderRow[c2].clone(), e3 && (n3.y = this.internal.__cell__.margins.top || 0, u3.push(n3)), n3.lineNumber = t3;
      var l2 = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, n3), this.setTextColor(l2);
    }
    u3.length > 0 && this.setTableHeaderRow(u3), this.setFont(void 0, "normal"), r2 = false;
  };
})(E$1.API);
var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Ft = _t(kt), It = [100, 200, 300, 400, 500, 600, 700, 800, 900], jt = _t(It);
function Ct(t3) {
  var e2 = t3.family.replace(/"|'/g, "").toLowerCase(), n2 = (function(t4) {
    return Pt[t4 = t4 || "normal"] ? t4 : "normal";
  })(t3.style), r2 = (function(t4) {
    return t4 ? "number" == typeof t4 ? t4 >= 100 && t4 <= 900 && t4 % 100 == 0 ? t4 : 400 : /^\d00$/.test(t4) ? parseInt(t4) : "bold" === t4 ? 700 : 400 : 400;
  })(t3.weight), i2 = (function(t4) {
    return "number" == typeof Ft[t4 = t4 || "normal"] ? t4 : "normal";
  })(t3.stretch);
  return { family: e2, style: n2, weight: r2, stretch: i2, src: t3.src || [], ref: t3.ref || { name: e2, style: [i2, n2, r2].join(" ") } };
}
function Ot(t3, e2, n2, r2) {
  var i2;
  for (i2 = n2; i2 >= 0 && i2 < e2.length; i2 += r2) if (t3[e2[i2]]) return t3[e2[i2]];
  for (i2 = n2; i2 >= 0 && i2 < e2.length; i2 -= r2) if (t3[e2[i2]]) return t3[e2[i2]];
}
var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function qt(t3) {
  return [t3.stretch, t3.style, t3.weight, t3.family].join(" ");
}
function Et(t3) {
  return t3.trimLeft();
}
function Rt(t3, e2) {
  for (var n2 = 0; n2 < t3.length; ) {
    if (t3.charAt(n2) === e2) return [t3.substring(0, n2), t3.substring(n2 + 1)];
    n2 += 1;
  }
  return null;
}
function Dt(t3) {
  var e2 = t3.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return null === e2 ? null : [e2[0], t3.substring(e2[0].length)];
}
var Tt, zt, Ut, Ht, Wt, Vt, Gt, Yt, Jt = ["times"];
function Xt(t3, n2, r2, i2, a2) {
  var o2 = 4, s2 = $t;
  switch (a2) {
    case E$1.API.image_compression.FAST:
      o2 = 1, s2 = Zt;
      break;
    case E$1.API.image_compression.MEDIUM:
      o2 = 6, s2 = Qt;
      break;
    case E$1.API.image_compression.SLOW:
      o2 = 9, s2 = te;
  }
  t3 = (function(t4, e2, n3, r3) {
    for (var i3, a3 = t4.length / e2, o3 = new Uint8Array(t4.length + a3), s3 = [Kt, Zt, $t, Qt, te], u3 = 0; u3 < a3; u3 += 1) {
      var c2 = u3 * e2, l2 = t4.subarray(c2, c2 + e2);
      if (r3) o3.set(r3(l2, n3, i3), c2 + u3);
      else {
        for (var h2 = s3.length, f2 = [], d2 = 0; d2 < h2; d2 += 1) f2[d2] = s3[d2](l2, n3, i3);
        var p2 = ne(f2.concat());
        o3.set(f2[p2], c2 + u3);
      }
      i3 = l2;
    }
    return o3;
  })(t3, n2, Math.ceil(r2 * i2 / 8), s2);
  var u2 = zlibSync(t3, { level: o2 });
  return E$1.API.__addimage__.arrayBufferToBinaryString(u2);
}
function Kt(t3) {
  var e2 = Array.apply([], t3);
  return e2.unshift(0), e2;
}
function Zt(t3, e2) {
  var n2 = t3.length, r2 = [];
  r2[0] = 1;
  for (var i2 = 0; i2 < n2; i2 += 1) {
    var a2 = t3[i2 - e2] || 0;
    r2[i2 + 1] = t3[i2] - a2 + 256 & 255;
  }
  return r2;
}
function $t(t3, e2, n2) {
  var r2 = t3.length, i2 = [];
  i2[0] = 2;
  for (var a2 = 0; a2 < r2; a2 += 1) {
    var o2 = n2 && n2[a2] || 0;
    i2[a2 + 1] = t3[a2] - o2 + 256 & 255;
  }
  return i2;
}
function Qt(t3, e2, n2) {
  var r2 = t3.length, i2 = [];
  i2[0] = 3;
  for (var a2 = 0; a2 < r2; a2 += 1) {
    var o2 = t3[a2 - e2] || 0, s2 = n2 && n2[a2] || 0;
    i2[a2 + 1] = t3[a2] + 256 - (o2 + s2 >>> 1) & 255;
  }
  return i2;
}
function te(t3, e2, n2) {
  var r2 = t3.length, i2 = [];
  i2[0] = 4;
  for (var a2 = 0; a2 < r2; a2 += 1) {
    var o2 = ee(t3[a2 - e2] || 0, n2 && n2[a2] || 0, n2 && n2[a2 - e2] || 0);
    i2[a2 + 1] = t3[a2] - o2 + 256 & 255;
  }
  return i2;
}
function ee(t3, e2, n2) {
  if (t3 === e2 && e2 === n2) return t3;
  var r2 = Math.abs(e2 - n2), i2 = Math.abs(t3 - n2), a2 = Math.abs(t3 + e2 - n2 - n2);
  return r2 <= i2 && r2 <= a2 ? t3 : i2 <= a2 ? e2 : n2;
}
function ne(t3) {
  var e2 = t3.map(function(t4) {
    return t4.reduce(function(t5, e3) {
      return t5 + Math.abs(e3);
    }, 0);
  });
  return e2.indexOf(Math.min.apply(null, e2));
}
function re(t3, e2, n2) {
  var r2 = e2 * n2, i2 = Math.floor(r2 / 8), a2 = 16 - (r2 - 8 * i2 + n2), o2 = (1 << n2) - 1;
  return ae(t3, i2) >> a2 & o2;
}
function ie(t3, e2, n2, r2) {
  var i2 = n2 * r2, a2 = Math.floor(i2 / 8), o2 = 16 - (i2 - 8 * a2 + r2), s2 = (1 << r2) - 1, u2 = (e2 & s2) << o2;
  !(function(t4, e3, n3) {
    if (e3 + 1 < t4.byteLength) t4.setUint16(e3, n3, false);
    else {
      var r3 = n3 >> 8 & 255;
      t4.setUint8(e3, r3);
    }
  })(t3, a2, ae(t3, a2) & ~(s2 << o2) & 65535 | u2);
}
function ae(t3, e2) {
  return e2 + 1 < t3.byteLength ? t3.getUint16(e2, false) : t3.getUint8(e2) << 8;
}
function oe(t3) {
  var e2 = 0;
  if (71 !== t3[e2++] || 73 !== t3[e2++] || 70 !== t3[e2++] || 56 !== t3[e2++] || 56 != (t3[e2++] + 1 & 253) || 97 !== t3[e2++]) throw new Error("Invalid GIF 87a/89a header.");
  var n2 = t3[e2++] | t3[e2++] << 8, r2 = t3[e2++] | t3[e2++] << 8, i2 = t3[e2++], a2 = i2 >> 7, o2 = 1 << 1 + (7 & i2);
  t3[e2++], t3[e2++];
  var s2 = null, u2 = null;
  a2 && (s2 = e2, u2 = o2, e2 += 3 * o2);
  var c2 = true, l2 = [], h2 = 0, f2 = null, d2 = 0, p2 = null;
  for (this.width = n2, this.height = r2; c2 && e2 < t3.length; ) switch (t3[e2++]) {
    case 33:
      switch (t3[e2++]) {
        case 255:
          if (11 !== t3[e2] || 78 == t3[e2 + 1] && 69 == t3[e2 + 2] && 84 == t3[e2 + 3] && 83 == t3[e2 + 4] && 67 == t3[e2 + 5] && 65 == t3[e2 + 6] && 80 == t3[e2 + 7] && 69 == t3[e2 + 8] && 50 == t3[e2 + 9] && 46 == t3[e2 + 10] && 48 == t3[e2 + 11] && 3 == t3[e2 + 12] && 1 == t3[e2 + 13] && 0 == t3[e2 + 16]) e2 += 14, p2 = t3[e2++] | t3[e2++] << 8, e2++;
          else for (e2 += 12; ; ) {
            if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e2 += P2;
          }
          break;
        case 249:
          if (4 !== t3[e2++] || 0 !== t3[e2 + 4]) throw new Error("Invalid graphics extension block.");
          var g2 = t3[e2++];
          h2 = t3[e2++] | t3[e2++] << 8, f2 = t3[e2++], 1 & g2 || (f2 = null), d2 = g2 >> 2 & 7, e2++;
          break;
        case 254:
          for (; ; ) {
            if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
            if (0 === P2) break;
            e2 += P2;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + t3[e2 - 1].toString(16));
      }
      break;
    case 44:
      var m2 = t3[e2++] | t3[e2++] << 8, v2 = t3[e2++] | t3[e2++] << 8, b2 = t3[e2++] | t3[e2++] << 8, y2 = t3[e2++] | t3[e2++] << 8, w2 = t3[e2++], N2 = w2 >> 6 & 1, L2 = 1 << 1 + (7 & w2), x2 = s2, A2 = u2, S2 = false;
      w2 >> 7 && (S2 = true, x2 = e2, A2 = L2, e2 += 3 * L2);
      var _2 = e2;
      for (e2++; ; ) {
        var P2;
        if (!((P2 = t3[e2++]) >= 0)) throw Error("Invalid block size");
        if (0 === P2) break;
        e2 += P2;
      }
      l2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: x2, palette_size: A2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: h2, disposal: d2 });
      break;
    case 59:
      c2 = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + t3[e2 - 1].toString(16));
  }
  this.numFrames = function() {
    return l2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(t4) {
    if (t4 < 0 || t4 >= l2.length) throw new Error("Frame index out of range.");
    return l2[t4];
  }, this.decodeAndBlitFrameBGRA = function(e3, r3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    se(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, u3 = i3.transparent_index;
    null === u3 && (u3 = 256);
    var c3 = i3.width, l3 = n2 - c3, h3 = c3, f3 = 4 * (i3.y * n2 + i3.x), d3 = 4 * ((i3.y + i3.height) * n2 + i3.x), p3 = f3, g3 = 4 * l3;
    true === i3.interlaced && (g3 += 4 * n2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === h3 && (h3 = c3, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * n2 * (m3 - 1), p3 = f3 + (c3 + l3) * (m3 << 1), m3 >>= 1)), y3 === u3) p3 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        r3[p3++] = L3, r3[p3++] = N3, r3[p3++] = w3, r3[p3++] = 255;
      }
      --h3;
    }
  }, this.decodeAndBlitFrameRGBA = function(e3, r3) {
    var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
    se(t3, i3.data_offset, o3, a3);
    var s3 = i3.palette_offset, u3 = i3.transparent_index;
    null === u3 && (u3 = 256);
    var c3 = i3.width, l3 = n2 - c3, h3 = c3, f3 = 4 * (i3.y * n2 + i3.x), d3 = 4 * ((i3.y + i3.height) * n2 + i3.x), p3 = f3, g3 = 4 * l3;
    true === i3.interlaced && (g3 += 4 * n2 * 7);
    for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
      var y3 = o3[v3];
      if (0 === h3 && (h3 = c3, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * n2 * (m3 - 1), p3 = f3 + (c3 + l3) * (m3 << 1), m3 >>= 1)), y3 === u3) p3 += 4;
      else {
        var w3 = t3[s3 + 3 * y3], N3 = t3[s3 + 3 * y3 + 1], L3 = t3[s3 + 3 * y3 + 2];
        r3[p3++] = w3, r3[p3++] = N3, r3[p3++] = L3, r3[p3++] = 255;
      }
      --h3;
    }
  };
}
function se(t3, e2, n2, r2) {
  for (var i2 = t3[e2++], a2 = 1 << i2, s2 = a2 + 1, u2 = s2 + 1, c2 = i2 + 1, l2 = (1 << c2) - 1, h2 = 0, f2 = 0, d2 = 0, p2 = t3[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
    for (; h2 < 16 && 0 !== p2; ) f2 |= t3[e2++] << h2, h2 += 8, 1 === p2 ? p2 = t3[e2++] : --p2;
    if (h2 < c2) break;
    var v2 = f2 & l2;
    if (f2 >>= c2, h2 -= c2, v2 !== a2) {
      if (v2 === s2) break;
      for (var b2 = v2 < u2 ? v2 : m2, y2 = 0, w2 = b2; w2 > a2; ) w2 = g2[w2] >> 8, ++y2;
      var N2 = w2;
      if (d2 + y2 + (b2 !== v2 ? 1 : 0) > r2) return void o$1.log("Warning, gif stream longer than expected.");
      n2[d2++] = N2;
      var L2 = d2 += y2;
      for (b2 !== v2 && (n2[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], n2[--L2] = 255 & w2, w2 >>= 8;
      null !== m2 && u2 < 4096 && (g2[u2++] = m2 << 8 | N2, u2 >= l2 + 1 && c2 < 12 && (++c2, l2 = l2 << 1 | 1)), m2 = v2;
    } else u2 = s2 + 1, l2 = (1 << (c2 = i2 + 1)) - 1, m2 = null;
  }
  return d2 !== r2 && o$1.log("Warning, gif stream shorter than expected."), n2;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function ue(t3) {
  var e2, n2, r2, i2, a2, o2 = Math.floor, s2 = new Array(64), u2 = new Array(64), c2 = new Array(64), l2 = new Array(64), h2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), x2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], A2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], F2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], I2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], j2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function C2(t4, e3) {
    for (var n3 = 0, r3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
      for (var o3 = 1; o3 <= t4[a3]; o3++) i3[e3[r3]] = [], i3[e3[r3]][0] = n3, i3[e3[r3]][1] = a3, r3++, n3++;
      n3 *= 2;
    }
    return i3;
  }
  function O2(t4) {
    for (var e3 = t4[0], n3 = t4[1] - 1; n3 >= 0; ) e3 & 1 << n3 && (m2 |= 1 << v2), n3--, --v2 < 0 && (255 == m2 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
  }
  function B3(t4) {
    g2.push(t4);
  }
  function M2(t4) {
    B3(t4 >> 8 & 255), B3(255 & t4);
  }
  function q2(t4, e3, n3, r3, i3) {
    for (var a3, o3 = i3[0], s3 = i3[240], u3 = (function(t5, e4) {
      var n4, r4, i4, a4, o4, s4, u4, c4, l4, h3, f3 = 0;
      for (l4 = 0; l4 < 8; ++l4) {
        n4 = t5[f3], r4 = t5[f3 + 1], i4 = t5[f3 + 2], a4 = t5[f3 + 3], o4 = t5[f3 + 4], s4 = t5[f3 + 5], u4 = t5[f3 + 6];
        var p3 = n4 + (c4 = t5[f3 + 7]), g4 = n4 - c4, m4 = r4 + u4, v4 = r4 - u4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, x3 = p3 - w4, A3 = m4 + b4, S3 = m4 - b4;
        t5[f3] = L3 + A3, t5[f3 + 4] = L3 - A3;
        var _3 = 0.707106781 * (S3 + x3);
        t5[f3 + 2] = x3 + _3, t5[f3 + 6] = x3 - _3;
        var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, F3 = 1.306562965 * S3 + P3, I3 = 0.707106781 * (A3 = y4 + v4), j3 = g4 + I3, C3 = g4 - I3;
        t5[f3 + 5] = C3 + k3, t5[f3 + 3] = C3 - k3, t5[f3 + 1] = j3 + F3, t5[f3 + 7] = j3 - F3, f3 += 8;
      }
      for (f3 = 0, l4 = 0; l4 < 8; ++l4) {
        n4 = t5[f3], r4 = t5[f3 + 8], i4 = t5[f3 + 16], a4 = t5[f3 + 24], o4 = t5[f3 + 32], s4 = t5[f3 + 40], u4 = t5[f3 + 48];
        var O3 = n4 + (c4 = t5[f3 + 56]), B4 = n4 - c4, M3 = r4 + u4, q3 = r4 - u4, E3 = i4 + s4, R2 = i4 - s4, D2 = a4 + o4, T2 = a4 - o4, z2 = O3 + D2, U2 = O3 - D2, H4 = M3 + E3, W2 = M3 - E3;
        t5[f3] = z2 + H4, t5[f3 + 32] = z2 - H4;
        var V2 = 0.707106781 * (W2 + U2);
        t5[f3 + 16] = U2 + V2, t5[f3 + 48] = U2 - V2;
        var G2 = 0.382683433 * ((z2 = T2 + R2) - (W2 = q3 + B4)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = R2 + q3), K2 = B4 + X2, Z2 = B4 - X2;
        t5[f3 + 40] = Z2 + Y2, t5[f3 + 24] = Z2 - Y2, t5[f3 + 8] = K2 + J2, t5[f3 + 56] = K2 - J2, f3++;
      }
      for (l4 = 0; l4 < 64; ++l4) h3 = t5[l4] * e4[l4], d2[l4] = h3 > 0 ? h3 + 0.5 | 0 : h3 - 0.5 | 0;
      return d2;
    })(t4, e3), c3 = 0; c3 < 64; ++c3) p2[x2[c3]] = u3[c3];
    var l3 = p2[0] - n3;
    n3 = p2[0], 0 == l3 ? O2(r3[0]) : (O2(r3[f2[a3 = 32767 + l3]]), O2(h2[a3]));
    for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
    if (0 == g3) return O2(o3), n3;
    for (var m3, v3 = 1; v3 <= g3; ) {
      for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
      var y3 = v3 - b3;
      if (y3 >= 16) {
        m3 = y3 >> 4;
        for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
        y3 &= 15;
      }
      a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(h2[a3]), v3++;
    }
    return 63 != g3 && O2(o3), n3;
  }
  function E2(t4) {
    t4 = Math.min(Math.max(t4, 1), 100), a2 != t4 && ((function(t5) {
      for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n3 = 0; n3 < 64; n3++) {
        var r3 = o2((e3[n3] * t5 + 50) / 100);
        r3 = Math.min(Math.max(r3, 1), 255), s2[x2[n3]] = r3;
      }
      for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
        var h3 = o2((i3[a3] * t5 + 50) / 100);
        h3 = Math.min(Math.max(h3, 1), 255), u2[x2[a3]] = h3;
      }
      for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) c2[d3] = 1 / (s2[x2[d3]] * f3[p3] * f3[g3] * 8), l2[d3] = 1 / (u2[x2[d3]] * f3[p3] * f3[g3] * 8), d3++;
    })(t4 < 50 ? Math.floor(5e3 / t4) : Math.floor(200 - 2 * t4)), a2 = t4);
  }
  this.encode = function(t4, a3) {
    a3 && E2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), (function() {
      M2(65499), M2(132), B3(0);
      for (var t5 = 0; t5 < 64; t5++) B3(s2[t5]);
      B3(1);
      for (var e3 = 0; e3 < 64; e3++) B3(u2[e3]);
    })(), (function(t5, e3) {
      M2(65472), M2(17), B3(8), M2(e3), M2(t5), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
    })(t4.width, t4.height), (function() {
      M2(65476), M2(418), B3(0);
      for (var t5 = 0; t5 < 16; t5++) B3(A2[t5 + 1]);
      for (var e3 = 0; e3 <= 11; e3++) B3(S2[e3]);
      B3(16);
      for (var n3 = 0; n3 < 16; n3++) B3(_2[n3 + 1]);
      for (var r3 = 0; r3 <= 161; r3++) B3(P2[r3]);
      B3(1);
      for (var i3 = 0; i3 < 16; i3++) B3(k2[i3 + 1]);
      for (var a4 = 0; a4 <= 11; a4++) B3(F2[a4]);
      B3(17);
      for (var o4 = 0; o4 < 16; o4++) B3(I2[o4 + 1]);
      for (var s3 = 0; s3 <= 161; s3++) B3(j2[s3]);
    })(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
    var o3 = 0, h3 = 0, f3 = 0;
    m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
    for (var d3, p3, N3, x3, C3, R2, D2, T2, z2, U2 = t4.data, H4 = t4.width, W2 = t4.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
      for (d3 = 0; d3 < V2; ) {
        for (C3 = V2 * G2 + d3, D2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++) R2 = C3 + (T2 = z2 >> 3) * V2 + (D2 = 4 * (7 & z2)), G2 + T2 >= W2 && (R2 -= V2 * (G2 + 1 + T2 - W2)), d3 + D2 >= V2 && (R2 -= d3 + D2 - V2 + 4), p3 = U2[R2++], N3 = U2[R2++], x3 = U2[R2++], b2[z2] = (L2[p3] + L2[N3 + 256 | 0] + L2[x3 + 512 | 0] >> 16) - 128, y2[z2] = (L2[p3 + 768 | 0] + L2[N3 + 1024 | 0] + L2[x3 + 1280 | 0] >> 16) - 128, w2[z2] = (L2[p3 + 1280 | 0] + L2[N3 + 1536 | 0] + L2[x3 + 1792 | 0] >> 16) - 128;
        o3 = q2(b2, c2, o3, e2, r2), h3 = q2(y2, l2, h3, n2, i2), f3 = q2(w2, l2, f3, n2, i2), d3 += 32;
      }
      G2 += 8;
    }
    if (v2 >= 0) {
      var Y2 = [];
      Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
    }
    return M2(65497), new Uint8Array(g2);
  }, t3 = t3 || 50, (function() {
    for (var t4 = String.fromCharCode, e3 = 0; e3 < 256; e3++) N2[e3] = t4(e3);
  })(), e2 = C2(A2, S2), n2 = C2(k2, F2), r2 = C2(_2, P2), i2 = C2(I2, j2), (function() {
    for (var t4 = 1, e3 = 2, n3 = 1; n3 <= 15; n3++) {
      for (var r3 = t4; r3 < e3; r3++) f2[32767 + r3] = n3, h2[32767 + r3] = [], h2[32767 + r3][1] = n3, h2[32767 + r3][0] = r3;
      for (var i3 = -(e3 - 1); i3 <= -t4; i3++) f2[32767 + i3] = n3, h2[32767 + i3] = [], h2[32767 + i3][1] = n3, h2[32767 + i3][0] = e3 - 1 + i3;
      t4 <<= 1, e3 <<= 1;
    }
  })(), (function() {
    for (var t4 = 0; t4 < 256; t4++) L2[t4] = 19595 * t4, L2[t4 + 256 | 0] = 38470 * t4, L2[t4 + 512 | 0] = 7471 * t4 + 32768, L2[t4 + 768 | 0] = -11059 * t4, L2[t4 + 1024 | 0] = -21709 * t4, L2[t4 + 1280 | 0] = 32768 * t4 + 8421375, L2[t4 + 1536 | 0] = -27439 * t4, L2[t4 + 1792 | 0] = -5329 * t4;
  })(), E2(t3);
}
/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
function ce(t3, e2) {
  if (this.pos = 0, this.buffer = t3, this.datav = new DataView(t3.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function le(t3) {
  function e2(t4) {
    if (!t4) throw Error("assert :P");
  }
  function n2(t4, e3, n3) {
    for (var r3 = 0; 4 > r3; r3++) if (t4[e3 + r3] != n3.charCodeAt(r3)) return true;
    return false;
  }
  function r2(t4, e3, n3, r3, i3) {
    for (var a3 = 0; a3 < i3; a3++) t4[e3 + a3] = n3[r3 + a3];
  }
  function i2(t4, e3, n3, r3) {
    for (var i3 = 0; i3 < r3; i3++) t4[e3 + i3] = n3;
  }
  function a2(t4) {
    return new Int32Array(t4);
  }
  function o2(t4, e3) {
    for (var n3 = [], r3 = 0; r3 < t4; r3++) n3.push(new e3());
    return n3;
  }
  function s2(t4, e3) {
    var n3 = [];
    return (function t5(n4, r3, i3) {
      for (var a3 = i3[r3], o3 = 0; o3 < a3 && (n4.push(i3.length > r3 + 1 ? [] : new e3()), !(i3.length < r3 + 1)); o3++) t5(n4[o3], r3 + 1, i3);
    })(n3, 0, t4), n3;
  }
  var u2 = function() {
    var t4 = this;
    function u3(t5, e3) {
      for (var n3 = 1 << e3 - 1 >>> 0; t5 & n3; ) n3 >>>= 1;
      return n3 ? (t5 & n3 - 1) + n3 : t5;
    }
    function c3(t5, n3, r3, i3, a3) {
      e2(!(i3 % r3));
      do {
        t5[n3 + (i3 -= r3)] = a3;
      } while (0 < i3);
    }
    function l3(t5, n3, r3, i3, o3) {
      if (e2(2328 >= o3), 512 >= o3) var s3 = a2(512);
      else if (null == (s3 = a2(o3))) return 0;
      return (function(t6, n4, r4, i4, o4, s4) {
        var l4, f4, d4 = n4, p4 = 1 << r4, g4 = a2(16), m4 = a2(16);
        for (e2(0 != o4), e2(null != i4), e2(null != t6), e2(0 < r4), f4 = 0; f4 < o4; ++f4) {
          if (15 < i4[f4]) return 0;
          ++g4[i4[f4]];
        }
        if (g4[0] == o4) return 0;
        for (m4[1] = 0, l4 = 1; 15 > l4; ++l4) {
          if (g4[l4] > 1 << l4) return 0;
          m4[l4 + 1] = m4[l4] + g4[l4];
        }
        for (f4 = 0; f4 < o4; ++f4) l4 = i4[f4], 0 < i4[f4] && (s4[m4[l4]++] = f4);
        if (1 == m4[15]) return (i4 = new h3()).g = 0, i4.value = s4[0], c3(t6, d4, 1, p4, i4), p4;
        var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, x4 = 1 << r4;
        for (f4 = 0, l4 = 1, o4 = 2; l4 <= r4; ++l4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[l4])) return 0;
          for (; 0 < g4[l4]; --g4[l4]) (i4 = new h3()).g = l4, i4.value = s4[f4++], c3(t6, d4 + w4, o4, x4, i4), w4 = u3(w4, l4);
        }
        for (l4 = r4 + 1, o4 = 2; 15 >= l4; ++l4, o4 <<= 1) {
          if (N4 += L4 <<= 1, 0 > (L4 -= g4[l4])) return 0;
          for (; 0 < g4[l4]; --g4[l4]) {
            if (i4 = new h3(), (w4 & y4) != b4) {
              for (d4 += x4, v4 = 1 << (b4 = l4) - r4; 15 > b4 && !(0 >= (v4 -= g4[b4])); ) ++b4, v4 <<= 1;
              p4 += x4 = 1 << (v4 = b4 - r4), t6[n4 + (b4 = w4 & y4)].g = v4 + r4, t6[n4 + b4].value = d4 - n4 - b4;
            }
            i4.g = l4 - r4, i4.value = s4[f4++], c3(t6, d4 + (w4 >> r4), o4, x4, i4), w4 = u3(w4, l4);
          }
        }
        return N4 != 2 * m4[15] - 1 ? 0 : p4;
      })(t5, n3, r3, i3, o3, s3);
    }
    function h3() {
      this.value = this.g = 0;
    }
    function f3() {
      this.value = this.g = 0;
    }
    function d3() {
      this.G = o2(5, h3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Rn, f3);
    }
    function p3(t5, n3, r3, i3) {
      e2(null != t5), e2(null != n3), e2(2147483648 > i3), t5.Ca = 254, t5.I = 0, t5.b = -8, t5.Ka = 0, t5.oa = n3, t5.pa = r3, t5.Jd = n3, t5.Yc = r3 + i3, t5.Zc = 4 <= i3 ? r3 + i3 - 4 + 1 : r3, _2(t5);
    }
    function g3(t5, e3) {
      for (var n3 = 0; 0 < e3--; ) n3 |= k2(t5, 128) << e3;
      return n3;
    }
    function m3(t5, e3) {
      var n3 = g3(t5, e3);
      return P2(t5) ? -n3 : n3;
    }
    function v3(t5, n3, r3, i3) {
      var a3, o3 = 0;
      for (e2(null != t5), e2(null != n3), e2(4294967288 > i3), t5.Sb = i3, t5.Ra = 0, t5.u = 0, t5.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3) o3 += n3[r3 + a3] << 8 * a3;
      t5.Ra = o3, t5.bb = i3, t5.oa = n3, t5.pa = r3;
    }
    function b3(t5) {
      for (; 8 <= t5.u && t5.bb < t5.Sb; ) t5.Ra >>>= 8, t5.Ra += t5.oa[t5.pa + t5.bb] << zn - 8 >>> 0, ++t5.bb, t5.u -= 8;
      x3(t5) && (t5.h = 1, t5.u = 0);
    }
    function y3(t5, n3) {
      if (e2(0 <= n3), !t5.h && n3 <= Tn) {
        var r3 = L3(t5) & Dn[n3];
        return t5.u += n3, b3(t5), r3;
      }
      return t5.h = 1, t5.u = 0;
    }
    function w3() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function N3() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function L3(t5) {
      return t5.Ra >>> (t5.u & zn - 1) >>> 0;
    }
    function x3(t5) {
      return e2(t5.bb <= t5.Sb), t5.h || t5.bb == t5.Sb && t5.u > zn;
    }
    function A3(t5, e3) {
      t5.u = e3, t5.h = x3(t5);
    }
    function S2(t5) {
      t5.u >= Un && (e2(t5.u >= Un), b3(t5));
    }
    function _2(t5) {
      e2(null != t5 && null != t5.oa), t5.pa < t5.Zc ? (t5.I = (t5.oa[t5.pa++] | t5.I << 8) >>> 0, t5.b += 8) : (e2(null != t5 && null != t5.oa), t5.pa < t5.Yc ? (t5.b += 8, t5.I = t5.oa[t5.pa++] | t5.I << 8) : t5.Ka ? t5.b = 0 : (t5.I <<= 8, t5.b += 8, t5.Ka = 1));
    }
    function P2(t5) {
      return g3(t5, 1);
    }
    function k2(t5, e3) {
      var n3 = t5.Ca;
      0 > t5.b && _2(t5);
      var r3 = t5.b, i3 = n3 * e3 >>> 8, a3 = (t5.I >>> r3 > i3) + 0;
      for (a3 ? (n3 -= i3, t5.I -= i3 + 1 << r3 >>> 0) : n3 = i3 + 1, r3 = n3, i3 = 0; 256 <= r3; ) i3 += 8, r3 >>= 8;
      return r3 = 7 ^ i3 + Hn[r3], t5.b -= r3, t5.Ca = (n3 << r3) - 1, a3;
    }
    function F2(t5, e3, n3) {
      t5[e3 + 0] = n3 >> 24 & 255, t5[e3 + 1] = n3 >> 16 & 255, t5[e3 + 2] = n3 >> 8 & 255, t5[e3 + 3] = 255 & n3;
    }
    function I2(t5, e3) {
      return t5[e3 + 0] | t5[e3 + 1] << 8;
    }
    function j2(t5, e3) {
      return I2(t5, e3) | t5[e3 + 2] << 16;
    }
    function C2(t5, e3) {
      return I2(t5, e3) | I2(t5, e3 + 2) << 16;
    }
    function O2(t5, n3) {
      var r3 = 1 << n3;
      return e2(null != t5), e2(0 < n3), t5.X = a2(r3), null == t5.X ? 0 : (t5.Mb = 32 - n3, t5.Xa = n3, 1);
    }
    function B3(t5, n3) {
      e2(null != t5), e2(null != n3), e2(t5.Xa == n3.Xa), r2(n3.X, 0, t5.X, 0, 1 << n3.Xa);
    }
    function M2() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function q2(t5, n3, r3, i3) {
      e2(null != r3), e2(null != i3);
      var a3 = r3[0], o3 = i3[0];
      return 0 == a3 && (a3 = (t5 * o3 + n3 / 2) / n3), 0 == o3 && (o3 = (n3 * a3 + t5 / 2) / t5), 0 >= a3 || 0 >= o3 ? 0 : (r3[0] = a3, i3[0] = o3, 1);
    }
    function E2(t5, e3) {
      return t5 + (1 << e3) - 1 >>> e3;
    }
    function R2(t5, e3) {
      return ((4278255360 & t5) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t5) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
    }
    function D2(e3, n3) {
      t4[n3] = function(n4, r3, i3, a3, o3, s3, u4) {
        var c4;
        for (c4 = 0; c4 < o3; ++c4) {
          var l4 = t4[e3](s3[u4 + c4 - 1], i3, a3 + c4);
          s3[u4 + c4] = R2(n4[r3 + c4], l4);
        }
      };
    }
    function T2() {
      this.ud = this.hd = this.jd = 0;
    }
    function z2(t5, e3) {
      return ((4278124286 & (t5 ^ e3)) >>> 1) + (t5 & e3) >>> 0;
    }
    function U2(t5) {
      return 0 <= t5 && 256 > t5 ? t5 : 0 > t5 ? 0 : 255 < t5 ? 255 : void 0;
    }
    function H4(t5, e3) {
      return U2(t5 + (t5 - e3 + 0.5 >> 1));
    }
    function W2(t5, e3, n3) {
      return Math.abs(e3 - n3) - Math.abs(t5 - n3);
    }
    function V2(t5, e3, n3, r3, i3, a3, o3) {
      for (r3 = a3[o3 - 1], n3 = 0; n3 < i3; ++n3) a3[o3 + n3] = r3 = R2(t5[e3 + n3], r3);
    }
    function G2(t5, e3, n3, r3, i3) {
      var a3;
      for (a3 = 0; a3 < n3; ++a3) {
        var o3 = t5[e3 + a3], s3 = o3 >> 8 & 255, u4 = 16711935 & (u4 = (u4 = 16711935 & o3) + ((s3 << 16) + s3));
        r3[i3 + a3] = (4278255360 & o3) + u4 >>> 0;
      }
    }
    function Y2(t5, e3) {
      e3.jd = 255 & t5, e3.hd = t5 >> 8 & 255, e3.ud = t5 >> 16 & 255;
    }
    function J2(t5, e3, n3, r3, i3, a3) {
      var o3;
      for (o3 = 0; o3 < r3; ++o3) {
        var s3 = e3[n3 + o3], u4 = s3 >>> 8, c4 = s3, l4 = 255 & (l4 = (l4 = s3 >>> 16) + ((t5.jd << 24 >> 24) * (u4 << 24 >> 24) >>> 5));
        c4 = 255 & (c4 = (c4 += (t5.hd << 24 >> 24) * (u4 << 24 >> 24) >>> 5) + ((t5.ud << 24 >> 24) * (l4 << 24 >> 24) >>> 5)), i3[a3 + o3] = (4278255360 & s3) + (l4 << 16) + c4;
      }
    }
    function X2(e3, n3, r3, i3, a3) {
      t4[n3] = function(t5, e4, n4, r4, o3, s3, u4, c4, l4) {
        for (r4 = u4; r4 < c4; ++r4) for (u4 = 0; u4 < l4; ++u4) o3[s3++] = a3(n4[i3(t5[e4++])]);
      }, t4[e3] = function(e4, n4, o3, s3, u4, c4, l4) {
        var h4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p4 = e4.w;
        if (8 > h4) for (e4 = (1 << e4.b) - 1, p4 = (1 << h4) - 1; n4 < o3; ++n4) {
          var g4, m4 = 0;
          for (g4 = 0; g4 < f4; ++g4) g4 & e4 || (m4 = i3(s3[u4++])), c4[l4++] = a3(d4[m4 & p4]), m4 >>= h4;
        }
        else t4["VP8LMapColor" + r3](s3, u4, d4, p4, c4, l4, n4, o3, f4);
      };
    }
    function K2(t5, e3, n3, r3, i3) {
      for (n3 = e3 + n3; e3 < n3; ) {
        var a3 = t5[e3++];
        r3[i3++] = a3 >> 16 & 255, r3[i3++] = a3 >> 8 & 255, r3[i3++] = 255 & a3;
      }
    }
    function Z2(t5, e3, n3, r3, i3) {
      for (n3 = e3 + n3; e3 < n3; ) {
        var a3 = t5[e3++];
        r3[i3++] = a3 >> 16 & 255, r3[i3++] = a3 >> 8 & 255, r3[i3++] = 255 & a3, r3[i3++] = a3 >> 24 & 255;
      }
    }
    function $2(t5, e3, n3, r3, i3) {
      for (n3 = e3 + n3; e3 < n3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = 240 & o3 | o3 >> 28 & 15;
        r3[i3++] = a3, r3[i3++] = o3;
      }
    }
    function Q2(t5, e3, n3, r3, i3) {
      for (n3 = e3 + n3; e3 < n3; ) {
        var a3 = (o3 = t5[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
        r3[i3++] = a3, r3[i3++] = o3;
      }
    }
    function tt2(t5, e3, n3, r3, i3) {
      for (n3 = e3 + n3; e3 < n3; ) {
        var a3 = t5[e3++];
        r3[i3++] = 255 & a3, r3[i3++] = a3 >> 8 & 255, r3[i3++] = a3 >> 16 & 255;
      }
    }
    function et2(t5, e3, n3, i3, a3, o3) {
      if (0 == o3) for (n3 = e3 + n3; e3 < n3; ) F2(i3, ((o3 = t5[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
      else r2(i3, a3, t5, e3, n3);
    }
    function nt2(e3, n3) {
      t4[n3][0] = t4[e3 + "0"], t4[n3][1] = t4[e3 + "1"], t4[n3][2] = t4[e3 + "2"], t4[n3][3] = t4[e3 + "3"], t4[n3][4] = t4[e3 + "4"], t4[n3][5] = t4[e3 + "5"], t4[n3][6] = t4[e3 + "6"], t4[n3][7] = t4[e3 + "7"], t4[n3][8] = t4[e3 + "8"], t4[n3][9] = t4[e3 + "9"], t4[n3][10] = t4[e3 + "10"], t4[n3][11] = t4[e3 + "11"], t4[n3][12] = t4[e3 + "12"], t4[n3][13] = t4[e3 + "13"], t4[n3][14] = t4[e3 + "0"], t4[n3][15] = t4[e3 + "0"];
    }
    function rt2(t5) {
      return t5 == Ur || t5 == Hr || t5 == Wr || t5 == Vr;
    }
    function it2() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function at2() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function ot2() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
    }
    function st2() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function ut2() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function ct2(t5) {
      return alert("todo:WebPSamplerProcessPlane"), t5.T;
    }
    function lt2(t5, e3) {
      var n3 = t5.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t5.ka * i3.A, s3 = mi[e3.ba.S], u4 = t5.y, c4 = t5.O, l4 = t5.f, h4 = t5.N, f4 = t5.ea, d4 = t5.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t5.ka, y4 = t5.ka + t5.T, w4 = t5.U, N4 = w4 + 1 >> 1;
      for (0 == b4 ? s3(u4, c4, null, null, l4, h4, f4, d4, l4, h4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, u4, c4, p4, g4, m4, v4, l4, h4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++n3); b4 + 2 < y4; b4 += 2) p4 = l4, g4 = h4, m4 = f4, v4 = d4, h4 += t5.Rc, d4 += t5.Rc, o3 += 2 * i3.A, s3(u4, (c4 += 2 * t5.fa) - t5.fa, u4, c4, p4, g4, m4, v4, l4, h4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
      return c4 += t5.fa, t5.j + y4 < t5.o ? (r2(e3.ec, e3.fc, u4, c4, w4), r2(e3.cc, e3.dc, l4, h4, N4), r2(e3.Mc, e3.Nc, f4, d4, N4), n3--) : 1 & y4 || s3(u4, c4, null, null, l4, h4, f4, d4, l4, h4, f4, d4, a3, o3 + i3.A, null, null, w4), n3;
    }
    function ht2(t5, n3, r3) {
      var i3 = t5.F, a3 = [t5.J];
      if (null != i3) {
        var o3 = t5.U, s3 = n3.ba.S, u4 = s3 == Dr || s3 == Wr;
        n3 = n3.ba.f.RGBA;
        var c4 = [0], l4 = t5.ka;
        c4[0] = t5.T, t5.Kb && (0 == l4 ? --c4[0] : (--l4, a3[0] -= t5.width), t5.j + t5.ka + t5.T == t5.o && (c4[0] = t5.o - t5.j - l4));
        var h4 = n3.eb;
        l4 = n3.fb + l4 * n3.A, t5 = Ar(i3, a3[0], t5.width, o3, c4, h4, l4 + (u4 ? 0 : 3), n3.A), e2(r3 == c4), t5 && rt2(s3) && Lr(h4, l4, u4, o3, c4, n3.A);
      }
      return 0;
    }
    function ft2(t5) {
      var e3 = t5.ma, n3 = e3.ba.S, r3 = 11 > n3, i3 = n3 == qr || n3 == Rr || n3 == Dr || n3 == Tr || 12 == n3 || rt2(n3);
      if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mn(e3.Oa, t5, i3 ? 11 : 12)) return 0;
      if (i3 && rt2(n3) && bn(), t5.da) alert("todo:use_scaling");
      else {
        if (r3) {
          if (e3.Ib = ct2, t5.Kb) {
            if (n3 = t5.U + 1 >> 1, e3.memory = a2(t5.U + 2 * n3), null == e3.memory) return 0;
            e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t5.U, e3.Mc = e3.cc, e3.Nc = e3.dc + n3, e3.Ib = lt2, bn();
          }
        } else alert("todo:EmitYUV");
        i3 && (e3.Jb = ht2, r3 && mn());
      }
      if (r3 && !Ii) {
        for (t5 = 0; 256 > t5; ++t5) ji[t5] = 89858 * (t5 - 128) + Si >> Ai, Bi[t5] = -22014 * (t5 - 128) + Si, Oi[t5] = -45773 * (t5 - 128), Ci[t5] = 113618 * (t5 - 128) + Si >> Ai;
        for (t5 = _i; t5 < Pi; ++t5) e3 = 76283 * (t5 - 16) + Si >> Ai, Mi[t5 - _i] = Vt2(e3, 255), qi[t5 - _i] = Vt2(e3 + 8 >> 4, 15);
        Ii = 1;
      }
      return 1;
    }
    function dt2(t5) {
      var n3 = t5.ma, r3 = t5.U, i3 = t5.T;
      return e2(!(1 & t5.ka)), 0 >= r3 || 0 >= i3 ? 0 : (r3 = n3.Ib(t5, n3), null != n3.Jb && n3.Jb(t5, n3, r3), n3.Dc += r3, 1);
    }
    function pt2(t5) {
      t5.ma.memory = null;
    }
    function gt2(t5, e3, n3, r3) {
      return 47 != y3(t5, 8) ? 0 : (e3[0] = y3(t5, 14) + 1, n3[0] = y3(t5, 14) + 1, r3[0] = y3(t5, 1), 0 != y3(t5, 3) ? 0 : !t5.h);
    }
    function mt2(t5, e3) {
      if (4 > t5) return t5 + 1;
      var n3 = t5 - 2 >> 1;
      return (2 + (1 & t5) << n3) + y3(e3, n3) + 1;
    }
    function vt2(t5, e3) {
      return 120 < e3 ? e3 - 120 : 1 <= (n3 = ((n3 = Zr[e3 - 1]) >> 4) * t5 + (8 - (15 & n3))) ? n3 : 1;
      var n3;
    }
    function bt2(t5, e3, n3) {
      var r3 = L3(n3), i3 = t5[e3 += 255 & r3].g - 8;
      return 0 < i3 && (A3(n3, n3.u + 8), r3 = L3(n3), e3 += t5[e3].value, e3 += r3 & (1 << i3) - 1), A3(n3, n3.u + t5[e3].g), t5[e3].value;
    }
    function yt2(t5, n3, r3) {
      return r3.g += t5.g, r3.value += t5.value << n3 >>> 0, e2(8 >= r3.g), t5.g;
    }
    function wt2(t5, n3, r3) {
      var i3 = t5.xc;
      return e2((n3 = 0 == i3 ? 0 : t5.vc[t5.md * (r3 >> i3) + (n3 >> i3)]) < t5.Wb), t5.Ya[n3];
    }
    function Nt2(t5, n3, i3, a3) {
      var o3 = t5.ab, s3 = t5.c * n3, u4 = t5.C;
      n3 = u4 + n3;
      var c4 = i3, l4 = a3;
      for (a3 = t5.Ta, i3 = t5.Ua; 0 < o3--; ) {
        var h4 = t5.gc[o3], f4 = u4, d4 = n3, p4 = c4, g4 = l4, m4 = (l4 = a3, c4 = i3, h4.Ea);
        switch (e2(f4 < d4), e2(d4 <= h4.nc), h4.hc) {
          case 2:
            Gn(p4, g4, (d4 - f4) * m4, l4, c4);
            break;
          case 0:
            var v4 = f4, b4 = d4, y4 = l4, w4 = c4, N4 = (_3 = h4).Ea;
            0 == v4 && (Wn(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
            for (var L4 = 1 << _3.b, x4 = L4 - 1, A4 = E2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * A4; v4 < b4; ) {
              var P3 = S3, k3 = _3, F3 = 1;
              for (Vn(p4, g4, y4, w4 - N4, 1, y4, w4); F3 < N4; ) {
                var I3 = (F3 & ~x4) + L4;
                I3 > N4 && (I3 = N4), (0, Zn[P3[k3++] >> 8 & 15])(p4, g4 + +F3, y4, w4 + F3 - N4, I3 - F3, y4, w4 + F3), F3 = I3;
              }
              g4 += N4, w4 += N4, ++v4 & x4 || (_3 += A4);
            }
            d4 != h4.nc && r2(l4, c4 - m4, l4, c4 + (d4 - f4 - 1) * m4, m4);
            break;
          case 1:
            for (m4 = p4, b4 = g4, N4 = (p4 = h4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << h4.b) - 1)), v4 = E2(p4, h4.b), L4 = h4.K, h4 = h4.w + (f4 >> h4.b) * v4; f4 < d4; ) {
              for (x4 = L4, A4 = h4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(x4[A4++], S3), $n(S3, m4, b4, g4, l4, c4), b4 += g4, c4 += g4;
              b4 < P3 && (Y2(x4[A4++], S3), $n(S3, m4, b4, N4, l4, c4), b4 += N4, c4 += N4), ++f4 & y4 || (h4 += v4);
            }
            break;
          case 3:
            if (p4 == l4 && g4 == c4 && 0 < h4.b) {
              for (b4 = l4, p4 = m4 = c4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * E2(h4.Ea, h4.b)), g4 = l4, y4 = c4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v4[w4] = g4[y4 + w4];
              for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v4[w4];
              Yn(h4, f4, d4, l4, m4, l4, c4);
            } else Yn(h4, f4, d4, p4, g4, l4, c4);
        }
        c4 = a3, l4 = i3;
      }
      l4 != i3 && r2(a3, i3, c4, l4, s3);
    }
    function Lt2(t5, n3) {
      var r3 = t5.V, i3 = t5.Ba + t5.c * t5.C, a3 = n3 - t5.C;
      if (e2(n3 <= t5.l.o), e2(16 >= a3), 0 < a3) {
        var o3 = t5.l, s3 = t5.Ta, u4 = t5.Ua, c4 = o3.width;
        if (Nt2(t5, a3, r3, i3), a3 = u4 = [u4], e2((r3 = t5.C) < (i3 = n3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), r3 < o3.j) {
          var l4 = o3.j - r3;
          r3 = o3.j, a3[0] += l4 * c4;
        }
        if (r3 >= i3 ? r3 = 0 : (a3[0] += 4 * o3.v, o3.ka = r3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - r3, r3 = 1), r3) {
          if (u4 = u4[0], 11 > (r3 = t5.ca).S) {
            var h4 = r3.f.RGBA, f4 = (i3 = r3.S, a3 = o3.U, o3 = o3.T, l4 = h4.eb, h4.A), d4 = o3;
            for (h4 = h4.fb + t5.Ma * h4.A; 0 < d4--; ) {
              var p4 = s3, g4 = u4, m4 = a3, v4 = l4, b4 = h4;
              switch (i3) {
                case Mr:
                  Qn(p4, g4, m4, v4, b4);
                  break;
                case qr:
                  tr(p4, g4, m4, v4, b4);
                  break;
                case Ur:
                  tr(p4, g4, m4, v4, b4), Lr(v4, b4, 0, m4, 1, 0);
                  break;
                case Er:
                  rr(p4, g4, m4, v4, b4);
                  break;
                case Rr:
                  et2(p4, g4, m4, v4, b4, 1);
                  break;
                case Hr:
                  et2(p4, g4, m4, v4, b4, 1), Lr(v4, b4, 0, m4, 1, 0);
                  break;
                case Dr:
                  et2(p4, g4, m4, v4, b4, 0);
                  break;
                case Wr:
                  et2(p4, g4, m4, v4, b4, 0), Lr(v4, b4, 1, m4, 1, 0);
                  break;
                case Tr:
                  er(p4, g4, m4, v4, b4);
                  break;
                case Vr:
                  er(p4, g4, m4, v4, b4), xr(v4, b4, m4, 1, 0);
                  break;
                case zr:
                  nr(p4, g4, m4, v4, b4);
                  break;
                default:
                  e2(0);
              }
              u4 += c4, h4 += f4;
            }
            t5.Ma += o3;
          } else alert("todo:EmitRescaledRowsYUVA");
          e2(t5.Ma <= r3.height);
        }
      }
      t5.C = n3, e2(t5.C <= t5.i);
    }
    function xt2(t5) {
      var e3;
      if (0 < t5.ua) return 0;
      for (e3 = 0; e3 < t5.Wb; ++e3) {
        var n3 = t5.Ya[e3].G, r3 = t5.Ya[e3].H;
        if (0 < n3[1][r3[1] + 0].g || 0 < n3[2][r3[2] + 0].g || 0 < n3[3][r3[3] + 0].g) return 0;
      }
      return 1;
    }
    function At2(t5, n3, r3, i3, a3, o3) {
      if (0 != t5.Z) {
        var s3 = t5.qd, u4 = t5.rd;
        for (e2(null != gi[t5.Z]); n3 < r3; ++n3) gi[t5.Z](s3, u4, i3, a3, i3, a3, o3), s3 = i3, u4 = a3, a3 += o3;
        t5.qd = s3, t5.rd = u4;
      }
    }
    function St(t5, n3) {
      var r3 = t5.l.ma, i3 = 0 == r3.Z || 1 == r3.Z ? t5.l.j : t5.C;
      if (i3 = t5.C < i3 ? i3 : t5.C, e2(n3 <= t5.l.o), n3 > i3) {
        var a3 = t5.l.width, o3 = r3.ca, s3 = r3.tb + a3 * i3, u4 = t5.V, c4 = t5.Ba + t5.c * i3, l4 = t5.gc;
        e2(1 == t5.ab), e2(3 == l4[0].hc), Xn(l4[0], i3, n3, u4, c4, o3, s3), At2(r3, i3, n3, o3, s3, a3);
      }
      t5.C = t5.Ma = n3;
    }
    function _t2(t5, n3, r3, i3, a3, o3, s3) {
      var u4 = t5.$ / i3, c4 = t5.$ % i3, l4 = t5.m, h4 = t5.s, f4 = r3 + t5.$, d4 = f4;
      a3 = r3 + i3 * a3;
      var p4 = r3 + i3 * o3, g4 = 280 + h4.ua, m4 = t5.Pb ? u4 : 16777216, v4 = 0 < h4.ua ? h4.Wa : null, b4 = h4.wc, y4 = f4 < p4 ? wt2(h4, c4, u4) : null;
      e2(t5.C < o3), e2(p4 <= a3);
      var w4 = false;
      t: for (; ; ) {
        for (; w4 || f4 < p4; ) {
          var N4 = 0;
          if (u4 >= m4) {
            var _3 = f4 - r3;
            e2((m4 = t5).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = u4 + Qr;
          }
          if (c4 & b4 || (y4 = wt2(h4, c4, u4)), e2(null != y4), y4.Qb && (n3[f4] = y4.qb, w4 = true), !w4) if (S2(l4), y4.jc) {
            N4 = l4, _3 = n3;
            var P3 = f4, k3 = y4.pd[L3(N4) & Rn - 1];
            e2(y4.jc), 256 > k3.g ? (A3(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (A3(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
          } else N4 = bt2(y4.G[0], y4.H[0], l4);
          if (l4.h) break;
          if (w4 || 256 > N4) {
            if (!w4) if (y4.nd) n3[f4] = (y4.qb | N4 << 8) >>> 0;
            else {
              if (S2(l4), w4 = bt2(y4.G[1], y4.H[1], l4), S2(l4), _3 = bt2(y4.G[2], y4.H[2], l4), P3 = bt2(y4.G[3], y4.H[3], l4), l4.h) break;
              n3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
            }
            if (w4 = false, ++f4, ++c4 >= i3 && (c4 = 0, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t5, u4), null != v4)) for (; d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
          } else if (280 > N4) {
            if (N4 = mt2(N4 - 256, l4), _3 = bt2(y4.G[4], y4.H[4], l4), S2(l4), _3 = vt2(i3, _3 = mt2(_3, l4)), l4.h) break;
            if (f4 - r3 < _3 || a3 - f4 < N4) break t;
            for (P3 = 0; P3 < N4; ++P3) n3[f4 + P3] = n3[f4 + P3 - _3];
            for (f4 += N4, c4 += N4; c4 >= i3; ) c4 -= i3, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t5, u4);
            if (e2(f4 <= a3), c4 & b4 && (y4 = wt2(h4, c4, u4)), null != v4) for (; d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
          } else {
            if (!(N4 < g4)) break t;
            for (w4 = N4 - 280, e2(null != v4); d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), n3[N4] = _3.X[w4], w4 = true;
          }
          w4 || e2(l4.h == x3(l4));
        }
        if (t5.Pb && l4.h && f4 < a3) e2(t5.m.h), t5.a = 5, t5.m = t5.wd, t5.$ = t5.xd, 0 < t5.s.ua && B3(t5.s.vb, t5.s.Wa);
        else {
          if (l4.h) break t;
          null != s3 && s3(t5, u4 > o3 ? o3 : u4), t5.a = 0, t5.$ = f4 - r3;
        }
        return 1;
      }
      return t5.a = 3, 0;
    }
    function Pt2(t5) {
      e2(null != t5), t5.vc = null, t5.yc = null, t5.Ya = null;
      var n3 = t5.Wa;
      null != n3 && (n3.X = null), t5.vb = null, e2(null != t5);
    }
    function kt2() {
      var e3 = new on();
      return null == e3 ? null : (e3.a = 0, e3.xb = pi, nt2("Predictor", "VP8LPredictors"), nt2("Predictor", "VP8LPredictors_C"), nt2("PredictorAdd", "VP8LPredictorsAdd"), nt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gn = G2, $n = J2, Qn = K2, tr = Z2, er = $2, nr = Q2, rr = tt2, t4.VP8LMapColor32b = Jn, t4.VP8LMapColor8b = Kn, e3);
    }
    function Ft2(t5, n3, r3, s3, u4) {
      var c4 = 1, f4 = [t5], p4 = [n3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
      t: for (; ; ) {
        if (r3) for (; c4 && y3(g4, 1); ) {
          var w4 = f4, N4 = p4, x4 = s3, _3 = 1, P3 = x4.m, k3 = x4.gc[x4.ab], F3 = y3(P3, 2);
          if (x4.Oc & 1 << F3) c4 = 0;
          else {
            switch (x4.Oc |= 1 << F3, k3.hc = F3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++x4.ab, e2(4 >= x4.ab), F3) {
              case 0:
              case 1:
                k3.b = y3(P3, 3) + 2, _3 = Ft2(E2(k3.Ea, k3.b), E2(k3.nc, k3.b), 0, x4, k3.K), k3.K = k3.K[0];
                break;
              case 3:
                var I3, j3 = y3(P3, 8) + 1, C3 = 16 < j3 ? 0 : 4 < j3 ? 1 : 2 < j3 ? 2 : 3;
                if (w4[0] = E2(k3.Ea, C3), k3.b = C3, I3 = _3 = Ft2(j3, 1, 0, x4, k3.K)) {
                  var B4, M3 = j3, q3 = k3, D3 = 1 << (8 >> q3.b), T3 = a2(D3);
                  if (null == T3) I3 = 0;
                  else {
                    var z3 = q3.K[0], U3 = q3.w;
                    for (T3[0] = q3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4) T3[B4] = R2(z3[U3 + B4], T3[B4 - 1]);
                    for (; B4 < 4 * D3; ++B4) T3[B4] = 0;
                    q3.K[0] = null, q3.K[0] = T3, I3 = 1;
                  }
                }
                _3 = I3;
                break;
              case 2:
                break;
              default:
                e2(0);
            }
            c4 = _3;
          }
        }
        if (f4 = f4[0], p4 = p4[0], c4 && y3(g4, 1) && !(c4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
          s3.a = 3;
          break t;
        }
        var H5;
        if (H5 = c4) e: {
          var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = r3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, nt3 = 0, rt3 = $r[K3];
          n: for (; ; ) {
            if (Z3 && y3($3, 1)) {
              var it3 = y3($3, 3) + 2, at3 = E2(J3, it3), ot3 = E2(X3, it3), st3 = at3 * ot3;
              if (!Ft2(at3, ot3, 0, Y3, tt3)) break n;
              for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                var ut3 = tt3[W3] >> 8 & 65535;
                tt3[W3] = ut3, ut3 >= et3 && (et3 = ut3 + 1);
              }
            }
            if ($3.h) break n;
            for (V3 = 0; 5 > V3; ++V3) {
              var ct3 = Jr[V3];
              !V3 && 0 < K3 && (ct3 += 1 << K3), nt3 < ct3 && (nt3 = ct3);
            }
            var lt3 = o2(et3 * rt3, h3), ht3 = et3, ft3 = o2(ht3, d3);
            if (null == ft3) var dt3 = null;
            else e2(65536 >= ht3), dt3 = ft3;
            var pt3 = a2(nt3);
            if (null == dt3 || null == pt3 || null == lt3) {
              Y3.a = 1;
              break n;
            }
            var gt3 = lt3;
            for (W3 = G3 = 0; W3 < et3; ++W3) {
              var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
              for (V3 = 0; 5 > V3; ++V3) {
                ct3 = Jr[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ct3 += 1 << K3);
                r: {
                  var xt3, At3 = ct3, St2 = Y3, kt3 = pt3, It3 = gt3, jt3 = G3, Ct3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);
                  if (i2(kt3, 0, 0, At3), Bt3) {
                    var Mt3 = y3(Ot3, 1) + 1, qt3 = y3(Ot3, 1), Et3 = y3(Ot3, 0 == qt3 ? 1 : 8);
                    kt3[Et3] = 1, 2 == Mt3 && (kt3[Et3 = y3(Ot3, 8)] = 1);
                    var Rt3 = 1;
                  } else {
                    var Dt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                    if (19 < Tt3) {
                      St2.a = 3;
                      var zt3 = 0;
                      break r;
                    }
                    for (xt3 = 0; xt3 < Tt3; ++xt3) Dt3[Kr[xt3]] = y3(Ot3, 3);
                    var Ut3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Dt3, Gt3 = At3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, h3);
                    i: for (; l3(Zt3, 0, 7, Vt3, 19); ) {
                      if (y3(Xt3, 1)) {
                        var $t3 = 2 + 2 * y3(Xt3, 3);
                        if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3) break i;
                      } else Ut3 = Gt3;
                      for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                        S2(Xt3);
                        var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                        A3(Xt3, Xt3.u + Qt3.g);
                        var te3 = Qt3.value;
                        if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                        else {
                          var ee3 = 16 == te3, ne3 = te3 - 16, re3 = Yr[ne3], ie3 = y3(Xt3, Gr[ne3]) + re3;
                          if (Ht3 + ie3 > Gt3) break i;
                          for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                        }
                      }
                      Jt3 = 1;
                      break i;
                    }
                    Jt3 || (Wt3.a = 3), Rt3 = Jt3;
                  }
                  (Rt3 = Rt3 && !Ot3.h) && (Ct3 = l3(It3, jt3, 8, kt3, At3)), Rt3 && 0 != Ct3 ? zt3 = Ct3 : (St2.a = 3, zt3 = 0);
                }
                if (0 == zt3) break n;
                if (Nt3 && 1 == Xr[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {
                  var oe3, se3 = pt3[0];
                  for (oe3 = 1; oe3 < ct3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                  Lt3 += se3;
                }
              }
              if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                var ue3, ce3 = mt3;
                for (ue3 = 0; ue3 < Rn; ++ue3) {
                  var le3 = ue3, he3 = ce3.pd[le3], fe3 = ce3.G[0][ce3.H[0] + le3];
                  256 <= fe3.value ? (he3.g = fe3.g + 256, he3.value = fe3.value) : (he3.g = 0, he3.value = 0, le3 >>= yt2(fe3, 8, he3), le3 >>= yt2(ce3.G[1][ce3.H[1] + le3], 16, he3), le3 >>= yt2(ce3.G[2][ce3.H[2] + le3], 0, he3), yt2(ce3.G[3][ce3.H[3] + le3], 24, he3));
                }
              }
            }
            Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = lt3, H5 = 1;
            break e;
          }
          H5 = 0;
        }
        if (!(c4 = H5)) {
          s3.a = 3;
          break t;
        }
        if (0 < b4) {
          if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
            s3.a = 1, c4 = 0;
            break t;
          }
        } else m4.ua = 0;
        var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
        if (de3.c = pe3, de3.i = ge3, me3.md = E2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, r3) {
          s3.xb = di;
          break t;
        }
        if (null == (v4 = a2(f4 * p4))) {
          s3.a = 1, c4 = 0;
          break t;
        }
        c4 = (c4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
        break t;
      }
      return c4 ? (null != u4 ? u4[0] = v4 : (e2(null == v4), e2(r3)), s3.$ = 0, r3 || Pt2(m4)) : Pt2(m4), c4;
    }
    function It2(t5, n3) {
      var r3 = t5.c * t5.i, i3 = r3 + n3 + 16 * n3;
      return e2(t5.c <= n3), t5.V = a2(i3), null == t5.V ? (t5.Ta = null, t5.Ua = 0, t5.a = 1, 0) : (t5.Ta = t5.V, t5.Ua = t5.Ba + r3 + n3, 1);
    }
    function jt2(t5, n3) {
      var r3 = t5.C, i3 = n3 - r3, a3 = t5.V, o3 = t5.Ba + t5.c * r3;
      for (e2(n3 <= t5.l.o); 0 < i3; ) {
        var s3 = 16 < i3 ? 16 : i3, u4 = t5.l.ma, c4 = t5.l.width, l4 = c4 * s3, h4 = u4.ca, f4 = u4.tb + c4 * r3, d4 = t5.Ta, p4 = t5.Ua;
        Nt2(t5, s3, a3, o3), Sr(d4, p4, h4, f4, l4), At2(u4, r3, r3 + s3, h4, f4, c4), i3 -= s3, a3 += s3 * t5.c, r3 += s3;
      }
      e2(r3 == n3), t5.C = t5.Ma = n3;
    }
    function Ct2() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ot2() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function Bt2() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
    }
    function Mt2() {
      this.Yb = (function() {
        var t5 = [];
        return (function t6(e3, n3, r3) {
          for (var i3 = r3[n3], a3 = 0; a3 < i3 && (e3.push(r3.length > n3 + 1 ? [] : 0), !(r3.length < n3 + 1)); a3++) t6(e3[a3], n3 + 1, r3);
        })(t5, 0, [3, 11]), t5;
      })();
    }
    function qt2() {
      this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
    }
    function Et2() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
    }
    function Rt2() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Dt2() {
      this.Na = this.la = 0;
    }
    function Tt2() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function zt2() {
      this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Ut2() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
    }
    function Ht2() {
      this.y = a2(16), this.f = a2(8), this.ea = a2(8);
    }
    function Wt2() {
      this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new Ct2(), this.Kc = new Ot2(), this.ed = new Et2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new qt2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Dt2()), this.sb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Rt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function Gt2() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Yt2() {
      var t5 = new Wt2();
      return null != t5 && (t5.a = 0, t5.sc = "OK", t5.cb = 0, t5.Xb = 0, ni || (ni = Zt2)), t5;
    }
    function Jt2(t5, e3, n3) {
      return 0 == t5.a && (t5.a = e3, t5.sc = n3, t5.cb = 0), 0;
    }
    function Xt2(t5, e3, n3) {
      return 3 <= n3 && 157 == t5[e3 + 0] && 1 == t5[e3 + 1] && 42 == t5[e3 + 2];
    }
    function Kt2(t5, n3) {
      if (null == t5) return 0;
      if (t5.a = 0, t5.sc = "OK", null == n3) return Jt2(t5, 2, "null VP8Io passed to VP8GetHeaders()");
      var r3 = n3.data, a3 = n3.w, o3 = n3.ha;
      if (4 > o3) return Jt2(t5, 7, "Truncated header.");
      var s3 = r3[a3 + 0] | r3[a3 + 1] << 8 | r3[a3 + 2] << 16, u4 = t5.Od;
      if (u4.Rb = !(1 & s3), u4.td = s3 >> 1 & 7, u4.yd = s3 >> 4 & 1, u4.ub = s3 >> 5, 3 < u4.td) return Jt2(t5, 3, "Incorrect keyframe parameters.");
      if (!u4.yd) return Jt2(t5, 4, "Frame not displayable.");
      a3 += 3, o3 -= 3;
      var c4 = t5.Kc;
      if (u4.Rb) {
        if (7 > o3) return Jt2(t5, 7, "cannot parse picture header");
        if (!Xt2(r3, a3, o3)) return Jt2(t5, 3, "Bad code word");
        c4.c = 16383 & (r3[a3 + 4] << 8 | r3[a3 + 3]), c4.Td = r3[a3 + 4] >> 6, c4.i = 16383 & (r3[a3 + 6] << 8 | r3[a3 + 5]), c4.Ud = r3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t5.za = c4.c + 15 >> 4, t5.Ub = c4.i + 15 >> 4, n3.width = c4.c, n3.height = c4.i, n3.Da = 0, n3.j = 0, n3.v = 0, n3.va = n3.width, n3.o = n3.height, n3.da = 0, n3.ib = n3.width, n3.hb = n3.height, n3.U = n3.width, n3.T = n3.height, i2((s3 = t5.Pa).jb, 0, 255, s3.jb.length), e2(null != (s3 = t5.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
      }
      if (u4.ub > o3) return Jt2(t5, 7, "bad partition length");
      p3(s3 = t5.m, r3, a3, u4.ub), a3 += u4.ub, o3 -= u4.ub, u4.Rb && (c4.Ld = P2(s3), c4.Kd = P2(s3)), c4 = t5.Qa;
      var l4, h4 = t5.Pa;
      if (e2(null != s3), e2(null != c4), c4.Cb = P2(s3), c4.Cb) {
        if (c4.Bb = P2(s3), P2(s3)) {
          for (c4.Fb = P2(s3), l4 = 0; 4 > l4; ++l4) c4.Zb[l4] = P2(s3) ? m3(s3, 7) : 0;
          for (l4 = 0; 4 > l4; ++l4) c4.Lb[l4] = P2(s3) ? m3(s3, 6) : 0;
        }
        if (c4.Bb) for (l4 = 0; 3 > l4; ++l4) h4.jb[l4] = P2(s3) ? g3(s3, 8) : 255;
      } else c4.Bb = 0;
      if (s3.Ka) return Jt2(t5, 3, "cannot parse segment header");
      if ((c4 = t5.ed).zd = P2(s3), c4.Tb = g3(s3, 6), c4.wb = g3(s3, 3), c4.Pc = P2(s3), c4.Pc && P2(s3)) {
        for (h4 = 0; 4 > h4; ++h4) P2(s3) && (c4.vd[h4] = m3(s3, 6));
        for (h4 = 0; 4 > h4; ++h4) P2(s3) && (c4.od[h4] = m3(s3, 6));
      }
      if (t5.L = 0 == c4.Tb ? 0 : c4.zd ? 1 : 2, s3.Ka) return Jt2(t5, 3, "cannot parse filter header");
      var f4 = o3;
      if (o3 = l4 = a3, a3 = l4 + f4, c4 = f4, t5.Xb = (1 << g3(t5.m, 2)) - 1, f4 < 3 * (h4 = t5.Xb)) r3 = 7;
      else {
        for (l4 += 3 * h4, c4 -= 3 * h4, f4 = 0; f4 < h4; ++f4) {
          var d4 = r3[o3 + 0] | r3[o3 + 1] << 8 | r3[o3 + 2] << 16;
          d4 > c4 && (d4 = c4), p3(t5.Jc[+f4], r3, l4, d4), l4 += d4, c4 -= d4, o3 += 3;
        }
        p3(t5.Jc[+h4], r3, l4, c4), r3 = l4 < a3 ? 0 : 5;
      }
      if (0 != r3) return Jt2(t5, r3, "cannot parse partitions");
      for (r3 = g3(l4 = t5.m, 7), o3 = P2(l4) ? m3(l4, 4) : 0, a3 = P2(l4) ? m3(l4, 4) : 0, c4 = P2(l4) ? m3(l4, 4) : 0, h4 = P2(l4) ? m3(l4, 4) : 0, l4 = P2(l4) ? m3(l4, 4) : 0, f4 = t5.Qa, d4 = 0; 4 > d4; ++d4) {
        if (f4.Cb) {
          var v4 = f4.Zb[d4];
          f4.Fb || (v4 += r3);
        } else {
          if (0 < d4) {
            t5.pb[d4] = t5.pb[0];
            continue;
          }
          v4 = r3;
        }
        var b4 = t5.pb[d4];
        b4.Sc[0] = ti[Vt2(v4 + o3, 127)], b4.Sc[1] = ei[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ti[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ei[Vt2(v4 + c4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ti[Vt2(v4 + h4, 117)], b4.Qc[1] = ei[Vt2(v4 + l4, 127)], b4.lc = v4 + l4;
      }
      if (!u4.Rb) return Jt2(t5, 4, "Not a key frame.");
      for (P2(s3), u4 = t5.Pa, r3 = 0; 4 > r3; ++r3) {
        for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (c4 = 0; 11 > c4; ++c4) h4 = k2(s3, ui[r3][o3][a3][c4]) ? g3(s3, 8) : oi[r3][o3][a3][c4], u4.Wc[r3][o3].Yb[a3][c4] = h4;
        for (o3 = 0; 17 > o3; ++o3) u4.Xc[r3][o3] = u4.Wc[r3][ci[o3]];
      }
      return t5.kc = P2(s3), t5.kc && (t5.Bd = g3(s3, 8)), t5.cb = 1;
    }
    function Zt2(t5, e3, n3, r3, i3, a3, o3) {
      var s3 = e3[i3].Yb[n3];
      for (n3 = 0; 16 > i3; ++i3) {
        if (!k2(t5, s3[n3 + 0])) return i3;
        for (; !k2(t5, s3[n3 + 1]); ) if (s3 = e3[++i3].Yb[0], n3 = 0, 16 == i3) return 16;
        var u4 = e3[i3 + 1].Yb;
        if (k2(t5, s3[n3 + 2])) {
          var c4 = t5, l4 = 0;
          if (k2(c4, (f4 = s3)[(h4 = n3) + 3])) if (k2(c4, f4[h4 + 6])) {
            for (s3 = 0, h4 = 2 * (l4 = k2(c4, f4[h4 + 8])) + (f4 = k2(c4, f4[h4 + 9 + l4])), l4 = 0, f4 = ri[h4]; f4[s3]; ++s3) l4 += l4 + k2(c4, f4[s3]);
            l4 += 3 + (8 << h4);
          } else k2(c4, f4[h4 + 7]) ? (l4 = 7 + 2 * k2(c4, 165), l4 += k2(c4, 145)) : l4 = 5 + k2(c4, 159);
          else l4 = k2(c4, f4[h4 + 4]) ? 3 + k2(c4, f4[h4 + 5]) : 2;
          s3 = u4[2];
        } else l4 = 1, s3 = u4[1];
        u4 = o3 + ii[i3], 0 > (c4 = t5).b && _2(c4);
        var h4, f4 = c4.b, d4 = (h4 = c4.Ca >> 1) - (c4.I >> f4) >> 31;
        --c4.b, c4.Ca += d4, c4.Ca |= 1, c4.I -= (h4 + 1 & d4) << f4, a3[u4] = ((l4 ^ d4) - d4) * r3[(0 < i3) + 0];
      }
      return 16;
    }
    function $t2(t5) {
      var e3 = t5.rb[t5.sb - 1];
      e3.la = 0, e3.Na = 0, i2(t5.zc, 0, 0, t5.zc.length), t5.ja = 0;
    }
    function Qt2(t5, e3, n3, r3, i3) {
      i3 = t5[e3 + n3 + 32 * r3] + (i3 >> 3), t5[e3 + n3 + 32 * r3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
    }
    function te2(t5, e3, n3, r3, i3, a3) {
      Qt2(t5, e3, 0, n3, r3 + i3), Qt2(t5, e3, 1, n3, r3 + a3), Qt2(t5, e3, 2, n3, r3 - a3), Qt2(t5, e3, 3, n3, r3 - i3);
    }
    function ee2(t5) {
      return (20091 * t5 >> 16) + t5;
    }
    function ne2(t5, e3, n3, r3) {
      var i3, o3 = 0, s3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var u4 = t5[e3 + 0] + t5[e3 + 8], c4 = t5[e3 + 0] - t5[e3 + 8], l4 = (35468 * t5[e3 + 4] >> 16) - ee2(t5[e3 + 12]), h4 = ee2(t5[e3 + 4]) + (35468 * t5[e3 + 12] >> 16);
        s3[o3 + 0] = u4 + h4, s3[o3 + 1] = c4 + l4, s3[o3 + 2] = c4 - l4, s3[o3 + 3] = u4 - h4, o3 += 4, e3++;
      }
      for (i3 = o3 = 0; 4 > i3; ++i3) u4 = (t5 = s3[o3 + 0] + 4) + s3[o3 + 8], c4 = t5 - s3[o3 + 8], l4 = (35468 * s3[o3 + 4] >> 16) - ee2(s3[o3 + 12]), Qt2(n3, r3, 0, 0, u4 + (h4 = ee2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), Qt2(n3, r3, 1, 0, c4 + l4), Qt2(n3, r3, 2, 0, c4 - l4), Qt2(n3, r3, 3, 0, u4 - h4), o3++, r3 += 32;
    }
    function re2(t5, e3, n3, r3) {
      var i3 = t5[e3 + 0] + 4, a3 = 35468 * t5[e3 + 4] >> 16, o3 = ee2(t5[e3 + 4]), s3 = 35468 * t5[e3 + 1] >> 16;
      te2(n3, r3, 0, i3 + o3, t5 = ee2(t5[e3 + 1]), s3), te2(n3, r3, 1, i3 + a3, t5, s3), te2(n3, r3, 2, i3 - a3, t5, s3), te2(n3, r3, 3, i3 - o3, t5, s3);
    }
    function ie2(t5, e3, n3, r3, i3) {
      ne2(t5, e3, n3, r3), i3 && ne2(t5, e3 + 16, n3, r3 + 4);
    }
    function ae2(t5, e3, n3, r3) {
      ar(t5, e3 + 0, n3, r3, 1), ar(t5, e3 + 32, n3, r3 + 128, 1);
    }
    function oe2(t5, e3, n3, r3) {
      var i3;
      for (t5 = t5[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e3 = 0; 4 > e3; ++e3) Qt2(n3, r3, e3, i3, t5);
    }
    function se2(t5, e3, n3, r3) {
      t5[e3 + 0] && ur(t5, e3 + 0, n3, r3), t5[e3 + 16] && ur(t5, e3 + 16, n3, r3 + 4), t5[e3 + 32] && ur(t5, e3 + 32, n3, r3 + 128), t5[e3 + 48] && ur(t5, e3 + 48, n3, r3 + 128 + 4);
    }
    function ue2(t5, e3, n3, r3) {
      var i3, o3 = a2(16);
      for (i3 = 0; 4 > i3; ++i3) {
        var s3 = t5[e3 + 0 + i3] + t5[e3 + 12 + i3], u4 = t5[e3 + 4 + i3] + t5[e3 + 8 + i3], c4 = t5[e3 + 4 + i3] - t5[e3 + 8 + i3], l4 = t5[e3 + 0 + i3] - t5[e3 + 12 + i3];
        o3[0 + i3] = s3 + u4, o3[8 + i3] = s3 - u4, o3[4 + i3] = l4 + c4, o3[12 + i3] = l4 - c4;
      }
      for (i3 = 0; 4 > i3; ++i3) s3 = (t5 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], u4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], c4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], l4 = t5 - o3[3 + 4 * i3], n3[r3 + 0] = s3 + u4 >> 3, n3[r3 + 16] = l4 + c4 >> 3, n3[r3 + 32] = s3 - u4 >> 3, n3[r3 + 48] = l4 - c4 >> 3, r3 += 64;
    }
    function ce2(t5, e3, n3) {
      var r3, i3 = e3 - 32, a3 = Or, o3 = 255 - t5[i3 - 1];
      for (r3 = 0; r3 < n3; ++r3) {
        var s3, u4 = a3, c4 = o3 + t5[e3 - 1];
        for (s3 = 0; s3 < n3; ++s3) t5[e3 + s3] = u4[c4 + t5[i3 + s3]];
        e3 += 32;
      }
    }
    function le2(t5, e3) {
      ce2(t5, e3, 4);
    }
    function he2(t5, e3) {
      ce2(t5, e3, 8);
    }
    function fe2(t5, e3) {
      ce2(t5, e3, 16);
    }
    function de2(t5, e3) {
      var n3;
      for (n3 = 0; 16 > n3; ++n3) r2(t5, e3 + 32 * n3, t5, e3 - 32, 16);
    }
    function pe2(t5, e3) {
      var n3;
      for (n3 = 16; 0 < n3; --n3) i2(t5, e3, t5[e3 - 1], 16), e3 += 32;
    }
    function ge2(t5, e3, n3) {
      var r3;
      for (r3 = 0; 16 > r3; ++r3) i2(e3, n3 + 32 * r3, t5, 16);
    }
    function me2(t5, e3) {
      var n3, r3 = 16;
      for (n3 = 0; 16 > n3; ++n3) r3 += t5[e3 - 1 + 32 * n3] + t5[e3 + n3 - 32];
      ge2(r3 >> 5, t5, e3);
    }
    function ve2(t5, e3) {
      var n3, r3 = 8;
      for (n3 = 0; 16 > n3; ++n3) r3 += t5[e3 - 1 + 32 * n3];
      ge2(r3 >> 4, t5, e3);
    }
    function be2(t5, e3) {
      var n3, r3 = 8;
      for (n3 = 0; 16 > n3; ++n3) r3 += t5[e3 + n3 - 32];
      ge2(r3 >> 4, t5, e3);
    }
    function ye2(t5, e3) {
      ge2(128, t5, e3);
    }
    function we2(t5, e3, n3) {
      return t5 + 2 * e3 + n3 + 2 >> 2;
    }
    function Ne2(t5, e3) {
      var n3, i3 = e3 - 32;
      for (i3 = new Uint8Array([we2(t5[i3 - 1], t5[i3 + 0], t5[i3 + 1]), we2(t5[i3 + 0], t5[i3 + 1], t5[i3 + 2]), we2(t5[i3 + 1], t5[i3 + 2], t5[i3 + 3]), we2(t5[i3 + 2], t5[i3 + 3], t5[i3 + 4])]), n3 = 0; 4 > n3; ++n3) r2(t5, e3 + 32 * n3, i3, 0, i3.length);
    }
    function Le2(t5, e3) {
      var n3 = t5[e3 - 1], r3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      F2(t5, e3 + 0, 16843009 * we2(t5[e3 - 1 - 32], n3, r3)), F2(t5, e3 + 32, 16843009 * we2(n3, r3, i3)), F2(t5, e3 + 64, 16843009 * we2(r3, i3, a3)), F2(t5, e3 + 96, 16843009 * we2(i3, a3, a3));
    }
    function xe2(t5, e3) {
      var n3, r3 = 4;
      for (n3 = 0; 4 > n3; ++n3) r3 += t5[e3 + n3 - 32] + t5[e3 - 1 + 32 * n3];
      for (r3 >>= 3, n3 = 0; 4 > n3; ++n3) i2(t5, e3 + 32 * n3, r3, 4);
    }
    function Ae2(t5, e3) {
      var n3 = t5[e3 - 1 + 0], r3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32], c4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 96] = we2(r3, i3, t5[e3 - 1 + 96]), t5[e3 + 1 + 96] = t5[e3 + 0 + 64] = we2(n3, r3, i3), t5[e3 + 2 + 96] = t5[e3 + 1 + 64] = t5[e3 + 0 + 32] = we2(a3, n3, r3), t5[e3 + 3 + 96] = t5[e3 + 2 + 64] = t5[e3 + 1 + 32] = t5[e3 + 0 + 0] = we2(o3, a3, n3), t5[e3 + 3 + 64] = t5[e3 + 2 + 32] = t5[e3 + 1 + 0] = we2(s3, o3, a3), t5[e3 + 3 + 32] = t5[e3 + 2 + 0] = we2(u4, s3, o3), t5[e3 + 3 + 0] = we2(c4, u4, s3);
    }
    function Se2(t5, e3) {
      var n3 = t5[e3 + 1 - 32], r3 = t5[e3 + 2 - 32], i3 = t5[e3 + 3 - 32], a3 = t5[e3 + 4 - 32], o3 = t5[e3 + 5 - 32], s3 = t5[e3 + 6 - 32], u4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = we2(t5[e3 + 0 - 32], n3, r3), t5[e3 + 1 + 0] = t5[e3 + 0 + 32] = we2(n3, r3, i3), t5[e3 + 2 + 0] = t5[e3 + 1 + 32] = t5[e3 + 0 + 64] = we2(r3, i3, a3), t5[e3 + 3 + 0] = t5[e3 + 2 + 32] = t5[e3 + 1 + 64] = t5[e3 + 0 + 96] = we2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 64] = t5[e3 + 1 + 96] = we2(a3, o3, s3), t5[e3 + 3 + 64] = t5[e3 + 2 + 96] = we2(o3, s3, u4), t5[e3 + 3 + 96] = we2(s3, u4, u4);
    }
    function _e2(t5, e3) {
      var n3 = t5[e3 - 1 + 0], r3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 - 32], o3 = t5[e3 + 0 - 32], s3 = t5[e3 + 1 - 32], u4 = t5[e3 + 2 - 32], c4 = t5[e3 + 3 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 3 + 64] = s3 + u4 + 1 >> 1, t5[e3 + 3 + 0] = u4 + c4 + 1 >> 1, t5[e3 + 0 + 96] = we2(i3, r3, n3), t5[e3 + 0 + 64] = we2(r3, n3, a3), t5[e3 + 0 + 32] = t5[e3 + 1 + 96] = we2(n3, a3, o3), t5[e3 + 1 + 32] = t5[e3 + 2 + 96] = we2(a3, o3, s3), t5[e3 + 2 + 32] = t5[e3 + 3 + 96] = we2(o3, s3, u4), t5[e3 + 3 + 32] = we2(s3, u4, c4);
    }
    function Pe2(t5, e3) {
      var n3 = t5[e3 + 0 - 32], r3 = t5[e3 + 1 - 32], i3 = t5[e3 + 2 - 32], a3 = t5[e3 + 3 - 32], o3 = t5[e3 + 4 - 32], s3 = t5[e3 + 5 - 32], u4 = t5[e3 + 6 - 32], c4 = t5[e3 + 7 - 32];
      t5[e3 + 0 + 0] = n3 + r3 + 1 >> 1, t5[e3 + 1 + 0] = t5[e3 + 0 + 64] = r3 + i3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 3 + 0] = t5[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = we2(n3, r3, i3), t5[e3 + 1 + 32] = t5[e3 + 0 + 96] = we2(r3, i3, a3), t5[e3 + 2 + 32] = t5[e3 + 1 + 96] = we2(i3, a3, o3), t5[e3 + 3 + 32] = t5[e3 + 2 + 96] = we2(a3, o3, s3), t5[e3 + 3 + 64] = we2(o3, s3, u4), t5[e3 + 3 + 96] = we2(s3, u4, c4);
    }
    function ke2(t5, e3) {
      var n3 = t5[e3 - 1 + 0], r3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96];
      t5[e3 + 0 + 0] = n3 + r3 + 1 >> 1, t5[e3 + 2 + 0] = t5[e3 + 0 + 32] = r3 + i3 + 1 >> 1, t5[e3 + 2 + 32] = t5[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t5[e3 + 1 + 0] = we2(n3, r3, i3), t5[e3 + 3 + 0] = t5[e3 + 1 + 32] = we2(r3, i3, a3), t5[e3 + 3 + 32] = t5[e3 + 1 + 64] = we2(i3, a3, a3), t5[e3 + 3 + 64] = t5[e3 + 2 + 64] = t5[e3 + 0 + 96] = t5[e3 + 1 + 96] = t5[e3 + 2 + 96] = t5[e3 + 3 + 96] = a3;
    }
    function Fe2(t5, e3) {
      var n3 = t5[e3 - 1 + 0], r3 = t5[e3 - 1 + 32], i3 = t5[e3 - 1 + 64], a3 = t5[e3 - 1 + 96], o3 = t5[e3 - 1 - 32], s3 = t5[e3 + 0 - 32], u4 = t5[e3 + 1 - 32], c4 = t5[e3 + 2 - 32];
      t5[e3 + 0 + 0] = t5[e3 + 2 + 32] = n3 + o3 + 1 >> 1, t5[e3 + 0 + 32] = t5[e3 + 2 + 64] = r3 + n3 + 1 >> 1, t5[e3 + 0 + 64] = t5[e3 + 2 + 96] = i3 + r3 + 1 >> 1, t5[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t5[e3 + 3 + 0] = we2(s3, u4, c4), t5[e3 + 2 + 0] = we2(o3, s3, u4), t5[e3 + 1 + 0] = t5[e3 + 3 + 32] = we2(n3, o3, s3), t5[e3 + 1 + 32] = t5[e3 + 3 + 64] = we2(r3, n3, o3), t5[e3 + 1 + 64] = t5[e3 + 3 + 96] = we2(i3, r3, n3), t5[e3 + 1 + 96] = we2(a3, i3, r3);
    }
    function Ie2(t5, e3) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3) r2(t5, e3 + 32 * n3, t5, e3 - 32, 8);
    }
    function je2(t5, e3) {
      var n3;
      for (n3 = 0; 8 > n3; ++n3) i2(t5, e3, t5[e3 - 1], 8), e3 += 32;
    }
    function Ce(t5, e3, n3) {
      var r3;
      for (r3 = 0; 8 > r3; ++r3) i2(e3, n3 + 32 * r3, t5, 8);
    }
    function Oe(t5, e3) {
      var n3, r3 = 8;
      for (n3 = 0; 8 > n3; ++n3) r3 += t5[e3 + n3 - 32] + t5[e3 - 1 + 32 * n3];
      Ce(r3 >> 4, t5, e3);
    }
    function Be(t5, e3) {
      var n3, r3 = 4;
      for (n3 = 0; 8 > n3; ++n3) r3 += t5[e3 + n3 - 32];
      Ce(r3 >> 3, t5, e3);
    }
    function Me(t5, e3) {
      var n3, r3 = 4;
      for (n3 = 0; 8 > n3; ++n3) r3 += t5[e3 - 1 + 32 * n3];
      Ce(r3 >> 3, t5, e3);
    }
    function qe(t5, e3) {
      Ce(128, t5, e3);
    }
    function Ee(t5, e3, n3) {
      var r3 = t5[e3 - n3], i3 = t5[e3 + 0], a3 = 3 * (i3 - r3) + jr[1020 + t5[e3 - 2 * n3] - t5[e3 + n3]], o3 = Cr[112 + (a3 + 4 >> 3)];
      t5[e3 - n3] = Or[255 + r3 + Cr[112 + (a3 + 3 >> 3)]], t5[e3 + 0] = Or[255 + i3 - o3];
    }
    function Re(t5, e3, n3, r3) {
      var i3 = t5[e3 + 0], a3 = t5[e3 + n3];
      return Br[255 + t5[e3 - 2 * n3] - t5[e3 - n3]] > r3 || Br[255 + a3 - i3] > r3;
    }
    function De(t5, e3, n3, r3) {
      return 4 * Br[255 + t5[e3 - n3] - t5[e3 + 0]] + Br[255 + t5[e3 - 2 * n3] - t5[e3 + n3]] <= r3;
    }
    function Te(t5, e3, n3, r3, i3) {
      var a3 = t5[e3 - 3 * n3], o3 = t5[e3 - 2 * n3], s3 = t5[e3 - n3], u4 = t5[e3 + 0], c4 = t5[e3 + n3], l4 = t5[e3 + 2 * n3], h4 = t5[e3 + 3 * n3];
      return 4 * Br[255 + s3 - u4] + Br[255 + o3 - c4] > r3 ? 0 : Br[255 + t5[e3 - 4 * n3] - a3] <= i3 && Br[255 + a3 - o3] <= i3 && Br[255 + o3 - s3] <= i3 && Br[255 + h4 - l4] <= i3 && Br[255 + l4 - c4] <= i3 && Br[255 + c4 - u4] <= i3;
    }
    function ze(t5, e3, n3, r3) {
      var i3 = 2 * r3 + 1;
      for (r3 = 0; 16 > r3; ++r3) De(t5, e3 + r3, n3, i3) && Ee(t5, e3 + r3, n3);
    }
    function Ue(t5, e3, n3, r3) {
      var i3 = 2 * r3 + 1;
      for (r3 = 0; 16 > r3; ++r3) De(t5, e3 + r3 * n3, 1, i3) && Ee(t5, e3 + r3 * n3, 1);
    }
    function He(t5, e3, n3, r3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) ze(t5, e3 += 4 * n3, n3, r3);
    }
    function We(t5, e3, n3, r3) {
      var i3;
      for (i3 = 3; 0 < i3; --i3) Ue(t5, e3 += 4, n3, r3);
    }
    function Ve(t5, e3, n3, r3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Te(t5, e3, n3, a3, o3)) if (Re(t5, e3, n3, s3)) Ee(t5, e3, n3);
        else {
          var u4 = t5, c4 = e3, l4 = n3, h4 = u4[c4 - 2 * l4], f4 = u4[c4 - l4], d4 = u4[c4 + 0], p4 = u4[c4 + l4], g4 = u4[c4 + 2 * l4], m4 = 27 * (b4 = jr[1020 + 3 * (d4 - f4) + jr[1020 + h4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
          u4[c4 - 3 * l4] = Or[255 + u4[c4 - 3 * l4] + b4], u4[c4 - 2 * l4] = Or[255 + h4 + v4], u4[c4 - l4] = Or[255 + f4 + m4], u4[c4 + 0] = Or[255 + d4 - m4], u4[c4 + l4] = Or[255 + p4 - v4], u4[c4 + 2 * l4] = Or[255 + g4 - b4];
        }
        e3 += r3;
      }
    }
    function Ge(t5, e3, n3, r3, i3, a3, o3, s3) {
      for (a3 = 2 * a3 + 1; 0 < i3--; ) {
        if (Te(t5, e3, n3, a3, o3)) if (Re(t5, e3, n3, s3)) Ee(t5, e3, n3);
        else {
          var u4 = t5, c4 = e3, l4 = n3, h4 = u4[c4 - l4], f4 = u4[c4 + 0], d4 = u4[c4 + l4], p4 = Cr[112 + (4 + (g4 = 3 * (f4 - h4)) >> 3)], g4 = Cr[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
          u4[c4 - 2 * l4] = Or[255 + u4[c4 - 2 * l4] + m4], u4[c4 - l4] = Or[255 + h4 + g4], u4[c4 + 0] = Or[255 + f4 - p4], u4[c4 + l4] = Or[255 + d4 - m4];
        }
        e3 += r3;
      }
    }
    function Ye(t5, e3, n3, r3, i3, a3) {
      Ve(t5, e3, n3, 1, 16, r3, i3, a3);
    }
    function Je(t5, e3, n3, r3, i3, a3) {
      Ve(t5, e3, 1, n3, 16, r3, i3, a3);
    }
    function Xe(t5, e3, n3, r3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ge(t5, e3 += 4 * n3, n3, 1, 16, r3, i3, a3);
    }
    function Ke(t5, e3, n3, r3, i3, a3) {
      var o3;
      for (o3 = 3; 0 < o3; --o3) Ge(t5, e3 += 4, 1, n3, 16, r3, i3, a3);
    }
    function Ze(t5, e3, n3, r3, i3, a3, o3, s3) {
      Ve(t5, e3, i3, 1, 8, a3, o3, s3), Ve(n3, r3, i3, 1, 8, a3, o3, s3);
    }
    function $e(t5, e3, n3, r3, i3, a3, o3, s3) {
      Ve(t5, e3, 1, i3, 8, a3, o3, s3), Ve(n3, r3, 1, i3, 8, a3, o3, s3);
    }
    function Qe(t5, e3, n3, r3, i3, a3, o3, s3) {
      Ge(t5, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ge(n3, r3 + 4 * i3, i3, 1, 8, a3, o3, s3);
    }
    function tn(t5, e3, n3, r3, i3, a3, o3, s3) {
      Ge(t5, e3 + 4, 1, i3, 8, a3, o3, s3), Ge(n3, r3 + 4, 1, i3, 8, a3, o3, s3);
    }
    function en() {
      this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ut2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function nn() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function rn() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function an() {
      this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new h3();
    }
    function on() {
      this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new an(), this.ab = 0, this.gc = o2(4, rn), this.Oc = 0;
    }
    function sn() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function un(t5, e3, n3, r3, i3, a3, o3) {
      for (t5 = null == t5 ? 0 : t5[e3 + 0], e3 = 0; e3 < o3; ++e3) i3[a3 + e3] = t5 + n3[r3 + e3] & 255, t5 = i3[a3 + e3];
    }
    function cn(t5, e3, n3, r3, i3, a3, o3) {
      var s3;
      if (null == t5) un(null, null, n3, r3, i3, a3, o3);
      else for (s3 = 0; s3 < o3; ++s3) i3[a3 + s3] = t5[e3 + s3] + n3[r3 + s3] & 255;
    }
    function ln2(t5, e3, n3, r3, i3, a3, o3) {
      if (null == t5) un(null, null, n3, r3, i3, a3, o3);
      else {
        var s3, u4 = t5[e3 + 0], c4 = u4, l4 = u4;
        for (s3 = 0; s3 < o3; ++s3) c4 = l4 + (u4 = t5[e3 + s3]) - c4, l4 = n3[r3 + s3] + (-256 & c4 ? 0 > c4 ? 0 : 255 : c4) & 255, c4 = u4, i3[a3 + s3] = l4;
      }
    }
    function hn(t5, n3, i3, o3) {
      var s3 = n3.width, u4 = n3.o;
      if (e2(null != t5 && null != n3), 0 > i3 || 0 >= o3 || i3 + o3 > u4) return null;
      if (!t5.Cc) {
        if (null == t5.ga) {
          var c4;
          if (t5.ga = new sn(), (c4 = null == t5.ga) || (c4 = n3.width * n3.o, e2(0 == t5.Gb.length), t5.Gb = a2(c4), t5.Uc = 0, null == t5.Gb ? c4 = 0 : (t5.mb = t5.Gb, t5.nb = t5.Uc, t5.rc = null, c4 = 1), c4 = !c4), !c4) {
            c4 = t5.ga;
            var l4 = t5.Fa, h4 = t5.P, f4 = t5.qc, d4 = t5.mb, p4 = t5.nb, g4 = h4 + 1, m4 = f4 - 1, b4 = c4.l;
            if (e2(null != l4 && null != d4 && null != n3), gi[0] = null, gi[1] = un, gi[2] = cn, gi[3] = ln2, c4.ca = d4, c4.tb = p4, c4.c = n3.width, c4.i = n3.height, e2(0 < c4.c && 0 < c4.i), 1 >= f4) n3 = 0;
            else if (c4.$a = 3 & l4[h4 + 0], c4.Z = l4[h4 + 0] >> 2 & 3, c4.Lc = l4[h4 + 0] >> 4 & 3, h4 = l4[h4 + 0] >> 6 & 3, 0 > c4.$a || 1 < c4.$a || 4 <= c4.Z || 1 < c4.Lc || h4) n3 = 0;
            else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = c4, b4.width = n3.width, b4.height = n3.height, b4.Da = n3.Da, b4.v = n3.v, b4.va = n3.va, b4.j = n3.j, b4.o = n3.o, c4.$a) t: {
              e2(1 == c4.$a), n3 = kt2();
              e: for (; ; ) {
                if (null == n3) {
                  n3 = 0;
                  break t;
                }
                if (e2(null != c4), c4.mc = n3, n3.c = c4.c, n3.i = c4.i, n3.l = c4.l, n3.l.ma = c4, n3.l.width = c4.c, n3.l.height = c4.i, n3.a = 0, v3(n3.m, l4, g4, m4), !Ft2(c4.c, c4.i, 1, n3, null)) break e;
                if (1 == n3.ab && 3 == n3.gc[0].hc && xt2(n3.s) ? (c4.ic = 1, l4 = n3.c * n3.i, n3.Ta = null, n3.Ua = 0, n3.V = a2(l4), n3.Ba = 0, null == n3.V ? (n3.a = 1, n3 = 0) : n3 = 1) : (c4.ic = 0, n3 = It2(n3, c4.c)), !n3) break e;
                n3 = 1;
                break t;
              }
              c4.mc = null, n3 = 0;
            }
            else n3 = m4 >= c4.c * c4.i;
            c4 = !n3;
          }
          if (c4) return null;
          1 != t5.ga.Lc ? t5.Ga = 0 : o3 = u4 - i3;
        }
        e2(null != t5.ga), e2(i3 + o3 <= u4);
        t: {
          if (n3 = (l4 = t5.ga).c, u4 = l4.l.o, 0 == l4.$a) {
            if (g4 = t5.rc, m4 = t5.Vc, b4 = t5.Fa, h4 = t5.P + 1 + i3 * n3, f4 = t5.mb, d4 = t5.nb + i3 * n3, e2(h4 <= t5.P + t5.qc), 0 != l4.Z) for (e2(null != gi[l4.Z]), c4 = 0; c4 < o3; ++c4) gi[l4.Z](g4, m4, b4, h4, f4, d4, n3), g4 = f4, m4 = d4, d4 += n3, h4 += n3;
            else for (c4 = 0; c4 < o3; ++c4) r2(f4, d4, b4, h4, n3), g4 = f4, m4 = d4, d4 += n3, h4 += n3;
            t5.rc = g4, t5.Vc = m4;
          } else {
            if (e2(null != l4.mc), n3 = i3 + o3, e2(null != (c4 = l4.mc)), e2(n3 <= c4.i), c4.C >= n3) n3 = 1;
            else if (l4.ic || mn(), l4.ic) {
              l4 = c4.V, g4 = c4.Ba, m4 = c4.c;
              var y4 = c4.i, w4 = (b4 = 1, h4 = c4.$ / m4, f4 = c4.$ % m4, d4 = c4.m, p4 = c4.s, c4.$), N4 = m4 * y4, L4 = m4 * n3, A4 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, h4) : null;
              e2(w4 <= N4), e2(n3 <= y4), e2(xt2(p4));
              e: for (; ; ) {
                for (; !d4.h && w4 < L4; ) {
                  if (f4 & A4 || (_3 = wt2(p4, f4, h4)), e2(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4))) l4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++h4 <= n3 && !(h4 % 16) && St(c4, h4));
                  else {
                    if (!(280 > y4)) {
                      b4 = 0;
                      break e;
                    }
                    y4 = mt2(y4 - 256, d4);
                    var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                    if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                      b4 = 0;
                      break e;
                    }
                    for (P3 = 0; P3 < y4; ++P3) l4[g4 + w4 + P3] = l4[g4 + w4 + P3 - k3];
                    for (w4 += y4, f4 += y4; f4 >= m4; ) f4 -= m4, ++h4 <= n3 && !(h4 % 16) && St(c4, h4);
                    w4 < L4 && f4 & A4 && (_3 = wt2(p4, f4, h4));
                  }
                  e2(d4.h == x3(d4));
                }
                St(c4, h4 > n3 ? n3 : h4);
                break e;
              }
              !b4 || d4.h && w4 < N4 ? (b4 = 0, c4.a = d4.h ? 5 : 3) : c4.$ = w4, n3 = b4;
            } else n3 = _t2(c4, c4.V, c4.Ba, c4.c, c4.i, n3, jt2);
            if (!n3) {
              o3 = 0;
              break t;
            }
          }
          i3 + o3 >= u4 && (t5.Cc = 1), o3 = 1;
        }
        if (!o3) return null;
        if (t5.Cc && (null != (o3 = t5.ga) && (o3.mc = null), t5.ga = null, 0 < t5.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return t5.nb + i3 * s3;
    }
    function fn(t5, e3, n3, r3, i3, a3) {
      for (; 0 < i3--; ) {
        var o3, s3 = t5, u4 = e3 + (n3 ? 1 : 0), c4 = t5, l4 = e3 + (n3 ? 0 : 3);
        for (o3 = 0; o3 < r3; ++o3) {
          var h4 = c4[l4 + 4 * o3];
          255 != h4 && (h4 *= 32897, s3[u4 + 4 * o3 + 0] = s3[u4 + 4 * o3 + 0] * h4 >> 23, s3[u4 + 4 * o3 + 1] = s3[u4 + 4 * o3 + 1] * h4 >> 23, s3[u4 + 4 * o3 + 2] = s3[u4 + 4 * o3 + 2] * h4 >> 23);
        }
        e3 += a3;
      }
    }
    function dn(t5, e3, n3, r3, i3) {
      for (; 0 < r3--; ) {
        var a3;
        for (a3 = 0; a3 < n3; ++a3) {
          var o3 = t5[e3 + 2 * a3 + 0], s3 = 15 & (c4 = t5[e3 + 2 * a3 + 1]), u4 = 4369 * s3, c4 = (240 & c4 | c4 >> 4) * u4 >> 16;
          t5[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * u4 >> 16 & 240 | (15 & o3 | o3 << 4) * u4 >> 16 >> 4 & 15, t5[e3 + 2 * a3 + 1] = 240 & c4 | s3;
        }
        e3 += i3;
      }
    }
    function pn(t5, e3, n3, r3, i3, a3, o3, s3) {
      var u4, c4, l4 = 255;
      for (c4 = 0; c4 < i3; ++c4) {
        for (u4 = 0; u4 < r3; ++u4) {
          var h4 = t5[e3 + u4];
          a3[o3 + 4 * u4] = h4, l4 &= h4;
        }
        e3 += n3, o3 += s3;
      }
      return 255 != l4;
    }
    function gn(t5, e3, n3, r3, i3) {
      var a3;
      for (a3 = 0; a3 < i3; ++a3) n3[r3 + a3] = t5[e3 + a3] >> 8;
    }
    function mn() {
      Lr = fn, xr = dn, Ar = pn, Sr = gn;
    }
    function vn(n3, r3, i3) {
      t4[n3] = function(t5, n4, a3, o3, s3, u4, c4, l4, h4, f4, d4, p4, g4, m4, v4, b4, y4) {
        var w4, N4 = y4 - 1 >> 1, L4 = s3[u4 + 0] | c4[l4 + 0] << 16, x4 = h4[f4 + 0] | d4[p4 + 0] << 16;
        e2(null != t5);
        var A4 = 3 * L4 + x4 + 131074 >> 2;
        for (r3(t5[n4 + 0], 255 & A4, A4 >> 16, g4, m4), null != a3 && (A4 = 3 * x4 + L4 + 131074 >> 2, r3(a3[o3 + 0], 255 & A4, A4 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
          var S3 = s3[u4 + w4] | c4[l4 + w4] << 16, _3 = h4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + x4 + _3 + 524296, k3 = P3 + 2 * (S3 + x4) >> 3;
          A4 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, r3(t5[n4 + 2 * w4 - 1], 255 & A4, A4 >> 16, g4, m4 + (2 * w4 - 1) * i3), r3(t5[n4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (A4 = P3 + x4 >> 1, L4 = k3 + _3 >> 1, r3(a3[o3 + 2 * w4 - 1], 255 & A4, A4 >> 16, v4, b4 + (2 * w4 - 1) * i3), r3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, x4 = _3;
        }
        1 & y4 || (A4 = 3 * L4 + x4 + 131074 >> 2, r3(t5[n4 + y4 - 1], 255 & A4, A4 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (A4 = 3 * x4 + L4 + 131074 >> 2, r3(a3[o3 + y4 - 1], 255 & A4, A4 >> 16, v4, b4 + (y4 - 1) * i3)));
      };
    }
    function bn() {
      mi[Mr] = vi, mi[qr] = yi, mi[Er] = bi, mi[Rr] = wi, mi[Dr] = Ni, mi[Tr] = Li, mi[zr] = xi, mi[Ur] = yi, mi[Hr] = wi, mi[Wr] = Ni, mi[Vr] = Li;
    }
    function yn(t5) {
      return t5 & -16384 ? 0 > t5 ? 0 : 255 : t5 >> ki;
    }
    function wn(t5, e3) {
      return yn((19077 * t5 >> 8) + (26149 * e3 >> 8) - 14234);
    }
    function Nn(t5, e3, n3) {
      return yn((19077 * t5 >> 8) - (6419 * e3 >> 8) - (13320 * n3 >> 8) + 8708);
    }
    function Ln(t5, e3) {
      return yn((19077 * t5 >> 8) + (33050 * e3 >> 8) - 17685);
    }
    function xn(t5, e3, n3, r3, i3) {
      r3[i3 + 0] = wn(t5, n3), r3[i3 + 1] = Nn(t5, e3, n3), r3[i3 + 2] = Ln(t5, e3);
    }
    function An(t5, e3, n3, r3, i3) {
      r3[i3 + 0] = Ln(t5, e3), r3[i3 + 1] = Nn(t5, e3, n3), r3[i3 + 2] = wn(t5, n3);
    }
    function Sn(t5, e3, n3, r3, i3) {
      var a3 = Nn(t5, e3, n3);
      e3 = a3 << 3 & 224 | Ln(t5, e3) >> 3, r3[i3 + 0] = 248 & wn(t5, n3) | a3 >> 5, r3[i3 + 1] = e3;
    }
    function _n(t5, e3, n3, r3, i3) {
      var a3 = 240 & Ln(t5, e3) | 15;
      r3[i3 + 0] = 240 & wn(t5, n3) | Nn(t5, e3, n3) >> 4, r3[i3 + 1] = a3;
    }
    function Pn(t5, e3, n3, r3, i3) {
      r3[i3 + 0] = 255, xn(t5, e3, n3, r3, i3 + 1);
    }
    function kn(t5, e3, n3, r3, i3) {
      An(t5, e3, n3, r3, i3), r3[i3 + 3] = 255;
    }
    function Fn(t5, e3, n3, r3, i3) {
      xn(t5, e3, n3, r3, i3), r3[i3 + 3] = 255;
    }
    function Vt2(t5, e3) {
      return 0 > t5 ? 0 : t5 > e3 ? e3 : t5;
    }
    function In(e3, n3, r3) {
      t4[e3] = function(t5, e4, i3, a3, o3, s3, u4, c4, l4) {
        for (var h4 = c4 + (-2 & l4) * r3; c4 != h4; ) n3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4), n3(t5[e4 + 1], i3[a3 + 0], o3[s3 + 0], u4, c4 + r3), e4 += 2, ++a3, ++s3, c4 += 2 * r3;
        1 & l4 && n3(t5[e4 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4);
      };
    }
    function jn(t5, e3, n3) {
      return 0 == n3 ? 0 == t5 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : n3;
    }
    function Cn(t5, e3, n3, r3, i3) {
      switch (t5 >>> 30) {
        case 3:
          ar(e3, n3, r3, i3, 0);
          break;
        case 2:
          or(e3, n3, r3, i3);
          break;
        case 1:
          ur(e3, n3, r3, i3);
      }
    }
    function On(t5, e3) {
      var n3, a3, o3 = e3.M, s3 = e3.Nb, u4 = t5.oc, c4 = t5.pc + 40, l4 = t5.oc, h4 = t5.pc + 584, f4 = t5.oc, d4 = t5.pc + 600;
      for (n3 = 0; 16 > n3; ++n3) u4[c4 + 32 * n3 - 1] = 129;
      for (n3 = 0; 8 > n3; ++n3) l4[h4 + 32 * n3 - 1] = 129, f4[d4 + 32 * n3 - 1] = 129;
      for (0 < o3 ? u4[c4 - 1 - 32] = l4[h4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(u4, c4 - 32 - 1, 127, 21), i2(l4, h4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t5.za; ++a3) {
        var p4 = e3.ya[e3.aa + a3];
        if (0 < a3) {
          for (n3 = -1; 16 > n3; ++n3) r2(u4, c4 + 32 * n3 - 4, u4, c4 + 32 * n3 + 12, 4);
          for (n3 = -1; 8 > n3; ++n3) r2(l4, h4 + 32 * n3 - 4, l4, h4 + 32 * n3 + 4, 4), r2(f4, d4 + 32 * n3 - 4, f4, d4 + 32 * n3 + 4, 4);
        }
        var g4 = t5.Gd, m4 = t5.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
        if (0 < o3 && (r2(u4, c4 - 32, g4[m4].y, 0, 16), r2(l4, h4 - 32, g4[m4].f, 0, 8), r2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
          var y4 = u4, w4 = c4 - 32 + 16;
          for (0 < o3 && (a3 >= t5.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : r2(y4, w4, g4[m4 + 1].y, 0, 4)), n3 = 0; 4 > n3; n3++) y4[w4 + 128 + n3] = y4[w4 + 256 + n3] = y4[w4 + 384 + n3] = y4[w4 + 0 + n3];
          for (n3 = 0; 16 > n3; ++n3, b4 <<= 2) y4 = u4, w4 = c4 + Ei[n3], hi[p4.Ob[n3]](y4, w4), Cn(b4, v4, 16 * +n3, y4, w4);
        } else if (y4 = jn(a3, o3, p4.Ob[0]), li[y4](u4, c4), 0 != b4) for (n3 = 0; 16 > n3; ++n3, b4 <<= 2) Cn(b4, v4, 16 * +n3, u4, c4 + Ei[n3]);
        for (n3 = p4.Gc, y4 = jn(a3, o3, p4.Dd), fi[y4](l4, h4), fi[y4](f4, d4), b4 = v4, y4 = l4, w4 = h4, 255 & (p4 = 0 | n3) && (170 & p4 ? sr(b4, 256, y4, w4) : cr(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (n3 >>= 8) && (170 & n3 ? sr(v4, 320, p4, b4) : cr(v4, 320, p4, b4)), o3 < t5.Ub - 1 && (r2(g4[m4].y, 0, u4, c4 + 480, 16), r2(g4[m4].f, 0, l4, h4 + 224, 8), r2(g4[m4].ea, 0, f4, d4 + 224, 8)), n3 = 8 * s3 * t5.B, g4 = t5.sa, m4 = t5.ta + 16 * a3 + 16 * s3 * t5.R, v4 = t5.qa, p4 = t5.ra + 8 * a3 + n3, b4 = t5.Ha, y4 = t5.Ia + 8 * a3 + n3, n3 = 0; 16 > n3; ++n3) r2(g4, m4 + n3 * t5.R, u4, c4 + 32 * n3, 16);
        for (n3 = 0; 8 > n3; ++n3) r2(v4, p4 + n3 * t5.B, l4, h4 + 32 * n3, 8), r2(b4, y4 + n3 * t5.B, f4, d4 + 32 * n3, 8);
      }
    }
    function Bn(t5, r3, i3, a3, o3, s3, u4, c4, l4) {
      var h4 = [0], f4 = [0], d4 = 0, p4 = null != l4 ? l4.kd : 0, g4 = null != l4 ? l4 : new nn();
      if (null == t5 || 12 > i3) return 7;
      g4.data = t5, g4.w = r3, g4.ha = i3, r3 = [r3], i3 = [i3], g4.gb = [g4.gb];
      t: {
        var m4 = r3, b4 = i3, y4 = g4.gb;
        if (e2(null != t5), e2(null != b4), e2(null != y4), y4[0] = 0, 12 <= b4[0] && !n2(t5, m4[0], "RIFF")) {
          if (n2(t5, m4[0] + 8, "WEBP")) {
            y4 = 3;
            break t;
          }
          var w4 = C2(t5, m4[0] + 4);
          if (12 > w4 || 4294967286 < w4) {
            y4 = 3;
            break t;
          }
          if (p4 && w4 > b4[0] - 8) {
            y4 = 7;
            break t;
          }
          y4[0] = w4, m4[0] += 12, b4[0] -= 12;
        }
        y4 = 0;
      }
      if (0 != y4) return y4;
      for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
        t: {
          var L4 = t5;
          b4 = r3, y4 = i3;
          var x4 = h4, A4 = f4, S3 = m4 = [0];
          if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0]) y4 = 7;
          else {
            if (!n2(L4, b4[0], "VP8X")) {
              if (10 != C2(L4, b4[0] + 4)) {
                y4 = 3;
                break t;
              }
              if (18 > y4[0]) {
                y4 = 7;
                break t;
              }
              var _3 = C2(L4, b4[0] + 8), P3 = 1 + j2(L4, b4[0] + 12);
              if (2147483648 <= P3 * (L4 = 1 + j2(L4, b4[0] + 15))) {
                y4 = 3;
                break t;
              }
              null != S3 && (S3[0] = _3), null != x4 && (x4[0] = P3), null != A4 && (A4[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
            }
            y4 = 0;
          }
        }
        if (d4 = d4[0], m4 = m4[0], 0 != y4) return y4;
        if (b4 = !!(2 & m4), !w4 && d4) return 3;
        if (null != s3 && (s3[0] = !!(16 & m4)), null != u4 && (u4[0] = b4), null != c4 && (c4[0] = 0), u4 = h4[0], m4 = f4[0], d4 && b4 && null == l4) {
          y4 = 0;
          break;
        }
        if (4 > i3) {
          y4 = 7;
          break;
        }
        if (w4 && d4 || !w4 && !d4 && !n2(t5, r3[0], "ALPH")) {
          i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
          t: {
            _3 = t5, y4 = r3, w4 = i3;
            var k3 = g4.gb;
            x4 = g4.na, A4 = g4.P, S3 = g4.Sa, P3 = 22, e2(null != _3), e2(null != w4), L4 = y4[0];
            var F3 = w4[0];
            for (e2(null != x4), e2(null != S3), x4[0] = null, A4[0] = null, S3[0] = 0; ; ) {
              if (y4[0] = L4, w4[0] = F3, 8 > F3) {
                y4 = 7;
                break t;
              }
              var I3 = C2(_3, L4 + 4);
              if (4294967286 < I3) {
                y4 = 3;
                break t;
              }
              var O3 = 8 + I3 + 1 & -2;
              if (P3 += O3, 0 < k3 && P3 > k3) {
                y4 = 3;
                break t;
              }
              if (!n2(_3, L4, "VP8 ") || !n2(_3, L4, "VP8L")) {
                y4 = 0;
                break t;
              }
              if (F3[0] < O3) {
                y4 = 7;
                break t;
              }
              n2(_3, L4, "ALPH") || (x4[0] = _3, A4[0] = L4 + 8, S3[0] = I3), L4 += O3, F3 -= O3;
            }
          }
          if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
        }
        i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
        t: if (k3 = t5, y4 = r3, w4 = i3, x4 = g4.gb[0], A4 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !n2(k3, _3, "VP8 "), P3 = !n2(k3, _3, "VP8L"), e2(null != k3), e2(null != w4), e2(null != A4), e2(null != S3), 8 > w4[0]) y4 = 7;
        else {
          if (L4 || P3) {
            if (k3 = C2(k3, _3 + 4), 12 <= x4 && k3 > x4 - 12) {
              y4 = 3;
              break t;
            }
            if (p4 && k3 > w4[0] - 8) {
              y4 = 7;
              break t;
            }
            A4[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
          } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), A4[0] = w4[0];
          y4 = 0;
        }
        if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], r3 = r3[0], 0 != y4) break;
        if (4294967286 < g4.Ja) return 3;
        if (null == c4 || b4 || (c4[0] = g4.xa ? 2 : 1), u4 = [u4], m4 = [m4], g4.xa) {
          if (5 > i3) {
            y4 = 7;
            break;
          }
          c4 = u4, p4 = m4, b4 = s3, null == t5 || 5 > i3 ? t5 = 0 : 5 <= i3 && 47 == t5[r3 + 0] && !(t5[r3 + 4] >> 5) ? (w4 = [0], k3 = [0], x4 = [0], v3(A4 = new N3(), t5, r3, i3), gt2(A4, w4, k3, x4) ? (null != c4 && (c4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = x4[0]), t5 = 1) : t5 = 0) : t5 = 0;
        } else {
          if (10 > i3) {
            y4 = 7;
            break;
          }
          c4 = m4, null == t5 || 10 > i3 || !Xt2(t5, r3 + 3, i3 - 3) ? t5 = 0 : (p4 = t5[r3 + 0] | t5[r3 + 1] << 8 | t5[r3 + 2] << 16, b4 = 16383 & (t5[r3 + 7] << 8 | t5[r3 + 6]), t5 = 16383 & (t5[r3 + 9] << 8 | t5[r3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t5 ? t5 = 0 : (u4 && (u4[0] = b4), c4 && (c4[0] = t5), t5 = 1));
        }
        if (!t5) return 3;
        if (u4 = u4[0], m4 = m4[0], d4 && (h4[0] != u4 || f4[0] != m4)) return 3;
        null != l4 && (l4[0] = g4, l4.offset = r3 - l4.w, e2(4294967286 > r3 - l4.w), e2(l4.offset == l4.ha - i3));
        break;
      }
      return 0 == y4 || 7 == y4 && d4 && null == l4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = u4), null != o3 && (o3[0] = m4), 0) : y4;
    }
    function Mn(t5, e3, n3) {
      var r3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = r3, u4 = i3;
      if (e3.Da = null != t5 && 0 < t5.Da, e3.Da && (s3 = t5.cd, u4 = t5.bd, a3 = t5.v, o3 = t5.j, 11 > n3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= u4 || a3 + s3 > r3 || o3 + u4 > i3)) return 0;
      if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + u4, e3.U = s3, e3.T = u4, e3.da = null != t5 && 0 < t5.da, e3.da) {
        if (!q2(s3, u4, n3 = [t5.ib], a3 = [t5.hb])) return 0;
        e3.ib = n3[0], e3.hb = a3[0];
      }
      return e3.ob = null != t5 && t5.ob, e3.Kb = null == t5 || !t5.Sd, e3.da && (e3.ob = e3.ib < 3 * r3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
    }
    function qn(t5) {
      if (null == t5) return 2;
      if (11 > t5.S) {
        var e3 = t5.f.RGBA;
        e3.fb += (t5.height - 1) * e3.A, e3.A = -e3.A;
      } else e3 = t5.f.kb, t5 = t5.height, e3.O += (t5 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t5 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t5 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t5 - 1) * e3.lb, e3.lb = -e3.lb);
      return 0;
    }
    function En(t5, e3, n3, r3) {
      if (null == r3 || 0 >= t5 || 0 >= e3) return 2;
      if (null != n3) {
        if (n3.Da) {
          var i3 = n3.cd, o3 = n3.bd, s3 = -2 & n3.v, u4 = -2 & n3.j;
          if (0 > s3 || 0 > u4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t5 || u4 + o3 > e3) return 2;
          t5 = i3, e3 = o3;
        }
        if (n3.da) {
          if (!q2(t5, e3, i3 = [n3.ib], o3 = [n3.hb])) return 2;
          t5 = i3[0], e3 = o3[0];
        }
      }
      r3.width = t5, r3.height = e3;
      t: {
        var c4 = r3.width, l4 = r3.height;
        if (t5 = r3.S, 0 >= c4 || 0 >= l4 || !(t5 >= Mr && 13 > t5)) t5 = 2;
        else {
          if (0 >= r3.Rd && null == r3.sd) {
            s3 = o3 = i3 = e3 = 0;
            var h4 = (u4 = c4 * zi[t5]) * l4;
            if (11 > t5 || (o3 = (l4 + 1) / 2 * (e3 = (c4 + 1) / 2), 12 == t5 && (s3 = (i3 = c4) * l4)), null == (l4 = a2(h4 + 2 * o3 + s3))) {
              t5 = 1;
              break t;
            }
            r3.sd = l4, 11 > t5 ? ((c4 = r3.f.RGBA).eb = l4, c4.fb = 0, c4.A = u4, c4.size = h4) : ((c4 = r3.f.kb).y = l4, c4.O = 0, c4.fa = u4, c4.Fd = h4, c4.f = l4, c4.N = 0 + h4, c4.Ab = e3, c4.Cd = o3, c4.ea = l4, c4.W = 0 + h4 + o3, c4.Db = e3, c4.Ed = o3, 12 == t5 && (c4.F = l4, c4.J = 0 + h4 + 2 * o3), c4.Tc = s3, c4.lb = i3);
          }
          if (e3 = 1, i3 = r3.S, o3 = r3.width, s3 = r3.height, i3 >= Mr && 13 > i3) if (11 > i3) t5 = r3.f.RGBA, e3 &= (u4 = Math.abs(t5.A)) * (s3 - 1) + o3 <= t5.size, e3 &= u4 >= o3 * zi[i3], e3 &= null != t5.eb;
          else {
            t5 = r3.f.kb, u4 = (o3 + 1) / 2, h4 = (s3 + 1) / 2, c4 = Math.abs(t5.fa), l4 = Math.abs(t5.Ab);
            var f4 = Math.abs(t5.Db), d4 = Math.abs(t5.lb), p4 = d4 * (s3 - 1) + o3;
            e3 &= c4 * (s3 - 1) + o3 <= t5.Fd, e3 &= l4 * (h4 - 1) + u4 <= t5.Cd, e3 = (e3 &= f4 * (h4 - 1) + u4 <= t5.Ed) & c4 >= o3 & l4 >= u4 & f4 >= u4, e3 &= null != t5.y, e3 &= null != t5.f, e3 &= null != t5.ea, 12 == i3 && (e3 &= d4 >= o3, e3 &= p4 <= t5.Tc, e3 &= null != t5.F);
          }
          else e3 = 0;
          t5 = e3 ? 0 : 2;
        }
      }
      return 0 != t5 || null != n3 && n3.fd && (t5 = qn(r3)), t5;
    }
    var Rn = 64, Dn = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tn = 24, zn = 32, Un = 8, Hn = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    D2("Predictor0", "PredictorAdd0"), t4.Predictor0 = function() {
      return 4278190080;
    }, t4.Predictor1 = function(t5) {
      return t5;
    }, t4.Predictor2 = function(t5, e3, n3) {
      return e3[n3 + 0];
    }, t4.Predictor3 = function(t5, e3, n3) {
      return e3[n3 + 1];
    }, t4.Predictor4 = function(t5, e3, n3) {
      return e3[n3 - 1];
    }, t4.Predictor5 = function(t5, e3, n3) {
      return z2(z2(t5, e3[n3 + 1]), e3[n3 + 0]);
    }, t4.Predictor6 = function(t5, e3, n3) {
      return z2(t5, e3[n3 - 1]);
    }, t4.Predictor7 = function(t5, e3, n3) {
      return z2(t5, e3[n3 + 0]);
    }, t4.Predictor8 = function(t5, e3, n3) {
      return z2(e3[n3 - 1], e3[n3 + 0]);
    }, t4.Predictor9 = function(t5, e3, n3) {
      return z2(e3[n3 + 0], e3[n3 + 1]);
    }, t4.Predictor10 = function(t5, e3, n3) {
      return z2(z2(t5, e3[n3 - 1]), z2(e3[n3 + 0], e3[n3 + 1]));
    }, t4.Predictor11 = function(t5, e3, n3) {
      var r3 = e3[n3 + 0];
      return 0 >= W2(r3 >> 24 & 255, t5 >> 24 & 255, (e3 = e3[n3 - 1]) >> 24 & 255) + W2(r3 >> 16 & 255, t5 >> 16 & 255, e3 >> 16 & 255) + W2(r3 >> 8 & 255, t5 >> 8 & 255, e3 >> 8 & 255) + W2(255 & r3, 255 & t5, 255 & e3) ? r3 : t5;
    }, t4.Predictor12 = function(t5, e3, n3) {
      var r3 = e3[n3 + 0];
      return (U2((t5 >> 24 & 255) + (r3 >> 24 & 255) - ((e3 = e3[n3 - 1]) >> 24 & 255)) << 24 | U2((t5 >> 16 & 255) + (r3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | U2((t5 >> 8 & 255) + (r3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | U2((255 & t5) + (255 & r3) - (255 & e3))) >>> 0;
    }, t4.Predictor13 = function(t5, e3, n3) {
      var r3 = e3[n3 - 1];
      return (H4((t5 = z2(t5, e3[n3 + 0])) >> 24 & 255, r3 >> 24 & 255) << 24 | H4(t5 >> 16 & 255, r3 >> 16 & 255) << 16 | H4(t5 >> 8 & 255, r3 >> 8 & 255) << 8 | H4(255 & t5, 255 & r3)) >>> 0;
    };
    var Wn = t4.PredictorAdd0;
    t4.PredictorAdd1 = V2, D2("Predictor2", "PredictorAdd2"), D2("Predictor3", "PredictorAdd3"), D2("Predictor4", "PredictorAdd4"), D2("Predictor5", "PredictorAdd5"), D2("Predictor6", "PredictorAdd6"), D2("Predictor7", "PredictorAdd7"), D2("Predictor8", "PredictorAdd8"), D2("Predictor9", "PredictorAdd9"), D2("Predictor10", "PredictorAdd10"), D2("Predictor11", "PredictorAdd11"), D2("Predictor12", "PredictorAdd12"), D2("Predictor13", "PredictorAdd13");
    var Vn = t4.PredictorAdd2;
    X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t5) {
      return t5 >> 8 & 255;
    }, function(t5) {
      return t5;
    }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t5) {
      return t5;
    }, function(t5) {
      return t5 >> 8 & 255;
    });
    var Gn, Yn = t4.ColorIndexInverseTransform, Jn = t4.MapARGB, Xn = t4.VP8LColorIndexInverseTransformAlpha, Kn = t4.MapAlpha, Zn = t4.VP8LPredictorsAdd = [];
    Zn.length = 16, (t4.VP8LPredictors = []).length = 16, (t4.VP8LPredictorsAdd_C = []).length = 16, (t4.VP8LPredictors_C = []).length = 16;
    var $n, Qn, tr, er, nr, rr, ir, ar, or, sr, ur, cr, lr, hr, fr, dr, pr, gr, mr, vr, br, yr, wr, Nr, Lr, xr, Ar, Sr, _r = a2(511), Pr = a2(2041), kr = a2(225), Fr = a2(767), Ir = 0, jr = Pr, Cr = kr, Or = Fr, Br = _r, Mr = 0, qr = 1, Er = 2, Rr = 3, Dr = 4, Tr = 5, zr = 6, Ur = 7, Hr = 8, Wr = 9, Vr = 10, Gr = [2, 3, 7], Yr = [3, 3, 11], Jr = [280, 256, 256, 256, 40], Xr = [0, 1, 1, 1, 0], Kr = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Zr = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], $r = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Qr = 8, ti = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ei = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ri = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ii = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], ai = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], oi = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], si = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ci = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], hi = [], fi = [], di = 1, pi = 2, gi = [], mi = [];
    vn("UpsampleRgbLinePair", xn, 3), vn("UpsampleBgrLinePair", An, 3), vn("UpsampleRgbaLinePair", Fn, 4), vn("UpsampleBgraLinePair", kn, 4), vn("UpsampleArgbLinePair", Pn, 4), vn("UpsampleRgba4444LinePair", _n, 2), vn("UpsampleRgb565LinePair", Sn, 2);
    var vi = t4.UpsampleRgbLinePair, bi = t4.UpsampleBgrLinePair, yi = t4.UpsampleRgbaLinePair, wi = t4.UpsampleBgraLinePair, Ni = t4.UpsampleArgbLinePair, Li = t4.UpsampleRgba4444LinePair, xi = t4.UpsampleRgb565LinePair, Ai = 16, Si = 1 << Ai - 1, _i = -227, Pi = 482, ki = 6, Ii = 0, ji = a2(256), Ci = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(Pi - _i), qi = a2(Pi - _i);
    In("YuvToRgbRow", xn, 3), In("YuvToBgrRow", An, 3), In("YuvToRgbaRow", Fn, 4), In("YuvToBgraRow", kn, 4), In("YuvToArgbRow", Pn, 4), In("YuvToRgba4444Row", _n, 2), In("YuvToRgb565Row", Sn, 2);
    var Ei = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Di = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ti = 1;
    this.WebPDecodeRGBA = function(t5, n3, s3, u4, c4) {
      var l4 = qr, h4 = new en(), f4 = new ot2();
      h4.ba = f4, f4.S = l4, f4.width = [f4.width], f4.height = [f4.height];
      var d4 = f4.width, p4 = f4.height, g4 = new st2();
      if (null == g4 || null == t5) var m4 = 2;
      else e2(null != g4), m4 = Bn(t5, n3, s3, g4.width, g4.height, g4.Pd, g4.Qd, g4.format, null);
      if (0 != m4 ? d4 = 0 : (null != d4 && (d4[0] = g4.width[0]), null != p4 && (p4[0] = g4.height[0]), d4 = 1), d4) {
        f4.width = f4.width[0], f4.height = f4.height[0], null != u4 && (u4[0] = f4.width), null != c4 && (c4[0] = f4.height);
        t: {
          if (u4 = new Gt2(), (c4 = new nn()).data = t5, c4.w = n3, c4.ha = s3, c4.kd = 1, n3 = [0], e2(null != c4), (0 == (t5 = Bn(c4.data, c4.w, c4.ha, null, null, null, n3, null, c4)) || 7 == t5) && n3[0] && (t5 = 4), 0 == (n3 = t5)) {
            if (e2(null != h4), u4.data = c4.data, u4.w = c4.w + c4.offset, u4.ha = c4.ha - c4.offset, u4.put = dt2, u4.ac = ft2, u4.bc = pt2, u4.ma = h4, c4.xa) {
              if (null == (t5 = kt2())) {
                h4 = 1;
                break t;
              }
              if ((function(t6, n4) {
                var r3 = [0], i3 = [0], a3 = [0];
                e: for (; ; ) {
                  if (null == t6) return 0;
                  if (null == n4) return t6.a = 2, 0;
                  if (t6.l = n4, t6.a = 0, v3(t6.m, n4.data, n4.w, n4.ha), !gt2(t6.m, r3, i3, a3)) {
                    t6.a = 3;
                    break e;
                  }
                  if (t6.xb = pi, n4.width = r3[0], n4.height = i3[0], !Ft2(r3[0], i3[0], 1, t6, null)) break e;
                  return 1;
                }
                return e2(0 != t6.a), 0;
              })(t5, u4)) {
                if (u4 = 0 == (n3 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                  e: {
                    u4 = t5;
                    n: for (; ; ) {
                      if (null == u4) {
                        u4 = 0;
                        break e;
                      }
                      if (e2(null != u4.s.yc), e2(null != u4.s.Ya), e2(0 < u4.s.Wb), e2(null != (s3 = u4.l)), e2(null != (c4 = s3.ma)), 0 != u4.xb) {
                        if (u4.ca = c4.ba, u4.tb = c4.tb, e2(null != u4.ca), !Mn(c4.Oa, s3, Rr)) {
                          u4.a = 2;
                          break n;
                        }
                        if (!It2(u4, s3.width)) break n;
                        if (s3.da) break n;
                        if ((s3.da || rt2(u4.ca.S)) && mn(), 11 > u4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != u4.ca.f.kb.F && mn()), u4.Pb && 0 < u4.s.ua && null == u4.s.vb.X && !O2(u4.s.vb, u4.s.Wa.Xa)) {
                          u4.a = 1;
                          break n;
                        }
                        u4.xb = 0;
                      }
                      if (!_t2(u4, u4.V, u4.Ba, u4.c, u4.i, s3.o, Lt2)) break n;
                      c4.Dc = u4.Ma, u4 = 1;
                      break e;
                    }
                    e2(0 != u4.a), u4 = 0;
                  }
                  u4 = !u4;
                }
                u4 && (n3 = t5.a);
              } else n3 = t5.a;
            } else {
              if (null == (t5 = new Yt2())) {
                h4 = 1;
                break t;
              }
              if (t5.Fa = c4.na, t5.P = c4.P, t5.qc = c4.Sa, Kt2(t5, u4)) {
                if (0 == (n3 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                  if (t5.Aa = 0, s3 = h4.Oa, e2(null != (c4 = t5)), null != s3) {
                    if (0 < (d4 = 0 > (d4 = s3.Md) ? 0 : 100 < d4 ? 255 : 255 * d4 / 100)) {
                      for (p4 = g4 = 0; 4 > p4; ++p4) 12 > (m4 = c4.pb[p4]).lc && (m4.ia = d4 * Di[0 > m4.lc ? 0 : m4.lc] >> 3), g4 |= m4.ia;
                      g4 && (alert("todo:VP8InitRandom"), c4.ia = 1);
                    }
                    c4.Ga = s3.Id, 100 < c4.Ga ? c4.Ga = 100 : 0 > c4.Ga && (c4.Ga = 0);
                  }
                  (function(t6, n4) {
                    if (null == t6) return 0;
                    if (null == n4) return Jt2(t6, 2, "NULL VP8Io parameter in VP8Decode().");
                    if (!t6.cb && !Kt2(t6, n4)) return 0;
                    if (e2(t6.cb), null == n4.ac || n4.ac(n4)) {
                      n4.ob && (t6.L = 0);
                      var s4 = Ri[t6.L];
                      if (2 == t6.L ? (t6.yb = 0, t6.zb = 0) : (t6.yb = n4.v - s4 >> 4, t6.zb = n4.j - s4 >> 4, 0 > t6.yb && (t6.yb = 0), 0 > t6.zb && (t6.zb = 0)), t6.Va = n4.o + 15 + s4 >> 4, t6.Hb = n4.va + 15 + s4 >> 4, t6.Hb > t6.za && (t6.Hb = t6.za), t6.Va > t6.Ub && (t6.Va = t6.Ub), 0 < t6.L) {
                        var u5 = t6.ed;
                        for (s4 = 0; 4 > s4; ++s4) {
                          var c5;
                          if (t6.Qa.Cb) {
                            var l5 = t6.Qa.Lb[s4];
                            t6.Qa.Fb || (l5 += u5.Tb);
                          } else l5 = u5.Tb;
                          for (c5 = 0; 1 >= c5; ++c5) {
                            var h5 = t6.gd[s4][c5], f5 = l5;
                            if (u5.Pc && (f5 += u5.vd[0], c5 && (f5 += u5.od[0])), 0 < (f5 = 0 > f5 ? 0 : 63 < f5 ? 63 : f5)) {
                              var d5 = f5;
                              0 < u5.wb && (d5 = 4 < u5.wb ? d5 >> 2 : d5 >> 1) > 9 - u5.wb && (d5 = 9 - u5.wb), 1 > d5 && (d5 = 1), h5.dd = d5, h5.tc = 2 * f5 + d5, h5.ld = 40 <= f5 ? 2 : 15 <= f5 ? 1 : 0;
                            } else h5.tc = 0;
                            h5.La = c5;
                          }
                        }
                      }
                      s4 = 0;
                    } else Jt2(t6, 6, "Frame setup failed"), s4 = t6.a;
                    if (s4 = 0 == s4) {
                      if (s4) {
                        t6.$c = 0, 0 < t6.Aa || (t6.Ic = Ti);
                        e: {
                          s4 = t6.Ic, u5 = 4 * (d5 = t6.za);
                          var p5 = 32 * d5, g5 = d5 + 1, m5 = 0 < t6.L ? d5 * (0 < t6.Aa ? 2 : 1) : 0, v4 = (2 == t6.Aa ? 2 : 1) * d5;
                          if ((h5 = u5 + 832 + (c5 = 3 * (16 * s4 + Ri[t6.L]) / 2 * p5) + (l5 = null != t6.Fa && 0 < t6.Fa.length ? t6.Kc.c * t6.Kc.i : 0)) != h5) s4 = 0;
                          else {
                            if (h5 > t6.Vb) {
                              if (t6.Vb = 0, t6.Ec = a2(h5), t6.Fc = 0, null == t6.Ec) {
                                s4 = Jt2(t6, 1, "no memory during frame initialization.");
                                break e;
                              }
                              t6.Vb = h5;
                            }
                            h5 = t6.Ec, f5 = t6.Fc, t6.Ac = h5, t6.Bc = f5, f5 += u5, t6.Gd = o2(p5, Ht2), t6.Hd = 0, t6.rb = o2(g5 + 1, Dt2), t6.sb = 1, t6.wa = m5 ? o2(m5, Rt2) : null, t6.Y = 0, t6.D.Nb = 0, t6.D.wa = t6.wa, t6.D.Y = t6.Y, 0 < t6.Aa && (t6.D.Y += d5), e2(true), t6.oc = h5, t6.pc = f5, f5 += 832, t6.ya = o2(v4, zt2), t6.aa = 0, t6.D.ya = t6.ya, t6.D.aa = t6.aa, 2 == t6.Aa && (t6.D.aa += d5), t6.R = 16 * d5, t6.B = 8 * d5, d5 = (p5 = Ri[t6.L]) * t6.R, p5 = p5 / 2 * t6.B, t6.sa = h5, t6.ta = f5 + d5, t6.qa = t6.sa, t6.ra = t6.ta + 16 * s4 * t6.R + p5, t6.Ha = t6.qa, t6.Ia = t6.ra + 8 * s4 * t6.B + p5, t6.$c = 0, f5 += c5, t6.mb = l5 ? h5 : null, t6.nb = l5 ? f5 : null, e2(f5 + l5 <= t6.Fc + t6.Vb), $t2(t6), i2(t6.Ac, t6.Bc, 0, u5), s4 = 1;
                          }
                        }
                        if (s4) {
                          if (n4.ka = 0, n4.y = t6.sa, n4.O = t6.ta, n4.f = t6.qa, n4.N = t6.ra, n4.ea = t6.Ha, n4.Vd = t6.Ia, n4.fa = t6.R, n4.Rc = t6.B, n4.F = null, n4.J = 0, !Ir) {
                            for (s4 = -255; 255 >= s4; ++s4) _r[255 + s4] = 0 > s4 ? -s4 : s4;
                            for (s4 = -1020; 1020 >= s4; ++s4) Pr[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
                            for (s4 = -112; 112 >= s4; ++s4) kr[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
                            for (s4 = -255; 510 >= s4; ++s4) Fr[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
                            Ir = 1;
                          }
                          ir = ue2, ar = ie2, sr = ae2, ur = oe2, cr = se2, or = re2, lr = Ye, hr = Je, fr = Ze, dr = $e, pr = Xe, gr = Ke, mr = Qe, vr = tn, br = ze, yr = Ue, wr = He, Nr = We, hi[0] = xe2, hi[1] = le2, hi[2] = Ne2, hi[3] = Le2, hi[4] = Ae2, hi[5] = _e2, hi[6] = Se2, hi[7] = Pe2, hi[8] = Fe2, hi[9] = ke2, li[0] = me2, li[1] = fe2, li[2] = de2, li[3] = pe2, li[4] = ve2, li[5] = be2, li[6] = ye2, fi[0] = Oe, fi[1] = he2, fi[2] = Ie2, fi[3] = je2, fi[4] = Me, fi[5] = Be, fi[6] = qe, s4 = 1;
                        } else s4 = 0;
                      }
                      s4 && (s4 = (function(t7, n5) {
                        for (t7.M = 0; t7.M < t7.Va; ++t7.M) {
                          var o3, s5 = t7.Jc[t7.M & t7.Xb], u6 = t7.m, c6 = t7;
                          for (o3 = 0; o3 < c6.za; ++o3) {
                            var l6 = u6, h6 = c6, f6 = h6.Ac, d6 = h6.Bc + 4 * o3, p6 = h6.zc, g6 = h6.ya[h6.aa + o3];
                            if (h6.Qa.Bb ? g6.$b = k2(l6, h6.Pa.jb[0]) ? 2 + k2(l6, h6.Pa.jb[2]) : k2(l6, h6.Pa.jb[1]) : g6.$b = 0, h6.kc && (g6.Ad = k2(l6, h6.Bd)), g6.Za = !k2(l6, 145) + 0, g6.Za) {
                              var m6 = g6.Ob, v5 = 0;
                              for (h6 = 0; 4 > h6; ++h6) {
                                var b4, y4 = p6[0 + h6];
                                for (b4 = 0; 4 > b4; ++b4) {
                                  y4 = si[f6[d6 + b4]][y4];
                                  for (var w4 = ai[k2(l6, y4[0])]; 0 < w4; ) w4 = ai[2 * w4 + k2(l6, y4[w4])];
                                  y4 = -w4, f6[d6 + b4] = y4;
                                }
                                r2(m6, v5, f6, d6, 4), v5 += 4, p6[0 + h6] = y4;
                              }
                            } else y4 = k2(l6, 156) ? k2(l6, 128) ? 1 : 3 : k2(l6, 163) ? 2 : 0, g6.Ob[0] = y4, i2(f6, d6, y4, 4), i2(p6, 0, y4, 4);
                            g6.Dd = k2(l6, 142) ? k2(l6, 114) ? k2(l6, 183) ? 1 : 3 : 2 : 0;
                          }
                          if (c6.m.Ka) return Jt2(t7, 7, "Premature end-of-partition0 encountered.");
                          for (; t7.ja < t7.za; ++t7.ja) {
                            if (c6 = s5, l6 = (u6 = t7).rb[u6.sb - 1], f6 = u6.rb[u6.sb + u6.ja], o3 = u6.ya[u6.aa + u6.ja], d6 = u6.kc ? o3.Ad : 0) l6.la = f6.la = 0, o3.Za || (l6.Na = f6.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                            else {
                              var N4, L4;
                              if (l6 = f6, f6 = c6, d6 = u6.Pa.Xc, p6 = u6.ya[u6.aa + u6.ja], g6 = u6.pb[p6.$b], h6 = p6.ad, m6 = 0, v5 = u6.rb[u6.sb - 1], y4 = b4 = 0, i2(h6, m6, 0, 384), p6.Za) var x4 = 0, A4 = d6[3];
                              else {
                                w4 = a2(16);
                                var S3 = l6.Na + v5.Na;
                                if (S3 = ni(f6, d6[1], S3, g6.Eb, 0, w4, 0), l6.Na = v5.Na = (0 < S3) + 0, 1 < S3) ir(w4, 0, h6, m6);
                                else {
                                  var _3 = w4[0] + 3 >> 3;
                                  for (w4 = 0; 256 > w4; w4 += 16) h6[m6 + w4] = _3;
                                }
                                x4 = 1, A4 = d6[0];
                              }
                              var P3 = 15 & l6.la, F3 = 15 & v5.la;
                              for (w4 = 0; 4 > w4; ++w4) {
                                var I3 = 1 & F3;
                                for (_3 = L4 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (I3 = (S3 = ni(f6, A4, S3 = I3 + (1 & P3), g6.Sc, x4, h6, m6)) > x4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                P3 >>= 4, F3 = F3 >> 1 | I3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                              }
                              for (A4 = P3, x4 = F3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                                for (L4 = 0, P3 = l6.la >> 4 + N4, F3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                                  for (I3 = 1 & F3, _3 = 0; 2 > _3; ++_3) S3 = I3 + (1 & P3), P3 = P3 >> 1 | (I3 = 0 < (S3 = ni(f6, d6[2], S3, g6.Qc, 0, h6, m6))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                  P3 >>= 2, F3 = F3 >> 1 | I3 << 5;
                                }
                                y4 |= L4 << 4 * N4, A4 |= P3 << 4 << N4, x4 |= (240 & F3) << N4;
                              }
                              l6.la = A4, v5.la = x4, p6.Hc = b4, p6.Gc = y4, p6.ia = 43690 & y4 ? 0 : g6.ia, d6 = !(b4 | y4);
                            }
                            if (0 < u6.L && (u6.wa[u6.Y + u6.ja] = u6.gd[o3.$b][o3.Za], u6.wa[u6.Y + u6.ja].La |= !d6), c6.Ka) return Jt2(t7, 7, "Premature end-of-file encountered.");
                          }
                          if ($t2(t7), u6 = n5, c6 = 1, o3 = (s5 = t7).D, l6 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, 0 == s5.Aa) e: {
                            if (o3.M = s5.M, o3.uc = l6, On(s5, o3), c6 = 1, o3 = (L4 = s5.D).Nb, l6 = (y4 = Ri[s5.L]) * s5.R, f6 = y4 / 2 * s5.B, w4 = 16 * o3 * s5.R, _3 = 8 * o3 * s5.B, d6 = s5.sa, p6 = s5.ta - l6 + w4, g6 = s5.qa, h6 = s5.ra - f6 + _3, m6 = s5.Ha, v5 = s5.Ia - f6 + _3, F3 = 0 == (P3 = L4.M), b4 = P3 >= s5.Va - 1, 2 == s5.Aa && On(s5, L4), L4.uc) for (I3 = (S3 = s5).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                              x4 = L4, A4 = I3;
                              var j3 = (C3 = (z3 = S3).D).Nb;
                              N4 = z3.R;
                              var C3 = C3.wa[C3.Y + x4], O3 = z3.sa, B4 = z3.ta + 16 * j3 * N4 + 16 * x4, M3 = C3.dd, q3 = C3.tc;
                              if (0 != q3) if (e2(3 <= q3), 1 == z3.L) 0 < x4 && yr(O3, B4, N4, q3 + 4), C3.La && Nr(O3, B4, N4, q3), 0 < A4 && br(O3, B4, N4, q3 + 4), C3.La && wr(O3, B4, N4, q3);
                              else {
                                var E3 = z3.B, R3 = z3.qa, D3 = z3.ra + 8 * j3 * E3 + 8 * x4, T3 = z3.Ha, z3 = z3.Ia + 8 * j3 * E3 + 8 * x4;
                                j3 = C3.ld, 0 < x4 && (hr(O3, B4, N4, q3 + 4, M3, j3), dr(R3, D3, T3, z3, E3, q3 + 4, M3, j3)), C3.La && (gr(O3, B4, N4, q3, M3, j3), vr(R3, D3, T3, z3, E3, q3, M3, j3)), 0 < A4 && (lr(O3, B4, N4, q3 + 4, M3, j3), fr(R3, D3, T3, z3, E3, q3 + 4, M3, j3)), C3.La && (pr(O3, B4, N4, q3, M3, j3), mr(R3, D3, T3, z3, E3, q3, M3, j3));
                              }
                            }
                            if (s5.ia && alert("todo:DitherRow"), null != u6.put) {
                              if (L4 = 16 * P3, P3 = 16 * (P3 + 1), F3 ? (u6.y = s5.sa, u6.O = s5.ta + w4, u6.f = s5.qa, u6.N = s5.ra + _3, u6.ea = s5.Ha, u6.W = s5.Ia + _3) : (L4 -= y4, u6.y = d6, u6.O = p6, u6.f = g6, u6.N = h6, u6.ea = m6, u6.W = v5), b4 || (P3 -= y4), P3 > u6.o && (P3 = u6.o), u6.F = null, u6.J = null, null != s5.Fa && 0 < s5.Fa.length && L4 < P3 && (u6.J = hn(s5, u6, L4, P3 - L4), u6.F = s5.mb, null == u6.F && 0 == u6.F.length)) {
                                c6 = Jt2(s5, 3, "Could not decode alpha data.");
                                break e;
                              }
                              L4 < u6.j && (y4 = u6.j - L4, L4 = u6.j, e2(!(1 & y4)), u6.O += s5.R * y4, u6.N += s5.B * (y4 >> 1), u6.W += s5.B * (y4 >> 1), null != u6.F && (u6.J += u6.width * y4)), L4 < P3 && (u6.O += u6.v, u6.N += u6.v >> 1, u6.W += u6.v >> 1, null != u6.F && (u6.J += u6.v), u6.ka = L4 - u6.j, u6.U = u6.va - u6.v, u6.T = P3 - L4, c6 = u6.put(u6));
                            }
                            o3 + 1 != s5.Ic || b4 || (r2(s5.sa, s5.ta - l6, d6, p6 + 16 * s5.R, l6), r2(s5.qa, s5.ra - f6, g6, h6 + 8 * s5.B, f6), r2(s5.Ha, s5.Ia - f6, m6, v5 + 8 * s5.B, f6));
                          }
                          if (!c6) return Jt2(t7, 6, "Output aborted.");
                        }
                        return 1;
                      })(t6, n4)), null != n4.bc && n4.bc(n4), s4 &= 1;
                    }
                    return s4 ? (t6.cb = 0, s4) : 0;
                  })(t5, u4) || (n3 = t5.a);
                }
              } else n3 = t5.a;
            }
            0 == n3 && null != h4.Oa && h4.Oa.fd && (n3 = qn(h4.ba));
          }
          h4 = n3;
        }
        l4 = 0 != h4 ? null : 11 > l4 ? f4.f.RGBA.eb : f4.f.kb.y;
      } else l4 = null;
      return l4;
    };
    var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function c2(t4, e3) {
    for (var n3 = "", r3 = 0; r3 < 4; r3++) n3 += String.fromCharCode(t4[e3++]);
    return n3;
  }
  function l2(t4, e3) {
    return t4[e3 + 0] | t4[e3 + 1] << 8;
  }
  function h2(t4, e3) {
    return (t4[e3 + 0] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16) >>> 0;
  }
  function f2(t4, e3) {
    return (t4[e3 + 0] | t4[e3 + 1] << 8 | t4[e3 + 2] << 16 | t4[e3 + 3] << 24) >>> 0;
  }
  new u2();
  var d2 = [0], p2 = [0], g2 = [], m2 = new u2(), v2 = t3, b2 = (function(t4, e3) {
    var n3 = {}, r3 = 0, i3 = false, a3 = 0, o3 = 0;
    if (n3.frames = [], !/** @license
       * Copyright (c) 2017 Dominik Homberger
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      https://webpjs.appspot.com
      WebPRiffParser dominikhlbg@gmail.com
      */
    (function(t5, e4) {
      for (var n4 = 0; n4 < 4; n4++) if (t5[e4 + n4] != "RIFF".charCodeAt(n4)) return true;
      return false;
    })(t4, e3)) {
      for (f2(t4, e3 += 4), e3 += 8; e3 < t4.length; ) {
        var s3 = c2(t4, e3), u3 = f2(t4, e3 += 4);
        e3 += 4;
        var d3 = u3 + (1 & u3);
        switch (s3) {
          case "VP8 ":
          case "VP8L":
            void 0 === n3.frames[r3] && (n3.frames[r3] = {}), (m3 = n3.frames[r3]).src_off = i3 ? o3 : e3 - 8, m3.src_size = a3 + u3 + 8, r3++, i3 && (i3 = false, a3 = 0, o3 = 0);
            break;
          case "VP8X":
            (m3 = n3.header = {}).feature_flags = t4[e3];
            var p3 = e3 + 4;
            m3.canvas_width = 1 + h2(t4, p3), p3 += 3, m3.canvas_height = 1 + h2(t4, p3), p3 += 3;
            break;
          case "ALPH":
            i3 = true, a3 = d3 + 8, o3 = e3 - 8;
            break;
          case "ANIM":
            (m3 = n3.header).bgcolor = f2(t4, e3), p3 = e3 + 4, m3.loop_count = l2(t4, p3), p3 += 2;
            break;
          case "ANMF":
            var g3, m3;
            (m3 = n3.frames[r3] = {}).offset_x = 2 * h2(t4, e3), e3 += 3, m3.offset_y = 2 * h2(t4, e3), e3 += 3, m3.width = 1 + h2(t4, e3), e3 += 3, m3.height = 1 + h2(t4, e3), e3 += 3, m3.duration = h2(t4, e3), e3 += 3, g3 = t4[e3++], m3.dispose = 1 & g3, m3.blend = g3 >> 1 & 1;
        }
        "ANMF" != s3 && (e3 += d3);
      }
      return n3;
    }
  })(v2, 0);
  b2.response = v2, b2.rgbaoutput = true, b2.dataurl = false;
  var y2 = b2.header ? b2.header : null, w2 = b2.frames ? b2.frames : null;
  if (y2) {
    y2.loop_counter = y2.loop_count, d2 = [y2.canvas_height], p2 = [y2.canvas_width];
    for (var N2 = 0; N2 < w2.length && 0 != w2[N2].blend; N2++) ;
  }
  var L2 = w2[0], x2 = m2.WebPDecodeRGBA(v2, L2.src_off, L2.src_size, p2, d2);
  L2.rgba = x2, L2.imgwidth = p2[0], L2.imgheight = d2[0];
  for (var A2 = 0; A2 < p2[0] * d2[0] * 4; A2++) g2[A2] = x2[A2];
  return this.width = p2, this.height = d2, this.data = g2, this;
}
!(function(e2) {
  var n2, r2, i2, a2, s2, u2, c2, l2, f2, d2 = function(t3) {
    return t3 = t3 || {}, this.isStrokeTransparent = t3.isStrokeTransparent || false, this.strokeOpacity = t3.strokeOpacity || 1, this.strokeStyle = t3.strokeStyle || "#000000", this.fillStyle = t3.fillStyle || "#000000", this.isFillTransparent = t3.isFillTransparent || false, this.fillOpacity = t3.fillOpacity || 1, this.font = t3.font || "10px sans-serif", this.textBaseline = t3.textBaseline || "alphabetic", this.textAlign = t3.textAlign || "left", this.lineWidth = t3.lineWidth || 1, this.lineJoin = t3.lineJoin || "miter", this.lineCap = t3.lineCap || "butt", this.path = t3.path || [], this.transform = void 0 !== t3.transform ? t3.transform.clone() : new l2(), this.globalCompositeOperation = t3.globalCompositeOperation || "normal", this.globalAlpha = t3.globalAlpha || 1, this.clip_path = t3.clip_path || [], this.currentPoint = t3.currentPoint || new u2(), this.miterLimit = t3.miterLimit || 10, this.lastPoint = t3.lastPoint || new u2(), this.lineDashOffset = t3.lineDashOffset || 0, this.lineDash = t3.lineDash || [], this.margin = t3.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t3.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t3.ignoreClearRect || t3.ignoreClearRect, this;
  };
  e2.events.push(["initialized", function() {
    this.context2d = new p2(this), n2 = this.internal.f2, r2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, a2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, u2 = this.internal.Point, c2 = this.internal.Rectangle, l2 = this.internal.Matrix, f2 = new d2();
  }]);
  var p2 = function(t3) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: false, style: false };
    } });
    var e3 = t3;
    Object.defineProperty(this, "pdf", { get: function() {
      return e3;
    } });
    var n3 = false;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return n3;
    }, set: function(t4) {
      n3 = Boolean(t4);
    } });
    var r3 = false;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return r3;
    }, set: function(t4) {
      r3 = Boolean(t4);
    } });
    var i3 = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return i3;
    }, set: function(t4) {
      isNaN(t4) || (i3 = t4);
    } });
    var a3 = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return a3;
    }, set: function(t4) {
      isNaN(t4) || (a3 = t4);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return f2.margin;
    }, set: function(t4) {
      var e4;
      "number" == typeof t4 ? e4 = [t4, t4, t4, t4] : ((e4 = new Array(4))[0] = t4[0], e4[1] = t4.length >= 2 ? t4[1] : e4[0], e4[2] = t4.length >= 3 ? t4[2] : e4[0], e4[3] = t4.length >= 4 ? t4[3] : e4[1]), f2.margin = e4;
    } });
    var o2 = false;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return o2;
    }, set: function(t4) {
      o2 = t4;
    } });
    var s3 = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return s3;
    }, set: function(t4) {
      s3 = t4;
    } });
    var u3 = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return u3;
    }, set: function(t4) {
      u3 = t4;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return f2;
    }, set: function(t4) {
      t4 instanceof d2 && (f2 = t4);
    } }), Object.defineProperty(this, "path", { get: function() {
      return f2.path;
    }, set: function(t4) {
      f2.path = t4;
    } });
    var c3 = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return c3;
    }, set: function(t4) {
      c3 = t4;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(t4) {
      var e4;
      e4 = g2(t4), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(t4) {
      var e4 = g2(t4);
      this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(t4) {
      -1 !== ["butt", "round", "square"].indexOf(t4) && (this.ctx.lineCap = t4, this.pdf.setLineCap(t4));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.lineWidth = t4, this.pdf.setLineWidth(t4));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(t4) {
      -1 !== ["bevel", "round", "miter"].indexOf(t4) && (this.ctx.lineJoin = t4, this.pdf.setLineJoin(t4));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(t4) {
      isNaN(t4) || (this.ctx.miterLimit = t4, this.pdf.setMiterLimit(t4));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(t4) {
      this.ctx.textBaseline = t4;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(t4) {
      -1 !== ["right", "end", "center", "left", "start"].indexOf(t4) && (this.ctx.textAlign = t4);
    } });
    var l3 = null;
    var h2 = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return h2;
    }, set: function(t4) {
      l3 = null, h2 = t4;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(t4) {
      var e4;
      if (this.ctx.font = t4, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(t4))) {
        var n4 = e4[1];
        e4[2];
        var r4 = e4[3], i4 = e4[4];
        e4[5];
        var a4 = e4[6], o3 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
        i4 = "px" === o3 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o3 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
        var s4 = (function(t5) {
          var e5, n5, r5 = [], i5 = t5.trim();
          if ("" === i5) return Jt;
          if (i5 in Mt) return [Mt[i5]];
          for (; "" !== i5; ) {
            switch (n5 = null, e5 = (i5 = Et(i5)).charAt(0)) {
              case '"':
              case "'":
                n5 = Rt(i5.substring(1), e5);
                break;
              default:
                n5 = Dt(i5);
            }
            if (null === n5) return Jt;
            if (r5.push(n5[0]), "" !== (i5 = Et(n5[1])) && "," !== i5.charAt(0)) return Jt;
            i5 = i5.replace(/^,/, "");
          }
          return r5;
        })(a4);
        if (this.fontFaces) {
          var u4 = (function(t5, e5) {
            if (null === l3) {
              var n5 = (function(t6) {
                var e6 = [];
                return Object.keys(t6).forEach(function(n6) {
                  t6[n6].forEach(function(t7) {
                    var r5 = null;
                    switch (t7) {
                      case "bold":
                        r5 = { family: n6, weight: "bold" };
                        break;
                      case "italic":
                        r5 = { family: n6, style: "italic" };
                        break;
                      case "bolditalic":
                        r5 = { family: n6, weight: "bold", style: "italic" };
                        break;
                      case "":
                      case "normal":
                        r5 = { family: n6 };
                    }
                    null !== r5 && (r5.ref = { name: n6, style: t7 }, e6.push(r5));
                  });
                }), e6;
              })(t5.getFontList());
              l3 = (function(t6) {
                for (var e6 = {}, n6 = 0; n6 < t6.length; ++n6) {
                  var r5 = Ct(t6[n6]), i5 = r5.family, a5 = r5.stretch, o4 = r5.style, s5 = r5.weight;
                  e6[i5] = e6[i5] || {}, e6[i5][a5] = e6[i5][a5] || {}, e6[i5][a5][o4] = e6[i5][a5][o4] || {}, e6[i5][a5][o4][s5] = r5;
                }
                return e6;
              })(n5.concat(e5));
            }
            return l3;
          })(this.pdf, this.fontFaces), c4 = s4.map(function(t5) {
            return { family: t5, stretch: "normal", weight: r4, style: n4 };
          }), h3 = (function(t5, e5, n5) {
            for (var r5 = (n5 = n5 || {}).defaultFontFamily || "times", i5 = Object.assign({}, Bt, n5.genericFontFamilies || {}), a5 = null, o4 = null, s5 = 0; s5 < e5.length; ++s5) if (i5[(a5 = Ct(e5[s5])).family] && (a5.family = i5[a5.family]), t5.hasOwnProperty(a5.family)) {
              o4 = t5[a5.family];
              break;
            }
            if (!(o4 = o4 || t5[r5])) throw new Error("Could not find a font-family for the rule '" + qt(a5) + "' and default family '" + r5 + "'.");
            if (o4 = (function(t6, e6) {
              if (e6[t6]) return e6[t6];
              var n6 = Ft[t6], r6 = n6 <= Ft.normal ? -1 : 1, i6 = Ot(e6, kt, n6, r6);
              if (!i6) throw new Error("Could not find a matching font-stretch value for " + t6);
              return i6;
            })(a5.stretch, o4), o4 = (function(t6, e6) {
              if (e6[t6]) return e6[t6];
              for (var n6 = Pt[t6], r6 = 0; r6 < n6.length; ++r6) if (e6[n6[r6]]) return e6[n6[r6]];
              throw new Error("Could not find a matching font-style for " + t6);
            })(a5.style, o4), !(o4 = (function(t6, e6) {
              if (e6[t6]) return e6[t6];
              if (400 === t6 && e6[500]) return e6[500];
              if (500 === t6 && e6[400]) return e6[400];
              var n6 = jt[t6], r6 = Ot(e6, It, n6, t6 < 400 ? -1 : 1);
              if (!r6) throw new Error("Could not find a matching font-weight for value " + t6);
              return r6;
            })(a5.weight, o4))) throw new Error("Failed to resolve a font for the rule '" + qt(a5) + "'.");
            return o4;
          })(u4, c4);
          this.pdf.setFont(h3.ref.name, h3.ref.style);
        } else {
          var f3 = "";
          ("bold" === r4 || parseInt(r4, 10) >= 700 || "bold" === n4) && (f3 = "bold"), "italic" === n4 && (f3 += "italic"), 0 === f3.length && (f3 = "normal");
          for (var d3 = "", p3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, g3 = 0; g3 < s4.length; g3++) {
            if (void 0 !== this.pdf.internal.getFont(s4[g3], f3, { noFallback: true, disableWarning: true })) {
              d3 = s4[g3];
              break;
            }
            if ("bolditalic" === f3 && void 0 !== this.pdf.internal.getFont(s4[g3], "bold", { noFallback: true, disableWarning: true })) d3 = s4[g3], f3 = "bold";
            else if (void 0 !== this.pdf.internal.getFont(s4[g3], "normal", { noFallback: true, disableWarning: true })) {
              d3 = s4[g3], f3 = "normal";
              break;
            }
          }
          if ("" === d3) {
            for (var m3 = 0; m3 < s4.length; m3++) if (p3[s4[m3]]) {
              d3 = p3[s4[m3]];
              break;
            }
          }
          d3 = "" === d3 ? "Times" : d3, this.pdf.setFont(d3, f3);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(t4) {
      this.ctx.globalCompositeOperation = t4;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(t4) {
      this.ctx.globalAlpha = t4;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(t4) {
      this.ctx.lineDashOffset = t4, T2.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(t4) {
      this.ctx.lineDash = t4, T2.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(t4) {
      this.ctx.ignoreClearRect = Boolean(t4);
    } });
  };
  p2.prototype.setLineDash = function(t3) {
    this.lineDash = t3;
  }, p2.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, p2.prototype.fill = function() {
    x2.call(this, "fill", false);
  }, p2.prototype.stroke = function() {
    x2.call(this, "stroke", false);
  }, p2.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, p2.prototype.moveTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3)) throw o$1.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var n3 = this.ctx.transform.applyToPoint(new u2(t3, e3));
    this.path.push({ type: "mt", x: n3.x, y: n3.y }), this.ctx.lastPoint = new u2(t3, e3);
  }, p2.prototype.closePath = function() {
    var e3 = new u2(0, 0), n3 = 0;
    for (n3 = this.path.length - 1; -1 !== n3; n3--) if ("begin" === this.path[n3].type && "object" === _typeof$1(this.path[n3 + 1]) && "number" == typeof this.path[n3 + 1].x) {
      e3 = new u2(this.path[n3 + 1].x, this.path[n3 + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new u2(e3.x, e3.y);
  }, p2.prototype.lineTo = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3)) throw o$1.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var n3 = this.ctx.transform.applyToPoint(new u2(t3, e3));
    this.path.push({ type: "lt", x: n3.x, y: n3.y }), this.ctx.lastPoint = new u2(n3.x, n3.y);
  }, p2.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), x2.call(this, null, true);
  }, p2.prototype.quadraticCurveTo = function(t3, e3, n3, r3) {
    if (isNaN(n3) || isNaN(r3) || isNaN(t3) || isNaN(e3)) throw o$1.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var i3 = this.ctx.transform.applyToPoint(new u2(n3, r3)), a3 = this.ctx.transform.applyToPoint(new u2(t3, e3));
    this.path.push({ type: "qct", x1: a3.x, y1: a3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new u2(i3.x, i3.y);
  }, p2.prototype.bezierCurveTo = function(t3, e3, n3, r3, i3, a3) {
    if (isNaN(i3) || isNaN(a3) || isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var s3 = this.ctx.transform.applyToPoint(new u2(i3, a3)), c3 = this.ctx.transform.applyToPoint(new u2(t3, e3)), l3 = this.ctx.transform.applyToPoint(new u2(n3, r3));
    this.path.push({ type: "bct", x1: c3.x, y1: c3.y, x2: l3.x, y2: l3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new u2(s3.x, s3.y);
  }, p2.prototype.arc = function(t3, e3, n3, r3, i3, a3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i3)) throw o$1.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (a3 = Boolean(a3), !this.ctx.transform.isIdentity) {
      var s3 = this.ctx.transform.applyToPoint(new u2(t3, e3));
      t3 = s3.x, e3 = s3.y;
      var c3 = this.ctx.transform.applyToPoint(new u2(0, n3)), l3 = this.ctx.transform.applyToPoint(new u2(0, 0));
      n3 = Math.sqrt(Math.pow(c3.x - l3.x, 2) + Math.pow(c3.y - l3.y, 2));
    }
    Math.abs(i3 - r3) >= 2 * Math.PI && (r3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t3, y: e3, radius: n3, startAngle: r3, endAngle: i3, counterclockwise: a3 });
  }, p2.prototype.arcTo = function(t3, e3, n3, r3, i3) {
    throw new Error("arcTo not implemented.");
  }, p2.prototype.rect = function(t3, e3, n3, r3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(t3, e3), this.lineTo(t3 + n3, e3), this.lineTo(t3 + n3, e3 + r3), this.lineTo(t3, e3 + r3), this.lineTo(t3, e3), this.lineTo(t3 + n3, e3), this.lineTo(t3, e3);
  }, p2.prototype.fillRect = function(t3, e3, n3, r3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!m2.call(this)) {
      var i3 = {};
      "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t3, e3, n3, r3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
    }
  }, p2.prototype.strokeRect = function(t3, e3, n3, r3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    v2.call(this) || (this.beginPath(), this.rect(t3, e3, n3, r3), this.stroke());
  }, p2.prototype.clearRect = function(t3, e3, n3, r3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t3, e3, n3, r3));
  }, p2.prototype.save = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, n3 = 0; n3 < this.pdf.internal.getNumberOfPages(); n3++) this.pdf.setPage(n3 + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(e3), t3) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var r3 = new d2(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = r3;
    }
  }, p2.prototype.restore = function(t3) {
    t3 = "boolean" != typeof t3 || t3;
    for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, n3 = 0; n3 < this.pdf.internal.getNumberOfPages(); n3++) this.pdf.setPage(n3 + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(e3), t3 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, p2.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var g2 = function(t3) {
    var e3, n3, r3, i3;
    if (true === t3.isCanvasGradient && (t3 = t3.getColor()), !t3) return { r: 0, g: 0, b: 0, a: 0, style: t3 };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t3)) e3 = 0, n3 = 0, r3 = 0, i3 = 0;
    else {
      var a3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t3);
      if (null !== a3) e3 = parseInt(a3[1]), n3 = parseInt(a3[2]), r3 = parseInt(a3[3]), i3 = 1;
      else if (null !== (a3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t3))) e3 = parseInt(a3[1]), n3 = parseInt(a3[2]), r3 = parseInt(a3[3]), i3 = parseFloat(a3[4]);
      else {
        if (i3 = 1, "string" == typeof t3 && "#" !== t3.charAt(0)) {
          var o2 = new h$1(t3);
          t3 = o2.ok ? o2.toHex() : "#000000";
        }
        4 === t3.length ? (e3 = t3.substring(1, 2), e3 += e3, n3 = t3.substring(2, 3), n3 += n3, r3 = t3.substring(3, 4), r3 += r3) : (e3 = t3.substring(1, 3), n3 = t3.substring(3, 5), r3 = t3.substring(5, 7)), e3 = parseInt(e3, 16), n3 = parseInt(n3, 16), r3 = parseInt(r3, 16);
      }
    }
    return { r: e3, g: n3, b: r3, a: i3, style: t3 };
  }, m2 = function() {
    return this.ctx.isFillTransparent || 0 == this.globalAlpha;
  }, v2 = function() {
    return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
  };
  p2.prototype.fillText = function(t3, e3, n3, r3) {
    if (isNaN(e3) || isNaN(n3) || "string" != typeof t3) throw o$1.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (r3 = isNaN(r3) ? void 0 : r3, !m2.call(this)) {
      var i3 = E2(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
      j2.call(this, { text: t3, x: e3, y: n3, scale: a3, angle: i3, align: this.textAlign, maxWidth: r3 });
    }
  }, p2.prototype.strokeText = function(t3, e3, n3, r3) {
    if (isNaN(e3) || isNaN(n3) || "string" != typeof t3) throw o$1.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!v2.call(this)) {
      r3 = isNaN(r3) ? void 0 : r3;
      var i3 = E2(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
      j2.call(this, { text: t3, x: e3, y: n3, scale: a3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: r3 });
    }
  }, p2.prototype.measureText = function(t3) {
    if ("string" != typeof t3) throw o$1.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var e3 = this.pdf, n3 = this.pdf.internal.scaleFactor, r3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t3) * r3 / e3.internal.scaleFactor;
    return new function(t4) {
      var e4 = (t4 = t4 || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return e4;
      } }), this;
    }({ width: i3 *= Math.round(96 * n3 / 72 * 1e4) / 1e4 });
  }, p2.prototype.scale = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3)) throw o$1.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var n3 = new l2(t3, 0, 0, e3, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(n3);
  }, p2.prototype.rotate = function(t3) {
    if (isNaN(t3)) throw o$1.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var e3 = new l2(Math.cos(t3), Math.sin(t3), -Math.sin(t3), Math.cos(t3), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(e3);
  }, p2.prototype.translate = function(t3, e3) {
    if (isNaN(t3) || isNaN(e3)) throw o$1.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var n3 = new l2(1, 0, 0, 1, t3, e3);
    this.ctx.transform = this.ctx.transform.multiply(n3);
  }, p2.prototype.transform = function(t3, e3, n3, r3, i3, a3) {
    if (isNaN(t3) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i3) || isNaN(a3)) throw o$1.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var s3 = new l2(t3, e3, n3, r3, i3, a3);
    this.ctx.transform = this.ctx.transform.multiply(s3);
  }, p2.prototype.setTransform = function(t3, e3, n3, r3, i3, a3) {
    t3 = isNaN(t3) ? 1 : t3, e3 = isNaN(e3) ? 0 : e3, n3 = isNaN(n3) ? 0 : n3, r3 = isNaN(r3) ? 1 : r3, i3 = isNaN(i3) ? 0 : i3, a3 = isNaN(a3) ? 0 : a3, this.ctx.transform = new l2(t3, e3, n3, r3, i3, a3);
  };
  var b2 = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  p2.prototype.drawImage = function(t3, e3, n3, r3, i3, a3, o2, s3, u3) {
    var h2 = this.pdf.getImageProperties(t3), f3 = 1, d3 = 1, p3 = 1, g3 = 1;
    void 0 !== r3 && void 0 !== s3 && (p3 = s3 / r3, g3 = u3 / i3, f3 = h2.width / r3 * s3 / r3, d3 = h2.height / i3 * u3 / i3), void 0 === a3 && (a3 = e3, o2 = n3, e3 = 0, n3 = 0), void 0 !== r3 && void 0 === s3 && (s3 = r3, u3 = i3), void 0 === r3 && void 0 === s3 && (s3 = h2.width, u3 = h2.height);
    for (var m3, v3 = this.ctx.transform.decompose(), w3 = E2(v3.rotate.shx), x3 = new l2(), S3 = (x3 = (x3 = (x3 = x3.multiply(v3.translate)).multiply(v3.skew)).multiply(v3.scale)).applyToRectangle(new c2(a3 - e3 * p3, o2 - n3 * g3, r3 * f3, i3 * d3)), _3 = y2.call(this, S3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
    if (L2(P3), this.autoPaging) for (var F3 = P3[0], I3 = P3[P3.length - 1], j3 = F3; j3 < I3 + 1; j3++) {
      this.pdf.setPage(j3);
      var C3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === j3 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], q3 = 1 === j3 ? 0 : B4 + (j3 - 2) * M3;
      if (0 !== this.ctx.clip_path.length) {
        var R3 = this.path;
        m3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(m3, this.posX + this.margin[3], -q3 + O3 + this.ctx.prevPageLastElemOffset), A2.call(this, "fill", true), this.path = R3;
      }
      var D3 = JSON.parse(JSON.stringify(S3));
      D3 = N2([D3], this.posX + this.margin[3], -q3 + O3 + this.ctx.prevPageLastElemOffset)[0];
      var T3 = (j3 > F3 || j3 < I3) && b2.call(this);
      T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], C3, M3, null).clip().discardPath()), this.pdf.addImage(t3, "JPEG", D3.x, D3.y, D3.w, D3.h, null, null, w3), T3 && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(t3, "JPEG", S3.x, S3.y, S3.w, S3.h, null, null, w3);
  };
  var y2 = function(t3, e3, n3) {
    var r3 = [];
    e3 = e3 || this.pdf.internal.pageSize.width, n3 = n3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var i3 = this.posY + this.ctx.prevPageLastElemOffset;
    switch (t3.type) {
      default:
      case "mt":
      case "lt":
        r3.push(Math.floor((t3.y + i3) / n3) + 1);
        break;
      case "arc":
        r3.push(Math.floor((t3.y + i3 - t3.radius) / n3) + 1), r3.push(Math.floor((t3.y + i3 + t3.radius) / n3) + 1);
        break;
      case "qct":
        var a3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x, t3.y);
        r3.push(Math.floor((a3.y + i3) / n3) + 1), r3.push(Math.floor((a3.y + a3.h + i3) / n3) + 1);
        break;
      case "bct":
        var o2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t3.x1, t3.y1, t3.x2, t3.y2, t3.x, t3.y);
        r3.push(Math.floor((o2.y + i3) / n3) + 1), r3.push(Math.floor((o2.y + o2.h + i3) / n3) + 1);
        break;
      case "rect":
        r3.push(Math.floor((t3.y + i3) / n3) + 1), r3.push(Math.floor((t3.y + t3.h + i3) / n3) + 1);
    }
    for (var s3 = 0; s3 < r3.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < r3[s3]; ) w2.call(this);
    return r3;
  }, w2 = function() {
    var t3 = this.fillStyle, e3 = this.strokeStyle, n3 = this.font, r3 = this.lineCap, i3 = this.lineWidth, a3 = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = t3, this.strokeStyle = e3, this.font = n3, this.lineCap = r3, this.lineWidth = i3, this.lineJoin = a3;
  }, N2 = function(t3, e3, n3) {
    for (var r3 = 0; r3 < t3.length; r3++) switch (t3[r3].type) {
      case "bct":
        t3[r3].x2 += e3, t3[r3].y2 += n3;
      case "qct":
        t3[r3].x1 += e3, t3[r3].y1 += n3;
      default:
        t3[r3].x += e3, t3[r3].y += n3;
    }
    return t3;
  }, L2 = function(t3) {
    return t3.sort(function(t4, e3) {
      return t4 - e3;
    });
  }, x2 = function(t3, e3) {
    for (var n3, r3, i3 = this.fillStyle, a3 = this.strokeStyle, o2 = this.lineCap, s3 = this.lineWidth, u3 = Math.abs(s3 * this.ctx.transform.scaleX), c3 = this.lineJoin, l3 = JSON.parse(JSON.stringify(this.path)), h2 = JSON.parse(JSON.stringify(this.path)), f3 = [], d3 = 0; d3 < h2.length; d3++) if (void 0 !== h2[d3].x) for (var p3 = y2.call(this, h2[d3]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f3.indexOf(p3[g3]) && f3.push(p3[g3]);
    for (var m3 = 0; m3 < f3.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f3[m3]; ) w2.call(this);
    if (L2(f3), this.autoPaging) for (var v3 = f3[0], x3 = f3[f3.length - 1], S3 = v3; S3 < x3 + 1; S3++) {
      this.pdf.setPage(S3), this.fillStyle = i3, this.strokeStyle = a3, this.lineCap = o2, this.lineWidth = u3, this.lineJoin = c3;
      var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], F3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], I3 = 1 === S3 ? 0 : k3 + (S3 - 2) * F3;
      if (0 !== this.ctx.clip_path.length) {
        var j3 = this.path;
        n3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(n3, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), A2.call(this, t3, true), this.path = j3;
      }
      if (r3 = JSON.parse(JSON.stringify(l3)), this.path = N2(r3, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
        var C3 = (S3 > v3 || S3 < x3) && b2.call(this);
        C3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, F3, null).clip().discardPath()), A2.call(this, t3, e3), C3 && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = s3;
    }
    else this.lineWidth = u3, A2.call(this, t3, e3), this.lineWidth = s3;
    this.path = l3;
  }, A2 = function(t3, e3) {
    if (("stroke" !== t3 || e3 || !v2.call(this)) && ("stroke" === t3 || e3 || !m2.call(this))) {
      for (var n3, r3, i3 = [], a3 = this.path, o2 = 0; o2 < a3.length; o2++) {
        var s3 = a3[o2];
        switch (s3.type) {
          case "begin":
            i3.push({ begin: true });
            break;
          case "close":
            i3.push({ close: true });
            break;
          case "mt":
            i3.push({ start: s3, deltas: [], abs: [] });
            break;
          case "lt":
            var u3 = i3.length;
            if (a3[o2 - 1] && !isNaN(a3[o2 - 1].x) && (n3 = [s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], u3 > 0)) {
              for (; u3 >= 0; u3--) if (true !== i3[u3 - 1].close && true !== i3[u3 - 1].begin) {
                i3[u3 - 1].deltas.push(n3), i3[u3 - 1].abs.push(s3);
                break;
              }
            }
            break;
          case "bct":
            n3 = [s3.x1 - a3[o2 - 1].x, s3.y1 - a3[o2 - 1].y, s3.x2 - a3[o2 - 1].x, s3.y2 - a3[o2 - 1].y, s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n3);
            break;
          case "qct":
            var c3 = a3[o2 - 1].x + 2 / 3 * (s3.x1 - a3[o2 - 1].x), l3 = a3[o2 - 1].y + 2 / 3 * (s3.y1 - a3[o2 - 1].y), h2 = s3.x + 2 / 3 * (s3.x1 - s3.x), f3 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
            n3 = [c3 - a3[o2 - 1].x, l3 - a3[o2 - 1].y, h2 - a3[o2 - 1].x, f3 - a3[o2 - 1].y, d3 - a3[o2 - 1].x, p3 - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n3);
            break;
          case "arc":
            i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
        }
      }
      r3 = e3 ? null : "stroke" === t3 ? "stroke" : "fill";
      for (var g3 = false, b3 = 0; b3 < i3.length; b3++) if (i3[b3].arc) for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
        var N3 = y3[w3];
        "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : C2.call(this, N3.x, N3.y), g3 = true;
      }
      else if (true === i3[b3].close) this.pdf.internal.out("h"), g3 = false;
      else if (true !== i3[b3].begin) {
        var L3 = i3[b3].start.x, x3 = i3[b3].start.y;
        O2.call(this, i3[b3].deltas, L3, x3), g3 = true;
      }
      r3 && k2.call(this, r3), e3 && F2.call(this);
    }
  }, S2 = function(t3) {
    var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, n3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return t3 - n3;
      case "top":
        return t3 + e3 - n3;
      case "hanging":
        return t3 + e3 - 2 * n3;
      case "middle":
        return t3 + e3 / 2 - n3;
      default:
        return t3;
    }
  }, _2 = function(t3) {
    return t3 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  p2.prototype.createLinearGradient = function() {
    var t3 = function() {
    };
    return t3.colorStops = [], t3.addColorStop = function(t4, e3) {
      this.colorStops.push([t4, e3]);
    }, t3.getColor = function() {
      return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
    }, t3.isCanvasGradient = true, t3;
  }, p2.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, p2.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var P2 = function(t3, e3, n3, r3, i3, a3, o2, s3, u3) {
    for (var c3 = M2.call(this, n3, r3, i3, a3), l3 = 0; l3 < c3.length; l3++) {
      var h2 = c3[l3];
      0 === l3 && (u3 ? I2.call(this, h2.x1 + t3, h2.y1 + e3) : C2.call(this, h2.x1 + t3, h2.y1 + e3)), B3.call(this, t3, e3, h2.x2, h2.y2, h2.x3, h2.y3, h2.x4, h2.y4);
    }
    s3 ? F2.call(this) : k2.call(this, o2);
  }, k2 = function(t3) {
    switch (t3) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, F2 = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, I2 = function(t3, e3) {
    this.pdf.internal.out(r2(t3) + " " + i2(e3) + " m");
  }, j2 = function(t3) {
    var e3;
    switch (t3.align) {
      case "right":
      case "end":
        e3 = "right";
        break;
      case "center":
        e3 = "center";
        break;
      default:
        e3 = "left";
    }
    var n3 = this.pdf.getTextDimensions(t3.text), r3 = S2.call(this, t3.y), i3 = _2.call(this, r3) - n3.h, a3 = this.ctx.transform.applyToPoint(new u2(t3.x, r3)), o2 = this.ctx.transform.decompose(), s3 = new l2();
    s3 = (s3 = (s3 = s3.multiply(o2.translate)).multiply(o2.skew)).multiply(o2.scale);
    for (var h2, f3, d3, p3 = this.ctx.transform.applyToRectangle(new c2(t3.x, r3, n3.w, n3.h)), g3 = s3.applyToRectangle(new c2(t3.x, i3, n3.w, n3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1) -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
    if (L2(v3), this.autoPaging) for (var x3 = v3[0], P3 = v3[v3.length - 1], k3 = x3; k3 < P3 + 1; k3++) {
      this.pdf.setPage(k3);
      var F3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], I3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], j3 = this.pdf.internal.pageSize.height - this.margin[2], C3 = j3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : I3 + (k3 - 2) * C3;
      if (0 !== this.ctx.clip_path.length) {
        var q3 = this.path;
        h2 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(h2, this.posX + this.margin[3], -1 * M3 + F3), A2.call(this, "fill", true), this.path = q3;
      }
      var E3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + F3 + this.ctx.prevPageLastElemOffset)[0];
      t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale);
      var R3 = "text" !== this.autoPaging;
      if (R3 || E3.y + E3.h <= j3) {
        if (R3 || E3.y >= F3 && E3.x <= O3) {
          var D3 = R3 ? t3.text : this.pdf.splitTextToSize(t3.text, t3.maxWidth || O3 - E3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + F3 + this.ctx.prevPageLastElemOffset)[0], z2 = R3 && (k3 > x3 || k3 < P3) && b2.call(this);
          z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, C3, null).clip().discardPath()), this.pdf.text(D3, T3.x, T3.y, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode }), z2 && this.pdf.restoreGraphicsState();
        }
      } else E3.y < j3 && (this.ctx.prevPageLastElemOffset += j3 - E3.y);
      t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
    }
    else t3.scale >= 0.01 && (f3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(f3 * t3.scale), d3 = this.lineWidth, this.lineWidth = d3 * t3.scale), this.pdf.text(t3.text, a3.x + this.posX, a3.y + this.posY, { angle: t3.angle, align: e3, renderingMode: t3.renderingMode, maxWidth: t3.maxWidth }), t3.scale >= 0.01 && (this.pdf.setFontSize(f3), this.lineWidth = d3);
  }, C2 = function(t3, e3, n3, a3) {
    n3 = n3 || 0, a3 = a3 || 0, this.pdf.internal.out(r2(t3 + n3) + " " + i2(e3 + a3) + " l");
  }, O2 = function(t3, e3, n3) {
    return this.pdf.lines(t3, e3, n3, null, null);
  }, B3 = function(t3, e3, r3, i3, o2, u3, c3, l3) {
    this.pdf.internal.out([n2(a2(r3 + t3)), n2(s2(i3 + e3)), n2(a2(o2 + t3)), n2(s2(u3 + e3)), n2(a2(c3 + t3)), n2(s2(l3 + e3)), "c"].join(" "));
  }, M2 = function(t3, e3, n3, r3) {
    for (var i3 = 2 * Math.PI, a3 = Math.PI / 2; e3 > n3; ) e3 -= i3;
    var o2 = Math.abs(n3 - e3);
    o2 < i3 && r3 && (o2 = i3 - o2);
    for (var s3 = [], u3 = r3 ? -1 : 1, c3 = e3; o2 > 1e-5; ) {
      var l3 = c3 + u3 * Math.min(o2, a3);
      s3.push(q2.call(this, t3, c3, l3)), o2 -= Math.abs(l3 - c3), c3 = l3;
    }
    return s3;
  }, q2 = function(t3, e3, n3) {
    var r3 = (n3 - e3) / 2, i3 = t3 * Math.cos(r3), a3 = t3 * Math.sin(r3), o2 = i3, s3 = -a3, u3 = o2 * o2 + s3 * s3, c3 = u3 + o2 * i3 + s3 * a3, l3 = 4 / 3 * (Math.sqrt(2 * u3 * c3) - c3) / (o2 * a3 - s3 * i3), h2 = o2 - l3 * s3, f3 = s3 + l3 * o2, d3 = h2, p3 = -f3, g3 = r3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
    return { x1: t3 * Math.cos(e3), y1: t3 * Math.sin(e3), x2: h2 * m3 - f3 * v3, y2: h2 * v3 + f3 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t3 * Math.cos(n3), y4: t3 * Math.sin(n3) };
  }, E2 = function(t3) {
    return 180 * t3 / Math.PI;
  }, R2 = function(t3, e3, n3, r3, i3, a3) {
    var o2 = t3 + 0.5 * (n3 - t3), s3 = e3 + 0.5 * (r3 - e3), u3 = i3 + 0.5 * (n3 - i3), l3 = a3 + 0.5 * (r3 - a3), h2 = Math.min(t3, i3, o2, u3), f3 = Math.max(t3, i3, o2, u3), d3 = Math.min(e3, a3, s3, l3), p3 = Math.max(e3, a3, s3, l3);
    return new c2(h2, d3, f3 - h2, p3 - d3);
  }, D2 = function(t3, e3, n3, r3, i3, a3, o2, s3) {
    var u3, l3, h2, f3, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, x3 = n3 - t3, A3 = r3 - e3, S3 = i3 - n3, _3 = a3 - r3, P3 = o2 - i3, k3 = s3 - a3;
    for (l3 = 0; l3 < 41; l3++) v3 = (g3 = (h2 = t3 + (u3 = l3 / 40) * x3) + u3 * ((d3 = n3 + u3 * S3) - h2)) + u3 * (d3 + u3 * (i3 + u3 * P3 - d3) - g3), b3 = (m3 = (f3 = e3 + u3 * A3) + u3 * ((p3 = r3 + u3 * _3) - f3)) + u3 * (p3 + u3 * (a3 + u3 * k3 - p3) - m3), 0 == l3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
    return new c2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
  }, T2 = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var t3, e3, n3 = (t3 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t3, lineDashOffset: e3 }));
      this.prevLineDash !== n3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = n3);
    }
  };
})(E$1.API), /**
 * @license
 * jsPDF filters PlugIn
 * Copyright (c) 2014 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var n2 = function(t4) {
    var e2, n3, r3, i3, a3, o3, s2, u2, c2, l2;
    for (n3 = [], r3 = 0, i3 = (t4 += e2 = "\0\0\0\0".slice(t4.length % 4 || 4)).length; i3 > r3; r3 += 4) 0 !== (a3 = (t4.charCodeAt(r3) << 24) + (t4.charCodeAt(r3 + 1) << 16) + (t4.charCodeAt(r3 + 2) << 8) + t4.charCodeAt(r3 + 3)) ? (o3 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (l2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, n3.push(o3 + 33, s2 + 33, u2 + 33, c2 + 33, l2 + 33)) : n3.push(122);
    return (function(t5, e3) {
      for (var n4 = e3; n4 > 0; n4--) t5.pop();
    })(n3, e2.length), String.fromCharCode.apply(String, n3) + "~>";
  }, r2 = function(t4) {
    var e2, n3, r3, i3, a3, o3 = String, s2 = "length", u2 = 255, c2 = "charCodeAt", l2 = "slice", h2 = "replace";
    for (t4[l2](-2), t4 = t4[l2](0, -2)[h2](/\s/g, "")[h2]("z", "!!!!!"), r3 = [], i3 = 0, a3 = (t4 += e2 = "uuuuu"[l2](t4[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5) n3 = 52200625 * (t4[c2](i3) - 33) + 614125 * (t4[c2](i3 + 1) - 33) + 7225 * (t4[c2](i3 + 2) - 33) + 85 * (t4[c2](i3 + 3) - 33) + (t4[c2](i3 + 4) - 33), r3.push(u2 & n3 >> 24, u2 & n3 >> 16, u2 & n3 >> 8, u2 & n3);
    return (function(t5, e3) {
      for (var n4 = e3; n4 > 0; n4--) t5.pop();
    })(r3, e2[s2]), o3.fromCharCode.apply(o3, r3);
  }, i2 = function(t4) {
    return t4.split("").map(function(t5) {
      return ("0" + t5.charCodeAt().toString(16)).slice(-2);
    }).join("") + ">";
  }, a2 = function(t4) {
    var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if (-1 !== (t4 = t4.replace(/\s/g, "")).indexOf(">") && (t4 = t4.substr(0, t4.indexOf(">"))), t4.length % 2 && (t4 += "0"), false === e2.test(t4)) return "";
    for (var n3 = "", r3 = 0; r3 < t4.length; r3 += 2) n3 += String.fromCharCode("0x" + (t4[r3] + t4[r3 + 1]));
    return n3;
  }, o2 = function(t4) {
    for (var n3 = new Uint8Array(t4.length), r3 = t4.length; r3--; ) n3[r3] = t4.charCodeAt(r3);
    return (n3 = zlibSync(n3)).reduce(function(t5, e2) {
      return t5 + String.fromCharCode(e2);
    }, "");
  };
  t3.processDataByFilters = function(t4, e2) {
    var s2 = 0, u2 = t4 || "", c2 = [];
    for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), s2 = 0; s2 < e2.length; s2 += 1) switch (e2[s2]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        u2 = r2(u2), c2.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        u2 = n2(u2), c2.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        u2 = a2(u2), c2.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        u2 = i2(u2), c2.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        u2 = o2(u2), c2.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + e2[s2] + '" is not implemented');
    }
    return { data: u2, reverseChain: c2.reverse().join(" ") };
  };
})(E$1.API), /**
 * @license
 * jsPDF fileloading PlugIn
 * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  t3.loadFile = function(t4, e2, n2) {
    return (function(t5, e3, n3) {
      e3 = false !== e3, n3 = "function" == typeof n3 ? n3 : function() {
      };
      var r2 = void 0;
      try {
        r2 = (function(t6, e4, n4) {
          var r3 = new XMLHttpRequest(), i2 = 0, a2 = function(t7) {
            var e5 = t7.length, n5 = [], r4 = String.fromCharCode;
            for (i2 = 0; i2 < e5; i2 += 1) n5.push(r4(255 & t7.charCodeAt(i2)));
            return n5.join("");
          };
          if (r3.open("GET", t6, !e4), r3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (r3.onload = function() {
            200 === r3.status ? n4(a2(this.responseText)) : n4(void 0);
          }), r3.send(null), e4 && 200 === r3.status) return a2(r3.responseText);
        })(t5, e3, n3);
      } catch (i2) {
      }
      return r2;
    })(t4, e2, n2);
  }, t3.loadImageFile = t3.loadFile;
})(E$1.API), (function(e2) {
  function n2() {
    return (i$5.html2canvas ? Promise.resolve(i$5.html2canvas) : Promise.resolve().then(() => html2canvas_esm)).catch(function(t3) {
      return Promise.reject(new Error("Could not load html2canvas: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  function r2() {
    return (i$5.DOMPurify ? Promise.resolve(i$5.DOMPurify) : Promise.resolve().then(() => purify_es)).catch(function(t3) {
      return Promise.reject(new Error("Could not load dompurify: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    });
  }
  var a2 = function(e3) {
    var n3 = _typeof$1(e3);
    return "undefined" === n3 ? "undefined" : "string" === n3 || e3 instanceof String ? "string" : "number" === n3 || e3 instanceof Number ? "number" : "function" === n3 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === n3 ? "object" : "unknown";
  }, o2 = function(t3, e3) {
    var n3 = document.createElement(t3);
    for (var r3 in e3.className && (n3.className = e3.className), e3.innerHTML && e3.dompurify && (n3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style) n3.style[r3] = e3.style[r3];
    return n3;
  }, s2 = function t3(e3, n3) {
    for (var r3 = 3 === e3.nodeType ? document.createTextNode(e3.nodeValue) : e3.cloneNode(false), i2 = e3.firstChild; i2; i2 = i2.nextSibling) true !== n3 && 1 === i2.nodeType && "SCRIPT" === i2.nodeName || r3.appendChild(t3(i2, n3));
    return 1 === e3.nodeType && ("CANVAS" === e3.nodeName ? (r3.width = e3.width, r3.height = e3.height, r3.getContext("2d").drawImage(e3, 0, 0)) : "TEXTAREA" !== e3.nodeName && "SELECT" !== e3.nodeName || (r3.value = e3.value), r3.addEventListener("load", function() {
      r3.scrollTop = e3.scrollTop, r3.scrollLeft = e3.scrollLeft;
    }, true)), r3;
  }, u2 = function t3(e3) {
    var n3 = Object.assign(t3.convert(Promise.resolve()), JSON.parse(JSON.stringify(t3.template))), r3 = t3.convert(Promise.resolve(), n3);
    return (r3 = r3.setProgress(1, t3, 1, [t3])).set(e3);
  };
  (u2.prototype = Object.create(Promise.prototype)).constructor = u2, u2.convert = function(t3, e3) {
    return t3.__proto__ = e3 || u2.prototype, t3;
  }, u2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, u2.prototype.from = function(t3, e3) {
    return this.then(function() {
      switch (e3 = e3 || (function(t4) {
        switch (a2(t4)) {
          case "string":
            return "string";
          case "element":
            return "canvas" === t4.nodeName.toLowerCase() ? "canvas" : "element";
          default:
            return "unknown";
        }
      })(t3), e3) {
        case "string":
          return this.then(r2).then(function(e4) {
            return this.set({ src: o2("div", { innerHTML: t3, dompurify: e4 }) });
          });
        case "element":
          return this.set({ src: t3 });
        case "canvas":
          return this.set({ canvas: t3 });
        case "img":
          return this.set({ img: t3 });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, u2.prototype.to = function(t3) {
    switch (t3) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, u2.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var t3 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = s2(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      "BODY" === e3.tagName && (t3.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t3 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, u2.prototype.toCanvas = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(n2).then(function(t4) {
      var e3 = Object.assign({}, this.opt.html2canvas);
      return delete e3.onrendered, t4(this.prop.container, e3);
    }).then(function(t4) {
      (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, u2.prototype.toContext2d = function() {
    var t3 = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(t3).then(n2).then(function(t4) {
      var e3 = this.opt.jsPDF, n3 = this.opt.fontFaces, r3 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i2 = Object.assign({ async: true, allowTaint: true, scale: r3, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
      if (delete i2.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = n3, n3) for (var a3 = 0; a3 < n3.length; ++a3) {
        var o3 = n3[a3], s3 = o3.src.find(function(t5) {
          return "truetype" === t5.format;
        });
        s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
      }
      return i2.windowHeight = i2.windowHeight || 0, i2.windowHeight = 0 == i2.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i2.windowHeight, e3.context2d.save(true), t4(this.prop.container, i2);
    }).then(function(t4) {
      this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
      })(t4), this.prop.canvas = t4, document.body.removeChild(this.prop.overlay);
    });
  }, u2.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var t3 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = t3;
    });
  }, u2.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, u2.prototype.output = function(t3, e3, n3) {
    return "img" === (n3 = n3 || "pdf").toLowerCase() || "image" === n3.toLowerCase() ? this.outputImg(t3, e3) : this.outputPdf(t3, e3);
  }, u2.prototype.outputPdf = function(t3, e3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(t3, e3);
    });
  }, u2.prototype.outputImg = function(t3) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (t3) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + t3 + '" is not supported.';
      }
    });
  }, u2.prototype.save = function(t3) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(t3 ? { filename: t3 } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, u2.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, u2.prototype.set = function(t3) {
    if ("object" !== a2(t3)) return this;
    var e3 = Object.keys(t3 || {}).map(function(e4) {
      if (e4 in u2.template.prop) return function() {
        this.prop[e4] = t3[e4];
      };
      switch (e4) {
        case "margin":
          return this.setMargin.bind(this, t3.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = t3.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, t3.pageSize);
        default:
          return function() {
            this.opt[e4] = t3[e4];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(e3);
    });
  }, u2.prototype.get = function(t3, e3) {
    return this.then(function() {
      var n3 = t3 in u2.template.prop ? this.prop[t3] : this.opt[t3];
      return e3 ? e3(n3) : n3;
    });
  }, u2.prototype.setMargin = function(t3) {
    return this.then(function() {
      switch (a2(t3)) {
        case "number":
          t3 = [t3, t3, t3, t3];
        case "array":
          if (2 === t3.length && (t3 = [t3[0], t3[1], t3[0], t3[1]]), 4 === t3.length) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = t3;
    }).then(this.setPageSize);
  }, u2.prototype.setPageSize = function(t3) {
    function e3(t4, e4) {
      return Math.floor(t4 * e4 / 72 * 96);
    }
    return this.then(function() {
      (t3 = t3 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t3.inner = { width: t3.width - this.opt.margin[1] - this.opt.margin[3], height: t3.height - this.opt.margin[0] - this.opt.margin[2] }, t3.inner.px = { width: e3(t3.inner.width, t3.k), height: e3(t3.inner.height, t3.k) }, t3.inner.ratio = t3.inner.height / t3.inner.width), this.prop.pageSize = t3;
    });
  }, u2.prototype.setProgress = function(t3, e3, n3, r3) {
    return null != t3 && (this.progress.val = t3), null != e3 && (this.progress.state = e3), null != n3 && (this.progress.n = n3), null != r3 && (this.progress.stack = r3), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, u2.prototype.updateProgress = function(t3, e3, n3, r3) {
    return this.setProgress(t3 ? this.progress.val + t3 : null, e3 || null, n3 ? this.progress.n + n3 : null, r3 ? this.progress.stack.concat(r3) : null);
  }, u2.prototype.then = function(t3, e3) {
    var n3 = this;
    return this.thenCore(t3, e3, function(t4, e4) {
      return n3.updateProgress(null, null, 1, [t4]), Promise.prototype.then.call(this, function(e5) {
        return n3.updateProgress(null, t4), e5;
      }).then(t4, e4).then(function(t5) {
        return n3.updateProgress(1), t5;
      });
    });
  }, u2.prototype.thenCore = function(t3, e3, n3) {
    n3 = n3 || Promise.prototype.then;
    var r3 = this;
    t3 && (t3 = t3.bind(r3)), e3 && (e3 = e3.bind(r3));
    var i2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? r3 : u2.convert(Object.assign({}, r3), Promise.prototype), a3 = n3.call(i2, t3, e3);
    return u2.convert(a3, r3.__proto__);
  }, u2.prototype.thenExternal = function(t3, e3) {
    return Promise.prototype.then.call(this, t3, e3);
  }, u2.prototype.thenList = function(t3) {
    var e3 = this;
    return t3.forEach(function(t4) {
      e3 = e3.thenCore(t4);
    }), e3;
  }, u2.prototype.catch = function(t3) {
    t3 && (t3 = t3.bind(this));
    var e3 = Promise.prototype.catch.call(this, t3);
    return u2.convert(e3, this);
  }, u2.prototype.catchExternal = function(t3) {
    return Promise.prototype.catch.call(this, t3);
  }, u2.prototype.error = function(t3) {
    return this.then(function() {
      throw new Error(t3);
    });
  }, u2.prototype.using = u2.prototype.set, u2.prototype.saveAs = u2.prototype.save, u2.prototype.export = u2.prototype.output, u2.prototype.run = u2.prototype.then, E$1.getPageSize = function(e3, n3, r3) {
    if ("object" === _typeof$1(e3)) {
      var i2 = e3;
      e3 = i2.orientation, n3 = i2.unit || n3, r3 = i2.format || r3;
    }
    n3 = n3 || "mm", r3 = r3 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
    var a3, o3 = ("" + r3).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (n3) {
      case "pt":
        a3 = 1;
        break;
      case "mm":
        a3 = 72 / 25.4;
        break;
      case "cm":
        a3 = 72 / 2.54;
        break;
      case "in":
        a3 = 72;
        break;
      case "px":
        a3 = 0.75;
        break;
      case "pc":
      case "em":
        a3 = 12;
        break;
      case "ex":
        a3 = 6;
        break;
      default:
        throw "Invalid unit: " + n3;
    }
    var u3, c2 = 0, l2 = 0;
    if (s3.hasOwnProperty(o3)) c2 = s3[o3][1] / a3, l2 = s3[o3][0] / a3;
    else try {
      c2 = r3[1], l2 = r3[0];
    } catch (h2) {
      throw new Error("Invalid format: " + r3);
    }
    if ("p" === e3 || "portrait" === e3) e3 = "p", l2 > c2 && (u3 = l2, l2 = c2, c2 = u3);
    else {
      if ("l" !== e3 && "landscape" !== e3) throw "Invalid orientation: " + e3;
      e3 = "l", c2 > l2 && (u3 = l2, l2 = c2, c2 = u3);
    }
    return { width: l2, height: c2, unit: n3, k: a3, orientation: e3 };
  }, e2.html = function(t3, e3) {
    (e3 = e3 || {}).callback = e3.callback || function() {
    }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(Ct) : null;
    var n3 = new u2(e3);
    return e3.worker ? n3 : n3.from(t3).doCallback();
  };
})(E$1.API), E$1.API.addJS = function(t3) {
  return Ut = t3, this.internal.events.subscribe("postPutResources", function() {
    Tt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Tt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ut + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    void 0 !== Tt && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Tt + " 0 R>>");
  }), this;
}, /**
 * @license
 * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2;
  t3.events.push(["postPutResources", function() {
    var t4 = this, n2 = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r2 = t4.outline.render().split(/\r\n/), i2 = 0; i2 < r2.length; i2++) {
      var a2 = r2[i2], o2 = n2.exec(a2);
      if (null != o2) {
        var s2 = o2[1];
        t4.internal.newObjectDeferredBegin(s2, false);
      }
      t4.internal.write(a2);
    }
    if (this.outline.createNamedDestinations) {
      var u2 = this.internal.pages.length, c2 = [];
      for (i2 = 0; i2 < u2; i2++) {
        var l2 = t4.internal.newObject();
        c2.push(l2);
        var h2 = t4.internal.getPageInfo(i2 + 1);
        t4.internal.write("<< /D[" + h2.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var f2 = t4.internal.newObject();
      for (t4.internal.write("<< /Names [ "), i2 = 0; i2 < c2.length; i2++) t4.internal.write("(page_" + (i2 + 1) + ")" + c2[i2] + " 0 R");
      t4.internal.write(" ] >>", "endobj"), e2 = t4.internal.newObject(), t4.internal.write("<< /Dests " + f2 + " 0 R"), t4.internal.write(">>", "endobj");
    }
  }]), t3.events.push(["putCatalog", function() {
    var t4 = this;
    t4.outline.root.children.length > 0 && (t4.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t4.internal.write("/Names " + e2 + " 0 R"));
  }]), t3.events.push(["initialized", function() {
    var t4 = this;
    t4.outline = { createNamedDestinations: false, root: { children: [] } }, t4.outline.add = function(t5, e3, n2) {
      var r2 = { title: e3, options: n2, children: [] };
      return null == t5 && (t5 = this.root), t5.children.push(r2), r2;
    }, t4.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t4, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t4.outline.genIds_r = function(e3) {
      e3.id = t4.internal.newObjectDeferred();
      for (var n2 = 0; n2 < e3.children.length; n2++) this.genIds_r(e3.children[n2]);
    }, t4.outline.renderRoot = function(t5) {
      this.objStart(t5), this.line("/Type /Outlines"), t5.children.length > 0 && (this.line("/First " + this.makeRef(t5.children[0])), this.line("/Last " + this.makeRef(t5.children[t5.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t5)), this.objEnd();
    }, t4.outline.renderItems = function(e3) {
      for (var n2 = this.ctx.pdf.internal.getVerticalCoordinateString, r2 = 0; r2 < e3.children.length; r2++) {
        var i2 = e3.children[r2];
        this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), r2 > 0 && this.line("/Prev " + this.makeRef(e3.children[r2 - 1])), r2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[r2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
        var a2 = this.count = this.count_r({ count: 0 }, i2);
        if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
          var o2 = t4.internal.getPageInfo(i2.options.pageNumber);
          this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + n2(0) + " 0]");
        }
        this.objEnd();
      }
      for (var s2 = 0; s2 < e3.children.length; s2++) this.renderItems(e3.children[s2]);
    }, t4.outline.line = function(t5) {
      this.ctx.val += t5 + "\r\n";
    }, t4.outline.makeRef = function(t5) {
      return t5.id + " 0 R";
    }, t4.outline.makeString = function(e3) {
      return "(" + t4.internal.pdfEscape(e3) + ")";
    }, t4.outline.objStart = function(t5) {
      this.ctx.val += "\r\n" + t5.id + " 0 obj\r\n<<\r\n";
    }, t4.outline.objEnd = function() {
      this.ctx.val += ">> \r\nendobj\r\n";
    }, t4.outline.count_r = function(t5, e3) {
      for (var n2 = 0; n2 < e3.children.length; n2++) t5.count++, this.count_r(t5, e3.children[n2]);
      return t5.count;
    };
  }]);
})(E$1.API), /**
 * @license
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
  t3.processJPEG = function(t4, n2, r2, i2, a2, o2) {
    var s2, u2 = this.decode.DCT_DECODE, c2 = null;
    if ("string" == typeof t4 || this.__addimage__.isArrayBuffer(t4) || this.__addimage__.isArrayBufferView(t4)) {
      switch (t4 = a2 || t4, t4 = this.__addimage__.isArrayBuffer(t4) ? new Uint8Array(t4) : t4, s2 = (function(t5) {
        for (var n3, r3 = 256 * t5.charCodeAt(4) + t5.charCodeAt(5), i3 = t5.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
          if (o3 += r3, -1 !== e2.indexOf(t5.charCodeAt(o3 + 1))) {
            n3 = 256 * t5.charCodeAt(o3 + 5) + t5.charCodeAt(o3 + 6), a3 = { width: 256 * t5.charCodeAt(o3 + 7) + t5.charCodeAt(o3 + 8), height: n3, numcomponents: t5.charCodeAt(o3 + 9) };
            break;
          }
          r3 = 256 * t5.charCodeAt(o3 + 2) + t5.charCodeAt(o3 + 3);
        }
        return a3;
      })(t4 = this.__addimage__.isArrayBufferView(t4) ? this.__addimage__.arrayBufferToBinaryString(t4) : t4), s2.numcomponents) {
        case 1:
          o2 = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o2 = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o2 = this.color_spaces.DEVICE_RGB;
      }
      c2 = { data: t4, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: u2, index: n2, alias: r2 };
    }
    return c2;
  };
})(E$1.API), E$1.API.processPNG = function(t3, i2, a2, o2) {
  if (this.__addimage__.isArrayBuffer(t3) && (t3 = new Uint8Array(t3)), this.__addimage__.isArrayBufferView(t3)) {
    var s2, u2 = decodePng(t3, { checkCrc: true }), c2 = u2.width, l2 = u2.height, h2 = u2.channels, f2 = u2.palette, d2 = u2.depth;
    s2 = f2 && 1 === h2 ? (function(t4) {
      for (var e2 = t4.width, r2 = t4.height, i3 = t4.data, a3 = t4.palette, o3 = t4.depth, s3 = false, u3 = [], c3 = [], l3 = void 0, h3 = false, f3 = 0, d3 = 0; d3 < a3.length; d3++) {
        var p3 = _slicedToArray(a3[d3], 4), g3 = p3[0], m3 = p3[1], v3 = p3[2], b3 = p3[3];
        u3.push(g3, m3, v3), null != b3 && (0 === b3 ? (f3++, c3.length < 1 && c3.push(d3)) : b3 < 255 && (h3 = true));
      }
      if (h3 || f3 > 1) {
        s3 = true, c3 = void 0;
        var y3 = e2 * r2;
        l3 = new Uint8Array(y3);
        for (var w3 = new DataView(i3.buffer), N3 = 0; N3 < y3; N3++) {
          var L3 = re(w3, N3, o3), x3 = _slicedToArray(a3[L3], 4)[3];
          l3[N3] = x3;
        }
      } else 0 === f3 && (c3 = void 0);
      return { colorSpace: "Indexed", colorsPerPixel: 1, sMaskBitsPerComponent: s3 ? 8 : void 0, colorBytes: i3, alphaBytes: l3, needSMask: s3, palette: u3, mask: c3 };
    })(u2) : 2 === h2 || 4 === h2 ? (function(t4) {
      for (var e2 = t4.data, n2 = t4.width, r2 = t4.height, i3 = t4.channels, a3 = t4.depth, o3 = 2 === i3 ? "DeviceGray" : "DeviceRGB", s3 = i3 - 1, u3 = n2 * r2, c3 = s3, l3 = u3 * c3, h3 = 1 * u3, f3 = Math.ceil(l3 * a3 / 8), d3 = Math.ceil(h3 * a3 / 8), p3 = new Uint8Array(f3), g3 = new Uint8Array(d3), m3 = new DataView(e2.buffer), v3 = new DataView(p3.buffer), b3 = new DataView(g3.buffer), y3 = false, w3 = 0; w3 < u3; w3++) {
        for (var N3 = w3 * i3, L3 = 0; L3 < c3; L3++) ie(v3, re(m3, N3 + L3, a3), w3 * c3 + L3, a3);
        var x3 = re(m3, N3 + c3, a3);
        x3 < (1 << a3) - 1 && (y3 = true), ie(b3, x3, 1 * w3, a3);
      }
      return { colorSpace: o3, colorsPerPixel: s3, sMaskBitsPerComponent: y3 ? a3 : void 0, colorBytes: p3, alphaBytes: g3, needSMask: y3 };
    })(u2) : (function(t4) {
      var e2 = t4.data, n2 = 1 === t4.channels ? "DeviceGray" : "DeviceRGB";
      return { colorSpace: n2, colorsPerPixel: "DeviceGray" === n2 ? 1 : 3, colorBytes: e2 instanceof Uint16Array ? (function(t5) {
        for (var e3 = t5.length, n3 = new Uint8Array(2 * e3), r2 = new DataView(n3.buffer, n3.byteOffset, n3.byteLength), i3 = 0; i3 < e3; i3++) r2.setUint16(2 * i3, t5[i3], false);
        return n3;
      })(e2) : e2, needSMask: false };
    })(u2);
    var p2, g2, m2, v2 = s2, b2 = v2.colorSpace, y2 = v2.colorsPerPixel, w2 = v2.sMaskBitsPerComponent, N2 = v2.colorBytes, L2 = v2.alphaBytes, x2 = v2.needSMask, A2 = v2.palette, S2 = v2.mask, _2 = null;
    return o2 !== E$1.API.image_compression.NONE && "function" == typeof zlibSync ? (_2 = (function(t4) {
      var e2;
      switch (t4) {
        case E$1.API.image_compression.FAST:
          e2 = 11;
          break;
        case E$1.API.image_compression.MEDIUM:
          e2 = 13;
          break;
        case E$1.API.image_compression.SLOW:
          e2 = 14;
          break;
        default:
          e2 = 12;
      }
      return e2;
    })(o2), p2 = this.decode.FLATE_DECODE, g2 = "/Predictor ".concat(_2, " /Colors ").concat(y2, " /BitsPerComponent ").concat(d2, " /Columns ").concat(c2), t3 = Xt(N2, Math.ceil(c2 * y2 * d2 / 8), y2, d2, o2), x2 && (m2 = Xt(L2, Math.ceil(c2 * w2 / 8), 1, w2, o2))) : (p2 = void 0, g2 = void 0, t3 = N2, x2 && (m2 = L2)), (this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) && (t3 = this.__addimage__.arrayBufferToBinaryString(t3)), (m2 && this.__addimage__.isArrayBuffer(m2) || this.__addimage__.isArrayBufferView(m2)) && (m2 = this.__addimage__.arrayBufferToBinaryString(m2)), { alias: a2, data: t3, index: i2, filter: p2, decodeParameters: g2, transparency: S2, palette: A2, sMask: m2, predictor: _2, width: c2, height: l2, bitsPerComponent: d2, sMaskBitsPerComponent: w2, colorSpace: b2 };
  }
}, (function(t3) {
  t3.processGIF89A = function(e2, n2, r2, i2) {
    var a2 = new oe(e2), o2 = a2.width, s2 = a2.height, u2 = [];
    a2.decodeAndBlitFrameRGBA(0, u2);
    var c2 = { data: u2, width: o2, height: s2 }, l2 = new ue(100).encode(c2, 100);
    return t3.processJPEG.call(this, l2, n2, r2, i2);
  }, t3.processGIF87A = t3.processGIF89A;
})(E$1.API), ce.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var t3 = 0 === this.colors ? 1 << this.bitPP : this.colors;
    this.palette = new Array(t3);
    for (var e2 = 0; e2 < t3; e2++) {
      var n2 = this.datav.getUint8(this.pos++, true), r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
      this.palette[e2] = { red: i2, green: r2, blue: n2, quad: a2 };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = false);
}, ce.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var t3 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
    this.data = new Uint8Array(e2), this[t3]();
  } catch (n2) {
    o$1.log("bit decode error:" + n2);
  }
}, ce.prototype.bit1 = function() {
  var t3, e2 = Math.ceil(this.width / 8), n2 = e2 % 4;
  for (t3 = this.height - 1; t3 >= 0; t3--) {
    for (var r2 = this.bottom_up ? t3 : this.height - 1 - t3, i2 = 0; i2 < e2; i2++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = r2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
      var u2 = this.palette[a2 >> 7 - s2 & 1];
      this.data[o2 + 4 * s2] = u2.blue, this.data[o2 + 4 * s2 + 1] = u2.green, this.data[o2 + 4 * s2 + 2] = u2.red, this.data[o2 + 4 * s2 + 3] = 255;
    }
    0 !== n2 && (this.pos += 4 - n2);
  }
}, ce.prototype.bit4 = function() {
  for (var t3 = Math.ceil(this.width / 2), e2 = t3 % 4, n2 = this.height - 1; n2 >= 0; n2--) {
    for (var r2 = this.bottom_up ? n2 : this.height - 1 - n2, i2 = 0; i2 < t3; i2++) {
      var a2 = this.datav.getUint8(this.pos++, true), o2 = r2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, u2 = 15 & a2, c2 = this.palette[s2];
      if (this.data[o2] = c2.blue, this.data[o2 + 1] = c2.green, this.data[o2 + 2] = c2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
      c2 = this.palette[u2], this.data[o2 + 4] = c2.blue, this.data[o2 + 4 + 1] = c2.green, this.data[o2 + 4 + 2] = c2.red, this.data[o2 + 4 + 3] = 255;
    }
    0 !== e2 && (this.pos += 4 - e2);
  }
}, ce.prototype.bit8 = function() {
  for (var t3 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
    for (var n2 = this.bottom_up ? e2 : this.height - 1 - e2, r2 = 0; r2 < this.width; r2++) {
      var i2 = this.datav.getUint8(this.pos++, true), a2 = n2 * this.width * 4 + 4 * r2;
      if (i2 < this.palette.length) {
        var o2 = this.palette[i2];
        this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
      } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
    }
    0 !== t3 && (this.pos += 4 - t3);
  }
}, ce.prototype.bit15 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
    for (var r2 = this.bottom_up ? n2 : this.height - 1 - n2, i2 = 0; i2 < this.width; i2++) {
      var a2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, u2 = (a2 >> 10 & e2) / e2 * 255 | 0, c2 = a2 >> 15 ? 255 : 0, l2 = r2 * this.width * 4 + 4 * i2;
      this.data[l2] = u2, this.data[l2 + 1] = s2, this.data[l2 + 2] = o2, this.data[l2 + 3] = c2;
    }
    this.pos += t3;
  }
}, ce.prototype.bit16 = function() {
  for (var t3 = this.width % 3, e2 = parseInt("11111", 2), n2 = parseInt("111111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
    for (var i2 = this.bottom_up ? r2 : this.height - 1 - r2, a2 = 0; a2 < this.width; a2++) {
      var o2 = this.datav.getUint16(this.pos, true);
      this.pos += 2;
      var s2 = (o2 & e2) / e2 * 255 | 0, u2 = (o2 >> 5 & n2) / n2 * 255 | 0, c2 = (o2 >> 11) / e2 * 255 | 0, l2 = i2 * this.width * 4 + 4 * a2;
      this.data[l2] = c2, this.data[l2 + 1] = u2, this.data[l2 + 2] = s2, this.data[l2 + 3] = 255;
    }
    this.pos += t3;
  }
}, ce.prototype.bit24 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) {
    for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, n2 = 0; n2 < this.width; n2++) {
      var r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * n2;
      this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = r2, this.data[o2 + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, ce.prototype.bit32 = function() {
  for (var t3 = this.height - 1; t3 >= 0; t3--) for (var e2 = this.bottom_up ? t3 : this.height - 1 - t3, n2 = 0; n2 < this.width; n2++) {
    var r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * n2;
    this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = r2, this.data[s2 + 3] = o2;
  }
}, ce.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2018 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  t3.processBMP = function(e2, n2, r2, i2) {
    var a2 = new ce(e2, false), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue(100).encode(u2, 100);
    return t3.processJPEG.call(this, c2, n2, r2, i2);
  };
})(E$1.API), le.prototype.getData = function() {
  return this.data;
}, /**
 * @license
 * Copyright (c) 2019 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  t3.processWEBP = function(e2, n2, r2, i2) {
    var a2 = new le(e2), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue(100).encode(u2, 100);
    return t3.processJPEG.call(this, c2, n2, r2, i2);
  };
})(E$1.API), E$1.API.processRGBA = function(t3, e2, n2) {
  for (var r2 = t3.data, i2 = r2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, u2 = 0, c2 = 0; c2 < i2; c2 += 4) {
    var l2 = r2[c2], h2 = r2[c2 + 1], f2 = r2[c2 + 2], d2 = r2[c2 + 3];
    a2[s2++] = l2, a2[s2++] = h2, a2[s2++] = f2, o2[u2++] = d2;
  }
  var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e2, alias: n2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t3.width, height: t3.height };
}, E$1.API.setLanguage = function(t3) {
  return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t3] && (this.internal.languageSettings.languageCode = t3, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = true)), this;
}, Ht = E$1.API, Wt = Ht.getCharWidthsArray = function(e2, n2) {
  var r2, i2, a2 = (n2 = n2 || {}).font || this.internal.getFont(), o2 = n2.fontSize || this.internal.getFontSize(), s2 = n2.charSpace || this.internal.getCharSpace(), u2 = n2.widths ? n2.widths : a2.metadata.Unicode.widths, c2 = u2.fof ? u2.fof : 1, l2 = n2.kerning ? n2.kerning : a2.metadata.Unicode.kerning, h2 = l2.fof ? l2.fof : 1, f2 = false !== n2.doKerning, d2 = 0, p2 = e2.length, g2 = 0, m2 = u2[0] || c2, v2 = [];
  for (r2 = 0; r2 < p2; r2++) i2 = e2.charCodeAt(r2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof$1(l2[i2]) && !isNaN(parseInt(l2[i2][g2], 10)) ? l2[i2][g2] / h2 : 0, v2.push((u2[i2] || m2) / c2 + d2)), g2 = i2;
  return v2;
}, Vt = Ht.getStringUnitWidth = function(t3, e2) {
  var n2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), r2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
  return Ht.processArabic && (t3 = Ht.processArabic(t3)), "function" == typeof r2.metadata.widthOfString ? r2.metadata.widthOfString(t3, n2, i2) / n2 : Wt.apply(this, arguments).reduce(function(t4, e3) {
    return t4 + e3;
  }, 0);
}, Gt = function(t3, e2, n2, r2) {
  for (var i2 = [], a2 = 0, o2 = t3.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < n2; ) s2 += e2[a2], a2++;
  i2.push(t3.slice(0, a2));
  var u2 = a2;
  for (s2 = 0; a2 !== o2; ) s2 + e2[a2] > r2 && (i2.push(t3.slice(u2, a2)), s2 = 0, u2 = a2), s2 += e2[a2], a2++;
  return u2 !== a2 && i2.push(t3.slice(u2, a2)), i2;
}, Yt = function(t3, e2, n2) {
  n2 || (n2 = {});
  var r2, i2, a2, o2, s2, u2, c2, l2 = [], h2 = [l2], f2 = n2.textIndent || 0, d2 = 0, p2 = 0, g2 = t3.split(" "), m2 = Wt.apply(this, [" ", n2])[0];
  if (u2 = -1 === n2.lineIndent ? g2[0].length + 2 : n2.lineIndent || 0) {
    var v2 = Array(u2).join(" "), b2 = [];
    g2.map(function(t4) {
      (t4 = t4.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t4.map(function(t5, e3) {
        return (e3 && t5.length ? "\n" : "") + t5;
      })) : b2.push(t4[0]);
    }), g2 = b2, u2 = Vt.apply(this, [v2, n2]);
  }
  for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
    var y2 = 0;
    if (r2 = g2[a2], u2 && "\n" == r2[0] && (r2 = r2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Wt.apply(this, [r2, n2])).reduce(function(t4, e3) {
      return t4 + e3;
    }, 0)) > e2 || y2) {
      if (p2 > e2) {
        for (s2 = Gt.apply(this, [r2, i2, e2 - (f2 + d2), e2]), l2.push(s2.shift()), l2 = [s2.pop()]; s2.length; ) h2.push([s2.shift()]);
        p2 = i2.slice(r2.length - (l2[0] ? l2[0].length : 0)).reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
      } else l2 = [r2];
      h2.push(l2), f2 = p2 + u2, d2 = m2;
    } else l2.push(r2), f2 += d2 + p2, d2 = m2;
  }
  return c2 = u2 ? function(t4, e3) {
    return (e3 ? v2 : "") + t4.join(" ");
  } : function(t4) {
    return t4.join(" ");
  }, h2.map(c2);
}, Ht.splitTextToSize = function(t3, e2, n2) {
  var r2, i2 = (n2 = n2 || {}).fontSize || this.internal.getFontSize(), a2 = (function(t4) {
    if (t4.widths && t4.kerning) return { widths: t4.widths, kerning: t4.kerning };
    var e3 = this.internal.getFont(t4.fontName, t4.fontStyle), n3 = "Unicode";
    return e3.metadata[n3] ? { widths: e3.metadata[n3].widths || { 0: 1 }, kerning: e3.metadata[n3].kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, n2);
  r2 = Array.isArray(t3) ? t3 : String(t3).split(/\r?\n/);
  var o2 = 1 * this.internal.scaleFactor * e2 / i2;
  a2.textIndent = n2.textIndent ? 1 * n2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = n2.lineIndent;
  var s2, u2, c2 = [];
  for (s2 = 0, u2 = r2.length; s2 < u2; s2++) c2 = c2.concat(Yt.apply(this, [r2[s2], o2, a2]));
  return c2;
}, (function(e2) {
  e2.__fontmetrics__ = e2.__fontmetrics__ || {};
  for (var n2 = "0123456789abcdef", r2 = "klmnopqrstuvwxyz", i2 = {}, a2 = {}, o2 = 0; o2 < 16; o2++) i2[r2[o2]] = n2[o2], a2[n2[o2]] = r2[o2];
  var s2 = function(t3) {
    return "0x" + parseInt(t3, 10).toString(16);
  }, u2 = e2.__fontmetrics__.compress = function(e3) {
    var n3, r3, i3, o3, c3 = ["{"];
    for (var l3 in e3) {
      if (n3 = e3[l3], isNaN(parseInt(l3, 10)) ? r3 = "'" + l3 + "'" : (l3 = parseInt(l3, 10), r3 = (r3 = s2(l3).slice(2)).slice(0, -1) + a2[r3.slice(-1)]), "number" == typeof n3) n3 < 0 ? (i3 = s2(n3).slice(3), o3 = "-") : (i3 = s2(n3).slice(2), o3 = ""), i3 = o3 + i3.slice(0, -1) + a2[i3.slice(-1)];
      else {
        if ("object" !== _typeof$1(n3)) throw new Error("Don't know what to do with value type " + _typeof$1(n3) + ".");
        i3 = u2(n3);
      }
      c3.push(r3 + i3);
    }
    return c3.push("}"), c3.join("");
  }, c2 = e2.__fontmetrics__.uncompress = function(t3) {
    if ("string" != typeof t3) throw new Error("Invalid argument passed to uncompress.");
    for (var e3, n3, r3, a3, o3 = {}, s3 = 1, u3 = o3, c3 = [], l3 = "", h3 = "", f3 = t3.length - 1, d2 = 1; d2 < f3; d2 += 1) "'" == (a3 = t3[d2]) ? e3 ? (r3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (c3.push([u3, r3]), u3 = {}, r3 = void 0) : "}" == a3 ? ((n3 = c3.pop())[0][n3[1]] = u3, r3 = void 0, u3 = n3[0]) : "-" == a3 ? s3 = -1 : void 0 === r3 ? i2.hasOwnProperty(a3) ? (l3 += i2[a3], r3 = parseInt(l3, 16) * s3, s3 = 1, l3 = "") : l3 += a3 : i2.hasOwnProperty(a3) ? (h3 += i2[a3], u3[r3] = parseInt(h3, 16) * s3, s3 = 1, r3 = void 0, h3 = "") : h3 += a3;
    return o3;
  }, l2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: l2, "Courier-Bold": l2, "Courier-BoldOblique": l2, "Courier-Oblique": l2, Helvetica: l2, "Helvetica-Bold": l2, "Helvetica-BoldOblique": l2, "Helvetica-Oblique": l2, "Times-Roman": l2, "Times-Bold": l2, "Times-BoldItalic": l2, "Times-Italic": l2 } }, f2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  e2.events.push(["addFont", function(t3) {
    var e3 = t3.font, n3 = f2.Unicode[e3.postScriptName];
    n3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = n3.widths, e3.metadata.Unicode.kerning = n3.kerning);
    var r3 = h2.Unicode[e3.postScriptName];
    r3 && (e3.metadata.Unicode.encoding = r3, e3.encoding = r3.codePages[0]);
  }]);
})(E$1.API), /**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = function(t4) {
    for (var e3 = t4.length, n2 = new Uint8Array(e3), r2 = 0; r2 < e3; r2++) n2[r2] = t4.charCodeAt(r2);
    return n2;
  };
  t3.API.events.push(["addFont", function(n2) {
    var r2 = void 0, i2 = n2.font, a2 = n2.instance;
    if (!i2.isStandardFont) {
      if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      if ("string" != typeof (r2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
      !(function(n3, r3) {
        r3 = /^\x00\x01\x00\x00/.test(r3) ? e2(r3) : e2(f$2(r3)), n3.metadata = t3.API.TTFFont.open(r3), n3.metadata.Unicode = n3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, n3.metadata.glyIdsUsed = [0];
      })(i2, r2);
    }
  }]);
})(E$1), E$1.API.addSvgAsImage = function(t3, e2, n2, r2, a2, s2, u2, c2) {
  if (isNaN(e2) || isNaN(n2)) throw o$1.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
  if (isNaN(r2) || isNaN(a2)) throw o$1.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
  var l2 = document.createElement("canvas");
  l2.width = r2, l2.height = a2;
  var h2 = l2.getContext("2d");
  h2.fillStyle = "#fff", h2.fillRect(0, 0, l2.width, l2.height);
  var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
  return (i$5.canvg ? Promise.resolve(i$5.canvg) : Promise.resolve().then(() => index_es)).catch(function(t4) {
    return Promise.reject(new Error("Could not load canvg: " + t4));
  }).then(function(t4) {
    return t4.default ? t4.default : t4;
  }).then(function(e3) {
    return e3.fromString(h2, t3, f2);
  }, function() {
    return Promise.reject(new Error("Could not load canvg."));
  }).then(function(t4) {
    return t4.render(f2);
  }).then(function() {
    d2.addImage(l2.toDataURL("image/jpeg", 1), e2, n2, r2, a2, u2, c2);
  });
}, E$1.API.putTotalPages = function(t3) {
  var e2, n2 = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t3, "g"), n2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t3, this.internal.getFont()), "g"), n2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var r2 = 1; r2 <= this.internal.getNumberOfPages(); r2++) for (var i2 = 0; i2 < this.internal.pages[r2].length; i2++) this.internal.pages[r2][i2] = this.internal.pages[r2][i2].replace(e2, n2);
  return this;
}, E$1.API.viewerPreferences = function(e2, n2) {
  var r2;
  e2 = e2 || {}, n2 = n2 || false;
  var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, u2 = Object.keys(s2), c2 = [], l2 = 0, h2 = 0, f2 = 0;
  function d2(t3, e3) {
    var n3, r3 = false;
    for (n3 = 0; n3 < t3.length; n3 += 1) t3[n3] === e3 && (r3 = true);
    return r3;
  }
  if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), r2 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === n2) {
    var p2 = u2.length;
    for (f2 = 0; f2 < p2; f2 += 1) r2[u2[f2]].value = r2[u2[f2]].defaultValue, r2[u2[f2]].explicitSet = false;
  }
  if ("object" === _typeof$1(e2)) {
    for (a2 in e2) if (o2 = e2[a2], d2(u2, a2) && void 0 !== o2) {
      if ("boolean" === r2[a2].type && "boolean" == typeof o2) r2[a2].value = o2;
      else if ("name" === r2[a2].type && d2(r2[a2].valueSet, o2)) r2[a2].value = o2;
      else if ("integer" === r2[a2].type && Number.isInteger(o2)) r2[a2].value = o2;
      else if ("array" === r2[a2].type) {
        for (l2 = 0; l2 < o2.length; l2 += 1) if (i2 = true, 1 === o2[l2].length && "number" == typeof o2[l2][0]) c2.push(String(o2[l2] - 1));
        else if (o2[l2].length > 1) {
          for (h2 = 0; h2 < o2[l2].length; h2 += 1) "number" != typeof o2[l2][h2] && (i2 = false);
          true === i2 && c2.push([o2[l2][0] - 1, o2[l2][1] - 1].join(" "));
        }
        r2[a2].value = "[" + c2.join(" ") + "]";
      } else r2[a2].value = r2[a2].defaultValue;
      r2[a2].explicitSet = true;
    }
  }
  return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
    var t3, e3 = [];
    for (t3 in r2) true === r2[t3].explicitSet && ("name" === r2[t3].type ? e3.push("/" + t3 + " /" + r2[t3].value) : e3.push("/" + t3 + " " + r2[t3].value));
    0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
  }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = r2, this;
}, /** ====================================================================
 * @license
 * jsPDF XMP metadata plugin
 * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 */
(function(t3) {
  var e2 = function() {
    var t4 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), n3 = unescape(encodeURIComponent(t4)), r2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = n3.length + r2.length + i2.length + e3.length + a2.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + n3 + r2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
  }, n2 = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  t3.addMetadata = function(t4, r2) {
    return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t4, namespaceuri: r2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", n2), this.internal.events.subscribe("postPutResources", e2)), this;
  };
})(E$1.API), (function(t3) {
  var e2 = t3.API, n2 = e2.pdfEscape16 = function(t4, e3) {
    for (var n3, r3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t4.length; o2 < s2; ++o2) {
      if (n3 = e3.metadata.characterToGlyph(t4.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(n3), e3.metadata.toUnicode[n3] = t4.charCodeAt(o2), -1 == r3.indexOf(n3) && (r3.push(n3), r3.push([parseInt(e3.metadata.widthOfGlyph(n3), 10)])), "0" == n3) return a2.join("");
      n3 = n3.toString(16), a2.push(i3[4 - n3.length], n3);
    }
    return a2.join("");
  }, r2 = function(t4) {
    var e3, n3, r3, i3, a2, o2, s2;
    for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", r3 = [], o2 = 0, s2 = (n3 = Object.keys(t4).sort(function(t5, e4) {
      return t5 - e4;
    })).length; o2 < s2; o2++) e3 = n3[o2], r3.length >= 100 && (a2 += "\n" + r3.length + " beginbfchar\n" + r3.join("\n") + "\nendbfchar", r3 = []), void 0 !== t4[e3] && null !== t4[e3] && "function" == typeof t4[e3].toString && (i3 = ("0000" + t4[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), r3.push("<" + e3 + "><" + i3 + ">"));
    return r3.length && (a2 += "\n" + r3.length + " beginbfchar\n" + r3.join("\n") + "\nendbfchar\n"), a2 + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
  };
  e2.events.push(["putFont", function(e3) {
    !(function(e4) {
      var n3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (n3.metadata instanceof t3.API.TTFFont && "Identity-H" === n3.encoding) {
        for (var s2 = n3.metadata.Unicode.widths, u2 = n3.metadata.subset.encode(n3.metadata.glyIdsUsed, 1), c2 = "", l2 = 0; l2 < u2.length; l2++) c2 += String.fromCharCode(u2[l2]);
        var h2 = a2();
        o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
        var f2 = a2();
        o2({ data: r2(n3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
        var d2 = a2();
        i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + j(n3.fontName)), i3("/FontFile2 " + h2 + " 0 R"), i3("/FontBBox " + t3.API.PDFObject.convert(n3.metadata.bbox)), i3("/Flags " + n3.metadata.flags), i3("/StemV " + n3.metadata.stemV), i3("/ItalicAngle " + n3.metadata.italicAngle), i3("/Ascent " + n3.metadata.ascender), i3("/Descent " + n3.metadata.decender), i3("/CapHeight " + n3.metadata.capHeight), i3(">>"), i3("endobj");
        var p2 = a2();
        i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + j(n3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t3.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + n3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), n3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + j(n3.fontName)), i3("/Encoding /" + n3.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), n3.isAlreadyPutted = true;
      }
    })(e3);
  }]), e2.events.push(["putFont", function(e3) {
    !(function(e4) {
      var n3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
      if (n3.metadata instanceof t3.API.TTFFont && "WinAnsiEncoding" === n3.encoding) {
        for (var s2 = n3.metadata.rawData, u2 = "", c2 = 0; c2 < s2.length; c2++) u2 += String.fromCharCode(s2[c2]);
        var l2 = a2();
        o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
        var h2 = a2();
        o2({ data: r2(n3.metadata.toUnicode), addLength1: true, objectId: h2 }), i3("endobj");
        var f2 = a2();
        i3("<<"), i3("/Descent " + n3.metadata.decender), i3("/CapHeight " + n3.metadata.capHeight), i3("/StemV " + n3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + l2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t3.API.PDFObject.convert(n3.metadata.bbox)), i3("/FontName /" + j(n3.fontName)), i3("/ItalicAngle " + n3.metadata.italicAngle), i3("/Ascent " + n3.metadata.ascender), i3(">>"), i3("endobj"), n3.objectNumber = a2();
        for (var d2 = 0; d2 < n3.metadata.hmtx.widths.length; d2++) n3.metadata.hmtx.widths[d2] = parseInt(n3.metadata.hmtx.widths[d2] * (1e3 / n3.metadata.head.unitsPerEm));
        i3("<</Subtype/TrueType/Type/Font/ToUnicode " + h2 + " 0 R/BaseFont/" + j(n3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + n3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t3.API.PDFObject.convert(n3.metadata.hmtx.widths) + ">>"), i3("endobj"), n3.isAlreadyPutted = true;
      }
    })(e3);
  }]);
  var i2 = function(t4) {
    var e3, r3 = t4.text || "", i3 = t4.x, a2 = t4.y, o2 = t4.options || {}, s2 = t4.mutex || {}, u2 = s2.pdfEscape, c2 = s2.activeFontKey, l2 = s2.fonts, h2 = c2, f2 = "", d2 = 0, p2 = "", g2 = l2[h2].encoding;
    if ("Identity-H" !== l2[h2].encoding) return { text: r3, x: i3, y: a2, options: o2, mutex: s2 };
    for (p2 = r3, h2 = c2, Array.isArray(r3) && (p2 = r3[0]), d2 = 0; d2 < p2.length; d2 += 1) l2[h2].metadata.hasOwnProperty("cmap") && (e3 = l2[h2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && l2[h2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
    var m2 = "";
    return parseInt(h2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = u2(f2, h2).split("").map(function(t5) {
      return t5.charCodeAt(0).toString(16);
    }).join("") : "Identity-H" === g2 && (m2 = n2(f2, l2[h2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
  };
  e2.events.push(["postProcessText", function(t4) {
    var e3 = t4.text || "", n3 = [], r3 = { text: e3, x: t4.x, y: t4.y, options: t4.options, mutex: t4.mutex };
    if (Array.isArray(e3)) {
      var a2 = 0;
      for (a2 = 0; a2 < e3.length; a2 += 1) Array.isArray(e3[a2]) && 3 === e3[a2].length ? n3.push([i2(Object.assign({}, r3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : n3.push(i2(Object.assign({}, r3, { text: e3[a2] })).text);
      t4.text = n3;
    } else t4.text = i2(Object.assign({}, r3, { text: e3 })).text;
  }]);
})(E$1), /**
 * @license
 * jsPDF virtual FileSystem functionality
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */
(function(t3) {
  var e2 = function() {
    return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
  };
  t3.existsFileInVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4];
  }, t3.addFileToVFS = function(t4, n2) {
    return e2.call(this), this.internal.vFS[t4] = n2, this;
  }, t3.getFileFromVFS = function(t4) {
    return e2.call(this), void 0 !== this.internal.vFS[t4] ? this.internal.vFS[t4] : null;
  };
})(E$1.API), /**
 * @license
 * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
 * MIT License
 */
(function(t3) {
  t3.__bidiEngine__ = t3.prototype.__bidiEngine__ = function(t4) {
    var n3, r2, i2, a2, o2, s2, u2, c2 = e2, l2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], h2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "Â«", "Â»", "Â«", "â¹", "âº", "â¹", "â", "â", "â", "â½", "â¾", "â½", "â", "â", "â", "â¤", "â¥", "â¤", "â©", "âª", "â©", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹", "ï¹¤", "ï¹¥", "ï¹¤"], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
    this.__bidiEngine__ = {};
    var b2 = function(t5) {
      var e3 = t5.charCodeAt(), n4 = e3 >> 8, r3 = d2[n4];
      return void 0 !== r3 ? c2[256 * r3 + (255 & e3)] : 252 === n4 || 253 === n4 ? "AL" : g2.test(n4) ? "L" : 8 === n4 ? "R" : "N";
    }, y2 = function(t5) {
      for (var e3, n4 = 0; n4 < t5.length; n4++) {
        if ("L" === (e3 = b2(t5.charAt(n4)))) return false;
        if ("R" === e3) return true;
      }
      return false;
    }, w2 = function(t5, e3, o3, s3) {
      var u3, c3, l3, h3, f3 = e3[s3];
      switch (f3) {
        case "L":
        case "R":
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          m2 = false;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          m2 && (f3 = "AN");
          break;
        case "AL":
          m2 = true, f3 = "R";
          break;
        case "WS":
        case "BN":
          f3 = "N";
          break;
        case "CS":
          s3 < 1 || s3 + 1 >= e3.length || "EN" !== (u3 = o3[s3 - 1]) && "AN" !== u3 || "EN" !== (c3 = e3[s3 + 1]) && "AN" !== c3 ? f3 = "N" : m2 && (c3 = "AN"), f3 = c3 === u3 ? c3 : "N";
          break;
        case "ES":
          f3 = "EN" === (u3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
          break;
        case "ET":
          if (s3 > 0 && "EN" === o3[s3 - 1]) {
            f3 = "EN";
            break;
          }
          if (m2) {
            f3 = "N";
            break;
          }
          for (l3 = s3 + 1, h3 = e3.length; l3 < h3 && "ET" === e3[l3]; ) l3++;
          f3 = l3 < h3 && "EN" === e3[l3] ? "EN" : "N";
          break;
        case "NSM":
          if (i2 && !a2) {
            for (h3 = e3.length, l3 = s3 + 1; l3 < h3 && "NSM" === e3[l3]; ) l3++;
            if (l3 < h3) {
              var d3 = t5[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
              if (u3 = e3[l3], p3 && ("R" === u3 || "AL" === u3)) {
                f3 = "R";
                break;
              }
            }
          }
          f3 = s3 < 1 || "B" === (u3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
          break;
        case "B":
          m2 = false, n3 = true, f3 = v2;
          break;
        case "S":
          r2 = true, f3 = "N";
      }
      return f3;
    }, N2 = function(t5, e3, n4) {
      var r3 = t5.split("");
      return n4 && L2(r3, n4, { hiLevel: v2 }), r3.reverse(), e3 && e3.reverse(), r3.join("");
    }, L2 = function(t5, e3, i3) {
      var a3, o3, s3, u3, c3, d3 = -1, p3 = t5.length, g3 = 0, y3 = [], N3 = v2 ? h2 : l2, L3 = [];
      for (m2 = false, n3 = false, r2 = false, o3 = 0; o3 < p3; o3++) L3[o3] = b2(t5[o3]);
      for (s3 = 0; s3 < p3; s3++) {
        if (c3 = g3, y3[s3] = w2(t5, L3, y3, s3), a3 = 240 & (g3 = N3[c3][f2[y3[s3]]]), g3 &= 15, e3[s3] = u3 = N3[g3][5], a3 > 0) if (16 === a3) {
          for (o3 = d3; o3 < s3; o3++) e3[o3] = 1;
          d3 = -1;
        } else d3 = -1;
        if (N3[g3][6]) -1 === d3 && (d3 = s3);
        else if (d3 > -1) {
          for (o3 = d3; o3 < s3; o3++) e3[o3] = u3;
          d3 = -1;
        }
        "B" === L3[s3] && (e3[s3] = 0), i3.hiLevel |= u3;
      }
      r2 && (function(t6, e4, n4) {
        for (var r3 = 0; r3 < n4; r3++) if ("S" === t6[r3]) {
          e4[r3] = v2;
          for (var i4 = r3 - 1; i4 >= 0 && "WS" === t6[i4]; i4--) e4[i4] = v2;
        }
      })(L3, e3, p3);
    }, x2 = function(t5, e3, r3, i3, a3) {
      if (!(a3.hiLevel < t5)) {
        if (1 === t5 && 1 === v2 && !n3) return e3.reverse(), void (r3 && r3.reverse());
        for (var o3, s3, u3, c3, l3 = e3.length, h3 = 0; h3 < l3; ) {
          if (i3[h3] >= t5) {
            for (u3 = h3 + 1; u3 < l3 && i3[u3] >= t5; ) u3++;
            for (c3 = h3, s3 = u3 - 1; c3 < s3; c3++, s3--) o3 = e3[c3], e3[c3] = e3[s3], e3[s3] = o3, r3 && (o3 = r3[c3], r3[c3] = r3[s3], r3[s3] = o3);
            h3 = u3;
          }
          h3++;
        }
      }
    }, A2 = function(t5, e3, n4) {
      var r3 = t5.split(""), i3 = { hiLevel: v2 };
      return n4 || (n4 = []), L2(r3, n4, i3), (function(t6, e4, n5) {
        if (0 !== n5.hiLevel && u2) for (var r4, i4 = 0; i4 < t6.length; i4++) 1 === e4[i4] && (r4 = p2.indexOf(t6[i4])) >= 0 && (t6[i4] = p2[r4 + 1]);
      })(r3, n4, i3), x2(2, r3, e3, n4, i3), x2(1, r3, e3, n4, i3), r3.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(t5, e3, n4) {
      if ((function(t6, e4) {
        if (e4) for (var n5 = 0; n5 < t6.length; n5++) e4[n5] = n5;
        void 0 === a2 && (a2 = y2(t6)), void 0 === s2 && (s2 = y2(t6));
      })(t5, e3), i2 || !o2 || s2) if (i2 && o2 && a2 ^ s2) v2 = a2 ? 1 : 0, t5 = N2(t5, e3, n4);
      else if (!i2 && o2 && s2) v2 = a2 ? 1 : 0, t5 = A2(t5, e3, n4), t5 = N2(t5, e3);
      else if (!i2 || a2 || o2 || s2) {
        if (i2 && !o2 && a2 ^ s2) t5 = N2(t5, e3), a2 ? (v2 = 0, t5 = A2(t5, e3, n4)) : (v2 = 1, t5 = A2(t5, e3, n4), t5 = N2(t5, e3));
        else if (i2 && a2 && !o2 && s2) v2 = 1, t5 = A2(t5, e3, n4), t5 = N2(t5, e3);
        else if (!i2 && !o2 && a2 ^ s2) {
          var r3 = u2;
          a2 ? (v2 = 1, t5 = A2(t5, e3, n4), v2 = 0, u2 = false, t5 = A2(t5, e3, n4), u2 = r3) : (v2 = 0, t5 = A2(t5, e3, n4), t5 = N2(t5, e3), v2 = 1, u2 = false, t5 = A2(t5, e3, n4), u2 = r3, t5 = N2(t5, e3));
        }
      } else v2 = 0, t5 = A2(t5, e3, n4);
      else v2 = a2 ? 1 : 0, t5 = A2(t5, e3, n4);
      return t5;
    }, this.__bidiEngine__.setOptions = function(t5) {
      t5 && (i2 = t5.isInputVisual, o2 = t5.isOutputVisual, a2 = t5.isInputRtl, s2 = t5.isOutputRtl, u2 = t5.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(t4), this.__bidiEngine__;
  };
  var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], n2 = new t3.__bidiEngine__({ isInputVisual: true });
  t3.API.events.push(["postProcessText", function(t4) {
    var e3 = t4.text;
    t4.x, t4.y;
    var r2 = t4.options || {};
    t4.mutex, r2.lang;
    var i2 = [];
    if (r2.isInputVisual = "boolean" != typeof r2.isInputVisual || r2.isInputVisual, n2.setOptions(r2), "[object Array]" === Object.prototype.toString.call(e3)) {
      var a2 = 0;
      for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i2.push([n2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([n2.doBidiReorder(e3[a2])]);
      t4.text = i2;
    } else t4.text = n2.doBidiReorder(e3);
    n2.setOptions({ isInputVisual: true });
  }]);
})(E$1), E$1.API.TTFFont = (function() {
  function t3(t4) {
    var e2;
    if (this.rawData = t4, e2 = this.contents = new fe(t4), this.contents.pos = 4, "ttcf" === e2.readString(4)) throw new Error("TTCF not supported.");
    e2.pos = 0, this.parse(), this.subset = new je(this), this.registerTTF();
  }
  return t3.open = function(e2) {
    return new t3(e2);
  }, t3.prototype.parse = function() {
    return this.directory = new de(this.contents), this.head = new me(this), this.name = new xe(this), this.cmap = new be(this), this.toUnicode = {}, this.hhea = new ye(this), this.maxp = new Ae(this), this.hmtx = new Se(this), this.post = new Ne(this), this.os2 = new we(this), this.loca = new Ie(this), this.glyf = new Pe(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, t3.prototype.registerTTF = function() {
    var t4, e2, n2, r2, i2;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var e3, n3, r3, i3;
      for (i3 = [], e3 = 0, n3 = (r3 = this.bbox).length; e3 < n3; e3++) t4 = r3[e3], i3.push(Math.round(t4 * this.scaleFactor));
      return i3;
    }).call(this), this.stemV = 0, this.post.exists ? (n2 = 255 & (r2 = this.post.italic_angle), 32768 & (e2 = r2 >> 16) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + n2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, t3.prototype.characterToGlyph = function(t4) {
    var e2;
    return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t4] : void 0) || 0;
  }, t3.prototype.widthOfGlyph = function(t4) {
    var e2;
    return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t4).advance * e2;
  }, t3.prototype.widthOfString = function(t4, e2, n2) {
    var r2, i2, a2, o2;
    for (a2 = 0, i2 = 0, o2 = (t4 = "" + t4).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) r2 = t4.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(r2)) + n2 * (1e3 / e2) || 0;
    return a2 * (e2 / 1e3);
  }, t3.prototype.lineHeight = function(t4, e2) {
    var n2;
    return null == e2 && (e2 = false), n2 = e2 ? this.lineGap : 0, (this.ascender + n2 - this.decender) / 1e3 * t4;
  }, t3;
})();
var he, fe = (function() {
  function t3(t4) {
    this.data = null != t4 ? t4 : [], this.pos = 0, this.length = this.data.length;
  }
  return t3.prototype.readByte = function() {
    return this.data[this.pos++];
  }, t3.prototype.writeByte = function(t4) {
    return this.data[this.pos++] = t4;
  }, t3.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, t3.prototype.writeUInt32 = function(t4) {
    return this.writeByte(t4 >>> 24 & 255), this.writeByte(t4 >> 16 & 255), this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt32 = function() {
    var t4;
    return (t4 = this.readUInt32()) >= 2147483648 ? t4 - 4294967296 : t4;
  }, t3.prototype.writeInt32 = function(t4) {
    return t4 < 0 && (t4 += 4294967296), this.writeUInt32(t4);
  }, t3.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, t3.prototype.writeUInt16 = function(t4) {
    return this.writeByte(t4 >> 8 & 255), this.writeByte(255 & t4);
  }, t3.prototype.readInt16 = function() {
    var t4;
    return (t4 = this.readUInt16()) >= 32768 ? t4 - 65536 : t4;
  }, t3.prototype.writeInt16 = function(t4) {
    return t4 < 0 && (t4 += 65536), this.writeUInt16(t4);
  }, t3.prototype.readString = function(t4) {
    var e2, n2;
    for (n2 = [], e2 = 0; 0 <= t4 ? e2 < t4 : e2 > t4; e2 = 0 <= t4 ? ++e2 : --e2) n2[e2] = String.fromCharCode(this.readByte());
    return n2.join("");
  }, t3.prototype.writeString = function(t4) {
    var e2, n2, r2;
    for (r2 = [], e2 = 0, n2 = t4.length; 0 <= n2 ? e2 < n2 : e2 > n2; e2 = 0 <= n2 ? ++e2 : --e2) r2.push(this.writeByte(t4.charCodeAt(e2)));
    return r2;
  }, t3.prototype.readShort = function() {
    return this.readInt16();
  }, t3.prototype.writeShort = function(t4) {
    return this.writeInt16(t4);
  }, t3.prototype.readLongLong = function() {
    var t4, e2, n2, r2, i2, a2, o2, s2;
    return t4 = this.readByte(), e2 = this.readByte(), n2 = this.readByte(), r2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t4 ? -1 * (72057594037927940 * (255 ^ t4) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ n2) + 4294967296 * (255 ^ r2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t4 + 281474976710656 * e2 + 1099511627776 * n2 + 4294967296 * r2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
  }, t3.prototype.writeLongLong = function(t4) {
    var e2, n2;
    return e2 = Math.floor(t4 / 4294967296), n2 = 4294967295 & t4, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(n2 >> 24 & 255), this.writeByte(n2 >> 16 & 255), this.writeByte(n2 >> 8 & 255), this.writeByte(255 & n2);
  }, t3.prototype.readInt = function() {
    return this.readInt32();
  }, t3.prototype.writeInt = function(t4) {
    return this.writeInt32(t4);
  }, t3.prototype.read = function(t4) {
    var e2, n2;
    for (e2 = [], n2 = 0; 0 <= t4 ? n2 < t4 : n2 > t4; n2 = 0 <= t4 ? ++n2 : --n2) e2.push(this.readByte());
    return e2;
  }, t3.prototype.write = function(t4) {
    var e2, n2, r2, i2;
    for (i2 = [], n2 = 0, r2 = t4.length; n2 < r2; n2++) e2 = t4[n2], i2.push(this.writeByte(e2));
    return i2;
  }, t3;
})(), de = (function() {
  var t3;
  function e2(t4) {
    var e3, n2, r2;
    for (this.scalarType = t4.readInt(), this.tableCount = t4.readShort(), this.searchRange = t4.readShort(), this.entrySelector = t4.readShort(), this.rangeShift = t4.readShort(), this.tables = {}, n2 = 0, r2 = this.tableCount; 0 <= r2 ? n2 < r2 : n2 > r2; n2 = 0 <= r2 ? ++n2 : --n2) e3 = { tag: t4.readString(4), checksum: t4.readInt(), offset: t4.readInt(), length: t4.readInt() }, this.tables[e3.tag] = e3;
  }
  return e2.prototype.encode = function(e3) {
    var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2;
    for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), l2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(l2 / s2), c2 = 16 * f2 - l2, (r2 = new fe()).writeInt(this.scalarType), r2.writeShort(f2), r2.writeShort(l2), r2.writeShort(a2), r2.writeShort(c2), i2 = 16 * f2, u2 = r2.pos + i2, o2 = null, d2 = [], e3) for (h2 = e3[p2], r2.writeString(p2), r2.writeInt(t3(h2)), r2.writeInt(u2), r2.writeInt(h2.length), d2 = d2.concat(h2), "head" === p2 && (o2 = u2), u2 += h2.length; u2 % 4; ) d2.push(0), u2++;
    return r2.write(d2), n2 = 2981146554 - t3(r2.data), r2.pos = o2 + 8, r2.writeUInt32(n2), r2.data;
  }, t3 = function(t4) {
    var e3, n2, r2, i2;
    for (t4 = _e.call(t4); t4.length % 4; ) t4.push(0);
    for (r2 = new fe(t4), n2 = 0, e3 = 0, i2 = t4.length; e3 < i2; e3 = e3 += 4) n2 += r2.readUInt32();
    return 4294967295 & n2;
  }, e2;
})(), pe = {}.hasOwnProperty, ge = function(t3, e2) {
  for (var n2 in e2) pe.call(e2, n2) && (t3[n2] = e2[n2]);
  function r2() {
    this.constructor = t3;
  }
  return r2.prototype = e2.prototype, t3.prototype = new r2(), t3.__super__ = e2.prototype, t3;
};
he = (function() {
  function t3(t4) {
    var e2;
    this.file = t4, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
  }
  return t3.prototype.parse = function() {
  }, t3.prototype.encode = function() {
  }, t3.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, t3;
})();
var me = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "head", t3.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.revision = t4.readInt(), this.checkSumAdjustment = t4.readInt(), this.magicNumber = t4.readInt(), this.flags = t4.readShort(), this.unitsPerEm = t4.readShort(), this.created = t4.readLongLong(), this.modified = t4.readLongLong(), this.xMin = t4.readShort(), this.yMin = t4.readShort(), this.xMax = t4.readShort(), this.yMax = t4.readShort(), this.macStyle = t4.readShort(), this.lowestRecPPEM = t4.readShort(), this.fontDirectionHint = t4.readShort(), this.indexToLocFormat = t4.readShort(), this.glyphDataFormat = t4.readShort();
  }, t3.prototype.encode = function(t4) {
    var e2;
    return (e2 = new fe()).writeInt(this.version), e2.writeInt(this.revision), e2.writeInt(this.checkSumAdjustment), e2.writeInt(this.magicNumber), e2.writeShort(this.flags), e2.writeShort(this.unitsPerEm), e2.writeLongLong(this.created), e2.writeLongLong(this.modified), e2.writeShort(this.xMin), e2.writeShort(this.yMin), e2.writeShort(this.xMax), e2.writeShort(this.yMax), e2.writeShort(this.macStyle), e2.writeShort(this.lowestRecPPEM), e2.writeShort(this.fontDirectionHint), e2.writeShort(t4), e2.writeShort(this.glyphDataFormat), e2.data;
  }, t3;
})(), ve = (function() {
  function t3(t4, e2) {
    var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2, v2, b2;
    switch (this.platformID = t4.readUInt16(), this.encodingID = t4.readShort(), this.offset = e2 + t4.readInt(), l2 = t4.pos, t4.pos = this.offset, this.format = t4.readUInt16(), this.length = t4.readUInt16(), this.language = t4.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
      case 0:
        for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t4.readByte();
        break;
      case 4:
        for (f2 = t4.readUInt16(), h2 = f2 / 2, t4.pos += 6, i2 = (function() {
          var e3, n3;
          for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t4.readUInt16());
          return n3;
        })(), t4.pos += 2, p2 = (function() {
          var e3, n3;
          for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t4.readUInt16());
          return n3;
        })(), u2 = (function() {
          var e3, n3;
          for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t4.readUInt16());
          return n3;
        })(), c2 = (function() {
          var e3, n3;
          for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t4.readUInt16());
          return n3;
        })(), r2 = (this.length - t4.pos + this.offset) / 2, o2 = (function() {
          var e3, n3;
          for (n3 = [], s2 = e3 = 0; 0 <= r2 ? e3 < r2 : e3 > r2; s2 = 0 <= r2 ? ++e3 : --e3) n3.push(t4.readUInt16());
          return n3;
        })(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2) for (g2 = i2[s2], n2 = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; n2 = d2 <= g2 ? ++v2 : --v2) 0 === c2[s2] ? a2 = n2 + u2[s2] : 0 !== (a2 = o2[c2[s2] / 2 + (n2 - d2) - (h2 - s2)] || 0) && (a2 += u2[s2]), this.codeMap[n2] = 65535 & a2;
    }
    t4.pos = l2;
  }
  return t3.encode = function(t4, e2) {
    var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, x2, A2, S2, _2, P2, k2, F2, I2, j2, C2, O2, B3, M2, q2, E2, R2, D2, T2, z2, U2, H4, W2, V2, G2, Y2;
    switch (F2 = new fe(), a2 = Object.keys(t4).sort(function(t5, e3) {
      return t5 - e3;
    }), e2) {
      case "macroman":
        for (p2 = 0, g2 = (function() {
          var t5 = [];
          for (d2 = 0; d2 < 256; ++d2) t5.push(0);
          return t5;
        })(), v2 = { 0: 0 }, i2 = {}, I2 = 0, B3 = a2.length; I2 < B3; I2++) null == v2[W2 = t4[r2 = a2[I2]]] && (v2[W2] = ++p2), i2[r2] = { old: t4[r2], new: v2[t4[r2]] }, g2[r2] = v2[t4[r2]];
        return F2.writeUInt16(1), F2.writeUInt16(0), F2.writeUInt32(12), F2.writeUInt16(0), F2.writeUInt16(262), F2.writeUInt16(0), F2.write(g2), { charMap: i2, subtable: F2.data, maxGlyphID: p2 + 1 };
      case "unicode":
        for (P2 = [], l2 = [], b2 = 0, v2 = {}, n2 = {}, m2 = u2 = null, j2 = 0, M2 = a2.length; j2 < M2; j2++) null == v2[w2 = t4[r2 = a2[j2]]] && (v2[w2] = ++b2), n2[r2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - r2, null != m2 && o2 === u2 || (m2 && l2.push(m2), P2.push(r2), u2 = o2), m2 = r2;
        for (m2 && l2.push(m2), l2.push(65535), P2.push(65535), S2 = 2 * (A2 = P2.length), x2 = 2 * Math.pow(Math.log(A2) / Math.LN2, 2), h2 = Math.log(x2 / 2) / Math.LN2, L2 = 2 * A2 - x2, s2 = [], N2 = [], f2 = [], d2 = C2 = 0, q2 = P2.length; C2 < q2; d2 = ++C2) {
          if (_2 = P2[d2], c2 = l2[d2], 65535 === _2) {
            s2.push(0), N2.push(0);
            break;
          }
          if (_2 - (k2 = n2[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f2.length + A2 - d2)), r2 = O2 = _2; _2 <= c2 ? O2 <= c2 : O2 >= c2; r2 = _2 <= c2 ? ++O2 : --O2) f2.push(n2[r2].new);
          else s2.push(k2 - _2), N2.push(0);
        }
        for (F2.writeUInt16(3), F2.writeUInt16(1), F2.writeUInt32(12), F2.writeUInt16(4), F2.writeUInt16(16 + 8 * A2 + 2 * f2.length), F2.writeUInt16(0), F2.writeUInt16(S2), F2.writeUInt16(x2), F2.writeUInt16(h2), F2.writeUInt16(L2), U2 = 0, E2 = l2.length; U2 < E2; U2++) r2 = l2[U2], F2.writeUInt16(r2);
        for (F2.writeUInt16(0), H4 = 0, R2 = P2.length; H4 < R2; H4++) r2 = P2[H4], F2.writeUInt16(r2);
        for (V2 = 0, D2 = s2.length; V2 < D2; V2++) o2 = s2[V2], F2.writeUInt16(o2);
        for (G2 = 0, T2 = N2.length; G2 < T2; G2++) y2 = N2[G2], F2.writeUInt16(y2);
        for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++) p2 = f2[Y2], F2.writeUInt16(p2);
        return { charMap: n2, subtable: F2.data, maxGlyphID: b2 + 1 };
    }
  }, t3;
})(), be = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "cmap", t3.prototype.parse = function(t4) {
    var e2, n2, r2;
    for (t4.pos = this.offset, this.version = t4.readUInt16(), r2 = t4.readUInt16(), this.tables = [], this.unicode = null, n2 = 0; 0 <= r2 ? n2 < r2 : n2 > r2; n2 = 0 <= r2 ? ++n2 : --n2) e2 = new ve(t4, this.offset), this.tables.push(e2), e2.isUnicode && null == this.unicode && (this.unicode = e2);
    return true;
  }, t3.encode = function(t4, e2) {
    var n2, r2;
    return null == e2 && (e2 = "macroman"), n2 = ve.encode(t4, e2), (r2 = new fe()).writeUInt16(0), r2.writeUInt16(1), n2.table = r2.data.concat(n2.subtable), n2;
  }, t3;
})(), ye = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "hhea", t3.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.ascender = t4.readShort(), this.decender = t4.readShort(), this.lineGap = t4.readShort(), this.advanceWidthMax = t4.readShort(), this.minLeftSideBearing = t4.readShort(), this.minRightSideBearing = t4.readShort(), this.xMaxExtent = t4.readShort(), this.caretSlopeRise = t4.readShort(), this.caretSlopeRun = t4.readShort(), this.caretOffset = t4.readShort(), t4.pos += 8, this.metricDataFormat = t4.readShort(), this.numberOfMetrics = t4.readUInt16();
  }, t3;
})(), we = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "OS/2", t3.prototype.parse = function(t4) {
    if (t4.pos = this.offset, this.version = t4.readUInt16(), this.averageCharWidth = t4.readShort(), this.weightClass = t4.readUInt16(), this.widthClass = t4.readUInt16(), this.type = t4.readShort(), this.ySubscriptXSize = t4.readShort(), this.ySubscriptYSize = t4.readShort(), this.ySubscriptXOffset = t4.readShort(), this.ySubscriptYOffset = t4.readShort(), this.ySuperscriptXSize = t4.readShort(), this.ySuperscriptYSize = t4.readShort(), this.ySuperscriptXOffset = t4.readShort(), this.ySuperscriptYOffset = t4.readShort(), this.yStrikeoutSize = t4.readShort(), this.yStrikeoutPosition = t4.readShort(), this.familyClass = t4.readShort(), this.panose = (function() {
      var e2, n2;
      for (n2 = [], e2 = 0; e2 < 10; ++e2) n2.push(t4.readByte());
      return n2;
    })(), this.charRange = (function() {
      var e2, n2;
      for (n2 = [], e2 = 0; e2 < 4; ++e2) n2.push(t4.readInt());
      return n2;
    })(), this.vendorID = t4.readString(4), this.selection = t4.readShort(), this.firstCharIndex = t4.readShort(), this.lastCharIndex = t4.readShort(), this.version > 0 && (this.ascent = t4.readShort(), this.descent = t4.readShort(), this.lineGap = t4.readShort(), this.winAscent = t4.readShort(), this.winDescent = t4.readShort(), this.codePageRange = (function() {
      var e2, n2;
      for (n2 = [], e2 = 0; e2 < 2; e2 = ++e2) n2.push(t4.readInt());
      return n2;
    })(), this.version > 1)) return this.xHeight = t4.readShort(), this.capHeight = t4.readShort(), this.defaultChar = t4.readShort(), this.breakChar = t4.readShort(), this.maxContext = t4.readShort();
  }, t3;
})(), Ne = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "post", t3.prototype.parse = function(t4) {
    var e2, n2, r2;
    switch (t4.pos = this.offset, this.format = t4.readInt(), this.italicAngle = t4.readInt(), this.underlinePosition = t4.readShort(), this.underlineThickness = t4.readShort(), this.isFixedPitch = t4.readInt(), this.minMemType42 = t4.readInt(), this.maxMemType42 = t4.readInt(), this.minMemType1 = t4.readInt(), this.maxMemType1 = t4.readInt(), this.format) {
      case 65536:
      case 196608:
        break;
      case 131072:
        var i2;
        for (n2 = t4.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= n2 ? i2 < n2 : i2 > n2; i2 = 0 <= n2 ? ++i2 : --i2) this.glyphNameIndex.push(t4.readUInt16());
        for (this.names = [], r2 = []; t4.pos < this.offset + this.length; ) e2 = t4.readByte(), r2.push(this.names.push(t4.readString(e2)));
        return r2;
      case 151552:
        return n2 = t4.readUInt16(), this.offsets = t4.read(n2);
      case 262144:
        return this.map = (function() {
          var e3, n3, r3;
          for (r3 = [], i2 = e3 = 0, n3 = this.file.maxp.numGlyphs; 0 <= n3 ? e3 < n3 : e3 > n3; i2 = 0 <= n3 ? ++e3 : --e3) r3.push(t4.readUInt32());
          return r3;
        }).call(this);
    }
  }, t3;
})(), Le = function(t3, e2) {
  this.raw = t3, this.length = t3.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
}, xe = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "name", t3.prototype.parse = function(t4) {
    var e2, n2, r2, i2, a2, o2, s2, u2, c2, l2, h2;
    for (t4.pos = this.offset, t4.readShort(), e2 = t4.readShort(), o2 = t4.readShort(), n2 = [], i2 = 0; 0 <= e2 ? i2 < e2 : i2 > e2; i2 = 0 <= e2 ? ++i2 : --i2) n2.push({ platformID: t4.readShort(), encodingID: t4.readShort(), languageID: t4.readShort(), nameID: t4.readShort(), length: t4.readShort(), offset: this.offset + o2 + t4.readShort() });
    for (s2 = {}, i2 = c2 = 0, l2 = n2.length; c2 < l2; i2 = ++c2) r2 = n2[i2], t4.pos = r2.offset, u2 = t4.readString(r2.length), a2 = new Le(u2, r2), null == s2[h2 = r2.nameID] && (s2[h2] = []), s2[r2.nameID].push(a2);
    this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
    try {
      this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch (f2) {
      this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
  }, t3;
})(), Ae = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "maxp", t3.prototype.parse = function(t4) {
    return t4.pos = this.offset, this.version = t4.readInt(), this.numGlyphs = t4.readUInt16(), this.maxPoints = t4.readUInt16(), this.maxContours = t4.readUInt16(), this.maxCompositePoints = t4.readUInt16(), this.maxComponentContours = t4.readUInt16(), this.maxZones = t4.readUInt16(), this.maxTwilightPoints = t4.readUInt16(), this.maxStorage = t4.readUInt16(), this.maxFunctionDefs = t4.readUInt16(), this.maxInstructionDefs = t4.readUInt16(), this.maxStackElements = t4.readUInt16(), this.maxSizeOfInstructions = t4.readUInt16(), this.maxComponentElements = t4.readUInt16(), this.maxComponentDepth = t4.readUInt16();
  }, t3;
})(), Se = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "hmtx", t3.prototype.parse = function(t4) {
    var e2, n2, r2, i2, a2, o2, s2;
    for (t4.pos = this.offset, this.metrics = [], e2 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e2 < o2 : e2 > o2; e2 = 0 <= o2 ? ++e2 : --e2) this.metrics.push({ advance: t4.readUInt16(), lsb: t4.readInt16() });
    for (r2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
      var n3, i3;
      for (i3 = [], e2 = n3 = 0; 0 <= r2 ? n3 < r2 : n3 > r2; e2 = 0 <= r2 ? ++n3 : --n3) i3.push(t4.readInt16());
      return i3;
    })(), this.widths = (function() {
      var t5, e3, n3, r3;
      for (r3 = [], t5 = 0, e3 = (n3 = this.metrics).length; t5 < e3; t5++) i2 = n3[t5], r3.push(i2.advance);
      return r3;
    }).call(this), n2 = this.widths[this.widths.length - 1], s2 = [], e2 = a2 = 0; 0 <= r2 ? a2 < r2 : a2 > r2; e2 = 0 <= r2 ? ++a2 : --a2) s2.push(this.widths.push(n2));
    return s2;
  }, t3.prototype.forGlyph = function(t4) {
    return t4 in this.metrics ? this.metrics[t4] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t4 - this.metrics.length] };
  }, t3;
})(), _e = [].slice, Pe = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "glyf", t3.prototype.parse = function() {
    return this.cache = {};
  }, t3.prototype.glyphFor = function(t4) {
    var e2, n2, r2, i2, a2, o2, s2, u2, c2, l2;
    return t4 in this.cache ? this.cache[t4] : (i2 = this.file.loca, e2 = this.file.contents, n2 = i2.indexOf(t4), 0 === (r2 = i2.lengthOf(t4)) ? this.cache[t4] = null : (e2.pos = this.offset + n2, a2 = (o2 = new fe(e2.read(r2))).readShort(), u2 = o2.readShort(), l2 = o2.readShort(), s2 = o2.readShort(), c2 = o2.readShort(), this.cache[t4] = -1 === a2 ? new Fe(o2, u2, l2, s2, c2) : new ke(o2, a2, u2, l2, s2, c2), this.cache[t4]));
  }, t3.prototype.encode = function(t4, e2, n2) {
    var r2, i2, a2, o2, s2;
    for (a2 = [], i2 = [], o2 = 0, s2 = e2.length; o2 < s2; o2++) r2 = t4[e2[o2]], i2.push(a2.length), r2 && (a2 = a2.concat(r2.encode(n2)));
    return i2.push(a2.length), { table: a2, offsets: i2 };
  }, t3;
})(), ke = (function() {
  function t3(t4, e2, n2, r2, i2, a2) {
    this.raw = t4, this.numberOfContours = e2, this.xMin = n2, this.yMin = r2, this.xMax = i2, this.yMax = a2, this.compound = false;
  }
  return t3.prototype.encode = function() {
    return this.raw.data;
  }, t3;
})(), Fe = (function() {
  function t3(t4, e2, n2, r2, i2) {
    var a2, o2;
    for (this.raw = t4, this.xMin = e2, this.yMin = n2, this.xMax = r2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
  }
  return t3.prototype.encode = function() {
    var t4, e2, n2;
    for (e2 = new fe(_e.call(this.raw.data)), t4 = 0, n2 = this.glyphIDs.length; t4 < n2; ++t4) e2.pos = this.glyphOffsets[t4];
    return e2.data;
  }, t3;
})(), Ie = (function() {
  function t3() {
    return t3.__super__.constructor.apply(this, arguments);
  }
  return ge(t3, he), t3.prototype.tag = "loca", t3.prototype.parse = function(t4) {
    var e2, n2;
    return t4.pos = this.offset, e2 = this.file.head.indexToLocFormat, this.offsets = 0 === e2 ? (function() {
      var e3, r2;
      for (r2 = [], n2 = 0, e3 = this.length; n2 < e3; n2 += 2) r2.push(2 * t4.readUInt16());
      return r2;
    }).call(this) : (function() {
      var e3, r2;
      for (r2 = [], n2 = 0, e3 = this.length; n2 < e3; n2 += 4) r2.push(t4.readUInt32());
      return r2;
    }).call(this);
  }, t3.prototype.indexOf = function(t4) {
    return this.offsets[t4];
  }, t3.prototype.lengthOf = function(t4) {
    return this.offsets[t4 + 1] - this.offsets[t4];
  }, t3.prototype.encode = function(t4, e2) {
    for (var n2 = new Uint32Array(this.offsets.length), r2 = 0, i2 = 0, a2 = 0; a2 < n2.length; ++a2) if (n2[a2] = r2, i2 < e2.length && e2[i2] == a2) {
      ++i2, n2[a2] = r2;
      var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
      s2 > 0 && (r2 += s2);
    }
    for (var u2 = new Array(4 * n2.length), c2 = 0; c2 < n2.length; ++c2) u2[4 * c2 + 3] = 255 & n2[c2], u2[4 * c2 + 2] = (65280 & n2[c2]) >> 8, u2[4 * c2 + 1] = (16711680 & n2[c2]) >> 16, u2[4 * c2] = (4278190080 & n2[c2]) >> 24;
    return u2;
  }, t3;
})(), je = (function() {
  function t3(t4) {
    this.font = t4, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return t3.prototype.generateCmap = function() {
    var t4, e2, n2, r2, i2;
    for (e2 in r2 = this.font.cmap.tables[0].codeMap, t4 = {}, i2 = this.subset) n2 = i2[e2], t4[e2] = r2[n2];
    return t4;
  }, t3.prototype.glyphsFor = function(t4) {
    var e2, n2, r2, i2, a2, o2, s2;
    for (r2 = {}, a2 = 0, o2 = t4.length; a2 < o2; a2++) r2[i2 = t4[a2]] = this.font.glyf.glyphFor(i2);
    for (i2 in e2 = [], r2) (null != (n2 = r2[i2]) ? n2.compound : void 0) && e2.push.apply(e2, n2.glyphIDs);
    if (e2.length > 0) for (i2 in s2 = this.glyphsFor(e2)) n2 = s2[i2], r2[i2] = n2;
    return r2;
  }, t3.prototype.encode = function(t4, e2) {
    var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2;
    for (r2 in n2 = be.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t4), f2 = { 0: 0 }, m2 = n2.charMap) f2[(s2 = m2[r2]).old] = s2.new;
    for (d2 in h2 = n2.maxGlyphID, a2) d2 in f2 || (f2[d2] = h2++);
    return c2 = (function(t5) {
      var e3, n3;
      for (e3 in n3 = {}, t5) n3[t5[e3]] = e3;
      return n3;
    })(f2), l2 = Object.keys(c2).sort(function(t5, e3) {
      return t5 - e3;
    }), p2 = (function() {
      var t5, e3, n3;
      for (n3 = [], t5 = 0, e3 = l2.length; t5 < e3; t5++) o2 = l2[t5], n3.push(c2[o2]);
      return n3;
    })(), i2 = this.font.glyf.encode(a2, p2, f2), u2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: u2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
  }, t3;
})();
E$1.API.PDFObject = (function() {
  var t3;
  function e2() {
  }
  return t3 = function(t4, e3) {
    return (Array(e3 + 1).join("0") + t4).slice(-e3);
  }, e2.convert = function(n2) {
    var r2, i2, a2, o2;
    if (Array.isArray(n2)) return "[" + (function() {
      var t4, i3, a3;
      for (a3 = [], t4 = 0, i3 = n2.length; t4 < i3; t4++) r2 = n2[t4], a3.push(e2.convert(r2));
      return a3;
    })().join(" ") + "]";
    if ("string" == typeof n2) return "/" + n2;
    if (null != n2 ? n2.isString : void 0) return "(" + n2 + ")";
    if (n2 instanceof Date) return "(D:" + t3(n2.getUTCFullYear(), 4) + t3(n2.getUTCMonth(), 2) + t3(n2.getUTCDate(), 2) + t3(n2.getUTCHours(), 2) + t3(n2.getUTCMinutes(), 2) + t3(n2.getUTCSeconds(), 2) + "Z)";
    if ("[object Object]" === {}.toString.call(n2)) {
      for (i2 in a2 = ["<<"], n2) o2 = n2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
      return a2.push(">>"), a2.join("\n");
    }
    return "" + n2;
  }, e2;
})();
class ValidSertifikat extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({
      mode: "open"
    });
  }
  connectedCallback() {
    this.shadowRoot.innerHTML = `<style> ${minifiedCss} </style> ${minifiedHtml} `;
    this.initializeApp();
  }
  initializeApp() {
    new CertificateEditorApp(this.shadowRoot, this);
  }
}
class CertificateEditorApp {
  // *** FIX: Constructor now accepts the shadowRoot and the host element.
  constructor(shadowRoot, hostElement) {
    this.root = shadowRoot;
    this.host = hostElement;
    this.canvas = null;
    this.zoom = 1;
    this.uploadedData = [];
    this.dataHeaders = [];
    this.fontCache = {};
    this.qrCodeConfig = {
      columns: [],
      validationUrl: "",
      styling: {}
    };
    this.history = [];
    this.historyIndex = -1;
    this.isRestoring = false;
    this._clipboard = null;
    this.$ = (selector) => this.root.querySelector(selector);
    this.$$ = (selector) => this.root.querySelectorAll(selector);
    document.head.appendChild(Object.assign(document.createElement("link"), {
      rel: "stylesheet",
      href: "https://fonts.googleapis.com/css2?family=Poppins&display=swap"
    }));
    document.querySelector("body").style.margin = "0px";
    document.querySelector("body").style.padding = "0px";
    document.querySelector("body").style.overflow = "clip";
    this.init();
  }
  init() {
    this.initCanvas();
    this.initEventListeners();
    this.initContextMenu();
    this.updateFontDropdown();
    this.initPanAndZoom();
  }
  showLoading(text2 = "Memproses...") {
    this.$("#loading-text").textContent = text2;
    this.$("#loading-modal").classList.remove("hidden");
    this.$("#loading-modal").classList.add("flex");
  }
  hideLoading() {
    this.$("#loading-modal").classList.add("hidden");
    this.$("#loading-modal").classList.remove("flex");
  }
  showAlert(message, type = "info") {
    console.log(`ALERT (${type}):`, message);
    alert(message);
  }
  initCanvas() {
    const initialWidth = this.$("#canvas-width").value;
    const initialHeight = this.$("#canvas-height").value;
    this.canvas = new fabricExports.fabric.Canvas(this.$("#certificate-canvas"), {
      width: parseInt(initialWidth),
      height: parseInt(initialHeight),
      backgroundColor: "#ffffff",
      preserveObjectStacking: true
    });
    fabricExports.fabric.Object.prototype.transparentCorners = false;
    fabricExports.fabric.Object.prototype.cornerColor = "#4f46e5";
    fabricExports.fabric.Object.prototype.cornerStyle = "circle";
    fabricExports.fabric.Object.prototype.borderColor = "#4f46e5";
    fabricExports.fabric.Object.prototype.borderScaleFactor = 1.5;
    this.canvas.on("object:modified", () => this.saveState());
    this.canvas.on("object:added", () => this.saveState());
    this.canvas.on("object:removed", () => this.saveState());
    this.canvas.on({
      "selection:created": (e2) => e2.selected && e2.selected.length > 0 && this.updateContextualToolbar(e2.selected[0]),
      "selection:updated": (e2) => e2.selected && e2.selected.length > 0 && this.updateContextualToolbar(e2.selected[0]),
      "selection:cleared": () => this.hideContextualToolbar()
    });
    this.saveState();
  }
  saveState() {
    if (this.isRestoring) return;
    this.history = this.history.slice(0, this.historyIndex + 1);
    this.history.push(this.canvas.toJSON(["dataLink", "isQrCode"]));
    this.historyIndex = this.history.length - 1;
    this.updateUndoRedoButtons();
  }
  restoreState(index2) {
    this.isRestoring = true;
    const state = this.history[index2];
    this.canvas.loadFromJSON(state, () => {
      this.canvas.renderAll();
      this.isRestoring = false;
      this.updateUndoRedoButtons();
    });
  }
  undo() {
    if (this.historyIndex > 0) {
      this.historyIndex--;
      this.restoreState(this.historyIndex);
    }
  }
  redo() {
    if (this.historyIndex < this.history.length - 1) {
      this.historyIndex++;
      this.restoreState(this.historyIndex);
    }
  }
  updateUndoRedoButtons() {
    this.$("#undo-btn").disabled = this.historyIndex <= 0;
    this.$("#redo-btn").disabled = this.historyIndex >= this.history.length - 1;
  }
  initPanAndZoom() {
    const mainArea = this.$("main");
    const canvasContainer = this.$("#canvas-container");
    mainArea.addEventListener("wheel", (e2) => {
      if (Math.abs(e2.deltaX) > Math.abs(e2.deltaY)) return;
      e2.preventDefault();
      const delta = e2.deltaY > 0 ? -0.01 : 0.01;
      const newZoom = this.zoom + delta;
      this.zoom = Math.max(0.01, Math.min(newZoom, 10));
      canvasContainer.style.transform = `scale(${this.zoom})`;
      this.updateZoomDisplay();
    });
    this.fitToScreen();
  }
  updateZoomDisplay() {
    this.$("#zoom-level-text").textContent = `${Math.round(this.zoom * 100)}%`;
  }
  setZoom(factor) {
    const canvasContainer = this.$("#canvas-container");
    const newZoom = this.zoom * factor;
    this.zoom = Math.max(0.01, Math.min(newZoom, 10));
    canvasContainer.style.transform = `scale(${this.zoom})`;
    this.updateZoomDisplay();
  }
  fitToScreen() {
    const mainArea = this.$("main");
    const canvasContainer = this.$("#canvas-container");
    const style = getComputedStyle(mainArea);
    const paddingX = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    const paddingY = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const availableWidth = mainArea.clientWidth - paddingX;
    const availableHeight = mainArea.clientHeight - paddingY;
    const canvasWidth = this.canvas.getWidth();
    const canvasHeight = this.canvas.getHeight();
    const scale = Math.min(availableWidth / canvasWidth, availableHeight / canvasHeight);
    this.zoom = scale;
    canvasContainer.style.transform = `scale(${this.zoom})`;
    this.updateZoomDisplay();
  }
  initContextMenu() {
    const main = this.$("#main-canvas");
    const contextMenu = this.$("#context-menu");
    main.addEventListener("contextmenu", (e2) => {
      const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0;
      if (isTouchDevice) {
        return;
      }
      e2.preventDefault();
      const target = this.canvas.findTarget(e2, false);
      if (target) {
        this.canvas.setActiveObject(target);
      } else {
        this.canvas.discardActiveObject();
      }
      this.canvas.renderAll();
      this.updateContextMenuState();
      this.showContextMenu(e2.clientX, e2.clientY);
    });
    this.root.addEventListener("click", () => this.hideContextMenu());
    document.addEventListener("click", () => this.hideContextMenu());
    contextMenu.addEventListener("click", (e2) => {
      const button = e2.target.closest("button");
      if (button && button.dataset.action) {
        e2.stopPropagation();
        this.handleMenuAction(button.dataset.action);
        this.hideContextMenu();
      }
    });
  }
  showContextMenu(x2, y2) {
    const contextMenu = this.$("#context-menu");
    contextMenu.classList.remove("hidden");
    contextMenu.style.visibility = "hidden";
    contextMenu.style.display = "block";
    const hostRect = this.host.getBoundingClientRect();
    const menuWidth = contextMenu.offsetWidth;
    const menuHeight = contextMenu.offsetHeight;
    contextMenu.style.visibility = "";
    contextMenu.style.display = "";
    let top = y2 - hostRect.top;
    let left = x2 - hostRect.left;
    if (x2 + menuWidth > window.innerWidth) left -= menuWidth;
    if (y2 + menuHeight > window.innerHeight) top -= menuHeight;
    contextMenu.style.top = `${top}px`;
    contextMenu.style.left = `${left}px`;
    contextMenu.querySelectorAll(".submenu-container").forEach((container) => {
      container.classList.remove("submenu-open-left", "submenu-open-right");
      const sub = container.querySelector(".submenu");
      if (!sub) return;
      const mainRect = container.getBoundingClientRect();
      if (mainRect.right + sub.offsetWidth > window.innerWidth) {
        container.classList.add("submenu-open-left");
      } else {
        container.classList.add("submenu-open-right");
      }
    });
  }
  hideContextMenu() {
    this.$("#context-menu").classList.add("hidden");
  }
  updateContextMenuState() {
    const contextMenu = this.$("#context-menu");
    const activeObject = this.canvas.getActiveObject();
    contextMenu.querySelectorAll("[data-menu-section] button").forEach((btn) => btn.disabled = true);
    if (activeObject) {
      contextMenu.querySelectorAll("[data-menu-section] button").forEach((btn) => btn.disabled = false);
    }
    if (this._clipboard) {
      contextMenu.querySelector('button[data-action="paste"]').disabled = false;
    }
  }
  handleMenuAction(action) {
    const activeObject = this.canvas.getActiveObject();
    if (!activeObject && !["paste"].includes(action)) return;
    switch (action) {
      case "copy":
        this.copyObject();
        break;
      case "paste":
        this.pasteObject();
        break;
      case "duplicate":
        this.duplicateObject();
        break;
      case "delete":
        this.deleteObject();
        break;
      case "bring-forward":
        activeObject.bringForward();
        break;
      case "bring-to-front":
        activeObject.bringToFront();
        break;
      case "send-backward":
        activeObject.sendBackwards();
        break;
      case "send-to-back":
        activeObject.sendToBack();
        break;
      case "align-left":
        activeObject.set({ left: 0 }).setCoords();
        break;
      case "align-center":
        activeObject.centerH();
        break;
      case "align-right":
        activeObject.set({ left: this.canvas.width - activeObject.getScaledWidth() }).setCoords();
        break;
      case "align-top":
        activeObject.set({ top: 0 }).setCoords();
        break;
      case "align-middle":
        activeObject.centerV();
        break;
      case "align-bottom":
        activeObject.set({ top: this.canvas.height - activeObject.getScaledHeight() }).setCoords();
        break;
    }
    this.canvas.renderAll();
    this.saveState();
  }
  copyObject() {
    const activeObject = this.canvas.getActiveObject();
    if (!activeObject) return;
    activeObject.clone((cloned) => {
      this._clipboard = cloned;
    });
  }
  pasteObject() {
    if (!this._clipboard) return;
    this._clipboard.clone((clonedObj) => {
      this.canvas.discardActiveObject();
      clonedObj.set({
        left: (this._clipboard.left || 0) + 10,
        top: (this._clipboard.top || 0) + 10,
        evented: true
      });
      if (clonedObj.type === "activeSelection") {
        clonedObj.canvas = this.canvas;
        clonedObj.forEachObject((obj) => this.canvas.add(obj));
        clonedObj.setCoords();
      } else {
        this.canvas.add(clonedObj);
      }
      this._clipboard.top += 10;
      this._clipboard.left += 10;
      this.canvas.setActiveObject(clonedObj);
      this.canvas.requestRenderAll();
      this.saveState();
    });
  }
  duplicateObject() {
    const activeObject = this.canvas.getActiveObject();
    if (!activeObject) return;
    activeObject.clone((cloned) => {
      this.canvas.discardActiveObject();
      cloned.set({
        left: cloned.left + 10,
        top: cloned.top + 10
      });
      this.canvas.add(cloned);
      this.canvas.setActiveObject(cloned);
      this.canvas.requestRenderAll();
      this.saveState();
    });
  }
  deleteObject() {
    const activeObjects = this.canvas.getActiveObjects();
    if (!activeObjects.length) return;
    activeObjects.forEach((obj) => this.canvas.remove(obj));
    this.canvas.discardActiveObject();
    this.canvas.requestRenderAll();
    this.saveState();
  }
  initEventListeners() {
    this.$("#zoom-in-btn").addEventListener("click", () => this.setZoom(1.2));
    this.$("#zoom-out-btn").addEventListener("click", () => this.setZoom(0.8));
    this.$("#fit-to-screen-btn").addEventListener("click", () => this.fitToScreen());
    this.$("#canvas-width").addEventListener("change", (e2) => this.setCanvasSize(e2.target.value, null));
    this.$("#canvas-height").addEventListener("change", (e2) => this.setCanvasSize(null, e2.target.value));
    this.$("#bg-uploader").addEventListener("change", (e2) => this.handleBackgroundUpload(e2));
    this.$("#add-text").addEventListener("click", () => this.addText());
    this.$("#add-rect").addEventListener("click", () => this.addRect());
    this.$("#image-uploader").addEventListener("change", (e2) => this.handleImageUpload(e2));
    this.$("#add-qrcode").addEventListener("click", () => this.openQrCodeModal());
    this.$("#data-uploader").addEventListener("change", (e2) => this.handleDataUpload(e2));
    this.$("#font-uploader").addEventListener("change", (e2) => this.handleFontUpload(e2));
    this.$("#undo-btn").addEventListener("click", () => this.undo());
    this.$("#redo-btn").addEventListener("click", () => this.redo());
    document.addEventListener("keydown", (e2) => {
      if (e2.target.tagName === "INPUT" || e2.target.tagName === "TEXTAREA") {
        if (this.root.contains(e2.target)) ;
        else {
          return;
        }
      }
      if (e2.ctrlKey || e2.metaKey) {
        if (e2.key.toLowerCase() === "z") {
          this.undo();
        }
        if (e2.key.toLowerCase() === "y") {
          this.redo();
        }
      }
      const isInputFocused = e2.target.tagName === "INPUT" || e2.target.tagName === "TEXTAREA";
      if (e2.key === "Delete") {
        this.handleMenuAction("delete");
      }
      if (!isInputFocused) {
        if (e2.ctrlKey || e2.metaKey) {
          switch (e2.key.toLowerCase()) {
            case "c":
              this.handleMenuAction("copy");
              break;
            case "v":
              this.handleMenuAction("paste");
              break;
            case "d":
              e2.preventDefault();
              this.handleMenuAction("duplicate");
              break;
            case "[":
              e2.preventDefault();
              e2.altKey ? this.handleMenuAction("send-to-back") : this.handleMenuAction("send-backward");
              break;
            case "]":
              e2.preventDefault();
              e2.altKey ? this.handleMenuAction("bring-to-front") : this.handleMenuAction("bring-forward");
              break;
          }
        }
      }
    });
    this.setupToolbarListeners();
    this.$("#close-qrcode-modal").addEventListener("click", () => this.$("#qrcode-modal").classList.add("hidden"));
    this.$("#add-qrcode-column").addEventListener("click", () => this.addQrCodeColumnSelector());
    this.$("#save-qrcode-btn").addEventListener("click", () => this.saveAndAddQrCode());
    const logoUploader = this.$("#logoUploader");
    const logoPreview = this.$("#logo-preview");
    const removeLogoBtn = this.$("#remove-logo");
    this.$$('input[name="dots-color-type"]').forEach((radio) => {
      radio.addEventListener("change", () => {
        const isGradient = this.$('input[name="dots-color-type"]:checked').value === "gradient";
        this.$(".dots-gradient-fields").classList.toggle("hidden", !isGradient);
        this.$(".dots-single-color-fields").classList.toggle("hidden", isGradient);
      });
    });
    logoUploader.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e2) => {
        this.uploadedLogoDataUrl = e2.target.result;
        logoPreview.src = this.uploadedLogoDataUrl;
        logoPreview.classList.remove("hidden");
        removeLogoBtn.classList.remove("hidden");
      };
      reader.readAsDataURL(file);
    });
    removeLogoBtn.addEventListener("click", () => {
      this.uploadedLogoDataUrl = null;
      logoUploader.value = "";
      logoPreview.src = "";
      logoPreview.classList.add("hidden");
      removeLogoBtn.classList.add("hidden");
    });
    this.$$(".download-format").forEach((button) => {
      button.addEventListener("click", (e2) => {
        let format = e2.currentTarget.getAttribute("data-format");
        this.generateAndDownloadZip(format);
      });
    });
    this.root.addEventListener("click", (event) => {
      const canvasWrapper = this.canvas.wrapperEl;
      if (canvasWrapper && !canvasWrapper.contains(event.target) && !event.target.closest("#contextual-toolbar") && !event.target.closest("#sidebar") && !event.target.closest("header")) {
        if (this.canvas.getActiveObject()) {
          this.canvas.discardActiveObject();
          this.canvas.requestRenderAll();
        }
      }
    });
    const appContainer = this.$("#app-container");
    const themeToggleBtn = this.$("#theme-toggle");
    const darkIcon = this.$("#theme-toggle-dark-icon");
    const lightIcon = this.$("#theme-toggle-light-icon");
    const toggleTheme = () => {
      appContainer.classList.toggle("dark");
      let isDark = appContainer.classList.contains("dark");
      localStorage.setItem("color-theme", isDark ? "dark" : "light");
      lightIcon.classList.toggle("hidden", isDark);
      darkIcon.classList.toggle("hidden", !isDark);
    };
    themeToggleBtn.addEventListener("click", toggleTheme);
    if (localStorage.getItem("color-theme") === "dark" || !("color-theme" in localStorage) && window.matchMedia("(prefers-color-scheme: dark)").matches) {
      appContainer.classList.add("dark");
      lightIcon.classList.add("hidden");
      darkIcon.classList.remove("hidden");
    } else {
      appContainer.classList.remove("dark");
      lightIcon.classList.remove("hidden");
      darkIcon.classList.add("hidden");
    }
    this.$("#sidebar-toggle").addEventListener("click", () => {
      this.$("#sidebar").classList.toggle("hidden");
    });
    const downloadButton = this.$("#download-zip-btn");
    const formatMenu = this.$("#download-format");
    downloadButton.addEventListener("click", (e2) => {
      e2.stopPropagation();
      const isExpanded = downloadButton.getAttribute("aria-expanded") === "true";
      downloadButton.setAttribute("aria-expanded", !isExpanded);
      formatMenu.classList.toggle("hidden");
    });
    document.addEventListener("click", (event) => {
      if (!event.composedPath().includes(downloadButton)) {
        formatMenu.classList.add("hidden");
        downloadButton.setAttribute("aria-expanded", "false");
      }
    });
  }
  setCanvasSize(width, height) {
    const newWidth = parseInt(width) || this.canvas.getWidth();
    const newHeight = parseInt(height) || this.canvas.getHeight();
    this.canvas.setZoom(1);
    this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    this.canvas.setWidth(newWidth);
    this.canvas.setHeight(newHeight);
    this.fitToScreen();
    this.canvas.renderAll();
  }
  updateContextualToolbar(obj) {
    if (!obj) {
      this.hideContextualToolbar();
      return;
    }
    const toolbar = this.$("#contextual-toolbar");
    toolbar.classList.remove("hidden");
    toolbar.classList.add("flex");
    const isText = obj.type === "i-text" || obj.type === "textbox";
    this.$("#text-options").classList.toggle("hidden", !isText);
    this.$("#text-options").classList.toggle("flex", isText);
    this.$("#general-options").classList.remove("hidden");
    this.$("#general-options").classList.add("flex");
    if (isText) {
      this.$("#font-family-select").value = obj.fontFamily;
      this.$("#font-size-input").value = obj.fontSize;
      this.$("#font-color-picker").value = obj.fill;
      this.$("#fill-color-picker").classList.add("hidden");
    } else {
      this.$("#fill-color-picker").classList.remove("hidden");
      this.$("#fill-color-picker").value = obj.fill;
    }
    const pasteButton = this.$('#general-options button[data-action="paste"]');
    if (pasteButton) {
      pasteButton.disabled = !this._clipboard;
    }
    this.updateDataMappingUI(obj);
  }
  hideContextualToolbar() {
    this.$("#contextual-toolbar").classList.add("hidden");
    this.updateDataMappingUI(null);
  }
  setupToolbarListeners() {
    const applyToActive = (callback) => {
      const activeObject = this.canvas.getActiveObject();
      if (activeObject) {
        callback(activeObject);
        this.canvas.renderAll();
        this.saveState();
      }
    };
    this.$("#contextual-toolbar").addEventListener("click", (e2) => {
      const button = e2.target.closest("button[data-action]");
      if (button) {
        e2.stopPropagation();
        this.handleMenuAction(button.dataset.action);
        this.$$("[data-submenu-container] > div").forEach((sub) => sub.classList.add("hidden"));
      }
    });
    this.$("#font-family-select").addEventListener("change", (e2) => applyToActive((obj) => obj.set("fontFamily", e2.target.value)));
    this.$("#font-size-input").addEventListener("input", (e2) => applyToActive((obj) => obj.set("fontSize", parseInt(e2.target.value, 10))));
    this.$("#font-color-picker").addEventListener("input", (e2) => applyToActive((obj) => obj.set("fill", e2.target.value)));
    this.$("#font-bold-btn").addEventListener("click", () => applyToActive((obj) => obj.set("fontWeight", obj.fontWeight === "bold" ? "normal" : "bold")));
    this.$("#font-italic-btn").addEventListener("click", () => applyToActive((obj) => obj.set("fontStyle", obj.fontStyle === "italic" ? "normal" : "italic")));
    this.$("#fill-color-picker").addEventListener("input", (e2) => applyToActive((obj) => obj.set("fill", e2.target.value)));
    this.$$("[data-submenu-container]").forEach((container) => {
      const submenu = container.querySelector("div");
      container.addEventListener("mouseenter", () => {
        submenu.classList.remove("hidden");
        submenu.classList.add("flex");
      });
      container.addEventListener("mouseleave", () => {
        submenu.classList.add("hidden");
        submenu.classList.remove("flex");
      });
    });
  }
  handleBackgroundUpload(e2) {
    const file = e2.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (f2) => {
      fabricExports.fabric.Image.fromURL(f2.target.result, (img) => {
        let canvasWidth = this.canvas.width;
        let canvasHeight = this.canvas.height;
        if (img.width > canvasWidth || img.height > canvasHeight) {
          this.setCanvasSize(img.width, img.height);
          canvasWidth = this.canvas.width;
          canvasHeight = this.canvas.height;
          this.$("#canvas-width").value = canvasWidth;
          this.$("#canvas-height").value = canvasHeight;
        }
        const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height);
        this.canvas.setBackgroundImage(img, () => {
          this.canvas.renderAll();
          this.fitToScreen();
        }, {
          scaleX: scale,
          scaleY: scale,
          originX: "center",
          originY: "center",
          left: canvasWidth / 2,
          top: canvasHeight / 2
        });
      });
    };
    reader.readAsDataURL(file);
  }
  handleImageUpload(e2) {
    const file = e2.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (f2) => {
      fabricExports.fabric.Image.fromURL(f2.target.result, (img) => {
        img.scaleToHeight(this.$("#canvas-height").value * 0.5);
        this.canvas.add(img).centerObject(img).renderAll();
      });
    };
    reader.readAsDataURL(file);
  }
  handleDataUpload(e2) {
    const file = e2.target.files[0];
    if (!file) return;
    this.showLoading("Membaca file data...");
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = event.target.result;
        if (file.name.endsWith(".csv")) {
          const parsed = Papa.parse(data, {
            header: true,
            skipEmptyLines: true
          });
          this.uploadedData = parsed.data;
          this.dataHeaders = parsed.meta.fields;
        } else {
          const workbook = readSync(data, {
            type: "binary"
          });
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          this.uploadedData = utils.sheet_to_json(worksheet);
          if (this.uploadedData.length > 0) {
            this.dataHeaders = Object.keys(this.uploadedData[0]);
          }
        }
        this.$("#data-mapping-container").classList.remove("hidden");
        this.updateDataMappingUI();
        this.showAlert(`${this.uploadedData.length} baris data berhasil di-load.`);
      } catch (err) {
        this.showAlert("Gagal memproses file. Pastikan formatnya benar.", "error");
        console.error(err);
      } finally {
        this.hideLoading();
      }
    };
    reader.readAsBinaryString(file);
  }
  handleFontUpload(e2) {
    const file = e2.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    const fontName = file.name.split(".")[0].replace(/[^a-zA-Z0-9]/g, "");
    reader.onload = (f2) => {
      const fontData = f2.target.result;
      const newFont = new FontFace(fontName, `url(${fontData})`);
      newFont.load().then((loadedFont) => {
        document.fonts.add(loadedFont);
        this.fontCache[fontName] = fontName;
        this.updateFontDropdown();
        this.showAlert(`Font '${fontName}' berhasil ditambahkan.`);
      }).catch((err) => {
        console.error("Font loading failed:", err);
        this.showAlert("Gagal memuat font.", "error");
      });
    };
    reader.readAsDataURL(file);
  }
  updateFontDropdown() {
    const select = this.$("#font-family-select");
    const defaultFonts = {
      "Poppins": "Poppins, sans-serif",
      "Arial": "Arial, sans-serif",
      "Verdana": "Verdana, sans-serif",
      "Georgia": "Georgia, serif",
      "Times New Roman": "Times New Roman, serif",
      "Courier New": "Courier New, monospace"
    };
    const allFonts = { ...defaultFonts, ...this.fontCache };
    select.innerHTML = Object.keys(allFonts).map((name) => `<option value="${allFonts[name]}">${name}</option>`).join("");
  }
  addText() {
    const text2 = new fabricExports.fabric.Textbox("Teks Contoh", {
      left: this.$("#canvas-width").value * 0.4,
      top: this.$("#canvas-height").value * 0.4,
      width: this.$("#canvas-width").value * 0.2,
      fontSize: 40,
      fontFamily: "Poppins",
      fill: "#000000"
    });
    this.canvas.add(text2).setActiveObject(text2).renderAll();
  }
  addRect() {
    const rect = new fabricExports.fabric.Rect({
      left: this.$("#canvas-width").value * 0.4,
      top: this.$("#canvas-height").value * 0.4,
      width: this.$("#canvas-width").value * 0.3,
      height: this.$("#canvas-height").value * 0.25,
      fill: "#93c5fd"
    });
    this.canvas.add(rect).setActiveObject(rect).renderAll();
  }
  updateDataMappingUI(selectedObject = this.canvas.getActiveObject()) {
    const container = this.$("#data-mapping-ui");
    if (this.dataHeaders.length === 0) {
      container.innerHTML = '<p class="text-xs text-slate-500">Upload file Excel/CSV untuk memulai.</p>';
      return;
    }
    if (!selectedObject) {
      container.innerHTML = '<p class="text-xs text-slate-500">Pilih elemen di kanvas untuk dihubungkan dengan kolom data.</p>';
      return;
    }
    const currentLink = selectedObject.dataLink || "none";
    const options = [
      '<option value="none">-- Tidak terhubung --</option>',
      ...this.dataHeaders.map((header) => `<option value="${header}" ${header === currentLink ? "selected" : ""}>${header}</option>`)
    ].join("");
    container.innerHTML = `
                <div class="bg-slate-100 p-2 rounded-md dark:bg-slate-700/50">
                    <p class="text-xs font-bold mb-1">Elemen terpilih: <span class="font-normal dark:text-slate-400">${selectedObject.type}</span></p>
                    <select id="data-linker" class="w-full h-8 rounded-md borders bg-white dark:bg-slate-700 px-2 text-sm">${options}</select>
                </div>
            `;
    this.$("#data-linker").addEventListener("change", (e2) => {
      const value = e2.target.value;
      if (value === "none") {
        delete selectedObject.dataLink;
      } else {
        selectedObject.set("dataLink", value);
        if (this.uploadedData.length > 0 && (selectedObject.type === "i-text" || selectedObject.type === "textbox")) {
          const cellValue = this.uploadedData[0][value];
          selectedObject.set("text", String(cellValue));
          this.canvas.renderAll();
        }
      }
    });
  }
  openQrCodeModal() {
    if (this.dataHeaders.length === 0) {
      this.showAlert("Harap upload data Excel/CSV terlebih dahulu untuk membuat QR Code dinamis.", "warning");
      return;
    }
    this.$("#qrcode-columns-container").innerHTML = "";
    this.addQrCodeColumnSelector();
    this.$("#qrcode-modal").classList.remove("hidden");
  }
  addQrCodeColumnSelector() {
    const container = this.$("#qrcode-columns-container");
    const count = container.children.length;
    const options = this.dataHeaders.map((h2) => `<option value="${h2}">${h2}</option>`).join("");
    const div = document.createElement("div");
    div.className = "flex items-center gap-2";
    div.innerHTML = `
                <select class="w-full h-9 rounded-md borders bg-slate-50 dark:bg-slate-700 px-2 text-sm dark:text-slate-400" data-qr-column-index="${count}">
                    <option value="">-- Pilih Kolom ${count + 1} --</option>
                    ${options}
                </select>
            `;
    container.appendChild(div);
  }
  async saveAndAddQrCode() {
    const columnSelectors = this.$$("[data-qr-column-index]");
    const columns = Array.from(columnSelectors).map((sel) => sel.value).filter(Boolean);
    if (columns.length === 0) {
      return this.showAlert("Pilih setidaknya satu kolom untuk data QR Code.", "warning");
    }
    this.qrCodeConfig.columns = columns;
    this.qrCodeConfig.validationUrl = this.$("#validation-url").value;
    const stylingOptions = {
      width: 500,
      height: 500,
      backgroundOptions: { color: this.$("#qr-bg-color").value },
      dotsOptions: { type: this.$("#qr-dots-type").value },
      cornersSquareOptions: { type: this.$("#qr-corners-square-type").value, color: this.$("#qr-corners-square-color").value },
      cornersDotOptions: { type: this.$("#qr-corners-dot-type").value, color: this.$("#qr-corners-dot-color").value },
      qrOptions: { errorCorrectionLevel: this.$("#qr-error-correction-level").value },
      imageOptions: { margin: parseInt(this.$("#qr-image-margin").value) || 0 },
      image: this.uploadedLogoDataUrl || null
    };
    if (this.$('input[name="dots-color-type"]:checked').value === "gradient") {
      stylingOptions.dotsOptions.gradient = {
        type: "linear",
        rotation: this.$("#qr-dots-gradient-rotation").value * (Math.PI / 180),
        colorStops: [
          { offset: 0, color: this.$("#qr-dots-gradient-color1").value },
          { offset: 1, color: this.$("#qr-dots-gradient-color2").value }
        ]
      };
    } else {
      stylingOptions.dotsOptions.color = this.$("#qr-dots-color").value;
    }
    this.qrCodeConfig.styling = stylingOptions;
    this.showLoading("Membuat QR Code...");
    try {
      const qrData = `${this.qrCodeConfig.validationUrl}[ENCRYPTED_CODE_PLACEHOLDER]`;
      const qrCode = new QRCodeStyling({ ...stylingOptions, data: qrData });
      const blob = await qrCode.getRawData("png");
      const qrImageUrl = URL.createObjectURL(blob);
      if (qrImageUrl) {
        fabricExports.fabric.Image.fromURL(qrImageUrl, (img) => {
          img.scaleToWidth(parseInt(this.$("#canvas-width").value * 0.2));
          img.set("isQrCode", true);
          this.canvas.add(img).centerObject(img).renderAll();
        });
      }
      this.$("#qrcode-modal").classList.add("hidden");
    } catch (error) {
      this.showAlert("Gagal membuat QR code placeholder.", "error");
      console.error(error);
    } finally {
      this.hideLoading();
    }
  }
  convertJpegToPng(jpegDataUrl) {
    return new Promise((resolve) => {
      const image2 = new Image();
      image2.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = image2.width;
        canvas.height = image2.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image2, 0, 0);
        const pngDataUrl = canvas.toDataURL("image/png");
        resolve(pngDataUrl);
      };
      image2.src = jpegDataUrl;
    });
  }
  async generateAndDownloadZip(paramFormat) {
    const format = paramFormat;
    if (!format) {
      console.error("Format unduhan tidak ditentukan.");
      return;
    }
    const isPdf = format === "pdf";
    const dataToProcess = this.uploadedData.length > 0 ? this.uploadedData : [{}];
    const qualityMultiplier = 2;
    const jpegQuality = 0.7;
    if (dataToProcess.length === 1 && this.uploadedData.length === 0) {
      this.showLoading("Membuat sertifikat...");
      const originalViewport2 = this.canvas.viewportTransform.slice();
      const originalZoom2 = this.canvas.getZoom();
      this.canvas.setZoom(1);
      this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
      const dataUrl = this.canvas.toDataURL({ format: isPdf ? "jpeg" : format, quality: jpegQuality, multiplier: qualityMultiplier });
      if (isPdf) {
        const orientation = this.canvas.width > this.canvas.height ? "l" : "p";
        const pdfDoc = new E$1({
          orientation,
          unit: "px",
          format: [this.canvas.width, this.canvas.height]
        });
        pdfDoc.addImage(dataUrl, "JPEG", 0, 0, this.canvas.width, this.canvas.height);
        pdfDoc.save("sertifikat.pdf");
      } else {
        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = `sertifikat.${format}`;
        link.click();
      }
      this.canvas.setZoom(originalZoom2);
      this.canvas.setViewportTransform(originalViewport2);
      this.canvas.renderAll();
      this.hideLoading();
      this.showAlert("Sertifikat berhasil dibuat!", "success");
      return;
    }
    this.showLoading("Memulai proses...");
    const zip = new JSZip();
    const originalViewport = this.canvas.viewportTransform.slice();
    const originalZoom = this.canvas.getZoom();
    this.canvas.setZoom(1);
    this.canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
    const originalCanvasState = this.canvas.toJSON(["dataLink", "isQrCode"]);
    let encryptedCodes = [];
    if (this.canvas.getObjects().some((o2) => o2.isQrCode) && this.uploadedData.length > 0) {
      this.showLoading(`Mengenkripsi ${this.uploadedData.length} data...`);
      const combinedTexts = this.uploadedData.map((row) => this.qrCodeConfig.columns.map((col) => row[col] || "").join(" - "));
      try {
        const response = await axios.post("https://aesapi-node.vercel.app/", { action: "encrypt", data: combinedTexts });
        encryptedCodes = response.data.result;
      } catch (error) {
        this.canvas.setZoom(originalZoom);
        this.canvas.setViewportTransform(originalViewport);
        this.hideLoading();
        console.error(error);
        return this.showAlert("Gagal saat enkripsi data. Proses dibatalkan.", "error");
      }
    }
    const filenameColumn = this.dataHeaders[0];
    for (let i2 = 0; i2 < dataToProcess.length; i2++) {
      const row = dataToProcess[i2];
      this.showLoading(`Membuat sertifikat ${i2 + 1}/${dataToProcess.length}...`);
      await new Promise((resolve) => {
        this.canvas.loadFromJSON(originalCanvasState, () => {
          if (this.uploadedData.length > 0) {
            this.canvas.getObjects().forEach((obj) => {
              if (obj.dataLink && (obj.type === "i-text" || obj.type === "textbox")) {
                const cellValue = row[obj.dataLink] || "";
                obj.set("text", String(cellValue));
              }
            });
          }
          this.canvas.renderAll();
          resolve();
        });
      });
      const currentQrObject = this.canvas.getObjects().find((obj) => obj.isQrCode);
      if (currentQrObject && encryptedCodes[i2]) {
        const qrFinalData = `${this.qrCodeConfig.validationUrl}${encryptedCodes[i2]}`;
        const qrCode = new QRCodeStyling({ ...this.qrCodeConfig.styling, data: qrFinalData });
        const blob = await qrCode.getRawData("png");
        const qrImageUrl = URL.createObjectURL(blob);
        await new Promise((resolve) => {
          fabricExports.fabric.Image.fromURL(qrImageUrl, (newImg) => {
            newImg.set({
              left: currentQrObject.left,
              top: currentQrObject.top,
              scaleX: currentQrObject.scaleX,
              scaleY: currentQrObject.scaleY,
              angle: currentQrObject.angle,
              isQrCode: true
            });
            this.canvas.remove(currentQrObject);
            this.canvas.add(newImg);
            this.canvas.renderAll();
            resolve();
          });
        });
      }
      const filename = this.uploadedData.length > 0 && filenameColumn ? `${row[filenameColumn] || `sertifikat-${i2 + 1}`}` : `sertifikat-${i2 + 1}`;
      if (format === "png") {
        const jpegDataUrl = this.canvas.toDataURL({
          format: "jpeg",
          quality: jpegQuality,
          multiplier: qualityMultiplier
        });
        const pngDataUrl = await this.convertJpegToPng(jpegDataUrl);
        zip.file(`${filename}-${i2 + 1}.png`, pngDataUrl.split(",")[1], { base64: true });
      } else {
        const dataUrlLoop = this.canvas.toDataURL({ format: isPdf ? "jpeg" : format, quality: jpegQuality, multiplier: qualityMultiplier });
        if (isPdf) {
          const orientation = this.canvas.width > this.canvas.height ? "l" : "p";
          const pdfDoc = new E$1({ orientation, unit: "px", format: [this.canvas.width, this.canvas.height] });
          pdfDoc.addImage(dataUrlLoop, "JPEG", 0, 0, this.canvas.width, this.canvas.height);
          const pdfBlob = pdfDoc.output("blob");
          zip.file(`${filename}-${i2 + 1}.pdf`, pdfBlob);
        } else {
          zip.file(`${filename}-${i2 + 1}.${format}`, dataUrlLoop.split(",")[1], { base64: true });
        }
      }
    }
    this.showLoading("Mengompres file ZIP...");
    this.canvas.loadFromJSON(originalCanvasState, () => {
      this.canvas.setZoom(originalZoom);
      this.canvas.setViewportTransform(originalViewport);
      this.canvas.renderAll();
      zip.generateAsync({ type: "blob" }).then((content2) => {
        const link = document.createElement("a");
        link.href = URL.createObjectURL(content2);
        link.download = `Sertifikat-${format.toUpperCase()}.zip`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        this.hideLoading();
        this.showAlert("File ZIP berhasil dibuat!", "success");
      });
    });
  }
}
if (!window.customElements.get("validsertifikat-app")) {
  window.customElements.define("validsertifikat-app", ValidSertifikat);
}
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t3[p2] = s2[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y2, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t3 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t3 = y2["return"]) && t3.call(y2), 0) : y2.next) && !(t3 = t3.call(y2, op[1])).done) return t3;
      if (y2 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || from);
}
var Bounds = (
  /** @class */
  (function() {
    function Bounds2(left, top, width, height) {
      this.left = left;
      this.top = top;
      this.width = width;
      this.height = height;
    }
    Bounds2.prototype.add = function(x2, y2, w2, h2) {
      return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
    };
    Bounds2.fromClientRect = function(context, clientRect) {
      return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
    };
    Bounds2.fromDOMRectList = function(context, domRectList) {
      var domRect = Array.from(domRectList).find(function(rect) {
        return rect.width !== 0;
      });
      return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
    };
    Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
    return Bounds2;
  })()
);
var parseBounds = function(context, node2) {
  return Bounds.fromClientRect(context, node2.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer = decode$1(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie$1 = (
  /** @class */
  (function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  })()
);
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "Ã";
var BREAK_ALLOWED$1 = "Ã·";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i2 = currentIndex;
    while (i2 <= classTypes.length) {
      i2++;
      var next = classTypes[i2];
      if (next === b2) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i2 = currentIndex;
    while (i2 > 0) {
      i2--;
      var prev = classTypes[i2];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n2 = currentIndex;
        while (n2 <= classTypes.length) {
          n2++;
          var next = classTypes[n2];
          if (next === b2) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i2 = currentIndex;
  while (i2 >= 0) {
    var type = classTypes[i2];
    if (type === SP) {
      i2--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (
    // (PR | PO) Ã ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY ) Ã NU
    [OP, HY].indexOf(current) !== -1 && next === NU || // NU Ã	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1
  ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next === RI$1) {
    var i2 = indicies[currentIndex];
    var count = 1;
    while (i2 > 0) {
      i2--;
      if (classTypes[i2] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
    return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = (
  /** @class */
  (function() {
    function Break2(codePoints, lineBreak2, start, end) {
      this.codePoints = codePoints;
      this.required = lineBreak2 === BREAK_MANDATORY;
      this.start = start;
      this.end = end;
    }
    Break2.prototype.slice = function() {
      return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
    };
    return Break2;
  })()
);
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a$1 = 97;
var e$1 = 101;
var f$1 = 102;
var u$1 = 117;
var z = 122;
var A = 65;
var E = 69;
var F = 70;
var U = 85;
var Z = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a$1 && codePoint <= f$1;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a$1 && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c2 = 0;
  var sign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      sign = -1;
    }
    c2++;
  }
  var integers = [];
  while (isDigit(codePoints[c2])) {
    integers.push(codePoints[c2++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c2] === FULL_STOP) {
    c2++;
  }
  var fraction = [];
  while (isDigit(codePoints[c2])) {
    fraction.push(codePoints[c2++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c2] === E || codePoints[c2] === e$1) {
    c2++;
  }
  var expsign = 1;
  if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
    if (codePoints[c2] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c2++;
  }
  var exponent = [];
  while (isDigit(codePoints[c2])) {
    exponent.push(codePoints[c2++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
  /* LEFT_PARENTHESIS_TOKEN */
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
  /* RIGHT_PARENTHESIS_TOKEN */
};
var COMMA_TOKEN = {
  type: 4
  /* COMMA_TOKEN */
};
var SUFFIX_MATCH_TOKEN = {
  type: 13
  /* SUFFIX_MATCH_TOKEN */
};
var PREFIX_MATCH_TOKEN = {
  type: 8
  /* PREFIX_MATCH_TOKEN */
};
var COLUMN_TOKEN = {
  type: 21
  /* COLUMN_TOKEN */
};
var DASH_MATCH_TOKEN = {
  type: 9
  /* DASH_MATCH_TOKEN */
};
var INCLUDE_MATCH_TOKEN = {
  type: 10
  /* INCLUDE_MATCH_TOKEN */
};
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
  /* LEFT_CURLY_BRACKET_TOKEN */
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
  /* RIGHT_CURLY_BRACKET_TOKEN */
};
var SUBSTRING_MATCH_TOKEN = {
  type: 14
  /* SUBSTRING_MATCH_TOKEN */
};
var BAD_URL_TOKEN = {
  type: 23
  /* BAD_URL_TOKEN */
};
var BAD_STRING_TOKEN = {
  type: 1
  /* BAD_STRING_TOKEN */
};
var CDO_TOKEN = {
  type: 25
  /* CDO_TOKEN */
};
var CDC_TOKEN = {
  type: 24
  /* CDC_TOKEN */
};
var COLON_TOKEN = {
  type: 26
  /* COLON_TOKEN */
};
var SEMICOLON_TOKEN = {
  type: 27
  /* SEMICOLON_TOKEN */
};
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
  /* LEFT_SQUARE_BRACKET_TOKEN */
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
  /* RIGHT_SQUARE_BRACKET_TOKEN */
};
var WHITESPACE_TOKEN = {
  type: 31
  /* WHITESPACE_TOKEN */
};
var EOF_TOKEN = {
  type: 32
  /* EOF_TOKEN */
};
var Tokenizer = (
  /** @class */
  (function() {
    function Tokenizer2() {
      this._value = [];
    }
    Tokenizer2.prototype.write = function(chunk) {
      this._value = this._value.concat(toCodePoints$1(chunk));
    };
    Tokenizer2.prototype.read = function() {
      var tokens = [];
      var token = this.consumeToken();
      while (token !== EOF_TOKEN) {
        tokens.push(token);
        token = this.consumeToken();
      }
      return tokens;
    };
    Tokenizer2.prototype.consumeToken = function() {
      var codePoint = this.consumeCodePoint();
      switch (codePoint) {
        case QUOTATION_MARK:
          return this.consumeStringToken(QUOTATION_MARK);
        case NUMBER_SIGN:
          var c1 = this.peekCodePoint(0);
          var c2 = this.peekCodePoint(1);
          var c3 = this.peekCodePoint(2);
          if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
            var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
            var value = this.consumeName();
            return { type: 5, value, flags };
          }
          break;
        case DOLLAR_SIGN:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUFFIX_MATCH_TOKEN;
          }
          break;
        case APOSTROPHE:
          return this.consumeStringToken(APOSTROPHE);
        case LEFT_PARENTHESIS:
          return LEFT_PARENTHESIS_TOKEN;
        case RIGHT_PARENTHESIS:
          return RIGHT_PARENTHESIS_TOKEN;
        case ASTERISK:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return SUBSTRING_MATCH_TOKEN;
          }
          break;
        case PLUS_SIGN:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case COMMA:
          return COMMA_TOKEN;
        case HYPHEN_MINUS:
          var e1 = codePoint;
          var e2 = this.peekCodePoint(0);
          var e3 = this.peekCodePoint(1);
          if (isNumberStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          if (isIdentifierStart(e1, e2, e3)) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDC_TOKEN;
          }
          break;
        case FULL_STOP:
          if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeNumericToken();
          }
          break;
        case SOLIDUS:
          if (this.peekCodePoint(0) === ASTERISK) {
            this.consumeCodePoint();
            while (true) {
              var c4 = this.consumeCodePoint();
              if (c4 === ASTERISK) {
                c4 = this.consumeCodePoint();
                if (c4 === SOLIDUS) {
                  return this.consumeToken();
                }
              }
              if (c4 === EOF) {
                return this.consumeToken();
              }
            }
          }
          break;
        case COLON:
          return COLON_TOKEN;
        case SEMICOLON:
          return SEMICOLON_TOKEN;
        case LESS_THAN_SIGN:
          if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
            this.consumeCodePoint();
            this.consumeCodePoint();
            return CDO_TOKEN;
          }
          break;
        case COMMERCIAL_AT:
          var a1 = this.peekCodePoint(0);
          var a2 = this.peekCodePoint(1);
          var a3 = this.peekCodePoint(2);
          if (isIdentifierStart(a1, a2, a3)) {
            var value = this.consumeName();
            return { type: 7, value };
          }
          break;
        case LEFT_SQUARE_BRACKET:
          return LEFT_SQUARE_BRACKET_TOKEN;
        case REVERSE_SOLIDUS:
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          }
          break;
        case RIGHT_SQUARE_BRACKET:
          return RIGHT_SQUARE_BRACKET_TOKEN;
        case CIRCUMFLEX_ACCENT:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return PREFIX_MATCH_TOKEN;
          }
          break;
        case LEFT_CURLY_BRACKET:
          return LEFT_CURLY_BRACKET_TOKEN;
        case RIGHT_CURLY_BRACKET:
          return RIGHT_CURLY_BRACKET_TOKEN;
        case u$1:
        case U:
          var u1 = this.peekCodePoint(0);
          var u2 = this.peekCodePoint(1);
          if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
            this.consumeCodePoint();
            this.consumeUnicodeRangeToken();
          }
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        case VERTICAL_LINE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return DASH_MATCH_TOKEN;
          }
          if (this.peekCodePoint(0) === VERTICAL_LINE) {
            this.consumeCodePoint();
            return COLUMN_TOKEN;
          }
          break;
        case TILDE:
          if (this.peekCodePoint(0) === EQUALS_SIGN) {
            this.consumeCodePoint();
            return INCLUDE_MATCH_TOKEN;
          }
          break;
        case EOF:
          return EOF_TOKEN;
      }
      if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        return WHITESPACE_TOKEN;
      }
      if (isDigit(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeNumericToken();
      }
      if (isNameStartCodePoint(codePoint)) {
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      }
      return { type: 6, value: fromCodePoint$1(codePoint) };
    };
    Tokenizer2.prototype.consumeCodePoint = function() {
      var value = this._value.shift();
      return typeof value === "undefined" ? -1 : value;
    };
    Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
      this._value.unshift(codePoint);
    };
    Tokenizer2.prototype.peekCodePoint = function(delta) {
      if (delta >= this._value.length) {
        return -1;
      }
      return this._value[delta];
    };
    Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
      var digits = [];
      var codePoint = this.consumeCodePoint();
      while (isHex(codePoint) && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var questionMarks = false;
      while (codePoint === QUESTION_MARK && digits.length < 6) {
        digits.push(codePoint);
        codePoint = this.consumeCodePoint();
        questionMarks = true;
      }
      if (questionMarks) {
        var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? ZERO : digit;
        })), 16);
        var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
          return digit === QUESTION_MARK ? F : digit;
        })), 16);
        return { type: 30, start: start_1, end };
      }
      var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
      if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
        this.consumeCodePoint();
        codePoint = this.consumeCodePoint();
        var endDigits = [];
        while (isHex(codePoint) && endDigits.length < 6) {
          endDigits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
        return { type: 30, start, end };
      } else {
        return { type: 30, start, end: start };
      }
    };
    Tokenizer2.prototype.consumeIdentLikeToken = function() {
      var value = this.consumeName();
      if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return this.consumeUrlToken();
      } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
        this.consumeCodePoint();
        return { type: 19, value };
      }
      return { type: 20, value };
    };
    Tokenizer2.prototype.consumeUrlToken = function() {
      var value = [];
      this.consumeWhiteSpace();
      if (this.peekCodePoint(0) === EOF) {
        return { type: 22, value: "" };
      }
      var next = this.peekCodePoint(0);
      if (next === APOSTROPHE || next === QUOTATION_MARK) {
        var stringToken = this.consumeStringToken(this.consumeCodePoint());
        if (stringToken.type === 0) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: stringToken.value };
          }
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      }
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        } else if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
            this.consumeCodePoint();
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        } else if (codePoint === REVERSE_SOLIDUS) {
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            value.push(this.consumeEscapedCodePoint());
          } else {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          }
        } else {
          value.push(codePoint);
        }
      }
    };
    Tokenizer2.prototype.consumeWhiteSpace = function() {
      while (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
    };
    Tokenizer2.prototype.consumeBadUrlRemnants = function() {
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
          return;
        }
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.consumeEscapedCodePoint();
        }
      }
    };
    Tokenizer2.prototype.consumeStringSlice = function(count) {
      var SLICE_STACK_SIZE = 5e4;
      var value = "";
      while (count > 0) {
        var amount = Math.min(SLICE_STACK_SIZE, count);
        value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
        count -= amount;
      }
      this._value.shift();
      return value;
    };
    Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
      var value = "";
      var i2 = 0;
      do {
        var codePoint = this._value[i2];
        if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
          value += this.consumeStringSlice(i2);
          return { type: 0, value };
        }
        if (codePoint === LINE_FEED) {
          this._value.splice(0, i2);
          return BAD_STRING_TOKEN;
        }
        if (codePoint === REVERSE_SOLIDUS) {
          var next = this._value[i2 + 1];
          if (next !== EOF && next !== void 0) {
            if (next === LINE_FEED) {
              value += this.consumeStringSlice(i2);
              i2 = -1;
              this._value.shift();
            } else if (isValidEscape(codePoint, next)) {
              value += this.consumeStringSlice(i2);
              value += fromCodePoint$1(this.consumeEscapedCodePoint());
              i2 = -1;
            }
          }
        }
        i2++;
      } while (true);
    };
    Tokenizer2.prototype.consumeNumber = function() {
      var repr = [];
      var type = FLAG_INTEGER;
      var c1 = this.peekCodePoint(0);
      if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
        repr.push(this.consumeCodePoint());
      }
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
      c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      if (c1 === FULL_STOP && isDigit(c2)) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      c1 = this.peekCodePoint(0);
      c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if ((c1 === E || c1 === e$1) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
        repr.push(this.consumeCodePoint(), this.consumeCodePoint());
        type = FLAG_NUMBER;
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
      }
      return [stringToNumber(repr), type];
    };
    Tokenizer2.prototype.consumeNumericToken = function() {
      var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
      var c1 = this.peekCodePoint(0);
      var c2 = this.peekCodePoint(1);
      var c3 = this.peekCodePoint(2);
      if (isIdentifierStart(c1, c2, c3)) {
        var unit = this.consumeName();
        return { type: 15, number, flags, unit };
      }
      if (c1 === PERCENTAGE_SIGN) {
        this.consumeCodePoint();
        return { type: 16, number, flags };
      }
      return { type: 17, number, flags };
    };
    Tokenizer2.prototype.consumeEscapedCodePoint = function() {
      var codePoint = this.consumeCodePoint();
      if (isHex(codePoint)) {
        var hex = fromCodePoint$1(codePoint);
        while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
          hex += fromCodePoint$1(this.consumeCodePoint());
        }
        if (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
        var hexCodePoint = parseInt(hex, 16);
        if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
          return REPLACEMENT_CHARACTER;
        }
        return hexCodePoint;
      }
      if (codePoint === EOF) {
        return REPLACEMENT_CHARACTER;
      }
      return codePoint;
    };
    Tokenizer2.prototype.consumeName = function() {
      var result = "";
      while (true) {
        var codePoint = this.consumeCodePoint();
        if (isNameCodePoint(codePoint)) {
          result += fromCodePoint$1(codePoint);
        } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          result += fromCodePoint$1(this.consumeEscapedCodePoint());
        } else {
          this.reconsumeCodePoint(codePoint);
          return result;
        }
      }
    };
    return Tokenizer2;
  })()
);
var Parser$1 = (
  /** @class */
  (function() {
    function Parser2(tokens) {
      this._tokens = tokens;
    }
    Parser2.create = function(value) {
      var tokenizer = new Tokenizer();
      tokenizer.write(value);
      return new Parser2(tokenizer.read());
    };
    Parser2.parseValue = function(value) {
      return Parser2.create(value).parseComponentValue();
    };
    Parser2.parseValues = function(value) {
      return Parser2.create(value).parseComponentValues();
    };
    Parser2.prototype.parseComponentValue = function() {
      var token = this.consumeToken();
      while (token.type === 31) {
        token = this.consumeToken();
      }
      if (token.type === 32) {
        throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
      }
      this.reconsumeToken(token);
      var value = this.consumeComponentValue();
      do {
        token = this.consumeToken();
      } while (token.type === 31);
      if (token.type === 32) {
        return value;
      }
      throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
    };
    Parser2.prototype.parseComponentValues = function() {
      var values = [];
      while (true) {
        var value = this.consumeComponentValue();
        if (value.type === 32) {
          return values;
        }
        values.push(value);
        values.push();
      }
    };
    Parser2.prototype.consumeComponentValue = function() {
      var token = this.consumeToken();
      switch (token.type) {
        case 11:
        case 28:
        case 2:
          return this.consumeSimpleBlock(token.type);
        case 19:
          return this.consumeFunction(token);
      }
      return token;
    };
    Parser2.prototype.consumeSimpleBlock = function(type) {
      var block = { type, values: [] };
      var token = this.consumeToken();
      while (true) {
        if (token.type === 32 || isEndingTokenFor(token, type)) {
          return block;
        }
        this.reconsumeToken(token);
        block.values.push(this.consumeComponentValue());
        token = this.consumeToken();
      }
    };
    Parser2.prototype.consumeFunction = function(functionToken) {
      var cssFunction = {
        name: functionToken.value,
        values: [],
        type: 18
        /* FUNCTION */
      };
      while (true) {
        var token = this.consumeToken();
        if (token.type === 32 || token.type === 3) {
          return cssFunction;
        }
        this.reconsumeToken(token);
        cssFunction.values.push(this.consumeComponentValue());
      }
    };
    Parser2.prototype.consumeToken = function() {
      var token = this._tokens.shift();
      return typeof token === "undefined" ? EOF_TOKEN : token;
    };
    Parser2.prototype.reconsumeToken = function(token) {
      this._tokens.unshift(token);
    };
    return Parser2;
  })()
);
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isStringToken = function(token) {
  return token.type === 0;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonWhiteSpace = function(token) {
  return token.type !== 31;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width, height) {
  var x2 = tuple[0], y2 = tuple[1];
  return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      // TODO use correct font-size
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
      }
      if (value.value.length === 4) {
        var r2 = value.value.substring(0, 1);
        var g2 = value.value.substring(1, 2);
        var b2 = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
      }
      if (value.value.length === 8) {
        var r2 = value.value.substring(0, 2);
        var g2 = value.value.substring(2, 4);
        var b2 = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r2, g2, b2, a2) {
  return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i2) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max = i2 === 3 ? 1 : 255;
    return i2 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
    return pack(r2, g2, b2, 1);
  }
  if (tokens.length === 4) {
    var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
    return pack(r2, g2, b2, a2);
  }
  return 0;
};
function hue2rgb(t1, t22, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t22 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t22;
  } else if (hue < 2 / 3) {
    return (t22 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s2 === 0) {
    return pack(l2 * 255, l2 * 255, l2 * 255, 1);
  }
  var t22 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
  var t1 = l2 * 2 - t22;
  var r2 = hue2rgb(t1, t22, h2 + 1 / 3);
  var g2 = hue2rgb(t1, t22, h2);
  var b2 = hue2rgb(t1, t22, h2 - 1 / 3);
  return pack(r2 * 255, g2 * 255, b2 * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1.parse(context, Parser$1.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i2 = 0; i2 < stops.length; i2++) {
    var stop_1 = stops[i2].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i2 = 0; i2 < processStops.length; i2++) {
    var stop_2 = processStops[i2];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i2;
      }
    } else if (gapBegin !== null) {
      var gapLength = i2 - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g2 = 1; g2 <= gapLength; g2++) {
        processStops[gapBegin + g2 - 1] = gapValue * g2;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i3) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width, height) {
  var centerX = width / 2;
  var centerY = height / 2;
  var x2 = getAbsoluteValue(corner[0], width) - centerX;
  var y2 = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b2) {
  return Math.sqrt(a2 * a2 + b2 * b2);
};
var findCorner = function(width, height, x2, y2, closest) {
  var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d2 = distance(x2 - cx, y2 - cy);
    if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d2
      };
    }
    return stat;
  }, {
    optimumDistance: closest ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x2, y2, width, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
        var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
        ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
      } else if (gradient.shape === 1) {
        var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
        var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
        rx = distance(cx - x2, (cy - y2) / c2);
        ry = c2 * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    if (i2 === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
    /* LINEAR_GRADIENT */
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var firstToken = arg[0];
    if (i2 === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values = firstToken.values.filter(nonFunctionArgSeparator);
        if (values.length === 2) {
          var color2 = color$1.parse(context, values[1]);
          var stop_1 = values[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var prefixRadialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i2) {
    var isColorStop = true;
    if (i2 === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i2 === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return {
    size,
    shape,
    stops,
    position: position2,
    type: 2
    /* RADIAL_GRADIENT */
  };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = {
        url: value.value,
        type: 0
        /* URL */
      };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style) {
      switch (style) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(
      function(bit, token) {
        return bit | parseDisplayValue(token.value);
      },
      0
      /* NONE */
    );
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
  /* TOKEN_VALUE */
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image.parse(context, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values.length; i2++) {
        var token = values[i2];
        if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values.length === 6 ? values : null;
};
var matrix3d = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values[0], b1 = values[1];
  values[2];
  values[3];
  var a2 = values[4], b2 = values[5];
  values[6];
  values[7];
  values[8];
  values[9];
  values[10];
  values[11];
  var a4 = values[12], b4 = values[13];
  values[14];
  values[15];
  return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line) {
      return line !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter = filtered[i2];
      var next = filtered[i2 + 1];
      if (counter.type === 20) {
        var increment = next && isNumberToken(next) ? next.number : 1;
        increments.push({ counter: counter.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i2 = 0; i2 < filtered.length; i2++) {
      var counter = filtered[i2];
      var next = filtered[i2 + 1];
      if (isIdentToken(counter) && counter.value !== "none") {
        var reset = next && isNumberToken(next) ? next.number : 0;
        resets.push({ counter: counter.value, reset });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token) {
      return time.parse(context, token);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i2 = 0; i2 < filtered.length; i2 += 2) {
      var open_1 = filtered[i2].value;
      var close_1 = filtered[i2 + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open2) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open2 ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c2 = 0;
      for (var i2 = 0; i2 < values.length; i2++) {
        var token = values[i2];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c2 === 0) {
            shadow.offsetX = token;
          } else if (c2 === 1) {
            shadow.offsetY = token;
          } else if (c2 === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c2++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [
      0,
      1,
      2
      /* MARKERS */
    ];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(
            1
            /* STROKE */
          );
          break;
        case "fill":
          layers.push(
            0
            /* FILL */
          );
          break;
        case "markers":
          layers.push(
            2
            /* MARKERS */
          );
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = (
  /** @class */
  (function() {
    function CSSParsedDeclaration2(context, declaration) {
      var _a2, _b2;
      this.animationDuration = parse(context, duration, declaration.animationDuration);
      this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
      this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
      this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
      this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
      this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
      this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
      this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
      this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
      this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
      this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
      this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
      this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
      this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
      this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
      this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
      this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
      this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
      this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
      this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
      this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
      this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
      this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
      this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
      this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
      this.color = parse(context, color, declaration.color);
      this.direction = parse(context, direction, declaration.direction);
      this.display = parse(context, display, declaration.display);
      this.float = parse(context, float, declaration.cssFloat);
      this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
      this.fontSize = parse(context, fontSize, declaration.fontSize);
      this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
      this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
      this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
      this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
      this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
      this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
      this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
      this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
      this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
      this.marginTop = parse(context, marginTop, declaration.marginTop);
      this.marginRight = parse(context, marginRight, declaration.marginRight);
      this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
      this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
      this.opacity = parse(context, opacity, declaration.opacity);
      var overflowTuple = parse(context, overflow, declaration.overflow);
      this.overflowX = overflowTuple[0];
      this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
      this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
      this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
      this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
      this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
      this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
      this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
      this.position = parse(context, position, declaration.position);
      this.textAlign = parse(context, textAlign, declaration.textAlign);
      this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
      this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
      this.textShadow = parse(context, textShadow, declaration.textShadow);
      this.textTransform = parse(context, textTransform, declaration.textTransform);
      this.transform = parse(context, transform$1, declaration.transform);
      this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
      this.visibility = parse(context, visibility, declaration.visibility);
      this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
      this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
      this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
      this.zIndex = parse(context, zIndex, declaration.zIndex);
    }
    CSSParsedDeclaration2.prototype.isVisible = function() {
      return this.display > 0 && this.opacity > 0 && this.visibility === 0;
    };
    CSSParsedDeclaration2.prototype.isTransparent = function() {
      return isTransparent(this.backgroundColor);
    };
    CSSParsedDeclaration2.prototype.isTransformed = function() {
      return this.transform !== null;
    };
    CSSParsedDeclaration2.prototype.isPositioned = function() {
      return this.position !== 0;
    };
    CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
      return this.isPositioned() && !this.zIndex.auto;
    };
    CSSParsedDeclaration2.prototype.isFloating = function() {
      return this.float !== 0;
    };
    CSSParsedDeclaration2.prototype.isInlineLevel = function() {
      return contains(
        this.display,
        4
        /* INLINE */
      ) || contains(
        this.display,
        33554432
        /* INLINE_BLOCK */
      ) || contains(
        this.display,
        268435456
        /* INLINE_FLEX */
      ) || contains(
        this.display,
        536870912
        /* INLINE_GRID */
      ) || contains(
        this.display,
        67108864
        /* INLINE_LIST_ITEM */
      ) || contains(
        this.display,
        134217728
        /* INLINE_TABLE */
      );
    };
    return CSSParsedDeclaration2;
  })()
);
var CSSParsedPseudoDeclaration = (
  /** @class */
  /* @__PURE__ */ (function() {
    function CSSParsedPseudoDeclaration2(context, declaration) {
      this.content = parse(context, content, declaration.content);
      this.quotes = parse(context, quotes, declaration.quotes);
    }
    return CSSParsedPseudoDeclaration2;
  })()
);
var CSSParsedCounterDeclaration = (
  /** @class */
  /* @__PURE__ */ (function() {
    function CSSParsedCounterDeclaration2(context, declaration) {
      this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
      this.counterReset = parse(context, counterReset, declaration.counterReset);
    }
    return CSSParsedCounterDeclaration2;
  })()
);
var parse = function(context, descriptor, style) {
  var tokenizer = new Tokenizer();
  var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser$1(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser.parseComponentValue());
        case "color":
          return color$1.parse(context, parser.parseComponentValue());
        case "image":
          return image.parse(context, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ElementContainer2(context, element) {
      this.context = context;
      this.textNodes = [];
      this.elements = [];
      this.flags = 0;
      if (isDebugging(
        element,
        3
        /* PARSE */
      )) {
        debugger;
      }
      this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
      if (isHTMLElementNode(element)) {
        if (this.styles.animationDuration.some(function(duration2) {
          return duration2 > 0;
        })) {
          element.style.animationDuration = "0s";
        }
        if (this.styles.transform !== null) {
          element.style.transform = "none";
        }
      }
      this.bounds = parseBounds(this.context, element);
      if (isDebugging(
        element,
        4
        /* RENDER */
      )) {
        this.flags |= 16;
      }
    }
    return ElementContainer2;
  })()
);
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  lookup$1[chars$1.charCodeAt(i$1)] = i$1;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i2)];
    encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
    bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 2) {
    bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var polyUint32Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i2 = 0; i2 < length; i2 += 4) {
    bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer = decode(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie = (
  /** @class */
  (function() {
    function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
      this.initialValue = initialValue;
      this.errorValue = errorValue;
      this.highStart = highStart;
      this.highValueIndex = highValueIndex;
      this.index = index2;
      this.data = data;
    }
    Trie2.prototype.get = function(codePoint) {
      var ix;
      if (codePoint >= 0) {
        if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
          ix = this.index[codePoint >> UTRIE2_SHIFT_2];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 65535) {
          ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint < this.highStart) {
          ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
          ix = this.index[ix];
          ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
          ix = this.index[ix];
          ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
          return this.data[ix];
        }
        if (codePoint <= 1114111) {
          return this.data[this.highValueIndex];
        }
      }
      return this.errorValue;
    };
    return Trie2;
  })()
);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$4 = 0; i$4 < chars.length; i$4++) {
  lookup[chars.charCodeAt(i$4)] = i$4;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L = 8;
var V = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i2 = 0;
  var length = str.length;
  while (i2 < length) {
    var value = str.charCodeAt(i2++);
    if (value >= 55296 && value <= 56319 && i2 < length) {
      var extra = str.charCodeAt(i2++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i2--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "Ã";
var BREAK_ALLOWED = "Ã·";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next = classTypes[index2];
  if (current === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V) && (next === V || next === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T$1) && next === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node2 = testElement.firstChild;
  var textList = toCodePoints$1(node2.data).map(function(i2) {
    return fromCodePoint$1(i2);
  });
  var offset = 0;
  var prev = {};
  var supports = textList.every(function(text2, i2) {
    range.setStart(node2, offset);
    range.setEnd(node2, offset + text2.length);
    var rect = range.getBoundingClientRect();
    offset += text2.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i2 === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg2 = createForeignObjectSVG(size, size, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg2).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    var node2 = document2.createElement("div");
    node2.style.backgroundImage = "url(" + greenImageSrc + ")";
    node2.style.height = size + "px";
    return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width, height, x2, y2, node2) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg2 = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg2.setAttributeNS(null, "width", width.toString());
  svg2.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x2.toString());
  foreignObject.setAttributeNS(null, "y", y2.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg2.appendChild(foreignObject);
  foreignObject.appendChild(node2);
  return svg2;
};
var loadSerializedSVG$1 = function(svg2) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TextBounds2(text2, bounds) {
      this.text = text2;
      this.bounds = bounds;
    }
    return TextBounds2;
  })()
);
var parseTextBounds = function(context, value, styles, node2) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset = 0;
  textList.forEach(function(text2) {
    if (styles.textDecorationLine.length || text2.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node2, offset, text2.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text2);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node2.splitText(text2.length);
        textBounds.push(new TextBounds(text2, getWrapperBounds(context, node2)));
        node2 = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node2 = node2.splitText(text2.length);
    }
    offset += text2.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node2) {
  var ownerDocument = node2.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node2.cloneNode(true));
    var parentNode = node2.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node2);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node2, offset, length) {
  var ownerDocument = node2.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node2, offset);
  range.setEnd(node2, offset + length);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value = bk.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TextContainer2(context, node2, styles) {
      this.text = transform(node2.data, styles.textTransform);
      this.textBounds = parseTextBounds(context, this.text, styles, node2);
    }
    return TextContainer2;
  })()
);
var transform = function(text2, transform2) {
  switch (transform2) {
    case 1:
      return text2.toLowerCase();
    case 3:
      return text2.replace(CAPITALIZE, capitalize);
    case 2:
      return text2.toUpperCase();
    default:
      return text2;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m2, p1, p2) {
  if (m2.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m2;
};
var ImageElementContainer = (
  /** @class */
  (function(_super) {
    __extends(ImageElementContainer2, _super);
    function ImageElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      _this.src = img.currentSrc || img.src;
      _this.intrinsicWidth = img.naturalWidth;
      _this.intrinsicHeight = img.naturalHeight;
      _this.context.cache.addImage(_this.src);
      return _this;
    }
    return ImageElementContainer2;
  })(ElementContainer)
);
var CanvasElementContainer = (
  /** @class */
  (function(_super) {
    __extends(CanvasElementContainer2, _super);
    function CanvasElementContainer2(context, canvas) {
      var _this = _super.call(this, context, canvas) || this;
      _this.canvas = canvas;
      _this.intrinsicWidth = canvas.width;
      _this.intrinsicHeight = canvas.height;
      return _this;
    }
    return CanvasElementContainer2;
  })(ElementContainer)
);
var SVGElementContainer = (
  /** @class */
  (function(_super) {
    __extends(SVGElementContainer2, _super);
    function SVGElementContainer2(context, img) {
      var _this = _super.call(this, context, img) || this;
      var s2 = new XMLSerializer();
      var bounds = parseBounds(context, img);
      img.setAttribute("width", bounds.width + "px");
      img.setAttribute("height", bounds.height + "px");
      _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
      _this.intrinsicWidth = img.width.baseVal.value;
      _this.intrinsicHeight = img.height.baseVal.value;
      _this.context.cache.addImage(_this.svg);
      return _this;
    }
    return SVGElementContainer2;
  })(ElementContainer)
);
var LIElementContainer = (
  /** @class */
  (function(_super) {
    __extends(LIElementContainer2, _super);
    function LIElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return LIElementContainer2;
  })(ElementContainer)
);
var OLElementContainer = (
  /** @class */
  (function(_super) {
    __extends(OLElementContainer2, _super);
    function OLElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.start = element.start;
      _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
      return _this;
    }
    return OLElementContainer2;
  })(ElementContainer)
);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node2) {
  var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("â¢") : node2.value;
  return value.length === 0 ? node2.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = (
  /** @class */
  (function(_super) {
    __extends(InputElementContainer2, _super);
    function InputElementContainer2(context, input) {
      var _this = _super.call(this, context, input) || this;
      _this.type = input.type.toLowerCase();
      _this.checked = input.checked;
      _this.value = getInputValue(input);
      if (_this.type === CHECKBOX || _this.type === RADIO) {
        _this.styles.backgroundColor = 3739148031;
        _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
        _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
        _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
        _this.styles.backgroundClip = [
          0
          /* BORDER_BOX */
        ];
        _this.styles.backgroundOrigin = [
          0
          /* BORDER_BOX */
        ];
        _this.bounds = reformatInputBounds(_this.bounds);
      }
      switch (_this.type) {
        case CHECKBOX:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
          break;
        case RADIO:
          _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
          break;
      }
      return _this;
    }
    return InputElementContainer2;
  })(ElementContainer)
);
var SelectElementContainer = (
  /** @class */
  (function(_super) {
    __extends(SelectElementContainer2, _super);
    function SelectElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      var option = element.options[element.selectedIndex || 0];
      _this.value = option ? option.text || "" : "";
      return _this;
    }
    return SelectElementContainer2;
  })(ElementContainer)
);
var TextareaElementContainer = (
  /** @class */
  (function(_super) {
    __extends(TextareaElementContainer2, _super);
    function TextareaElementContainer2(context, element) {
      var _this = _super.call(this, context, element) || this;
      _this.value = element.value;
      return _this;
    }
    return TextareaElementContainer2;
  })(ElementContainer)
);
var IFrameElementContainer = (
  /** @class */
  (function(_super) {
    __extends(IFrameElementContainer2, _super);
    function IFrameElementContainer2(context, iframe) {
      var _this = _super.call(this, context, iframe) || this;
      _this.src = iframe.src;
      _this.width = parseInt(iframe.width, 10) || 0;
      _this.height = parseInt(iframe.height, 10) || 0;
      _this.backgroundColor = _this.styles.backgroundColor;
      try {
        if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
          _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
          var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
          var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
          _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
        }
      } catch (e2) {
      }
      return _this;
    }
    return IFrameElementContainer2;
  })(ElementContainer)
);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node2, parent, root) {
  for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node2, container, root) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node2) {
  return node2.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node2) {
  return node2.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node2) {
  return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node2) {
  return node2.tagName === "LI";
};
var isOLElement = function(node2) {
  return node2.tagName === "OL";
};
var isInputElement = function(node2) {
  return node2.tagName === "INPUT";
};
var isHTMLElement = function(node2) {
  return node2.tagName === "HTML";
};
var isSVGElement = function(node2) {
  return node2.tagName === "svg";
};
var isBodyElement = function(node2) {
  return node2.tagName === "BODY";
};
var isCanvasElement = function(node2) {
  return node2.tagName === "CANVAS";
};
var isVideoElement = function(node2) {
  return node2.tagName === "VIDEO";
};
var isImageElement = function(node2) {
  return node2.tagName === "IMG";
};
var isIFrameElement = function(node2) {
  return node2.tagName === "IFRAME";
};
var isStyleElement = function(node2) {
  return node2.tagName === "STYLE";
};
var isScriptElement = function(node2) {
  return node2.tagName === "SCRIPT";
};
var isTextareaElement = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var isSelectElement = function(node2) {
  return node2.tagName === "SELECT";
};
var isSlotElement = function(node2) {
  return node2.tagName === "SLOT";
};
var isCustomElement = function(node2) {
  return node2.tagName.indexOf("-") > 0;
};
var CounterState = (
  /** @class */
  (function() {
    function CounterState2() {
      this.counters = {};
    }
    CounterState2.prototype.getCounterValue = function(name) {
      var counter = this.counters[name];
      if (counter && counter.length) {
        return counter[counter.length - 1];
      }
      return 1;
    };
    CounterState2.prototype.getCounterValues = function(name) {
      var counter = this.counters[name];
      return counter ? counter : [];
    };
    CounterState2.prototype.pop = function(counters) {
      var _this = this;
      counters.forEach(function(counter) {
        return _this.counters[counter].pop();
      });
    };
    CounterState2.prototype.parse = function(style) {
      var _this = this;
      var counterIncrement2 = style.counterIncrement;
      var counterReset2 = style.counterReset;
      var canReset = true;
      if (counterIncrement2 !== null) {
        counterIncrement2.forEach(function(entry) {
          var counter = _this.counters[entry.counter];
          if (counter && entry.increment !== 0) {
            canReset = false;
            if (!counter.length) {
              counter.push(1);
            }
            counter[Math.max(0, counter.length - 1)] += entry.increment;
          }
        });
      }
      var counterNames = [];
      if (canReset) {
        counterReset2.forEach(function(entry) {
          var counter = _this.counters[entry.counter];
          counterNames.push(entry.counter);
          if (!counter) {
            counter = _this.counters[entry.counter] = [];
          }
          counter.push(entry.reset);
        });
      }
      return counterNames;
    };
    return CounterState2;
  })()
);
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Õ",
    "Ô¿",
    "Ô¾",
    "Ô½",
    "Ô¼",
    "Ô»",
    "Ôº",
    "Ô¹",
    "Ô¸",
    "Ô·",
    "Ô¶",
    "Ôµ",
    "Ô´",
    "Ô³",
    "Ô²",
    "Ô±"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "××³",
    "×ª",
    "×©",
    "×¨",
    "×§",
    "×¦",
    "×¤",
    "×¢",
    "×¡",
    "× ",
    "×",
    "×",
    "×",
    "××",
    "××",
    "××",
    "××",
    "××",
    "×",
    "×",
    "×",
    "×",
    "×",
    "×",
    "×",
    "×",
    "×",
    "×"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "áµ",
    "á°",
    "á¯",
    "á´",
    "á®",
    "á­",
    "á¬",
    "á«",
    "áª",
    "á©",
    "á¨",
    "á§",
    "á¦",
    "á¥",
    "á¤",
    "á³",
    "á¢",
    "á¡",
    "á ",
    "á",
    "á",
    "á",
    "á²",
    "á",
    "á",
    "á",
    "á",
    "á",
    "á",
    "á±",
    "á",
    "á",
    "á",
    "á",
    "á",
    "á",
    "á"
  ]
};
var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
  if (value < min || value > max) {
    return createCounterText(value, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index2];
    }
    return string;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix.length > 0);
  }
  var tmp = Math.abs(value);
  var string = suffix;
  if (tmp === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "åç¾åè¬";
var CHINESE_FORMAL_MULTIPLIERS = "æ¾ä½°ä»è¬";
var JAPANESE_NEGATIVE = "ãã¤ãã¹";
var KOREAN_NEGATIVE = "ë§ì´ëì¤";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "ã" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "â¢" + spaceSuffix;
    case 1:
      return "â¦" + spaceSuffix;
    case 2:
      return "â¾" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value, "ãä¸äºä¸åäºå­ä¸å«ä¹", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "å­ä¸å¯å¯è¾°å·³åæªç³éæäº¥", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "ç²ä¹ä¸ä¸æå·±åºè¾å£¬ç¸", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "é¶ä¸äºä¸åäºå­ä¸å«ä¹", CHINESE_INFORMAL_MULTIPLIERS, "è² ", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "é¶å£¹è²³åèä¼é¸ææç", CHINESE_FORMAL_MULTIPLIERS, "è² ", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "é¶ä¸äºä¸åäºå­ä¸å«ä¹", CHINESE_INFORMAL_MULTIPLIERS, "è´", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "é¶å£¹è´°åèä¼éææç", CHINESE_FORMAL_MULTIPLIERS, "è´", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "ãä¸äºä¸åäºå­ä¸å«ä¹", "åç¾åä¸", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "é¶å£±å¼ååä¼å­ä¸å«ä¹", "æ¾ç¾åä¸", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "ìì¼ì´ì¼ì¬ì¤ì¡ì¹ íêµ¬", "ì­ë°±ì²ë§", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "é¶ä¸äºä¸åäºå­ä¸å«ä¹", "åç¾åè¬", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "é¶å£¹è²³ååäºå­ä¸å«ä¹", "æ¾ç¾å", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "ããããããããããããããããã¡ã¤ã¦ã¨ãªã«ã¬ã­ã®ã¯ã²ãµã¸ã»ã¾ã¿ãããããããããããããããã");
    case 24:
      return createCounterStyleFromSymbols(value, "ããã¯ã«ã»ã¸ã¨ã¡ãã¬ããããããããã¤ã­ãªããããã®ãããã¾ããµããã¦ãããããã¿ããã²ããã");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "ã¢ã¤ã¦ã¨ãªã«ã­ã¯ã±ã³ãµã·ã¹ã»ã½ã¿ããããããããããããããããã ã¡ã¢ã¤ã¦ã¨ã©ãªã«ã¬ã­ã¯ã°ã±ã²ã³", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "ã¤ã­ãããããããªãã«ã²ã¯ã«ã¨ã¿ã¬ã½ãããã©ã ã¦ã°ããªã¯ã¤ãã±ãã³ã¨ãã¢ãµã­ã¦ã¡ãã·ã±ãã¢ã»ã¹", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = (
  /** @class */
  (function() {
    function DocumentCloner2(context, element, options) {
      this.context = context;
      this.options = options;
      this.scrolledElements = [];
      this.referenceElement = element;
      this.counters = new CounterState();
      this.quoteDepth = 0;
      if (!element.ownerDocument) {
        throw new Error("Cloned element does not have an owner document");
      }
      this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
    }
    DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
      var _this = this;
      var iframe = createIFrameContainer(ownerDocument, windowSize);
      if (!iframe.contentWindow) {
        return Promise.reject("Unable to find iframe window");
      }
      var scrollX = ownerDocument.defaultView.pageXOffset;
      var scrollY = ownerDocument.defaultView.pageYOffset;
      var cloneWindow = iframe.contentWindow;
      var documentClone = cloneWindow.document;
      var iframeLoad = iframeLoader(iframe).then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var onclone, referenceElement;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                  cloneWindow.scrollTo(windowSize.left, windowSize.top);
                  if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                    this.context.logger.warn("Unable to restore scroll position for cloned document");
                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                  }
                }
                onclone = this.options.onclone;
                referenceElement = this.clonedReferenceElement;
                if (typeof referenceElement === "undefined") {
                  return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                }
                if (!(documentClone.fonts && documentClone.fonts.ready)) return [3, 2];
                return [4, documentClone.fonts.ready];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3, 4];
                return [4, imagesReady(documentClone)];
              case 3:
                _a2.sent();
                _a2.label = 4;
              case 4:
                if (typeof onclone === "function") {
                  return [2, Promise.resolve().then(function() {
                    return onclone(documentClone, referenceElement);
                  }).then(function() {
                    return iframe;
                  })];
                }
                return [2, iframe];
            }
          });
        });
      });
      documentClone.open();
      documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
      restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
      documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
      documentClone.close();
      return iframeLoad;
    };
    DocumentCloner2.prototype.createElementClone = function(node2) {
      if (isDebugging(
        node2,
        2
        /* CLONE */
      )) {
        debugger;
      }
      if (isCanvasElement(node2)) {
        return this.createCanvasClone(node2);
      }
      if (isVideoElement(node2)) {
        return this.createVideoClone(node2);
      }
      if (isStyleElement(node2)) {
        return this.createStyleClone(node2);
      }
      var clone2 = node2.cloneNode(false);
      if (isImageElement(clone2)) {
        if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
          clone2.src = node2.currentSrc;
          clone2.srcset = "";
        }
        if (clone2.loading === "lazy") {
          clone2.loading = "eager";
        }
      }
      if (isCustomElement(clone2)) {
        return this.createCustomElementClone(clone2);
      }
      return clone2;
    };
    DocumentCloner2.prototype.createCustomElementClone = function(node2) {
      var clone2 = document.createElement("html2canvascustomelement");
      copyCSSStyles(node2.style, clone2);
      return clone2;
    };
    DocumentCloner2.prototype.createStyleClone = function(node2) {
      try {
        var sheet = node2.sheet;
        if (sheet && sheet.cssRules) {
          var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
            if (rule && typeof rule.cssText === "string") {
              return css2 + rule.cssText;
            }
            return css2;
          }, "");
          var style = node2.cloneNode(false);
          style.textContent = css;
          return style;
        }
      } catch (e2) {
        this.context.logger.error("Unable to access cssRules property", e2);
        if (e2.name !== "SecurityError") {
          throw e2;
        }
      }
      return node2.cloneNode(false);
    };
    DocumentCloner2.prototype.createCanvasClone = function(canvas) {
      var _a2;
      if (this.options.inlineImages && canvas.ownerDocument) {
        var img = canvas.ownerDocument.createElement("img");
        try {
          img.src = canvas.toDataURL();
          return img;
        } catch (e2) {
          this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
        }
      }
      var clonedCanvas = canvas.cloneNode(false);
      try {
        clonedCanvas.width = canvas.width;
        clonedCanvas.height = canvas.height;
        var ctx = canvas.getContext("2d");
        var clonedCtx = clonedCanvas.getContext("2d");
        if (clonedCtx) {
          if (!this.options.allowTaint && ctx) {
            clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
          } else {
            var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
            if (gl) {
              var attribs = gl.getContextAttributes();
              if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
              }
            }
            clonedCtx.drawImage(canvas, 0, 0);
          }
        }
        return clonedCanvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
      }
      return clonedCanvas;
    };
    DocumentCloner2.prototype.createVideoClone = function(video) {
      var canvas = video.ownerDocument.createElement("canvas");
      canvas.width = video.offsetWidth;
      canvas.height = video.offsetHeight;
      var ctx = canvas.getContext("2d");
      try {
        if (ctx) {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
          if (!this.options.allowTaint) {
            ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
        }
        return canvas;
      } catch (e2) {
        this.context.logger.info("Unable to clone video as it is tainted", video);
      }
      var blankCanvas = video.ownerDocument.createElement("canvas");
      blankCanvas.width = video.offsetWidth;
      blankCanvas.height = video.offsetHeight;
      return blankCanvas;
    };
    DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
      if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
        if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
          clone2.appendChild(this.cloneNode(child, copyStyles));
        }
      }
    };
    DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
      var _this = this;
      for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
        if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
          var assignedNodes = child.assignedNodes();
          if (assignedNodes.length) {
            assignedNodes.forEach(function(assignedNode) {
              return _this.appendChildNode(clone2, assignedNode, copyStyles);
            });
          }
        } else {
          this.appendChildNode(clone2, child, copyStyles);
        }
      }
    };
    DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
      if (isTextNode(node2)) {
        return document.createTextNode(node2.data);
      }
      if (!node2.ownerDocument) {
        return node2.cloneNode(false);
      }
      var window2 = node2.ownerDocument.defaultView;
      if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
        var clone2 = this.createElementClone(node2);
        clone2.style.transitionProperty = "none";
        var style = window2.getComputedStyle(node2);
        var styleBefore = window2.getComputedStyle(node2, ":before");
        var styleAfter = window2.getComputedStyle(node2, ":after");
        if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
          this.clonedReferenceElement = clone2;
        }
        if (isBodyElement(clone2)) {
          createPseudoHideStyles(clone2);
        }
        var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
        if (isCustomElement(node2)) {
          copyStyles = true;
        }
        if (!isVideoElement(node2)) {
          this.cloneChildNodes(node2, clone2, copyStyles);
        }
        if (before) {
          clone2.insertBefore(before, clone2.firstChild);
        }
        var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
        if (after) {
          clone2.appendChild(after);
        }
        this.counters.pop(counters);
        if (style && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
          copyCSSStyles(style, clone2);
        }
        if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
          this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
        }
        if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
          clone2.value = node2.value;
        }
        return clone2;
      }
      return node2.cloneNode(false);
    };
    DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style, pseudoElt) {
      var _this = this;
      if (!style) {
        return;
      }
      var value = style.content;
      var document2 = clone2.ownerDocument;
      if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
        return;
      }
      this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
      var declaration = new CSSParsedPseudoDeclaration(this.context, style);
      var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
      copyCSSStyles(style, anonymousReplacedElement);
      declaration.content.forEach(function(token) {
        if (token.type === 0) {
          anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
        } else if (token.type === 22) {
          var img = document2.createElement("img");
          img.src = token.value;
          img.style.opacity = "1";
          anonymousReplacedElement.appendChild(img);
        } else if (token.type === 18) {
          if (token.name === "attr") {
            var attr = token.values.filter(isIdentToken);
            if (attr.length) {
              anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
            }
          } else if (token.name === "counter") {
            var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
            if (counter && isIdentToken(counter)) {
              var counterState = _this.counters.getCounterValue(counter.value);
              var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
            }
          } else if (token.name === "counters") {
            var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
            if (counter && isIdentToken(counter)) {
              var counterStates = _this.counters.getCounterValues(counter.value);
              var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
              var separator = delim && delim.type === 0 ? delim.value : "";
              var text2 = counterStates.map(function(value2) {
                return createCounterText(value2, counterType_1, false);
              }).join(separator);
              anonymousReplacedElement.appendChild(document2.createTextNode(text2));
            }
          } else ;
        } else if (token.type === 20) {
          switch (token.value) {
            case "open-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
              break;
            case "close-quote":
              anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
              break;
            default:
              anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
          }
        }
      });
      anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
      if (isSVGElementNode(clone2)) {
        clone2.className.baseValue += newClassName;
      } else {
        clone2.className += newClassName;
      }
      return anonymousReplacedElement;
    };
    DocumentCloner2.destroy = function(container) {
      if (container.parentNode) {
        container.parentNode.removeChild(container);
        return true;
      }
      return false;
    };
    return DocumentCloner2;
  })()
);
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve) {
    if (img.complete) {
      resolve();
      return;
    }
    if (!img.src) {
      resolve();
      return;
    }
    img.onload = resolve;
    img.onerror = resolve;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve, reject) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
  // Safari shows pseudoelements if content is set
];
var copyCSSStyles = function(style, target) {
  for (var i2 = style.length - 1; i2 >= 0; i2--) {
    var property = style.item(i2);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x2, y2) {
  if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x2, y2);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
  element.scrollLeft = x2;
  element.scrollTop = y2;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style = document2.createElement("style");
    style.textContent = styles;
    body.appendChild(style);
  }
};
var CacheStorage = (
  /** @class */
  (function() {
    function CacheStorage2() {
    }
    CacheStorage2.getOrigin = function(url) {
      var link = CacheStorage2._link;
      if (!link) {
        return "about:blank";
      }
      link.href = url;
      link.href = link.href;
      return link.protocol + link.hostname + link.port;
    };
    CacheStorage2.isSameOrigin = function(src) {
      return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
    };
    CacheStorage2.setContext = function(window2) {
      CacheStorage2._link = window2.document.createElement("a");
      CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
    };
    CacheStorage2._origin = "about:blank";
    return CacheStorage2;
  })()
);
var Cache = (
  /** @class */
  (function() {
    function Cache2(context, _options) {
      this.context = context;
      this._options = _options;
      this._cache = {};
    }
    Cache2.prototype.addImage = function(src) {
      var result = Promise.resolve();
      if (this.has(src)) {
        return result;
      }
      if (isBlobImage(src) || isRenderable(src)) {
        (this._cache[src] = this.loadImage(src)).catch(function() {
        });
        return result;
      }
      return result;
    };
    Cache2.prototype.match = function(src) {
      return this._cache[src];
    };
    Cache2.prototype.loadImage = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var isSameOrigin, useCORS, useProxy, src;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              isSameOrigin = CacheStorage.isSameOrigin(key);
              useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
              useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
              if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                return [
                  2
                  /*return*/
                ];
              }
              src = key;
              if (!useProxy) return [3, 2];
              return [4, this.proxy(src)];
            case 1:
              src = _a2.sent();
              _a2.label = 2;
            case 2:
              this.context.logger.debug("Added image " + key.substring(0, 256));
              return [4, new Promise(function(resolve, reject) {
                var img = new Image();
                img.onload = function() {
                  return resolve(img);
                };
                img.onerror = reject;
                if (isInlineBase64Image(src) || useCORS) {
                  img.crossOrigin = "anonymous";
                }
                img.src = src;
                if (img.complete === true) {
                  setTimeout(function() {
                    return resolve(img);
                  }, 500);
                }
                if (_this._options.imageTimeout > 0) {
                  setTimeout(function() {
                    return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                  }, _this._options.imageTimeout);
                }
              })];
            case 3:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Cache2.prototype.has = function(key) {
      return typeof this._cache[key] !== "undefined";
    };
    Cache2.prototype.keys = function() {
      return Promise.resolve(Object.keys(this._cache));
    };
    Cache2.prototype.proxy = function(src) {
      var _this = this;
      var proxy = this._options.proxy;
      if (!proxy) {
        throw new Error("No proxy defined");
      }
      var key = src.substring(0, 256);
      return new Promise(function(resolve, reject) {
        var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (xhr.status === 200) {
            if (responseType === "text") {
              resolve(xhr.response);
            } else {
              var reader_1 = new FileReader();
              reader_1.addEventListener("load", function() {
                return resolve(reader_1.result);
              }, false);
              reader_1.addEventListener("error", function(e2) {
                return reject(e2);
              }, false);
              reader_1.readAsDataURL(xhr.response);
            }
          } else {
            reject("Failed to proxy resource " + key + " with status code " + xhr.status);
          }
        };
        xhr.onerror = reject;
        var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
        xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
        if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
          xhr.responseType = responseType;
        }
        if (_this._options.imageTimeout) {
          var timeout_1 = _this._options.imageTimeout;
          xhr.timeout = timeout_1;
          xhr.ontimeout = function() {
            return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
          };
        }
        xhr.send();
      });
    };
    return Cache2;
  })()
);
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = (
  /** @class */
  (function() {
    function Vector2(x2, y2) {
      this.type = 0;
      this.x = x2;
      this.y = y2;
    }
    Vector2.prototype.add = function(deltaX, deltaY) {
      return new Vector2(this.x + deltaX, this.y + deltaY);
    };
    return Vector2;
  })()
);
var lerp = function(a2, b2, t3) {
  return new Vector(a2.x + (b2.x - a2.x) * t3, a2.y + (b2.y - a2.y) * t3);
};
var BezierCurve = (
  /** @class */
  (function() {
    function BezierCurve2(start, startControl, endControl, end) {
      this.type = 1;
      this.start = start;
      this.startControl = startControl;
      this.endControl = endControl;
      this.end = end;
    }
    BezierCurve2.prototype.subdivide = function(t3, firstHalf) {
      var ab = lerp(this.start, this.startControl, t3);
      var bc = lerp(this.startControl, this.endControl, t3);
      var cd = lerp(this.endControl, this.end, t3);
      var abbc = lerp(ab, bc, t3);
      var bccd = lerp(bc, cd, t3);
      var dest = lerp(abbc, bccd, t3);
      return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
    };
    BezierCurve2.prototype.add = function(deltaX, deltaY) {
      return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
    };
    BezierCurve2.prototype.reverse = function() {
      return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
    };
    return BezierCurve2;
  })()
);
var isBezierCurve = function(path2) {
  return path2.type === 1;
};
var BoundCurves = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BoundCurves2(element) {
      var styles = element.styles;
      var bounds = element.bounds;
      var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
      var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
      var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
      var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
      var factors = [];
      factors.push((tlh + trh) / bounds.width);
      factors.push((blh + brh) / bounds.width);
      factors.push((tlv + blv) / bounds.height);
      factors.push((trv + brv) / bounds.height);
      var maxFactor = Math.max.apply(Math, factors);
      if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
      }
      var topWidth = bounds.width - trh;
      var rightHeight = bounds.height - brv;
      var bottomWidth = bounds.width - brh;
      var leftHeight = bounds.height - blv;
      var borderTopWidth2 = styles.borderTopWidth;
      var borderRightWidth2 = styles.borderRightWidth;
      var borderBottomWidth2 = styles.borderBottomWidth;
      var borderLeftWidth2 = styles.borderLeftWidth;
      var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
      var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
      var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
      var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
      this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
      this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
      this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
      this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
      this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
      this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
      this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
      this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
      this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
      this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
      this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
      this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
      this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
      this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
      this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
      this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    }
    return BoundCurves2;
  })()
);
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x2, y2, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x2 + r1;
  var ym = y2 + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = (
  /** @class */
  /* @__PURE__ */ (function() {
    function TransformEffect2(offsetX, offsetY, matrix2) {
      this.offsetX = offsetX;
      this.offsetY = offsetY;
      this.matrix = matrix2;
      this.type = 0;
      this.target = 2 | 4;
    }
    return TransformEffect2;
  })()
);
var ClipEffect = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ClipEffect2(path2, target) {
      this.path = path2;
      this.target = target;
      this.type = 1;
    }
    return ClipEffect2;
  })()
);
var OpacityEffect = (
  /** @class */
  /* @__PURE__ */ (function() {
    function OpacityEffect2(opacity2) {
      this.opacity = opacity2;
      this.type = 2;
      this.target = 2 | 4;
    }
    return OpacityEffect2;
  })()
);
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b2) {
  if (a2.length === b2.length) {
    return a2.some(function(v2, i2) {
      return v2 === b2[i2];
    });
  }
  return false;
};
var transformPath = function(path2, deltaX, deltaY, deltaW, deltaH) {
  return path2.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = (
  /** @class */
  /* @__PURE__ */ (function() {
    function StackingContext2(container) {
      this.element = container;
      this.inlineLevel = [];
      this.nonInlineLevel = [];
      this.negativeZIndex = [];
      this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
      this.positiveZIndex = [];
      this.nonPositionedFloats = [];
      this.nonPositionedInlineLevel = [];
    }
    return StackingContext2;
  })()
);
var ElementPaint = (
  /** @class */
  (function() {
    function ElementPaint2(container, parent) {
      this.container = container;
      this.parent = parent;
      this.effects = [];
      this.curves = new BoundCurves(this.container);
      if (this.container.styles.opacity < 1) {
        this.effects.push(new OpacityEffect(this.container.styles.opacity));
      }
      if (this.container.styles.transform !== null) {
        var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
        var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
        var matrix2 = this.container.styles.transform;
        this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
      }
      if (this.container.styles.overflowX !== 0) {
        var borderBox = calculateBorderBoxPath(this.curves);
        var paddingBox2 = calculatePaddingBoxPath(this.curves);
        if (equalPath(borderBox, paddingBox2)) {
          this.effects.push(new ClipEffect(
            borderBox,
            2 | 4
            /* CONTENT */
          ));
        } else {
          this.effects.push(new ClipEffect(
            borderBox,
            2
            /* BACKGROUND_BORDERS */
          ));
          this.effects.push(new ClipEffect(
            paddingBox2,
            4
            /* CONTENT */
          ));
        }
      }
    }
    ElementPaint2.prototype.getEffects = function(target) {
      var inFlow = [
        2,
        3
        /* FIXED */
      ].indexOf(this.container.styles.position) === -1;
      var parent = this.parent;
      var effects = this.effects.slice(0);
      while (parent) {
        var croplessEffects = parent.effects.filter(function(effect) {
          return !isClipEffect(effect);
        });
        if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
          effects.unshift.apply(effects, croplessEffects);
          inFlow = [
            2,
            3
            /* FIXED */
          ].indexOf(parent.container.styles.position) === -1;
          if (parent.container.styles.overflowX !== 0) {
            var borderBox = calculateBorderBoxPath(parent.curves);
            var paddingBox2 = calculatePaddingBoxPath(parent.curves);
            if (!equalPath(borderBox, paddingBox2)) {
              effects.unshift(new ClipEffect(
                paddingBox2,
                2 | 4
                /* CONTENT */
              ));
            }
          }
        } else {
          effects.unshift.apply(effects, croplessEffects);
        }
        parent = parent.parent;
      }
      return effects.filter(function(effect) {
        return contains(effect.target, target);
      });
    };
    return ElementPaint2;
  })()
);
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(
      child.flags,
      4
      /* CREATES_REAL_STACKING_CONTEXT */
    );
    var createsStackingContext2 = contains(
      child.flags,
      2
      /* CREATES_STACKING_CONTEXT */
    );
    var paintContainer = new ElementPaint(child, parent);
    if (contains(
      child.styles.display,
      2048
      /* LIST_ITEM */
    )) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    ) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i2) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i2;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i2) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i2 + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(
      child.flags,
      8
      /* IS_LIST_OWNER */
    )) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements2) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i2 = 0; i2 < elements2.length; i2++) {
    var item = elements2[i2];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root, root, listItems);
  processListItems(paintContainer.container, listItems);
  return root;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path2 = [];
  if (isBezierCurve(outer1)) {
    path2.push(outer1.subdivide(0.5, false));
  } else {
    path2.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path2.push(outer2.subdivide(0.5, true));
  } else {
    path2.push(outer2);
  }
  return path2;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path2 = [];
  if (isBezierCurve(outer1)) {
    path2.push(outer1.subdivide(0.5, false));
  } else {
    path2.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path2.push(outer2.subdivide(0.5, true));
  } else {
    path2.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path2.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path2.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path2.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path2.push(inner1);
  }
  return path2;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path2 = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path2, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width !== null && height !== null) {
    return [width, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values, index2) {
  var value = values[index2];
  if (typeof value === "undefined") {
    return values[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
  var x2 = _a2[0], y2 = _a2[1];
  var width = _b2[0], height = _b2[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),
        new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = (
  /** @class */
  (function() {
    function FontMetrics2(document2) {
      this._data = {};
      this._document = document2;
    }
    FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
      var container = this._document.createElement("div");
      var img = this._document.createElement("img");
      var span = this._document.createElement("span");
      var body = this._document.body;
      container.style.visibility = "hidden";
      container.style.fontFamily = fontFamily2;
      container.style.fontSize = fontSize2;
      container.style.margin = "0";
      container.style.padding = "0";
      container.style.whiteSpace = "nowrap";
      body.appendChild(container);
      img.src = SMALL_IMAGE;
      img.width = 1;
      img.height = 1;
      img.style.margin = "0";
      img.style.padding = "0";
      img.style.verticalAlign = "baseline";
      span.style.fontFamily = fontFamily2;
      span.style.fontSize = fontSize2;
      span.style.margin = "0";
      span.style.padding = "0";
      span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.appendChild(span);
      container.appendChild(img);
      var baseline = img.offsetTop - span.offsetTop + 2;
      container.removeChild(span);
      container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
      container.style.lineHeight = "normal";
      img.style.verticalAlign = "super";
      var middle = img.offsetTop - container.offsetTop + 2;
      body.removeChild(container);
      return { baseline, middle };
    };
    FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
      var key = fontFamily2 + " " + fontSize2;
      if (typeof this._data[key] === "undefined") {
        this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
      }
      return this._data[key];
    };
    return FontMetrics2;
  })()
);
var Renderer = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Renderer2(context, options) {
      this.context = context;
      this.options = options;
    }
    return Renderer2;
  })()
);
var MASK_OFFSET = 1e4;
var CanvasRenderer = (
  /** @class */
  (function(_super) {
    __extends(CanvasRenderer2, _super);
    function CanvasRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this._activeEffects = [];
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      if (!options.canvas) {
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
      }
      _this.fontMetrics = new FontMetrics(document);
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.ctx.textBaseline = "bottom";
      _this._activeEffects = [];
      _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
      return _this;
    }
    CanvasRenderer2.prototype.applyEffects = function(effects) {
      var _this = this;
      while (this._activeEffects.length) {
        this.popEffect();
      }
      effects.forEach(function(effect) {
        return _this.applyEffect(effect);
      });
    };
    CanvasRenderer2.prototype.applyEffect = function(effect) {
      this.ctx.save();
      if (isOpacityEffect(effect)) {
        this.ctx.globalAlpha = effect.opacity;
      }
      if (isTransformEffect(effect)) {
        this.ctx.translate(effect.offsetX, effect.offsetY);
        this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
        this.ctx.translate(-effect.offsetX, -effect.offsetY);
      }
      if (isClipEffect(effect)) {
        this.path(effect.path);
        this.ctx.clip();
      }
      this._activeEffects.push(effect);
    };
    CanvasRenderer2.prototype.popEffect = function() {
      this._activeEffects.pop();
      this.ctx.restore();
    };
    CanvasRenderer2.prototype.renderStack = function(stack) {
      return __awaiter(this, void 0, void 0, function() {
        var styles;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              styles = stack.element.container.styles;
              if (!styles.isVisible()) return [3, 2];
              return [4, this.renderStackContent(stack)];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNode = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (contains(
                paint.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              if (!paint.container.styles.isVisible()) return [3, 3];
              return [4, this.renderNodeBackgroundAndBorders(paint)];
            case 1:
              _a2.sent();
              return [4, this.renderNodeContent(paint)];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
      var _this = this;
      if (letterSpacing2 === 0) {
        this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
      } else {
        var letters = segmentGraphemes(text2.text);
        letters.reduce(function(left, letter) {
          _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
          return left + _this.ctx.measureText(letter).width;
        }, text2.bounds.left);
      }
    };
    CanvasRenderer2.prototype.createFontStyle = function(styles) {
      var fontVariant2 = styles.fontVariant.filter(function(variant) {
        return variant === "normal" || variant === "small-caps";
      }).join("");
      var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
      var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
      return [
        [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
        fontFamily2,
        fontSize2
      ];
    };
    CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
      return __awaiter(this, void 0, void 0, function() {
        var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
        var _this = this;
        return __generator(this, function(_c) {
          _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
          this.ctx.font = font;
          this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "alphabetic";
          _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
          paintOrder2 = styles.paintOrder;
          text2.textBounds.forEach(function(text3) {
            paintOrder2.forEach(function(paintOrderLayer) {
              switch (paintOrderLayer) {
                case 0:
                  _this.ctx.fillStyle = asString(styles.color);
                  _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                  var textShadows = styles.textShadow;
                  if (textShadows.length && text3.text.trim().length) {
                    textShadows.slice(0).reverse().forEach(function(textShadow2) {
                      _this.ctx.shadowColor = asString(textShadow2.color);
                      _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                      _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                      _this.ctx.shadowBlur = textShadow2.blur.number;
                      _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                    });
                    _this.ctx.shadowColor = "";
                    _this.ctx.shadowOffsetX = 0;
                    _this.ctx.shadowOffsetY = 0;
                    _this.ctx.shadowBlur = 0;
                  }
                  if (styles.textDecorationLine.length) {
                    _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                    styles.textDecorationLine.forEach(function(textDecorationLine2) {
                      switch (textDecorationLine2) {
                        case 1:
                          _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                          break;
                        case 2:
                          _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                          break;
                        case 3:
                          _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                          break;
                      }
                    });
                  }
                  break;
                case 1:
                  if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                    _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                    _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                    _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                    _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                  }
                  _this.ctx.strokeStyle = "";
                  _this.ctx.lineWidth = 0;
                  _this.ctx.lineJoin = "miter";
                  break;
              }
            });
          });
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
      if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
        var box = contentBox(container);
        var path2 = calculatePaddingBoxPath(curves);
        this.path(path2);
        this.ctx.save();
        this.ctx.clip();
        this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
        this.ctx.restore();
      }
    };
    CanvasRenderer2.prototype.renderNodeContent = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                4
                /* CONTENT */
              ));
              container = paint.container;
              curves = paint.curves;
              styles = container.styles;
              _i = 0, _a2 = container.textNodes;
              _c.label = 1;
            case 1:
              if (!(_i < _a2.length)) return [3, 4];
              child = _a2[_i];
              return [4, this.renderTextNode(child, styles)];
            case 2:
              _c.sent();
              _c.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              if (!(container instanceof ImageElementContainer)) return [3, 8];
              _c.label = 5;
            case 5:
              _c.trys.push([5, 7, , 8]);
              return [4, this.context.cache.match(container.src)];
            case 6:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 8];
            case 7:
              _c.sent();
              this.context.logger.error("Error loading image " + container.src);
              return [3, 8];
            case 8:
              if (container instanceof CanvasElementContainer) {
                this.renderReplacedElement(container, curves, container.canvas);
              }
              if (!(container instanceof SVGElementContainer)) return [3, 12];
              _c.label = 9;
            case 9:
              _c.trys.push([9, 11, , 12]);
              return [4, this.context.cache.match(container.svg)];
            case 10:
              image2 = _c.sent();
              this.renderReplacedElement(container, curves, image2);
              return [3, 12];
            case 11:
              _c.sent();
              this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
              return [3, 12];
            case 12:
              if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
              iframeRenderer = new CanvasRenderer2(this.context, {
                scale: this.options.scale,
                backgroundColor: container.backgroundColor,
                x: 0,
                y: 0,
                width: container.width,
                height: container.height
              });
              return [4, iframeRenderer.render(container.tree)];
            case 13:
              canvas = _c.sent();
              if (container.width && container.height) {
                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
              }
              _c.label = 14;
            case 14:
              if (container instanceof InputElementContainer) {
                size = Math.min(container.bounds.width, container.bounds.height);
                if (container.type === CHECKBOX) {
                  if (container.checked) {
                    this.ctx.save();
                    this.path([
                      new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                      new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                      new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                      new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                      new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                      new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                      new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                    ]);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                } else if (container.type === RADIO) {
                  if (container.checked) {
                    this.ctx.save();
                    this.ctx.beginPath();
                    this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                    this.ctx.fillStyle = asString(INPUT_COLOR);
                    this.ctx.fill();
                    this.ctx.restore();
                  }
                }
              }
              if (isTextInputElement(container) && container.value.length) {
                _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                bounds = contentBox(container);
                x2 = 0;
                switch (container.styles.textAlign) {
                  case 1:
                    x2 += bounds.width / 2;
                    break;
                  case 2:
                    x2 += bounds.width;
                    break;
                }
                textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                this.ctx.save();
                this.path([
                  new Vector(bounds.left, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top),
                  new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                  new Vector(bounds.left, bounds.top + bounds.height)
                ]);
                this.ctx.clip();
                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                this.ctx.restore();
                this.ctx.textBaseline = "alphabetic";
                this.ctx.textAlign = "left";
              }
              if (!contains(
                container.styles.display,
                2048
                /* LIST_ITEM */
              )) return [3, 20];
              if (!(container.styles.listStyleImage !== null)) return [3, 19];
              img = container.styles.listStyleImage;
              if (!(img.type === 0)) return [3, 18];
              image2 = void 0;
              url = img.url;
              _c.label = 15;
            case 15:
              _c.trys.push([15, 17, , 18]);
              return [4, this.context.cache.match(url)];
            case 16:
              image2 = _c.sent();
              this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
              return [3, 18];
            case 17:
              _c.sent();
              this.context.logger.error("Error loading list-style-image " + url);
              return [3, 18];
            case 18:
              return [3, 20];
            case 19:
              if (paint.listValue && container.styles.listStyleType !== -1) {
                fontFamily2 = this.createFontStyle(styles)[0];
                this.ctx.font = fontFamily2;
                this.ctx.fillStyle = asString(styles.color);
                this.ctx.textBaseline = "middle";
                this.ctx.textAlign = "right";
                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                this.ctx.textBaseline = "bottom";
                this.ctx.textAlign = "left";
              }
              _c.label = 20;
            case 20:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderStackContent = function(stack) {
      return __awaiter(this, void 0, void 0, function() {
        var _i, _a2, child, _b2, _c, child, _d, _e2, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
        return __generator(this, function(_p) {
          switch (_p.label) {
            case 0:
              if (contains(
                stack.element.container.flags,
                16
                /* DEBUG_RENDER */
              )) {
                debugger;
              }
              return [4, this.renderNodeBackgroundAndBorders(stack.element)];
            case 1:
              _p.sent();
              _i = 0, _a2 = stack.negativeZIndex;
              _p.label = 2;
            case 2:
              if (!(_i < _a2.length)) return [3, 5];
              child = _a2[_i];
              return [4, this.renderStack(child)];
            case 3:
              _p.sent();
              _p.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [4, this.renderNodeContent(stack.element)];
            case 6:
              _p.sent();
              _b2 = 0, _c = stack.nonInlineLevel;
              _p.label = 7;
            case 7:
              if (!(_b2 < _c.length)) return [3, 10];
              child = _c[_b2];
              return [4, this.renderNode(child)];
            case 8:
              _p.sent();
              _p.label = 9;
            case 9:
              _b2++;
              return [3, 7];
            case 10:
              _d = 0, _e2 = stack.nonPositionedFloats;
              _p.label = 11;
            case 11:
              if (!(_d < _e2.length)) return [3, 14];
              child = _e2[_d];
              return [4, this.renderStack(child)];
            case 12:
              _p.sent();
              _p.label = 13;
            case 13:
              _d++;
              return [3, 11];
            case 14:
              _f = 0, _g = stack.nonPositionedInlineLevel;
              _p.label = 15;
            case 15:
              if (!(_f < _g.length)) return [3, 18];
              child = _g[_f];
              return [4, this.renderStack(child)];
            case 16:
              _p.sent();
              _p.label = 17;
            case 17:
              _f++;
              return [3, 15];
            case 18:
              _h = 0, _j = stack.inlineLevel;
              _p.label = 19;
            case 19:
              if (!(_h < _j.length)) return [3, 22];
              child = _j[_h];
              return [4, this.renderNode(child)];
            case 20:
              _p.sent();
              _p.label = 21;
            case 21:
              _h++;
              return [3, 19];
            case 22:
              _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
              _p.label = 23;
            case 23:
              if (!(_k < _l.length)) return [3, 26];
              child = _l[_k];
              return [4, this.renderStack(child)];
            case 24:
              _p.sent();
              _p.label = 25;
            case 25:
              _k++;
              return [3, 23];
            case 26:
              _m = 0, _o = stack.positiveZIndex;
              _p.label = 27;
            case 27:
              if (!(_m < _o.length)) return [3, 30];
              child = _o[_m];
              return [4, this.renderStack(child)];
            case 28:
              _p.sent();
              _p.label = 29;
            case 29:
              _m++;
              return [3, 27];
            case 30:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.mask = function(paths) {
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0);
      this.ctx.lineTo(this.canvas.width, 0);
      this.ctx.lineTo(this.canvas.width, this.canvas.height);
      this.ctx.lineTo(0, this.canvas.height);
      this.ctx.lineTo(0, 0);
      this.formatPath(paths.slice(0).reverse());
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.path = function(paths) {
      this.ctx.beginPath();
      this.formatPath(paths);
      this.ctx.closePath();
    };
    CanvasRenderer2.prototype.formatPath = function(paths) {
      var _this = this;
      paths.forEach(function(point, index2) {
        var start = isBezierCurve(point) ? point.start : point;
        if (index2 === 0) {
          _this.ctx.moveTo(start.x, start.y);
        } else {
          _this.ctx.lineTo(start.x, start.y);
        }
        if (isBezierCurve(point)) {
          _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
        }
      });
    };
    CanvasRenderer2.prototype.renderRepeat = function(path2, pattern, offsetX, offsetY) {
      this.path(path2);
      this.ctx.fillStyle = pattern;
      this.ctx.translate(offsetX, offsetY);
      this.ctx.fill();
      this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
      var _a2;
      if (image2.width === width && image2.height === height) {
        return image2;
      }
      var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
      var canvas = ownerDocument.createElement("canvas");
      canvas.width = Math.max(1, width);
      canvas.height = Math.max(1, height);
      var ctx = canvas.getContext("2d");
      ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
      return canvas;
    };
    CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
      return __awaiter(this, void 0, void 0, function() {
        var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              index2 = container.styles.backgroundImage.length - 1;
              _loop_1 = function(backgroundImage3) {
                var image2, url, _c, path2, x2, y2, width, height, pattern, _d, path2, x2, y2, width, height, _e2, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path2, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                return __generator(this, function(_h) {
                  switch (_h.label) {
                    case 0:
                      if (!(backgroundImage3.type === 0)) return [3, 5];
                      image2 = void 0;
                      url = backgroundImage3.url;
                      _h.label = 1;
                    case 1:
                      _h.trys.push([1, 3, , 4]);
                      return [4, this_1.context.cache.match(url)];
                    case 2:
                      image2 = _h.sent();
                      return [3, 4];
                    case 3:
                      _h.sent();
                      this_1.context.logger.error("Error loading background-image " + url);
                      return [3, 4];
                    case 4:
                      if (image2) {
                        _c = calculateBackgroundRendering(container, index2, [
                          image2.width,
                          image2.height,
                          image2.width / image2.height
                        ]), path2 = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                        pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                        this_1.renderRepeat(path2, pattern, x2, y2);
                      }
                      return [3, 6];
                    case 5:
                      if (isLinearGradient(backgroundImage3)) {
                        _d = calculateBackgroundRendering(container, index2, [null, null, null]), path2 = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                        _e2 = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e2[0], x0 = _e2[1], x1 = _e2[2], y0 = _e2[3], y1 = _e2[4];
                        canvas = document.createElement("canvas");
                        canvas.width = width;
                        canvas.height = height;
                        ctx = canvas.getContext("2d");
                        gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                        processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                          return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        ctx.fillStyle = gradient_1;
                        ctx.fillRect(0, 0, width, height);
                        if (width > 0 && height > 0) {
                          pattern = this_1.ctx.createPattern(canvas, "repeat");
                          this_1.renderRepeat(path2, pattern, x2, y2);
                        }
                      } else if (isRadialGradient(backgroundImage3)) {
                        _f = calculateBackgroundRendering(container, index2, [
                          null,
                          null,
                          null
                        ]), path2 = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                        position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                        x2 = getAbsoluteValue(position2[0], width);
                        y2 = getAbsoluteValue(position2[position2.length - 1], height);
                        _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                        if (rx > 0 && ry > 0) {
                          radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                          processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                            return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          this_1.path(path2);
                          this_1.ctx.fillStyle = radialGradient_1;
                          if (rx !== ry) {
                            midX = container.bounds.left + 0.5 * container.bounds.width;
                            midY = container.bounds.top + 0.5 * container.bounds.height;
                            f2 = ry / rx;
                            invF = 1 / f2;
                            this_1.ctx.save();
                            this_1.ctx.translate(midX, midY);
                            this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                            this_1.ctx.translate(-midX, -midY);
                            this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                            this_1.ctx.restore();
                          } else {
                            this_1.ctx.fill();
                          }
                        }
                      }
                      _h.label = 6;
                    case 6:
                      index2--;
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              this_1 = this;
              _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
              _b2.label = 1;
            case 1:
              if (!(_i < _a2.length)) return [3, 4];
              backgroundImage2 = _a2[_i];
              return [5, _loop_1(backgroundImage2)];
            case 2:
              _b2.sent();
              _b2.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a2) {
          this.path(parsePathForBorder(curvePoints, side));
          this.ctx.fillStyle = asString(color2);
          this.ctx.fill();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
      return __awaiter(this, void 0, void 0, function() {
        var outerPaths, innerPaths;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(width < 3)) return [3, 2];
              return [4, this.renderSolidBorder(color2, side, curvePoints)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
              this.path(outerPaths);
              this.ctx.fillStyle = asString(color2);
              this.ctx.fill();
              innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
              this.path(innerPaths);
              this.ctx.fill();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
      return __awaiter(this, void 0, void 0, function() {
        var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.applyEffects(paint.getEffects(
                2
                /* BACKGROUND_BORDERS */
              ));
              styles = paint.container.styles;
              hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
              borders = [
                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
              ];
              backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
              if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
              this.ctx.save();
              this.path(backgroundPaintingArea);
              this.ctx.clip();
              if (!isTransparent(styles.backgroundColor)) {
                this.ctx.fillStyle = asString(styles.backgroundColor);
                this.ctx.fill();
              }
              return [4, this.renderBackgroundImage(paint.container)];
            case 1:
              _a2.sent();
              this.ctx.restore();
              styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                _this.ctx.save();
                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                if (shadow.inset) {
                  _this.path(borderBoxArea);
                  _this.ctx.clip();
                  _this.mask(shadowPaintingArea);
                } else {
                  _this.mask(borderBoxArea);
                  _this.ctx.clip();
                  _this.path(shadowPaintingArea);
                }
                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                _this.ctx.shadowColor = asString(shadow.color);
                _this.ctx.shadowBlur = shadow.blur.number;
                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                _this.ctx.fill();
                _this.ctx.restore();
              });
              _a2.label = 2;
            case 2:
              side = 0;
              _i = 0, borders_1 = borders;
              _a2.label = 3;
            case 3:
              if (!(_i < borders_1.length)) return [3, 13];
              border = borders_1[_i];
              if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
              if (!(border.style === 2)) return [3, 5];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                2
                /* DASHED */
              )];
            case 4:
              _a2.sent();
              return [3, 11];
            case 5:
              if (!(border.style === 3)) return [3, 7];
              return [4, this.renderDashedDottedBorder(
                border.color,
                border.width,
                side,
                paint.curves,
                3
                /* DOTTED */
              )];
            case 6:
              _a2.sent();
              return [3, 11];
            case 7:
              if (!(border.style === 4)) return [3, 9];
              return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
            case 8:
              _a2.sent();
              return [3, 11];
            case 9:
              return [4, this.renderSolidBorder(border.color, side, paint.curves)];
            case 10:
              _a2.sent();
              _a2.label = 11;
            case 11:
              side++;
              _a2.label = 12;
            case 12:
              _i++;
              return [3, 3];
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
      return __awaiter(this, void 0, void 0, function() {
        var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
        return __generator(this, function(_a2) {
          this.ctx.save();
          strokePaths = parsePathForBorderStroke(curvePoints, side);
          boxPaths = parsePathForBorder(curvePoints, side);
          if (style === 2) {
            this.path(boxPaths);
            this.ctx.clip();
          }
          if (isBezierCurve(boxPaths[0])) {
            startX = boxPaths[0].start.x;
            startY = boxPaths[0].start.y;
          } else {
            startX = boxPaths[0].x;
            startY = boxPaths[0].y;
          }
          if (isBezierCurve(boxPaths[1])) {
            endX = boxPaths[1].end.x;
            endY = boxPaths[1].end.y;
          } else {
            endX = boxPaths[1].x;
            endY = boxPaths[1].y;
          }
          if (side === 0 || side === 2) {
            length = Math.abs(startX - endX);
          } else {
            length = Math.abs(startY - endY);
          }
          this.ctx.beginPath();
          if (style === 3) {
            this.formatPath(strokePaths);
          } else {
            this.formatPath(boxPaths.slice(0, 2));
          }
          dashLength = width < 3 ? width * 3 : width * 2;
          spaceLength = width < 3 ? width * 2 : width;
          if (style === 3) {
            dashLength = width;
            spaceLength = width;
          }
          useLineDash = true;
          if (length <= dashLength * 2) {
            useLineDash = false;
          } else if (length <= dashLength * 2 + spaceLength) {
            multiplier = length / (2 * dashLength + spaceLength);
            dashLength *= multiplier;
            spaceLength *= multiplier;
          } else {
            numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
            minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
            maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
            spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
          }
          if (useLineDash) {
            if (style === 3) {
              this.ctx.setLineDash([0, dashLength + spaceLength]);
            } else {
              this.ctx.setLineDash([dashLength, spaceLength]);
            }
          }
          if (style === 3) {
            this.ctx.lineCap = "round";
            this.ctx.lineWidth = width;
          } else {
            this.ctx.lineWidth = width * 2 + 1.1;
          }
          this.ctx.strokeStyle = asString(color2);
          this.ctx.stroke();
          this.ctx.setLineDash([]);
          if (style === 2) {
            if (isBezierCurve(boxPaths[0])) {
              path1 = boxPaths[3];
              path2 = boxPaths[0];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
            if (isBezierCurve(boxPaths[1])) {
              path1 = boxPaths[1];
              path2 = boxPaths[2];
              this.ctx.beginPath();
              this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
              this.ctx.stroke();
            }
          }
          this.ctx.restore();
          return [
            2
            /*return*/
          ];
        });
      });
    };
    CanvasRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var stack;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
              }
              stack = parseStackingContexts(element);
              return [4, this.renderStack(stack)];
            case 1:
              _a2.sent();
              this.applyEffects([]);
              return [2, this.canvas];
          }
        });
      });
    };
    return CanvasRenderer2;
  })(Renderer)
);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = (
  /** @class */
  (function(_super) {
    __extends(ForeignObjectRenderer2, _super);
    function ForeignObjectRenderer2(context, options) {
      var _this = _super.call(this, context, options) || this;
      _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
      _this.ctx = _this.canvas.getContext("2d");
      _this.options = options;
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
      _this.ctx.scale(_this.options.scale, _this.options.scale);
      _this.ctx.translate(-options.x, -options.y);
      _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
      return _this;
    }
    ForeignObjectRenderer2.prototype.render = function(element) {
      return __awaiter(this, void 0, void 0, function() {
        var svg2, img;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
              return [4, loadSerializedSVG(svg2)];
            case 1:
              img = _a2.sent();
              if (this.options.backgroundColor) {
                this.ctx.fillStyle = asString(this.options.backgroundColor);
                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
              }
              this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
              return [2, this.canvas];
          }
        });
      });
    };
    return ForeignObjectRenderer2;
  })(Renderer)
);
var loadSerializedSVG = function(svg2) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
  });
};
var Logger = (
  /** @class */
  (function() {
    function Logger2(_a2) {
      var id = _a2.id, enabled = _a2.enabled;
      this.id = id;
      this.enabled = enabled;
      this.start = Date.now();
    }
    Logger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
          console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.getTime = function() {
      return Date.now() - this.start;
    };
    Logger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
          console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        }
      }
    };
    Logger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
          console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (this.enabled) {
        if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
          console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
        } else {
          this.info.apply(this, args);
        }
      }
    };
    Logger2.instances = {};
    return Logger2;
  })()
);
var Context = (
  /** @class */
  (function() {
    function Context2(options, windowBounds) {
      var _a2;
      this.windowBounds = windowBounds;
      this.instanceName = "#" + Context2.instanceCount++;
      this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
      this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
    }
    Context2.instanceCount = 1;
    return Context2;
  })()
);
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
    var _b2, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e2 = opts.logging) !== null && _e2 !== void 0 ? _e2 : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering) return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root = parseTree(context, clonedElement);
          if (backgroundColor2 === root.styles.backgroundColor) {
            root.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer(context, renderOptions);
          return [4, renderer.render(root)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
const html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: html2canvas
}, Symbol.toStringTag, { value: "Module" }));
/*! @license DOMPurify 3.2.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.7/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!apply) {
  apply = function apply2(func, thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    return func.apply(thisArg, args);
  };
}
if (!construct) {
  construct = function construct2(Func) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim$1 = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(Func) {
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return construct(Func, args);
  };
}
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l2 = array.length;
  while (l2--) {
    let element = array[l2];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function cleanArray(array) {
  for (let index2 = 0; index2 < array.length; index2++) {
    const isPropertyExist = objectHasOwnProperty(array, index2);
    if (!isPropertyExist) {
      array[index2] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "slot", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html$2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
};
const getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
const _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.2.7";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element3,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser: DOMParser2,
    trustedTypes
  } = window2;
  const ElementPrototype = Element3.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html$2, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html$2);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      getParentNode(node2).removeChild(node2);
    } catch (_2) {
      remove(node2);
    }
  };
  const _removeAttribute = function _removeAttribute2(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    if (name === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_2) {
        }
      } else {
        try {
          element.setAttribute(name, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node2 === "function" && value instanceof Node2;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content2 = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i2 = childCount - 1; i2 >= 0; --i2) {
            const childClone = cloneNode(childNodes[i2], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content2 = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content2 = stringReplace(content2, expr, " ");
      });
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content2;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l2 = attributes.length;
    while (l2--) {
      const attr = attributes[l2];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      const initValue = attrValue;
      let value = name === "value" ? initValue : stringTrim$1(initValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (lcName === "attributename" && stringMatch(value, "href")) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      if (!hookEvent.keepAttr) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_2) {
          _removeAttribute(name, currentNode);
        }
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const purify_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: purify
}, Symbol.toStringTag, { value: "Module" }));
var es_promise = {};
var es_promise_constructor = {};
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis) return globalThis_1;
  hasRequiredGlobalThis = 1;
  var check = function(it2) {
    return it2 && it2.Math === Math && it2;
  };
  globalThis_1 = // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || check(typeof globalThis_1 == "object" && globalThis_1) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ (function() {
    return this;
  })() || Function("return this")();
  return globalThis_1;
}
var objectGetOwnPropertyDescriptor = {};
var fails;
var hasRequiredFails;
function requireFails() {
  if (hasRequiredFails) return fails;
  hasRequiredFails = 1;
  fails = function(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };
  return fails;
}
var descriptors;
var hasRequiredDescriptors;
function requireDescriptors() {
  if (hasRequiredDescriptors) return descriptors;
  hasRequiredDescriptors = 1;
  var fails2 = requireFails();
  descriptors = !fails2(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  });
  return descriptors;
}
var functionBindNative;
var hasRequiredFunctionBindNative;
function requireFunctionBindNative() {
  if (hasRequiredFunctionBindNative) return functionBindNative;
  hasRequiredFunctionBindNative = 1;
  var fails2 = requireFails();
  functionBindNative = !fails2(function() {
    var test2 = (function() {
    }).bind();
    return typeof test2 != "function" || test2.hasOwnProperty("prototype");
  });
  return functionBindNative;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var call = Function.prototype.call;
  functionCall = NATIVE_BIND ? call.bind(call) : function() {
    return call.apply(call, arguments);
  };
  return functionCall;
}
var objectPropertyIsEnumerable = {};
var hasRequiredObjectPropertyIsEnumerable;
function requireObjectPropertyIsEnumerable() {
  if (hasRequiredObjectPropertyIsEnumerable) return objectPropertyIsEnumerable;
  hasRequiredObjectPropertyIsEnumerable = 1;
  var $propertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  var NASHORN_BUG = getOwnPropertyDescriptor2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
  objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
    var descriptor = getOwnPropertyDescriptor2(this, V2);
    return !!descriptor && descriptor.enumerable;
  } : $propertyIsEnumerable;
  return objectPropertyIsEnumerable;
}
var createPropertyDescriptor;
var hasRequiredCreatePropertyDescriptor;
function requireCreatePropertyDescriptor() {
  if (hasRequiredCreatePropertyDescriptor) return createPropertyDescriptor;
  hasRequiredCreatePropertyDescriptor = 1;
  createPropertyDescriptor = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value
    };
  };
  return createPropertyDescriptor;
}
var functionUncurryThis;
var hasRequiredFunctionUncurryThis;
function requireFunctionUncurryThis() {
  if (hasRequiredFunctionUncurryThis) return functionUncurryThis;
  hasRequiredFunctionUncurryThis = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var call = FunctionPrototype.call;
  var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
  functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
    return function() {
      return call.apply(fn, arguments);
    };
  };
  return functionUncurryThis;
}
var classofRaw;
var hasRequiredClassofRaw;
function requireClassofRaw() {
  if (hasRequiredClassofRaw) return classofRaw;
  hasRequiredClassofRaw = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toString3 = uncurryThis({}.toString);
  var stringSlice = uncurryThis("".slice);
  classofRaw = function(it2) {
    return stringSlice(toString3(it2), 8, -1);
  };
  return classofRaw;
}
var indexedObject;
var hasRequiredIndexedObject;
function requireIndexedObject() {
  if (hasRequiredIndexedObject) return indexedObject;
  hasRequiredIndexedObject = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var classof2 = requireClassofRaw();
  var $Object = Object;
  var split = uncurryThis("".split);
  indexedObject = fails2(function() {
    return !$Object("z").propertyIsEnumerable(0);
  }) ? function(it2) {
    return classof2(it2) === "String" ? split(it2, "") : $Object(it2);
  } : $Object;
  return indexedObject;
}
var isNullOrUndefined;
var hasRequiredIsNullOrUndefined;
function requireIsNullOrUndefined() {
  if (hasRequiredIsNullOrUndefined) return isNullOrUndefined;
  hasRequiredIsNullOrUndefined = 1;
  isNullOrUndefined = function(it2) {
    return it2 === null || it2 === void 0;
  };
  return isNullOrUndefined;
}
var requireObjectCoercible;
var hasRequiredRequireObjectCoercible;
function requireRequireObjectCoercible() {
  if (hasRequiredRequireObjectCoercible) return requireObjectCoercible;
  hasRequiredRequireObjectCoercible = 1;
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var $TypeError = TypeError;
  requireObjectCoercible = function(it2) {
    if (isNullOrUndefined2(it2)) throw new $TypeError("Can't call method on " + it2);
    return it2;
  };
  return requireObjectCoercible;
}
var toIndexedObject;
var hasRequiredToIndexedObject;
function requireToIndexedObject() {
  if (hasRequiredToIndexedObject) return toIndexedObject;
  hasRequiredToIndexedObject = 1;
  var IndexedObject = requireIndexedObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  toIndexedObject = function(it2) {
    return IndexedObject(requireObjectCoercible2(it2));
  };
  return toIndexedObject;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var documentAll = typeof document == "object" && document.all;
  isCallable = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
    return typeof argument == "function" || argument === documentAll;
  } : function(argument) {
    return typeof argument == "function";
  };
  return isCallable;
}
var isObject;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject;
  hasRequiredIsObject = 1;
  var isCallable2 = requireIsCallable();
  isObject = function(it2) {
    return typeof it2 == "object" ? it2 !== null : isCallable2(it2);
  };
  return isObject;
}
var getBuiltIn;
var hasRequiredGetBuiltIn;
function requireGetBuiltIn() {
  if (hasRequiredGetBuiltIn) return getBuiltIn;
  hasRequiredGetBuiltIn = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var aFunction = function(argument) {
    return isCallable2(argument) ? argument : void 0;
  };
  getBuiltIn = function(namespace, method) {
    return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
  };
  return getBuiltIn;
}
var objectIsPrototypeOf;
var hasRequiredObjectIsPrototypeOf;
function requireObjectIsPrototypeOf() {
  if (hasRequiredObjectIsPrototypeOf) return objectIsPrototypeOf;
  hasRequiredObjectIsPrototypeOf = 1;
  var uncurryThis = requireFunctionUncurryThis();
  objectIsPrototypeOf = uncurryThis({}.isPrototypeOf);
  return objectIsPrototypeOf;
}
var environmentUserAgent;
var hasRequiredEnvironmentUserAgent;
function requireEnvironmentUserAgent() {
  if (hasRequiredEnvironmentUserAgent) return environmentUserAgent;
  hasRequiredEnvironmentUserAgent = 1;
  var globalThis2 = requireGlobalThis();
  var navigator2 = globalThis2.navigator;
  var userAgent = navigator2 && navigator2.userAgent;
  environmentUserAgent = userAgent ? String(userAgent) : "";
  return environmentUserAgent;
}
var environmentV8Version;
var hasRequiredEnvironmentV8Version;
function requireEnvironmentV8Version() {
  if (hasRequiredEnvironmentV8Version) return environmentV8Version;
  hasRequiredEnvironmentV8Version = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var process2 = globalThis2.process;
  var Deno2 = globalThis2.Deno;
  var versions = process2 && process2.versions || Deno2 && Deno2.version;
  var v8 = versions && versions.v8;
  var match, version;
  if (v8) {
    match = v8.split(".");
    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
  }
  if (!version && userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
      match = userAgent.match(/Chrome\/(\d+)/);
      if (match) version = +match[1];
    }
  }
  environmentV8Version = version;
  return environmentV8Version;
}
var symbolConstructorDetection;
var hasRequiredSymbolConstructorDetection;
function requireSymbolConstructorDetection() {
  if (hasRequiredSymbolConstructorDetection) return symbolConstructorDetection;
  hasRequiredSymbolConstructorDetection = 1;
  var V8_VERSION = requireEnvironmentV8Version();
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $String = globalThis2.String;
  symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails2(function() {
    var symbol = Symbol("symbol detection");
    return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
  });
  return symbolConstructorDetection;
}
var useSymbolAsUid;
var hasRequiredUseSymbolAsUid;
function requireUseSymbolAsUid() {
  if (hasRequiredUseSymbolAsUid) return useSymbolAsUid;
  hasRequiredUseSymbolAsUid = 1;
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  useSymbolAsUid = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  return useSymbolAsUid;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var isCallable2 = requireIsCallable();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var $Object = Object;
  isSymbol = USE_SYMBOL_AS_UID ? function(it2) {
    return typeof it2 == "symbol";
  } : function(it2) {
    var $Symbol = getBuiltIn2("Symbol");
    return isCallable2($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it2));
  };
  return isSymbol;
}
var tryToString;
var hasRequiredTryToString;
function requireTryToString() {
  if (hasRequiredTryToString) return tryToString;
  hasRequiredTryToString = 1;
  var $String = String;
  tryToString = function(argument) {
    try {
      return $String(argument);
    } catch (error) {
      return "Object";
    }
  };
  return tryToString;
}
var aCallable;
var hasRequiredACallable;
function requireACallable() {
  if (hasRequiredACallable) return aCallable;
  hasRequiredACallable = 1;
  var isCallable2 = requireIsCallable();
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aCallable = function(argument) {
    if (isCallable2(argument)) return argument;
    throw new $TypeError(tryToString2(argument) + " is not a function");
  };
  return aCallable;
}
var getMethod;
var hasRequiredGetMethod;
function requireGetMethod() {
  if (hasRequiredGetMethod) return getMethod;
  hasRequiredGetMethod = 1;
  var aCallable2 = requireACallable();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  getMethod = function(V2, P2) {
    var func = V2[P2];
    return isNullOrUndefined2(func) ? void 0 : aCallable2(func);
  };
  return getMethod;
}
var ordinaryToPrimitive;
var hasRequiredOrdinaryToPrimitive;
function requireOrdinaryToPrimitive() {
  if (hasRequiredOrdinaryToPrimitive) return ordinaryToPrimitive;
  hasRequiredOrdinaryToPrimitive = 1;
  var call = requireFunctionCall();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var $TypeError = TypeError;
  ordinaryToPrimitive = function(input, pref) {
    var fn, val;
    if (pref === "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
    if (isCallable2(fn = input.valueOf) && !isObject2(val = call(fn, input))) return val;
    if (pref !== "string" && isCallable2(fn = input.toString) && !isObject2(val = call(fn, input))) return val;
    throw new $TypeError("Can't convert object to primitive value");
  };
  return ordinaryToPrimitive;
}
var sharedStore = { exports: {} };
var isPure;
var hasRequiredIsPure;
function requireIsPure() {
  if (hasRequiredIsPure) return isPure;
  hasRequiredIsPure = 1;
  isPure = false;
  return isPure;
}
var defineGlobalProperty;
var hasRequiredDefineGlobalProperty;
function requireDefineGlobalProperty() {
  if (hasRequiredDefineGlobalProperty) return defineGlobalProperty;
  hasRequiredDefineGlobalProperty = 1;
  var globalThis2 = requireGlobalThis();
  var defineProperty = Object.defineProperty;
  defineGlobalProperty = function(key, value) {
    try {
      defineProperty(globalThis2, key, { value, configurable: true, writable: true });
    } catch (error) {
      globalThis2[key] = value;
    }
    return value;
  };
  return defineGlobalProperty;
}
var hasRequiredSharedStore;
function requireSharedStore() {
  if (hasRequiredSharedStore) return sharedStore.exports;
  hasRequiredSharedStore = 1;
  var IS_PURE = requireIsPure();
  var globalThis2 = requireGlobalThis();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var SHARED = "__core-js_shared__";
  var store = sharedStore.exports = globalThis2[SHARED] || defineGlobalProperty2(SHARED, {});
  (store.versions || (store.versions = [])).push({
    version: "3.45.1",
    mode: IS_PURE ? "pure" : "global",
    copyright: "Â© 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
    source: "https://github.com/zloirock/core-js"
  });
  return sharedStore.exports;
}
var shared;
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared;
  hasRequiredShared = 1;
  var store = requireSharedStore();
  shared = function(key, value) {
    return store[key] || (store[key] = value || {});
  };
  return shared;
}
var toObject;
var hasRequiredToObject;
function requireToObject() {
  if (hasRequiredToObject) return toObject;
  hasRequiredToObject = 1;
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var $Object = Object;
  toObject = function(argument) {
    return $Object(requireObjectCoercible2(argument));
  };
  return toObject;
}
var hasOwnProperty_1;
var hasRequiredHasOwnProperty;
function requireHasOwnProperty() {
  if (hasRequiredHasOwnProperty) return hasOwnProperty_1;
  hasRequiredHasOwnProperty = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
  hasOwnProperty_1 = Object.hasOwn || function hasOwn(it2, key) {
    return hasOwnProperty2(toObject2(it2), key);
  };
  return hasOwnProperty_1;
}
var uid;
var hasRequiredUid;
function requireUid() {
  if (hasRequiredUid) return uid;
  hasRequiredUid = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var id = 0;
  var postfix = Math.random();
  var toString3 = uncurryThis(1.1.toString);
  uid = function(key) {
    return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString3(++id + postfix, 36);
  };
  return uid;
}
var wellKnownSymbol;
var hasRequiredWellKnownSymbol;
function requireWellKnownSymbol() {
  if (hasRequiredWellKnownSymbol) return wellKnownSymbol;
  hasRequiredWellKnownSymbol = 1;
  var globalThis2 = requireGlobalThis();
  var shared2 = requireShared();
  var hasOwn = requireHasOwnProperty();
  var uid2 = requireUid();
  var NATIVE_SYMBOL = requireSymbolConstructorDetection();
  var USE_SYMBOL_AS_UID = requireUseSymbolAsUid();
  var Symbol2 = globalThis2.Symbol;
  var WellKnownSymbolsStore = shared2("wks");
  var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
  wellKnownSymbol = function(name) {
    if (!hasOwn(WellKnownSymbolsStore, name)) {
      WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
    }
    return WellKnownSymbolsStore[name];
  };
  return wellKnownSymbol;
}
var toPrimitive$1;
var hasRequiredToPrimitive;
function requireToPrimitive() {
  if (hasRequiredToPrimitive) return toPrimitive$1;
  hasRequiredToPrimitive = 1;
  var call = requireFunctionCall();
  var isObject2 = requireIsObject();
  var isSymbol2 = requireIsSymbol();
  var getMethod2 = requireGetMethod();
  var ordinaryToPrimitive2 = requireOrdinaryToPrimitive();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var $TypeError = TypeError;
  var TO_PRIMITIVE = wellKnownSymbol2("toPrimitive");
  toPrimitive$1 = function(input, pref) {
    if (!isObject2(input) || isSymbol2(input)) return input;
    var exoticToPrim = getMethod2(input, TO_PRIMITIVE);
    var result;
    if (exoticToPrim) {
      if (pref === void 0) pref = "default";
      result = call(exoticToPrim, input, pref);
      if (!isObject2(result) || isSymbol2(result)) return result;
      throw new $TypeError("Can't convert object to primitive value");
    }
    if (pref === void 0) pref = "number";
    return ordinaryToPrimitive2(input, pref);
  };
  return toPrimitive$1;
}
var toPropertyKey$1;
var hasRequiredToPropertyKey;
function requireToPropertyKey() {
  if (hasRequiredToPropertyKey) return toPropertyKey$1;
  hasRequiredToPropertyKey = 1;
  var toPrimitive2 = requireToPrimitive();
  var isSymbol2 = requireIsSymbol();
  toPropertyKey$1 = function(argument) {
    var key = toPrimitive2(argument, "string");
    return isSymbol2(key) ? key : key + "";
  };
  return toPropertyKey$1;
}
var documentCreateElement;
var hasRequiredDocumentCreateElement;
function requireDocumentCreateElement() {
  if (hasRequiredDocumentCreateElement) return documentCreateElement;
  hasRequiredDocumentCreateElement = 1;
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var document2 = globalThis2.document;
  var EXISTS = isObject2(document2) && isObject2(document2.createElement);
  documentCreateElement = function(it2) {
    return EXISTS ? document2.createElement(it2) : {};
  };
  return documentCreateElement;
}
var ie8DomDefine;
var hasRequiredIe8DomDefine;
function requireIe8DomDefine() {
  if (hasRequiredIe8DomDefine) return ie8DomDefine;
  hasRequiredIe8DomDefine = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  var createElement = requireDocumentCreateElement();
  ie8DomDefine = !DESCRIPTORS && !fails2(function() {
    return Object.defineProperty(createElement("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  });
  return ie8DomDefine;
}
var hasRequiredObjectGetOwnPropertyDescriptor;
function requireObjectGetOwnPropertyDescriptor() {
  if (hasRequiredObjectGetOwnPropertyDescriptor) return objectGetOwnPropertyDescriptor;
  hasRequiredObjectGetOwnPropertyDescriptor = 1;
  var DESCRIPTORS = requireDescriptors();
  var call = requireFunctionCall();
  var propertyIsEnumerableModule = requireObjectPropertyIsEnumerable();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var toIndexedObject2 = requireToIndexedObject();
  var toPropertyKey2 = requireToPropertyKey();
  var hasOwn = requireHasOwnProperty();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  objectGetOwnPropertyDescriptor.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor2(O2, P2) {
    O2 = toIndexedObject2(O2);
    P2 = toPropertyKey2(P2);
    if (IE8_DOM_DEFINE) try {
      return $getOwnPropertyDescriptor(O2, P2);
    } catch (error) {
    }
    if (hasOwn(O2, P2)) return createPropertyDescriptor2(!call(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
  };
  return objectGetOwnPropertyDescriptor;
}
var objectDefineProperty = {};
var v8PrototypeDefineBug;
var hasRequiredV8PrototypeDefineBug;
function requireV8PrototypeDefineBug() {
  if (hasRequiredV8PrototypeDefineBug) return v8PrototypeDefineBug;
  hasRequiredV8PrototypeDefineBug = 1;
  var DESCRIPTORS = requireDescriptors();
  var fails2 = requireFails();
  v8PrototypeDefineBug = DESCRIPTORS && fails2(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: false
    }).prototype !== 42;
  });
  return v8PrototypeDefineBug;
}
var anObject;
var hasRequiredAnObject;
function requireAnObject() {
  if (hasRequiredAnObject) return anObject;
  hasRequiredAnObject = 1;
  var isObject2 = requireIsObject();
  var $String = String;
  var $TypeError = TypeError;
  anObject = function(argument) {
    if (isObject2(argument)) return argument;
    throw new $TypeError($String(argument) + " is not an object");
  };
  return anObject;
}
var hasRequiredObjectDefineProperty;
function requireObjectDefineProperty() {
  if (hasRequiredObjectDefineProperty) return objectDefineProperty;
  hasRequiredObjectDefineProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var IE8_DOM_DEFINE = requireIe8DomDefine();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var anObject2 = requireAnObject();
  var toPropertyKey2 = requireToPropertyKey();
  var $TypeError = TypeError;
  var $defineProperty = Object.defineProperty;
  var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var ENUMERABLE = "enumerable";
  var CONFIGURABLE = "configurable";
  var WRITABLE = "writable";
  objectDefineProperty.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O2, P2, Attributes) {
    anObject2(O2);
    P2 = toPropertyKey2(P2);
    anObject2(Attributes);
    if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
      var current = $getOwnPropertyDescriptor(O2, P2);
      if (current && current[WRITABLE]) {
        O2[P2] = Attributes.value;
        Attributes = {
          configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
          enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
          writable: false
        };
      }
    }
    return $defineProperty(O2, P2, Attributes);
  } : $defineProperty : function defineProperty(O2, P2, Attributes) {
    anObject2(O2);
    P2 = toPropertyKey2(P2);
    anObject2(Attributes);
    if (IE8_DOM_DEFINE) try {
      return $defineProperty(O2, P2, Attributes);
    } catch (error) {
    }
    if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
    if ("value" in Attributes) O2[P2] = Attributes.value;
    return O2;
  };
  return objectDefineProperty;
}
var createNonEnumerableProperty;
var hasRequiredCreateNonEnumerableProperty;
function requireCreateNonEnumerableProperty() {
  if (hasRequiredCreateNonEnumerableProperty) return createNonEnumerableProperty;
  hasRequiredCreateNonEnumerableProperty = 1;
  var DESCRIPTORS = requireDescriptors();
  var definePropertyModule = requireObjectDefineProperty();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  createNonEnumerableProperty = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor2(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  return createNonEnumerableProperty;
}
var makeBuiltIn = { exports: {} };
var functionName;
var hasRequiredFunctionName;
function requireFunctionName() {
  if (hasRequiredFunctionName) return functionName;
  hasRequiredFunctionName = 1;
  var DESCRIPTORS = requireDescriptors();
  var hasOwn = requireHasOwnProperty();
  var FunctionPrototype = Function.prototype;
  var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
  var EXISTS = hasOwn(FunctionPrototype, "name");
  var PROPER = EXISTS && (function something() {
  }).name === "something";
  var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
  functionName = {
    EXISTS,
    PROPER,
    CONFIGURABLE
  };
  return functionName;
}
var inspectSource;
var hasRequiredInspectSource;
function requireInspectSource() {
  if (hasRequiredInspectSource) return inspectSource;
  hasRequiredInspectSource = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var isCallable2 = requireIsCallable();
  var store = requireSharedStore();
  var functionToString = uncurryThis(Function.toString);
  if (!isCallable2(store.inspectSource)) {
    store.inspectSource = function(it2) {
      return functionToString(it2);
    };
  }
  inspectSource = store.inspectSource;
  return inspectSource;
}
var weakMapBasicDetection;
var hasRequiredWeakMapBasicDetection;
function requireWeakMapBasicDetection() {
  if (hasRequiredWeakMapBasicDetection) return weakMapBasicDetection;
  hasRequiredWeakMapBasicDetection = 1;
  var globalThis2 = requireGlobalThis();
  var isCallable2 = requireIsCallable();
  var WeakMap = globalThis2.WeakMap;
  weakMapBasicDetection = isCallable2(WeakMap) && /native code/.test(String(WeakMap));
  return weakMapBasicDetection;
}
var sharedKey;
var hasRequiredSharedKey;
function requireSharedKey() {
  if (hasRequiredSharedKey) return sharedKey;
  hasRequiredSharedKey = 1;
  var shared2 = requireShared();
  var uid2 = requireUid();
  var keys2 = shared2("keys");
  sharedKey = function(key) {
    return keys2[key] || (keys2[key] = uid2(key));
  };
  return sharedKey;
}
var hiddenKeys;
var hasRequiredHiddenKeys;
function requireHiddenKeys() {
  if (hasRequiredHiddenKeys) return hiddenKeys;
  hasRequiredHiddenKeys = 1;
  hiddenKeys = {};
  return hiddenKeys;
}
var internalState;
var hasRequiredInternalState;
function requireInternalState() {
  if (hasRequiredInternalState) return internalState;
  hasRequiredInternalState = 1;
  var NATIVE_WEAK_MAP = requireWeakMapBasicDetection();
  var globalThis2 = requireGlobalThis();
  var isObject2 = requireIsObject();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var hasOwn = requireHasOwnProperty();
  var shared2 = requireSharedStore();
  var sharedKey2 = requireSharedKey();
  var hiddenKeys2 = requireHiddenKeys();
  var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
  var TypeError2 = globalThis2.TypeError;
  var WeakMap = globalThis2.WeakMap;
  var set, get, has;
  var enforce = function(it2) {
    return has(it2) ? get(it2) : set(it2, {});
  };
  var getterFor = function(TYPE2) {
    return function(it2) {
      var state;
      if (!isObject2(it2) || (state = get(it2)).type !== TYPE2) {
        throw new TypeError2("Incompatible receiver, " + TYPE2 + " required");
      }
      return state;
    };
  };
  if (NATIVE_WEAK_MAP || shared2.state) {
    var store = shared2.state || (shared2.state = new WeakMap());
    store.get = store.get;
    store.has = store.has;
    store.set = store.set;
    set = function(it2, metadata) {
      if (store.has(it2)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it2;
      store.set(it2, metadata);
      return metadata;
    };
    get = function(it2) {
      return store.get(it2) || {};
    };
    has = function(it2) {
      return store.has(it2);
    };
  } else {
    var STATE = sharedKey2("state");
    hiddenKeys2[STATE] = true;
    set = function(it2, metadata) {
      if (hasOwn(it2, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
      metadata.facade = it2;
      createNonEnumerableProperty2(it2, STATE, metadata);
      return metadata;
    };
    get = function(it2) {
      return hasOwn(it2, STATE) ? it2[STATE] : {};
    };
    has = function(it2) {
      return hasOwn(it2, STATE);
    };
  }
  internalState = {
    set,
    get,
    has,
    enforce,
    getterFor
  };
  return internalState;
}
var hasRequiredMakeBuiltIn;
function requireMakeBuiltIn() {
  if (hasRequiredMakeBuiltIn) return makeBuiltIn.exports;
  hasRequiredMakeBuiltIn = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var hasOwn = requireHasOwnProperty();
  var DESCRIPTORS = requireDescriptors();
  var CONFIGURABLE_FUNCTION_NAME = requireFunctionName().CONFIGURABLE;
  var inspectSource2 = requireInspectSource();
  var InternalStateModule = requireInternalState();
  var enforceInternalState = InternalStateModule.enforce;
  var getInternalState = InternalStateModule.get;
  var $String = String;
  var defineProperty = Object.defineProperty;
  var stringSlice = uncurryThis("".slice);
  var replace = uncurryThis("".replace);
  var join = uncurryThis([].join);
  var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails2(function() {
    return defineProperty(function() {
    }, "length", { value: 8 }).length !== 8;
  });
  var TEMPLATE = String(String).split("String");
  var makeBuiltIn$1 = makeBuiltIn.exports = function(value, name, options) {
    if (stringSlice($String(name), 0, 7) === "Symbol(") {
      name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
    }
    if (options && options.getter) name = "get " + name;
    if (options && options.setter) name = "set " + name;
    if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
      if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
      else value.name = name;
    }
    if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
      defineProperty(value, "length", { value: options.arity });
    }
    try {
      if (options && hasOwn(options, "constructor") && options.constructor) {
        if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
      } else if (value.prototype) value.prototype = void 0;
    } catch (error) {
    }
    var state = enforceInternalState(value);
    if (!hasOwn(state, "source")) {
      state.source = join(TEMPLATE, typeof name == "string" ? name : "");
    }
    return value;
  };
  Function.prototype.toString = makeBuiltIn$1(function toString3() {
    return isCallable2(this) && getInternalState(this).source || inspectSource2(this);
  }, "toString");
  return makeBuiltIn.exports;
}
var defineBuiltIn;
var hasRequiredDefineBuiltIn;
function requireDefineBuiltIn() {
  if (hasRequiredDefineBuiltIn) return defineBuiltIn;
  hasRequiredDefineBuiltIn = 1;
  var isCallable2 = requireIsCallable();
  var definePropertyModule = requireObjectDefineProperty();
  var makeBuiltIn2 = requireMakeBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  defineBuiltIn = function(O2, key, value, options) {
    if (!options) options = {};
    var simple = options.enumerable;
    var name = options.name !== void 0 ? options.name : key;
    if (isCallable2(value)) makeBuiltIn2(value, name, options);
    if (options.global) {
      if (simple) O2[key] = value;
      else defineGlobalProperty2(key, value);
    } else {
      try {
        if (!options.unsafe) delete O2[key];
        else if (O2[key]) simple = true;
      } catch (error) {
      }
      if (simple) O2[key] = value;
      else definePropertyModule.f(O2, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
    }
    return O2;
  };
  return defineBuiltIn;
}
var objectGetOwnPropertyNames = {};
var mathTrunc;
var hasRequiredMathTrunc;
function requireMathTrunc() {
  if (hasRequiredMathTrunc) return mathTrunc;
  hasRequiredMathTrunc = 1;
  var ceil = Math.ceil;
  var floor = Math.floor;
  mathTrunc = Math.trunc || function trunc(x2) {
    var n2 = +x2;
    return (n2 > 0 ? floor : ceil)(n2);
  };
  return mathTrunc;
}
var toIntegerOrInfinity;
var hasRequiredToIntegerOrInfinity;
function requireToIntegerOrInfinity() {
  if (hasRequiredToIntegerOrInfinity) return toIntegerOrInfinity;
  hasRequiredToIntegerOrInfinity = 1;
  var trunc = requireMathTrunc();
  toIntegerOrInfinity = function(argument) {
    var number = +argument;
    return number !== number || number === 0 ? 0 : trunc(number);
  };
  return toIntegerOrInfinity;
}
var toAbsoluteIndex;
var hasRequiredToAbsoluteIndex;
function requireToAbsoluteIndex() {
  if (hasRequiredToAbsoluteIndex) return toAbsoluteIndex;
  hasRequiredToAbsoluteIndex = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var max = Math.max;
  var min = Math.min;
  toAbsoluteIndex = function(index2, length) {
    var integer = toIntegerOrInfinity2(index2);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
  };
  return toAbsoluteIndex;
}
var toLength;
var hasRequiredToLength;
function requireToLength() {
  if (hasRequiredToLength) return toLength;
  hasRequiredToLength = 1;
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var min = Math.min;
  toLength = function(argument) {
    var len = toIntegerOrInfinity2(argument);
    return len > 0 ? min(len, 9007199254740991) : 0;
  };
  return toLength;
}
var lengthOfArrayLike;
var hasRequiredLengthOfArrayLike;
function requireLengthOfArrayLike() {
  if (hasRequiredLengthOfArrayLike) return lengthOfArrayLike;
  hasRequiredLengthOfArrayLike = 1;
  var toLength2 = requireToLength();
  lengthOfArrayLike = function(obj) {
    return toLength2(obj.length);
  };
  return lengthOfArrayLike;
}
var arrayIncludes;
var hasRequiredArrayIncludes;
function requireArrayIncludes() {
  if (hasRequiredArrayIncludes) return arrayIncludes;
  hasRequiredArrayIncludes = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var toAbsoluteIndex2 = requireToAbsoluteIndex();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
      var O2 = toIndexedObject2($this);
      var length = lengthOfArrayLike2(O2);
      if (length === 0) return !IS_INCLUDES && -1;
      var index2 = toAbsoluteIndex2(fromIndex, length);
      var value;
      if (IS_INCLUDES && el !== el) while (length > index2) {
        value = O2[index2++];
        if (value !== value) return true;
      }
      else for (; length > index2; index2++) {
        if ((IS_INCLUDES || index2 in O2) && O2[index2] === el) return IS_INCLUDES || index2 || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };
  arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };
  return arrayIncludes;
}
var objectKeysInternal;
var hasRequiredObjectKeysInternal;
function requireObjectKeysInternal() {
  if (hasRequiredObjectKeysInternal) return objectKeysInternal;
  hasRequiredObjectKeysInternal = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var hasOwn = requireHasOwnProperty();
  var toIndexedObject2 = requireToIndexedObject();
  var indexOf = requireArrayIncludes().indexOf;
  var hiddenKeys2 = requireHiddenKeys();
  var push = uncurryThis([].push);
  objectKeysInternal = function(object, names) {
    var O2 = toIndexedObject2(object);
    var i2 = 0;
    var result = [];
    var key;
    for (key in O2) !hasOwn(hiddenKeys2, key) && hasOwn(O2, key) && push(result, key);
    while (names.length > i2) if (hasOwn(O2, key = names[i2++])) {
      ~indexOf(result, key) || push(result, key);
    }
    return result;
  };
  return objectKeysInternal;
}
var enumBugKeys;
var hasRequiredEnumBugKeys;
function requireEnumBugKeys() {
  if (hasRequiredEnumBugKeys) return enumBugKeys;
  hasRequiredEnumBugKeys = 1;
  enumBugKeys = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ];
  return enumBugKeys;
}
var hasRequiredObjectGetOwnPropertyNames;
function requireObjectGetOwnPropertyNames() {
  if (hasRequiredObjectGetOwnPropertyNames) return objectGetOwnPropertyNames;
  hasRequiredObjectGetOwnPropertyNames = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = enumBugKeys2.concat("length", "prototype");
  objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
    return internalObjectKeys(O2, hiddenKeys2);
  };
  return objectGetOwnPropertyNames;
}
var objectGetOwnPropertySymbols = {};
var hasRequiredObjectGetOwnPropertySymbols;
function requireObjectGetOwnPropertySymbols() {
  if (hasRequiredObjectGetOwnPropertySymbols) return objectGetOwnPropertySymbols;
  hasRequiredObjectGetOwnPropertySymbols = 1;
  objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
  return objectGetOwnPropertySymbols;
}
var ownKeys$3;
var hasRequiredOwnKeys;
function requireOwnKeys() {
  if (hasRequiredOwnKeys) return ownKeys$3;
  hasRequiredOwnKeys = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var uncurryThis = requireFunctionUncurryThis();
  var getOwnPropertyNamesModule = requireObjectGetOwnPropertyNames();
  var getOwnPropertySymbolsModule = requireObjectGetOwnPropertySymbols();
  var anObject2 = requireAnObject();
  var concat = uncurryThis([].concat);
  ownKeys$3 = getBuiltIn2("Reflect", "ownKeys") || function ownKeys2(it2) {
    var keys2 = getOwnPropertyNamesModule.f(anObject2(it2));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it2)) : keys2;
  };
  return ownKeys$3;
}
var copyConstructorProperties;
var hasRequiredCopyConstructorProperties;
function requireCopyConstructorProperties() {
  if (hasRequiredCopyConstructorProperties) return copyConstructorProperties;
  hasRequiredCopyConstructorProperties = 1;
  var hasOwn = requireHasOwnProperty();
  var ownKeys2 = requireOwnKeys();
  var getOwnPropertyDescriptorModule = requireObjectGetOwnPropertyDescriptor();
  var definePropertyModule = requireObjectDefineProperty();
  copyConstructorProperties = function(target, source, exceptions) {
    var keys2 = ownKeys2(source);
    var defineProperty = definePropertyModule.f;
    var getOwnPropertyDescriptor2 = getOwnPropertyDescriptorModule.f;
    for (var i2 = 0; i2 < keys2.length; i2++) {
      var key = keys2[i2];
      if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
        defineProperty(target, key, getOwnPropertyDescriptor2(source, key));
      }
    }
  };
  return copyConstructorProperties;
}
var isForced_1;
var hasRequiredIsForced;
function requireIsForced() {
  if (hasRequiredIsForced) return isForced_1;
  hasRequiredIsForced = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var replacement = /#|\.prototype\./;
  var isForced = function(feature, detection) {
    var value = data[normalize(feature)];
    return value === POLYFILL ? true : value === NATIVE ? false : isCallable2(detection) ? fails2(detection) : !!detection;
  };
  var normalize = isForced.normalize = function(string) {
    return String(string).replace(replacement, ".").toLowerCase();
  };
  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = "N";
  var POLYFILL = isForced.POLYFILL = "P";
  isForced_1 = isForced;
  return isForced_1;
}
var _export;
var hasRequired_export;
function require_export() {
  if (hasRequired_export) return _export;
  hasRequired_export = 1;
  var globalThis2 = requireGlobalThis();
  var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var defineGlobalProperty2 = requireDefineGlobalProperty();
  var copyConstructorProperties2 = requireCopyConstructorProperties();
  var isForced = requireIsForced();
  _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = globalThis2;
    } else if (STATIC) {
      target = globalThis2[TARGET] || defineGlobalProperty2(TARGET, {});
    } else {
      target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor2(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty) continue;
        copyConstructorProperties2(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty2(sourceProperty, "sham", true);
      }
      defineBuiltIn2(target, key, sourceProperty, options);
    }
  };
  return _export;
}
var environment;
var hasRequiredEnvironment;
function requireEnvironment() {
  if (hasRequiredEnvironment) return environment;
  hasRequiredEnvironment = 1;
  var globalThis2 = requireGlobalThis();
  var userAgent = requireEnvironmentUserAgent();
  var classof2 = requireClassofRaw();
  var userAgentStartsWith = function(string) {
    return userAgent.slice(0, string.length) === string;
  };
  environment = (function() {
    if (userAgentStartsWith("Bun/")) return "BUN";
    if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
    if (userAgentStartsWith("Deno/")) return "DENO";
    if (userAgentStartsWith("Node.js/")) return "NODE";
    if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
    if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
    if (classof2(globalThis2.process) === "process") return "NODE";
    if (globalThis2.window && globalThis2.document) return "BROWSER";
    return "REST";
  })();
  return environment;
}
var environmentIsNode;
var hasRequiredEnvironmentIsNode;
function requireEnvironmentIsNode() {
  if (hasRequiredEnvironmentIsNode) return environmentIsNode;
  hasRequiredEnvironmentIsNode = 1;
  var ENVIRONMENT = requireEnvironment();
  environmentIsNode = ENVIRONMENT === "NODE";
  return environmentIsNode;
}
var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  var globalThis2 = requireGlobalThis();
  path = globalThis2;
  return path;
}
var functionUncurryThisAccessor;
var hasRequiredFunctionUncurryThisAccessor;
function requireFunctionUncurryThisAccessor() {
  if (hasRequiredFunctionUncurryThisAccessor) return functionUncurryThisAccessor;
  hasRequiredFunctionUncurryThisAccessor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var aCallable2 = requireACallable();
  functionUncurryThisAccessor = function(object, key, method) {
    try {
      return uncurryThis(aCallable2(Object.getOwnPropertyDescriptor(object, key)[method]));
    } catch (error) {
    }
  };
  return functionUncurryThisAccessor;
}
var isPossiblePrototype;
var hasRequiredIsPossiblePrototype;
function requireIsPossiblePrototype() {
  if (hasRequiredIsPossiblePrototype) return isPossiblePrototype;
  hasRequiredIsPossiblePrototype = 1;
  var isObject2 = requireIsObject();
  isPossiblePrototype = function(argument) {
    return isObject2(argument) || argument === null;
  };
  return isPossiblePrototype;
}
var aPossiblePrototype;
var hasRequiredAPossiblePrototype;
function requireAPossiblePrototype() {
  if (hasRequiredAPossiblePrototype) return aPossiblePrototype;
  hasRequiredAPossiblePrototype = 1;
  var isPossiblePrototype2 = requireIsPossiblePrototype();
  var $String = String;
  var $TypeError = TypeError;
  aPossiblePrototype = function(argument) {
    if (isPossiblePrototype2(argument)) return argument;
    throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
  };
  return aPossiblePrototype;
}
var objectSetPrototypeOf;
var hasRequiredObjectSetPrototypeOf;
function requireObjectSetPrototypeOf() {
  if (hasRequiredObjectSetPrototypeOf) return objectSetPrototypeOf;
  hasRequiredObjectSetPrototypeOf = 1;
  var uncurryThisAccessor = requireFunctionUncurryThisAccessor();
  var isObject2 = requireIsObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var aPossiblePrototype2 = requireAPossiblePrototype();
  objectSetPrototypeOf = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
    var CORRECT_SETTER = false;
    var test2 = {};
    var setter;
    try {
      setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
      setter(test2, []);
      CORRECT_SETTER = test2 instanceof Array;
    } catch (error) {
    }
    return function setPrototypeOf2(O2, proto) {
      requireObjectCoercible2(O2);
      aPossiblePrototype2(proto);
      if (!isObject2(O2)) return O2;
      if (CORRECT_SETTER) setter(O2, proto);
      else O2.__proto__ = proto;
      return O2;
    };
  })() : void 0);
  return objectSetPrototypeOf;
}
var setToStringTag;
var hasRequiredSetToStringTag;
function requireSetToStringTag() {
  if (hasRequiredSetToStringTag) return setToStringTag;
  hasRequiredSetToStringTag = 1;
  var defineProperty = requireObjectDefineProperty().f;
  var hasOwn = requireHasOwnProperty();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  setToStringTag = function(target, TAG, STATIC) {
    if (target && !STATIC) target = target.prototype;
    if (target && !hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
  };
  return setToStringTag;
}
var defineBuiltInAccessor;
var hasRequiredDefineBuiltInAccessor;
function requireDefineBuiltInAccessor() {
  if (hasRequiredDefineBuiltInAccessor) return defineBuiltInAccessor;
  hasRequiredDefineBuiltInAccessor = 1;
  var makeBuiltIn2 = requireMakeBuiltIn();
  var defineProperty = requireObjectDefineProperty();
  defineBuiltInAccessor = function(target, name, descriptor) {
    if (descriptor.get) makeBuiltIn2(descriptor.get, name, { getter: true });
    if (descriptor.set) makeBuiltIn2(descriptor.set, name, { setter: true });
    return defineProperty.f(target, name, descriptor);
  };
  return defineBuiltInAccessor;
}
var setSpecies;
var hasRequiredSetSpecies;
function requireSetSpecies() {
  if (hasRequiredSetSpecies) return setSpecies;
  hasRequiredSetSpecies = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  var defineBuiltInAccessor2 = requireDefineBuiltInAccessor();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var DESCRIPTORS = requireDescriptors();
  var SPECIES = wellKnownSymbol2("species");
  setSpecies = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn2(CONSTRUCTOR_NAME);
    if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
      defineBuiltInAccessor2(Constructor, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
    }
  };
  return setSpecies;
}
var anInstance;
var hasRequiredAnInstance;
function requireAnInstance() {
  if (hasRequiredAnInstance) return anInstance;
  hasRequiredAnInstance = 1;
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var $TypeError = TypeError;
  anInstance = function(it2, Prototype) {
    if (isPrototypeOf(Prototype, it2)) return it2;
    throw new $TypeError("Incorrect invocation");
  };
  return anInstance;
}
var toStringTagSupport;
var hasRequiredToStringTagSupport;
function requireToStringTagSupport() {
  if (hasRequiredToStringTagSupport) return toStringTagSupport;
  hasRequiredToStringTagSupport = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var test2 = {};
  test2[TO_STRING_TAG] = "z";
  toStringTagSupport = String(test2) === "[object z]";
  return toStringTagSupport;
}
var classof;
var hasRequiredClassof;
function requireClassof() {
  if (hasRequiredClassof) return classof;
  hasRequiredClassof = 1;
  var TO_STRING_TAG_SUPPORT = requireToStringTagSupport();
  var isCallable2 = requireIsCallable();
  var classofRaw2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var TO_STRING_TAG = wellKnownSymbol2("toStringTag");
  var $Object = Object;
  var CORRECT_ARGUMENTS = classofRaw2(/* @__PURE__ */ (function() {
    return arguments;
  })()) === "Arguments";
  var tryGet = function(it2, key) {
    try {
      return it2[key];
    } catch (error) {
    }
  };
  classof = TO_STRING_TAG_SUPPORT ? classofRaw2 : function(it2) {
    var O2, tag, result;
    return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw2(O2) : (result = classofRaw2(O2)) === "Object" && isCallable2(O2.callee) ? "Arguments" : result;
  };
  return classof;
}
var isConstructor;
var hasRequiredIsConstructor;
function requireIsConstructor() {
  if (hasRequiredIsConstructor) return isConstructor;
  hasRequiredIsConstructor = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassof();
  var getBuiltIn2 = requireGetBuiltIn();
  var inspectSource2 = requireInspectSource();
  var noop2 = function() {
  };
  var construct2 = getBuiltIn2("Reflect", "construct");
  var constructorRegExp = /^\s*(?:class|function)\b/;
  var exec = uncurryThis(constructorRegExp.exec);
  var INCORRECT_TO_STRING = !constructorRegExp.test(noop2);
  var isConstructorModern = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    try {
      construct2(noop2, [], argument);
      return true;
    } catch (error) {
      return false;
    }
  };
  var isConstructorLegacy = function isConstructor2(argument) {
    if (!isCallable2(argument)) return false;
    switch (classof2(argument)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource2(argument));
    } catch (error) {
      return true;
    }
  };
  isConstructorLegacy.sham = true;
  isConstructor = !construct2 || fails2(function() {
    var called;
    return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
      called = true;
    }) || called;
  }) ? isConstructorLegacy : isConstructorModern;
  return isConstructor;
}
var aConstructor;
var hasRequiredAConstructor;
function requireAConstructor() {
  if (hasRequiredAConstructor) return aConstructor;
  hasRequiredAConstructor = 1;
  var isConstructor2 = requireIsConstructor();
  var tryToString2 = requireTryToString();
  var $TypeError = TypeError;
  aConstructor = function(argument) {
    if (isConstructor2(argument)) return argument;
    throw new $TypeError(tryToString2(argument) + " is not a constructor");
  };
  return aConstructor;
}
var speciesConstructor;
var hasRequiredSpeciesConstructor;
function requireSpeciesConstructor() {
  if (hasRequiredSpeciesConstructor) return speciesConstructor;
  hasRequiredSpeciesConstructor = 1;
  var anObject2 = requireAnObject();
  var aConstructor2 = requireAConstructor();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var SPECIES = wellKnownSymbol2("species");
  speciesConstructor = function(O2, defaultConstructor) {
    var C2 = anObject2(O2).constructor;
    var S2;
    return C2 === void 0 || isNullOrUndefined2(S2 = anObject2(C2)[SPECIES]) ? defaultConstructor : aConstructor2(S2);
  };
  return speciesConstructor;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  var NATIVE_BIND = requireFunctionBindNative();
  var FunctionPrototype = Function.prototype;
  var apply2 = FunctionPrototype.apply;
  var call = FunctionPrototype.call;
  functionApply = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply2) : function() {
    return call.apply(apply2, arguments);
  });
  return functionApply;
}
var functionUncurryThisClause;
var hasRequiredFunctionUncurryThisClause;
function requireFunctionUncurryThisClause() {
  if (hasRequiredFunctionUncurryThisClause) return functionUncurryThisClause;
  hasRequiredFunctionUncurryThisClause = 1;
  var classofRaw2 = requireClassofRaw();
  var uncurryThis = requireFunctionUncurryThis();
  functionUncurryThisClause = function(fn) {
    if (classofRaw2(fn) === "Function") return uncurryThis(fn);
  };
  return functionUncurryThisClause;
}
var functionBindContext;
var hasRequiredFunctionBindContext;
function requireFunctionBindContext() {
  if (hasRequiredFunctionBindContext) return functionBindContext;
  hasRequiredFunctionBindContext = 1;
  var uncurryThis = requireFunctionUncurryThisClause();
  var aCallable2 = requireACallable();
  var NATIVE_BIND = requireFunctionBindNative();
  var bind2 = uncurryThis(uncurryThis.bind);
  functionBindContext = function(fn, that) {
    aCallable2(fn);
    return that === void 0 ? fn : NATIVE_BIND ? bind2(fn, that) : function() {
      return fn.apply(that, arguments);
    };
  };
  return functionBindContext;
}
var html;
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var getBuiltIn2 = requireGetBuiltIn();
  html = getBuiltIn2("document", "documentElement");
  return html;
}
var arraySlice;
var hasRequiredArraySlice;
function requireArraySlice() {
  if (hasRequiredArraySlice) return arraySlice;
  hasRequiredArraySlice = 1;
  var uncurryThis = requireFunctionUncurryThis();
  arraySlice = uncurryThis([].slice);
  return arraySlice;
}
var validateArgumentsLength;
var hasRequiredValidateArgumentsLength;
function requireValidateArgumentsLength() {
  if (hasRequiredValidateArgumentsLength) return validateArgumentsLength;
  hasRequiredValidateArgumentsLength = 1;
  var $TypeError = TypeError;
  validateArgumentsLength = function(passed, required) {
    if (passed < required) throw new $TypeError("Not enough arguments");
    return passed;
  };
  return validateArgumentsLength;
}
var environmentIsIos;
var hasRequiredEnvironmentIsIos;
function requireEnvironmentIsIos() {
  if (hasRequiredEnvironmentIsIos) return environmentIsIos;
  hasRequiredEnvironmentIsIos = 1;
  var userAgent = requireEnvironmentUserAgent();
  environmentIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);
  return environmentIsIos;
}
var task;
var hasRequiredTask;
function requireTask() {
  if (hasRequiredTask) return task;
  hasRequiredTask = 1;
  var globalThis2 = requireGlobalThis();
  var apply2 = requireFunctionApply();
  var bind2 = requireFunctionBindContext();
  var isCallable2 = requireIsCallable();
  var hasOwn = requireHasOwnProperty();
  var fails2 = requireFails();
  var html2 = requireHtml();
  var arraySlice2 = requireArraySlice();
  var createElement = requireDocumentCreateElement();
  var validateArgumentsLength2 = requireValidateArgumentsLength();
  var IS_IOS = requireEnvironmentIsIos();
  var IS_NODE = requireEnvironmentIsNode();
  var set = globalThis2.setImmediate;
  var clear = globalThis2.clearImmediate;
  var process2 = globalThis2.process;
  var Dispatch = globalThis2.Dispatch;
  var Function2 = globalThis2.Function;
  var MessageChannel2 = globalThis2.MessageChannel;
  var String2 = globalThis2.String;
  var counter = 0;
  var queue2 = {};
  var ONREADYSTATECHANGE = "onreadystatechange";
  var $location, defer, channel, port;
  fails2(function() {
    $location = globalThis2.location;
  });
  var run = function(id) {
    if (hasOwn(queue2, id)) {
      var fn = queue2[id];
      delete queue2[id];
      fn();
    }
  };
  var runner = function(id) {
    return function() {
      run(id);
    };
  };
  var eventListener = function(event) {
    run(event.data);
  };
  var globalPostMessageDefer = function(id) {
    globalThis2.postMessage(String2(id), $location.protocol + "//" + $location.host);
  };
  if (!set || !clear) {
    set = function setImmediate2(handler) {
      validateArgumentsLength2(arguments.length, 1);
      var fn = isCallable2(handler) ? handler : Function2(handler);
      var args = arraySlice2(arguments, 1);
      queue2[++counter] = function() {
        apply2(fn, void 0, args);
      };
      defer(counter);
      return counter;
    };
    clear = function clearImmediate(id) {
      delete queue2[id];
    };
    if (IS_NODE) {
      defer = function(id) {
        process2.nextTick(runner(id));
      };
    } else if (Dispatch && Dispatch.now) {
      defer = function(id) {
        Dispatch.now(runner(id));
      };
    } else if (MessageChannel2 && !IS_IOS) {
      channel = new MessageChannel2();
      port = channel.port2;
      channel.port1.onmessage = eventListener;
      defer = bind2(port.postMessage, port);
    } else if (globalThis2.addEventListener && isCallable2(globalThis2.postMessage) && !globalThis2.importScripts && $location && $location.protocol !== "file:" && !fails2(globalPostMessageDefer)) {
      defer = globalPostMessageDefer;
      globalThis2.addEventListener("message", eventListener, false);
    } else if (ONREADYSTATECHANGE in createElement("script")) {
      defer = function(id) {
        html2.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
          html2.removeChild(this);
          run(id);
        };
      };
    } else {
      defer = function(id) {
        setTimeout(runner(id), 0);
      };
    }
  }
  task = {
    set,
    clear
  };
  return task;
}
var safeGetBuiltIn;
var hasRequiredSafeGetBuiltIn;
function requireSafeGetBuiltIn() {
  if (hasRequiredSafeGetBuiltIn) return safeGetBuiltIn;
  hasRequiredSafeGetBuiltIn = 1;
  var globalThis2 = requireGlobalThis();
  var DESCRIPTORS = requireDescriptors();
  var getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
  safeGetBuiltIn = function(name) {
    if (!DESCRIPTORS) return globalThis2[name];
    var descriptor = getOwnPropertyDescriptor2(globalThis2, name);
    return descriptor && descriptor.value;
  };
  return safeGetBuiltIn;
}
var queue;
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  var Queue = function() {
    this.head = null;
    this.tail = null;
  };
  Queue.prototype = {
    add: function(item) {
      var entry = { item, next: null };
      var tail = this.tail;
      if (tail) tail.next = entry;
      else this.head = entry;
      this.tail = entry;
    },
    get: function() {
      var entry = this.head;
      if (entry) {
        var next = this.head = entry.next;
        if (next === null) this.tail = null;
        return entry.item;
      }
    }
  };
  queue = Queue;
  return queue;
}
var environmentIsIosPebble;
var hasRequiredEnvironmentIsIosPebble;
function requireEnvironmentIsIosPebble() {
  if (hasRequiredEnvironmentIsIosPebble) return environmentIsIosPebble;
  hasRequiredEnvironmentIsIosPebble = 1;
  var userAgent = requireEnvironmentUserAgent();
  environmentIsIosPebble = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != "undefined";
  return environmentIsIosPebble;
}
var environmentIsWebosWebkit;
var hasRequiredEnvironmentIsWebosWebkit;
function requireEnvironmentIsWebosWebkit() {
  if (hasRequiredEnvironmentIsWebosWebkit) return environmentIsWebosWebkit;
  hasRequiredEnvironmentIsWebosWebkit = 1;
  var userAgent = requireEnvironmentUserAgent();
  environmentIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);
  return environmentIsWebosWebkit;
}
var microtask_1;
var hasRequiredMicrotask;
function requireMicrotask() {
  if (hasRequiredMicrotask) return microtask_1;
  hasRequiredMicrotask = 1;
  var globalThis2 = requireGlobalThis();
  var safeGetBuiltIn2 = requireSafeGetBuiltIn();
  var bind2 = requireFunctionBindContext();
  var macrotask = requireTask().set;
  var Queue = requireQueue();
  var IS_IOS = requireEnvironmentIsIos();
  var IS_IOS_PEBBLE = requireEnvironmentIsIosPebble();
  var IS_WEBOS_WEBKIT = requireEnvironmentIsWebosWebkit();
  var IS_NODE = requireEnvironmentIsNode();
  var MutationObserver = globalThis2.MutationObserver || globalThis2.WebKitMutationObserver;
  var document2 = globalThis2.document;
  var process2 = globalThis2.process;
  var Promise2 = globalThis2.Promise;
  var microtask = safeGetBuiltIn2("queueMicrotask");
  var notify, toggle, node2, promise, then;
  if (!microtask) {
    var queue2 = new Queue();
    var flush = function() {
      var parent, fn;
      if (IS_NODE && (parent = process2.domain)) parent.exit();
      while (fn = queue2.get()) try {
        fn();
      } catch (error) {
        if (queue2.head) notify();
        throw error;
      }
      if (parent) parent.enter();
    };
    if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document2) {
      toggle = true;
      node2 = document2.createTextNode("");
      new MutationObserver(flush).observe(node2, { characterData: true });
      notify = function() {
        node2.data = toggle = !toggle;
      };
    } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
      promise = Promise2.resolve(void 0);
      promise.constructor = Promise2;
      then = bind2(promise.then, promise);
      notify = function() {
        then(flush);
      };
    } else if (IS_NODE) {
      notify = function() {
        process2.nextTick(flush);
      };
    } else {
      macrotask = bind2(macrotask, globalThis2);
      notify = function() {
        macrotask(flush);
      };
    }
    microtask = function(fn) {
      if (!queue2.head) notify();
      queue2.add(fn);
    };
  }
  microtask_1 = microtask;
  return microtask_1;
}
var hostReportErrors;
var hasRequiredHostReportErrors;
function requireHostReportErrors() {
  if (hasRequiredHostReportErrors) return hostReportErrors;
  hasRequiredHostReportErrors = 1;
  hostReportErrors = function(a2, b2) {
    try {
      arguments.length === 1 ? console.error(a2) : console.error(a2, b2);
    } catch (error) {
    }
  };
  return hostReportErrors;
}
var perform;
var hasRequiredPerform;
function requirePerform() {
  if (hasRequiredPerform) return perform;
  hasRequiredPerform = 1;
  perform = function(exec) {
    try {
      return { error: false, value: exec() };
    } catch (error) {
      return { error: true, value: error };
    }
  };
  return perform;
}
var promiseNativeConstructor;
var hasRequiredPromiseNativeConstructor;
function requirePromiseNativeConstructor() {
  if (hasRequiredPromiseNativeConstructor) return promiseNativeConstructor;
  hasRequiredPromiseNativeConstructor = 1;
  var globalThis2 = requireGlobalThis();
  promiseNativeConstructor = globalThis2.Promise;
  return promiseNativeConstructor;
}
var promiseConstructorDetection;
var hasRequiredPromiseConstructorDetection;
function requirePromiseConstructorDetection() {
  if (hasRequiredPromiseConstructorDetection) return promiseConstructorDetection;
  hasRequiredPromiseConstructorDetection = 1;
  var globalThis2 = requireGlobalThis();
  var NativePromiseConstructor = requirePromiseNativeConstructor();
  var isCallable2 = requireIsCallable();
  var isForced = requireIsForced();
  var inspectSource2 = requireInspectSource();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ENVIRONMENT = requireEnvironment();
  var IS_PURE = requireIsPure();
  var V8_VERSION = requireEnvironmentV8Version();
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  var SPECIES = wellKnownSymbol2("species");
  var SUBCLASSING = false;
  var NATIVE_PROMISE_REJECTION_EVENT = isCallable2(globalThis2.PromiseRejectionEvent);
  var FORCED_PROMISE_CONSTRUCTOR = isForced("Promise", function() {
    var PROMISE_CONSTRUCTOR_SOURCE = inspectSource2(NativePromiseConstructor);
    var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;
    if (IS_PURE && !(NativePromisePrototype["catch"] && NativePromisePrototype["finally"])) return true;
    if (!V8_VERSION || V8_VERSION < 51 || !/native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) {
      var promise = new NativePromiseConstructor(function(resolve) {
        resolve(1);
      });
      var FakePromise = function(exec) {
        exec(function() {
        }, function() {
        });
      };
      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      SUBCLASSING = promise.then(function() {
      }) instanceof FakePromise;
      if (!SUBCLASSING) return true;
    }
    return !GLOBAL_CORE_JS_PROMISE && (ENVIRONMENT === "BROWSER" || ENVIRONMENT === "DENO") && !NATIVE_PROMISE_REJECTION_EVENT;
  });
  promiseConstructorDetection = {
    CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR,
    REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT,
    SUBCLASSING
  };
  return promiseConstructorDetection;
}
var newPromiseCapability = {};
var hasRequiredNewPromiseCapability;
function requireNewPromiseCapability() {
  if (hasRequiredNewPromiseCapability) return newPromiseCapability;
  hasRequiredNewPromiseCapability = 1;
  var aCallable2 = requireACallable();
  var $TypeError = TypeError;
  var PromiseCapability = function(C2) {
    var resolve, reject;
    this.promise = new C2(function($$resolve, $$reject) {
      if (resolve !== void 0 || reject !== void 0) throw new $TypeError("Bad Promise constructor");
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aCallable2(resolve);
    this.reject = aCallable2(reject);
  };
  newPromiseCapability.f = function(C2) {
    return new PromiseCapability(C2);
  };
  return newPromiseCapability;
}
var hasRequiredEs_promise_constructor;
function requireEs_promise_constructor() {
  if (hasRequiredEs_promise_constructor) return es_promise_constructor;
  hasRequiredEs_promise_constructor = 1;
  var $2 = require_export();
  var IS_PURE = requireIsPure();
  var IS_NODE = requireEnvironmentIsNode();
  var globalThis2 = requireGlobalThis();
  var path2 = requirePath();
  var call = requireFunctionCall();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var setPrototypeOf2 = requireObjectSetPrototypeOf();
  var setToStringTag2 = requireSetToStringTag();
  var setSpecies2 = requireSetSpecies();
  var aCallable2 = requireACallable();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var anInstance2 = requireAnInstance();
  var speciesConstructor2 = requireSpeciesConstructor();
  var task2 = requireTask().set;
  var microtask = requireMicrotask();
  var hostReportErrors2 = requireHostReportErrors();
  var perform2 = requirePerform();
  var Queue = requireQueue();
  var InternalStateModule = requireInternalState();
  var NativePromiseConstructor = requirePromiseNativeConstructor();
  var PromiseConstructorDetection = requirePromiseConstructorDetection();
  var newPromiseCapabilityModule = requireNewPromiseCapability();
  var PROMISE = "Promise";
  var FORCED_PROMISE_CONSTRUCTOR = PromiseConstructorDetection.CONSTRUCTOR;
  var NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;
  var NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;
  var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
  var setInternalState = InternalStateModule.set;
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  var PromiseConstructor = NativePromiseConstructor;
  var PromisePrototype = NativePromisePrototype;
  var TypeError2 = globalThis2.TypeError;
  var document2 = globalThis2.document;
  var process2 = globalThis2.process;
  var newPromiseCapability2 = newPromiseCapabilityModule.f;
  var newGenericPromiseCapability = newPromiseCapability2;
  var DISPATCH_EVENT = !!(document2 && document2.createEvent && globalThis2.dispatchEvent);
  var UNHANDLED_REJECTION = "unhandledrejection";
  var REJECTION_HANDLED = "rejectionhandled";
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
  var isThenable2 = function(it2) {
    var then;
    return isObject2(it2) && isCallable2(then = it2.then) ? then : false;
  };
  var callReaction = function(reaction, state) {
    var value = state.value;
    var ok = state.state === FULFILLED;
    var handler = ok ? reaction.ok : reaction.fail;
    var resolve = reaction.resolve;
    var reject = reaction.reject;
    var domain = reaction.domain;
    var result, then, exited;
    try {
      if (handler) {
        if (!ok) {
          if (state.rejection === UNHANDLED) onHandleUnhandled(state);
          state.rejection = HANDLED;
        }
        if (handler === true) result = value;
        else {
          if (domain) domain.enter();
          result = handler(value);
          if (domain) {
            domain.exit();
            exited = true;
          }
        }
        if (result === reaction.promise) {
          reject(new TypeError2("Promise-chain cycle"));
        } else if (then = isThenable2(result)) {
          call(then, result, resolve, reject);
        } else resolve(result);
      } else reject(value);
    } catch (error) {
      if (domain && !exited) domain.exit();
      reject(error);
    }
  };
  var notify = function(state, isReject) {
    if (state.notified) return;
    state.notified = true;
    microtask(function() {
      var reactions = state.reactions;
      var reaction;
      while (reaction = reactions.get()) {
        callReaction(reaction, state);
      }
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(state);
    });
  };
  var dispatchEvent = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
      event = document2.createEvent("Event");
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      globalThis2.dispatchEvent(event);
    } else event = { promise, reason };
    if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = globalThis2["on" + name])) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors2("Unhandled promise rejection", reason);
  };
  var onUnhandled = function(state) {
    call(task2, globalThis2, function() {
      var promise = state.facade;
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;
      if (IS_UNHANDLED) {
        result = perform2(function() {
          if (IS_NODE) {
            process2.emit("unhandledRejection", value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        });
        state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };
  var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
  };
  var onHandleUnhandled = function(state) {
    call(task2, globalThis2, function() {
      var promise = state.facade;
      if (IS_NODE) {
        process2.emit("rejectionHandled", promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };
  var bind2 = function(fn, state, unwrap) {
    return function(value) {
      fn(state, value, unwrap);
    };
  };
  var internalReject = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(state, true);
  };
  var internalResolve = function(state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
      if (state.facade === value) throw new TypeError2("Promise can't be resolved itself");
      var then = isThenable2(value);
      if (then) {
        microtask(function() {
          var wrapper = { done: false };
          try {
            call(
              then,
              value,
              bind2(internalResolve, wrapper, state),
              bind2(internalReject, wrapper, state)
            );
          } catch (error) {
            internalReject(wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify(state, false);
      }
    } catch (error) {
      internalReject({ done: false }, error, state);
    }
  };
  if (FORCED_PROMISE_CONSTRUCTOR) {
    PromiseConstructor = function Promise2(executor) {
      anInstance2(this, PromisePrototype);
      aCallable2(executor);
      call(Internal, this);
      var state = getInternalPromiseState(this);
      try {
        executor(bind2(internalResolve, state), bind2(internalReject, state));
      } catch (error) {
        internalReject(state, error);
      }
    };
    PromisePrototype = PromiseConstructor.prototype;
    Internal = function Promise2(executor) {
      setInternalState(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: new Queue(),
        rejection: false,
        state: PENDING,
        value: null
      });
    };
    Internal.prototype = defineBuiltIn2(PromisePrototype, "then", function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability2(speciesConstructor2(this, PromiseConstructor));
      state.parent = true;
      reaction.ok = isCallable2(onFulfilled) ? onFulfilled : true;
      reaction.fail = isCallable2(onRejected) && onRejected;
      reaction.domain = IS_NODE ? process2.domain : void 0;
      if (state.state === PENDING) state.reactions.add(reaction);
      else microtask(function() {
        callReaction(reaction, state);
      });
      return reaction.promise;
    });
    OwnPromiseCapability = function() {
      var promise = new Internal();
      var state = getInternalPromiseState(promise);
      this.promise = promise;
      this.resolve = bind2(internalResolve, state);
      this.reject = bind2(internalReject, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability2 = function(C2) {
      return C2 === PromiseConstructor || C2 === PromiseWrapper ? new OwnPromiseCapability(C2) : newGenericPromiseCapability(C2);
    };
    if (!IS_PURE && isCallable2(NativePromiseConstructor) && NativePromisePrototype !== Object.prototype) {
      nativeThen = NativePromisePrototype.then;
      if (!NATIVE_PROMISE_SUBCLASSING) {
        defineBuiltIn2(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function(resolve, reject) {
            call(nativeThen, that, resolve, reject);
          }).then(onFulfilled, onRejected);
        }, { unsafe: true });
      }
      try {
        delete NativePromisePrototype.constructor;
      } catch (error) {
      }
      if (setPrototypeOf2) {
        setPrototypeOf2(NativePromisePrototype, PromisePrototype);
      }
    }
  }
  $2({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
    Promise: PromiseConstructor
  });
  PromiseWrapper = path2.Promise;
  setToStringTag2(PromiseConstructor, PROMISE, false, true);
  setSpecies2(PROMISE);
  return es_promise_constructor;
}
var es_promise_all = {};
var iterators;
var hasRequiredIterators;
function requireIterators() {
  if (hasRequiredIterators) return iterators;
  hasRequiredIterators = 1;
  iterators = {};
  return iterators;
}
var isArrayIteratorMethod;
var hasRequiredIsArrayIteratorMethod;
function requireIsArrayIteratorMethod() {
  if (hasRequiredIsArrayIteratorMethod) return isArrayIteratorMethod;
  hasRequiredIsArrayIteratorMethod = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var ITERATOR = wellKnownSymbol2("iterator");
  var ArrayPrototype = Array.prototype;
  isArrayIteratorMethod = function(it2) {
    return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
  };
  return isArrayIteratorMethod;
}
var getIteratorMethod;
var hasRequiredGetIteratorMethod;
function requireGetIteratorMethod() {
  if (hasRequiredGetIteratorMethod) return getIteratorMethod;
  hasRequiredGetIteratorMethod = 1;
  var classof2 = requireClassof();
  var getMethod2 = requireGetMethod();
  var isNullOrUndefined2 = requireIsNullOrUndefined();
  var Iterators = requireIterators();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  getIteratorMethod = function(it2) {
    if (!isNullOrUndefined2(it2)) return getMethod2(it2, ITERATOR) || getMethod2(it2, "@@iterator") || Iterators[classof2(it2)];
  };
  return getIteratorMethod;
}
var getIterator;
var hasRequiredGetIterator;
function requireGetIterator() {
  if (hasRequiredGetIterator) return getIterator;
  hasRequiredGetIterator = 1;
  var call = requireFunctionCall();
  var aCallable2 = requireACallable();
  var anObject2 = requireAnObject();
  var tryToString2 = requireTryToString();
  var getIteratorMethod2 = requireGetIteratorMethod();
  var $TypeError = TypeError;
  getIterator = function(argument, usingIterator) {
    var iteratorMethod = arguments.length < 2 ? getIteratorMethod2(argument) : usingIterator;
    if (aCallable2(iteratorMethod)) return anObject2(call(iteratorMethod, argument));
    throw new $TypeError(tryToString2(argument) + " is not iterable");
  };
  return getIterator;
}
var iteratorClose;
var hasRequiredIteratorClose;
function requireIteratorClose() {
  if (hasRequiredIteratorClose) return iteratorClose;
  hasRequiredIteratorClose = 1;
  var call = requireFunctionCall();
  var anObject2 = requireAnObject();
  var getMethod2 = requireGetMethod();
  iteratorClose = function(iterator2, kind, value) {
    var innerResult, innerError;
    anObject2(iterator2);
    try {
      innerResult = getMethod2(iterator2, "return");
      if (!innerResult) {
        if (kind === "throw") throw value;
        return value;
      }
      innerResult = call(innerResult, iterator2);
    } catch (error) {
      innerError = true;
      innerResult = error;
    }
    if (kind === "throw") throw value;
    if (innerError) throw innerResult;
    anObject2(innerResult);
    return value;
  };
  return iteratorClose;
}
var iterate;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate;
  hasRequiredIterate = 1;
  var bind2 = requireFunctionBindContext();
  var call = requireFunctionCall();
  var anObject2 = requireAnObject();
  var tryToString2 = requireTryToString();
  var isArrayIteratorMethod2 = requireIsArrayIteratorMethod();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var getIterator2 = requireGetIterator();
  var getIteratorMethod2 = requireGetIteratorMethod();
  var iteratorClose2 = requireIteratorClose();
  var $TypeError = TypeError;
  var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
  };
  var ResultPrototype = Result.prototype;
  iterate = function(iterable, unboundFunction, options) {
    var that = options && options.that;
    var AS_ENTRIES = !!(options && options.AS_ENTRIES);
    var IS_RECORD = !!(options && options.IS_RECORD);
    var IS_ITERATOR = !!(options && options.IS_ITERATOR);
    var INTERRUPTED = !!(options && options.INTERRUPTED);
    var fn = bind2(unboundFunction, that);
    var iterator2, iterFn, index2, length, result, next, step;
    var stop = function(condition) {
      if (iterator2) iteratorClose2(iterator2, "normal");
      return new Result(true, condition);
    };
    var callFn = function(value) {
      if (AS_ENTRIES) {
        anObject2(value);
        return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
      }
      return INTERRUPTED ? fn(value, stop) : fn(value);
    };
    if (IS_RECORD) {
      iterator2 = iterable.iterator;
    } else if (IS_ITERATOR) {
      iterator2 = iterable;
    } else {
      iterFn = getIteratorMethod2(iterable);
      if (!iterFn) throw new $TypeError(tryToString2(iterable) + " is not iterable");
      if (isArrayIteratorMethod2(iterFn)) {
        for (index2 = 0, length = lengthOfArrayLike2(iterable); length > index2; index2++) {
          result = callFn(iterable[index2]);
          if (result && isPrototypeOf(ResultPrototype, result)) return result;
        }
        return new Result(false);
      }
      iterator2 = getIterator2(iterable, iterFn);
    }
    next = IS_RECORD ? iterable.next : iterator2.next;
    while (!(step = call(next, iterator2)).done) {
      try {
        result = callFn(step.value);
      } catch (error) {
        iteratorClose2(iterator2, "throw", error);
      }
      if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result)) return result;
    }
    return new Result(false);
  };
  return iterate;
}
var checkCorrectnessOfIteration;
var hasRequiredCheckCorrectnessOfIteration;
function requireCheckCorrectnessOfIteration() {
  if (hasRequiredCheckCorrectnessOfIteration) return checkCorrectnessOfIteration;
  hasRequiredCheckCorrectnessOfIteration = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  var SAFE_CLOSING = false;
  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function() {
        return { done: !!called++ };
      },
      "return": function() {
        SAFE_CLOSING = true;
      }
    };
    iteratorWithReturn[ITERATOR] = function() {
      return this;
    };
    Array.from(iteratorWithReturn, function() {
      throw 2;
    });
  } catch (error) {
  }
  checkCorrectnessOfIteration = function(exec, SKIP_CLOSING) {
    try {
      if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    } catch (error) {
      return false;
    }
    var ITERATION_SUPPORT = false;
    try {
      var object = {};
      object[ITERATOR] = function() {
        return {
          next: function() {
            return { done: ITERATION_SUPPORT = true };
          }
        };
      };
      exec(object);
    } catch (error) {
    }
    return ITERATION_SUPPORT;
  };
  return checkCorrectnessOfIteration;
}
var promiseStaticsIncorrectIteration;
var hasRequiredPromiseStaticsIncorrectIteration;
function requirePromiseStaticsIncorrectIteration() {
  if (hasRequiredPromiseStaticsIncorrectIteration) return promiseStaticsIncorrectIteration;
  hasRequiredPromiseStaticsIncorrectIteration = 1;
  var NativePromiseConstructor = requirePromiseNativeConstructor();
  var checkCorrectnessOfIteration2 = requireCheckCorrectnessOfIteration();
  var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
  promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR || !checkCorrectnessOfIteration2(function(iterable) {
    NativePromiseConstructor.all(iterable).then(void 0, function() {
    });
  });
  return promiseStaticsIncorrectIteration;
}
var hasRequiredEs_promise_all;
function requireEs_promise_all() {
  if (hasRequiredEs_promise_all) return es_promise_all;
  hasRequiredEs_promise_all = 1;
  var $2 = require_export();
  var call = requireFunctionCall();
  var aCallable2 = requireACallable();
  var newPromiseCapabilityModule = requireNewPromiseCapability();
  var perform2 = requirePerform();
  var iterate2 = requireIterate();
  var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
  $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
    all: function all3(iterable) {
      var C2 = this;
      var capability = newPromiseCapabilityModule.f(C2);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform2(function() {
        var $promiseResolve = aCallable2(C2.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate2(iterable, function(promise) {
          var index2 = counter++;
          var alreadyCalled = false;
          remaining++;
          call($promiseResolve, C2, promise).then(function(value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index2] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });
  return es_promise_all;
}
var es_promise_catch = {};
var hasRequiredEs_promise_catch;
function requireEs_promise_catch() {
  if (hasRequiredEs_promise_catch) return es_promise_catch;
  hasRequiredEs_promise_catch = 1;
  var $2 = require_export();
  var IS_PURE = requireIsPure();
  var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
  var NativePromiseConstructor = requirePromiseNativeConstructor();
  var getBuiltIn2 = requireGetBuiltIn();
  var isCallable2 = requireIsCallable();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;
  $2({ target: "Promise", proto: true, forced: FORCED_PROMISE_CONSTRUCTOR, real: true }, {
    "catch": function(onRejected) {
      return this.then(void 0, onRejected);
    }
  });
  if (!IS_PURE && isCallable2(NativePromiseConstructor)) {
    var method = getBuiltIn2("Promise").prototype["catch"];
    if (NativePromisePrototype["catch"] !== method) {
      defineBuiltIn2(NativePromisePrototype, "catch", method, { unsafe: true });
    }
  }
  return es_promise_catch;
}
var es_promise_race = {};
var hasRequiredEs_promise_race;
function requireEs_promise_race() {
  if (hasRequiredEs_promise_race) return es_promise_race;
  hasRequiredEs_promise_race = 1;
  var $2 = require_export();
  var call = requireFunctionCall();
  var aCallable2 = requireACallable();
  var newPromiseCapabilityModule = requireNewPromiseCapability();
  var perform2 = requirePerform();
  var iterate2 = requireIterate();
  var PROMISE_STATICS_INCORRECT_ITERATION = requirePromiseStaticsIncorrectIteration();
  $2({ target: "Promise", stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
    race: function race(iterable) {
      var C2 = this;
      var capability = newPromiseCapabilityModule.f(C2);
      var reject = capability.reject;
      var result = perform2(function() {
        var $promiseResolve = aCallable2(C2.resolve);
        iterate2(iterable, function(promise) {
          call($promiseResolve, C2, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });
  return es_promise_race;
}
var es_promise_reject = {};
var hasRequiredEs_promise_reject;
function requireEs_promise_reject() {
  if (hasRequiredEs_promise_reject) return es_promise_reject;
  hasRequiredEs_promise_reject = 1;
  var $2 = require_export();
  var newPromiseCapabilityModule = requireNewPromiseCapability();
  var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
  $2({ target: "Promise", stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {
    reject: function reject(r2) {
      var capability = newPromiseCapabilityModule.f(this);
      var capabilityReject = capability.reject;
      capabilityReject(r2);
      return capability.promise;
    }
  });
  return es_promise_reject;
}
var es_promise_resolve = {};
var promiseResolve;
var hasRequiredPromiseResolve;
function requirePromiseResolve() {
  if (hasRequiredPromiseResolve) return promiseResolve;
  hasRequiredPromiseResolve = 1;
  var anObject2 = requireAnObject();
  var isObject2 = requireIsObject();
  var newPromiseCapability2 = requireNewPromiseCapability();
  promiseResolve = function(C2, x2) {
    anObject2(C2);
    if (isObject2(x2) && x2.constructor === C2) return x2;
    var promiseCapability = newPromiseCapability2.f(C2);
    var resolve = promiseCapability.resolve;
    resolve(x2);
    return promiseCapability.promise;
  };
  return promiseResolve;
}
var hasRequiredEs_promise_resolve;
function requireEs_promise_resolve() {
  if (hasRequiredEs_promise_resolve) return es_promise_resolve;
  hasRequiredEs_promise_resolve = 1;
  var $2 = require_export();
  var getBuiltIn2 = requireGetBuiltIn();
  var IS_PURE = requireIsPure();
  var NativePromiseConstructor = requirePromiseNativeConstructor();
  var FORCED_PROMISE_CONSTRUCTOR = requirePromiseConstructorDetection().CONSTRUCTOR;
  var promiseResolve2 = requirePromiseResolve();
  var PromiseConstructorWrapper = getBuiltIn2("Promise");
  var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;
  $2({ target: "Promise", stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
    resolve: function resolve(x2) {
      return promiseResolve2(CHECK_WRAPPER && this === PromiseConstructorWrapper ? NativePromiseConstructor : this, x2);
    }
  });
  return es_promise_resolve;
}
var hasRequiredEs_promise;
function requireEs_promise() {
  if (hasRequiredEs_promise) return es_promise;
  hasRequiredEs_promise = 1;
  requireEs_promise_constructor();
  requireEs_promise_all();
  requireEs_promise_catch();
  requireEs_promise_race();
  requireEs_promise_reject();
  requireEs_promise_resolve();
  return es_promise;
}
requireEs_promise();
function asyncGeneratorStep(n2, t3, e2, r2, o2, a2, c2) {
  try {
    var i2 = n2[a2](c2), u2 = i2.value;
  } catch (n3) {
    return void e2(n3);
  }
  i2.done ? t3(u2) : Promise.resolve(u2).then(r2, o2);
}
function _asyncToGenerator(n2) {
  return function() {
    var t3 = this, e2 = arguments;
    return new Promise(function(r2, o2) {
      var a2 = n2.apply(t3, e2);
      function _next(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
      }
      function _throw(n3) {
        asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
      }
      _next(void 0);
    });
  };
}
var es_string_match = {};
var es_regexp_exec = {};
var toString2;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString2;
  hasRequiredToString = 1;
  var classof2 = requireClassof();
  var $String = String;
  toString2 = function(argument) {
    if (classof2(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return $String(argument);
  };
  return toString2;
}
var regexpFlags;
var hasRequiredRegexpFlags;
function requireRegexpFlags() {
  if (hasRequiredRegexpFlags) return regexpFlags;
  hasRequiredRegexpFlags = 1;
  var anObject2 = requireAnObject();
  regexpFlags = function() {
    var that = anObject2(this);
    var result = "";
    if (that.hasIndices) result += "d";
    if (that.global) result += "g";
    if (that.ignoreCase) result += "i";
    if (that.multiline) result += "m";
    if (that.dotAll) result += "s";
    if (that.unicode) result += "u";
    if (that.unicodeSets) result += "v";
    if (that.sticky) result += "y";
    return result;
  };
  return regexpFlags;
}
var regexpStickyHelpers;
var hasRequiredRegexpStickyHelpers;
function requireRegexpStickyHelpers() {
  if (hasRequiredRegexpStickyHelpers) return regexpStickyHelpers;
  hasRequiredRegexpStickyHelpers = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  var UNSUPPORTED_Y = fails2(function() {
    var re2 = $RegExp("a", "y");
    re2.lastIndex = 2;
    return re2.exec("abcd") !== null;
  });
  var MISSED_STICKY = UNSUPPORTED_Y || fails2(function() {
    return !$RegExp("a", "y").sticky;
  });
  var BROKEN_CARET = UNSUPPORTED_Y || fails2(function() {
    var re2 = $RegExp("^r", "gy");
    re2.lastIndex = 2;
    return re2.exec("str") !== null;
  });
  regexpStickyHelpers = {
    BROKEN_CARET,
    MISSED_STICKY,
    UNSUPPORTED_Y
  };
  return regexpStickyHelpers;
}
var objectDefineProperties = {};
var objectKeys;
var hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var internalObjectKeys = requireObjectKeysInternal();
  var enumBugKeys2 = requireEnumBugKeys();
  objectKeys = Object.keys || function keys2(O2) {
    return internalObjectKeys(O2, enumBugKeys2);
  };
  return objectKeys;
}
var hasRequiredObjectDefineProperties;
function requireObjectDefineProperties() {
  if (hasRequiredObjectDefineProperties) return objectDefineProperties;
  hasRequiredObjectDefineProperties = 1;
  var DESCRIPTORS = requireDescriptors();
  var V8_PROTOTYPE_DEFINE_BUG = requireV8PrototypeDefineBug();
  var definePropertyModule = requireObjectDefineProperty();
  var anObject2 = requireAnObject();
  var toIndexedObject2 = requireToIndexedObject();
  var objectKeys2 = requireObjectKeys();
  objectDefineProperties.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
    anObject2(O2);
    var props = toIndexedObject2(Properties);
    var keys2 = objectKeys2(Properties);
    var length = keys2.length;
    var index2 = 0;
    var key;
    while (length > index2) definePropertyModule.f(O2, key = keys2[index2++], props[key]);
    return O2;
  };
  return objectDefineProperties;
}
var objectCreate;
var hasRequiredObjectCreate;
function requireObjectCreate() {
  if (hasRequiredObjectCreate) return objectCreate;
  hasRequiredObjectCreate = 1;
  var anObject2 = requireAnObject();
  var definePropertiesModule = requireObjectDefineProperties();
  var enumBugKeys2 = requireEnumBugKeys();
  var hiddenKeys2 = requireHiddenKeys();
  var html2 = requireHtml();
  var documentCreateElement2 = requireDocumentCreateElement();
  var sharedKey2 = requireSharedKey();
  var GT = ">";
  var LT = "<";
  var PROTOTYPE = "prototype";
  var SCRIPT = "script";
  var IE_PROTO = sharedKey2("IE_PROTO");
  var EmptyConstructor = function() {
  };
  var scriptTag = function(content2) {
    return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
  };
  var NullProtoObjectViaActiveX = function(activeXDocument2) {
    activeXDocument2.write(scriptTag(""));
    activeXDocument2.close();
    var temp = activeXDocument2.parentWindow.Object;
    activeXDocument2 = null;
    return temp;
  };
  var NullProtoObjectViaIFrame = function() {
    var iframe = documentCreateElement2("iframe");
    var JS = "java" + SCRIPT + ":";
    var iframeDocument;
    iframe.style.display = "none";
    html2.appendChild(iframe);
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag("document.F=Object"));
    iframeDocument.close();
    return iframeDocument.F;
  };
  var activeXDocument;
  var NullProtoObject = function() {
    try {
      activeXDocument = new ActiveXObject("htmlfile");
    } catch (error) {
    }
    NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
    var length = enumBugKeys2.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys2[length]];
    return NullProtoObject();
  };
  hiddenKeys2[IE_PROTO] = true;
  objectCreate = Object.create || function create2(O2, Properties) {
    var result;
    if (O2 !== null) {
      EmptyConstructor[PROTOTYPE] = anObject2(O2);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      result[IE_PROTO] = O2;
    } else result = NullProtoObject();
    return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
  };
  return objectCreate;
}
var regexpUnsupportedDotAll;
var hasRequiredRegexpUnsupportedDotAll;
function requireRegexpUnsupportedDotAll() {
  if (hasRequiredRegexpUnsupportedDotAll) return regexpUnsupportedDotAll;
  hasRequiredRegexpUnsupportedDotAll = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedDotAll = fails2(function() {
    var re2 = $RegExp(".", "s");
    return !(re2.dotAll && re2.test("\n") && re2.flags === "s");
  });
  return regexpUnsupportedDotAll;
}
var regexpUnsupportedNcg;
var hasRequiredRegexpUnsupportedNcg;
function requireRegexpUnsupportedNcg() {
  if (hasRequiredRegexpUnsupportedNcg) return regexpUnsupportedNcg;
  hasRequiredRegexpUnsupportedNcg = 1;
  var fails2 = requireFails();
  var globalThis2 = requireGlobalThis();
  var $RegExp = globalThis2.RegExp;
  regexpUnsupportedNcg = fails2(function() {
    var re2 = $RegExp("(?<a>b)", "g");
    return re2.exec("b").groups.a !== "b" || "b".replace(re2, "$<a>c") !== "bc";
  });
  return regexpUnsupportedNcg;
}
var regexpExec;
var hasRequiredRegexpExec;
function requireRegexpExec() {
  if (hasRequiredRegexpExec) return regexpExec;
  hasRequiredRegexpExec = 1;
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var toString3 = requireToString();
  var regexpFlags2 = requireRegexpFlags();
  var stickyHelpers = requireRegexpStickyHelpers();
  var shared2 = requireShared();
  var create2 = requireObjectCreate();
  var getInternalState = requireInternalState().get;
  var UNSUPPORTED_DOT_ALL = requireRegexpUnsupportedDotAll();
  var UNSUPPORTED_NCG = requireRegexpUnsupportedNcg();
  var nativeReplace = shared2("native-string-replace", String.prototype.replace);
  var nativeExec = RegExp.prototype.exec;
  var patchedExec = nativeExec;
  var charAt = uncurryThis("".charAt);
  var indexOf = uncurryThis("".indexOf);
  var replace = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var UPDATES_LAST_INDEX_WRONG = (function() {
    var re1 = /a/;
    var re2 = /b*/g;
    call(nativeExec, re1, "a");
    call(nativeExec, re2, "a");
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();
  var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
  var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
  if (PATCH) {
    patchedExec = function exec(string) {
      var re2 = this;
      var state = getInternalState(re2);
      var str = toString3(string);
      var raw = state.raw;
      var result, reCopy, lastIndex, match, i2, object, group;
      if (raw) {
        raw.lastIndex = re2.lastIndex;
        result = call(patchedExec, raw, str);
        re2.lastIndex = raw.lastIndex;
        return result;
      }
      var groups = state.groups;
      var sticky = UNSUPPORTED_Y && re2.sticky;
      var flags = call(regexpFlags2, re2);
      var source = re2.source;
      var charsAdded = 0;
      var strCopy = str;
      if (sticky) {
        flags = replace(flags, "y", "");
        if (indexOf(flags, "g") === -1) {
          flags += "g";
        }
        strCopy = stringSlice(str, re2.lastIndex);
        if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && charAt(str, re2.lastIndex - 1) !== "\n")) {
          source = "(?: " + source + ")";
          strCopy = " " + strCopy;
          charsAdded++;
        }
        reCopy = new RegExp("^(?:" + source + ")", flags);
      }
      if (NPCG_INCLUDED) {
        reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re2.lastIndex;
      match = call(nativeExec, sticky ? reCopy : re2, strCopy);
      if (sticky) {
        if (match) {
          match.input = stringSlice(match.input, charsAdded);
          match[0] = stringSlice(match[0], charsAdded);
          match.index = re2.lastIndex;
          re2.lastIndex += match[0].length;
        } else re2.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG && match) {
        re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED && match && match.length > 1) {
        call(nativeReplace, match[0], reCopy, function() {
          for (i2 = 1; i2 < arguments.length - 2; i2++) {
            if (arguments[i2] === void 0) match[i2] = void 0;
          }
        });
      }
      if (match && groups) {
        match.groups = object = create2(null);
        for (i2 = 0; i2 < groups.length; i2++) {
          group = groups[i2];
          object[group[0]] = match[group[1]];
        }
      }
      return match;
    };
  }
  regexpExec = patchedExec;
  return regexpExec;
}
var hasRequiredEs_regexp_exec;
function requireEs_regexp_exec() {
  if (hasRequiredEs_regexp_exec) return es_regexp_exec;
  hasRequiredEs_regexp_exec = 1;
  var $2 = require_export();
  var exec = requireRegexpExec();
  $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
    exec
  });
  return es_regexp_exec;
}
var fixRegexpWellKnownSymbolLogic;
var hasRequiredFixRegexpWellKnownSymbolLogic;
function requireFixRegexpWellKnownSymbolLogic() {
  if (hasRequiredFixRegexpWellKnownSymbolLogic) return fixRegexpWellKnownSymbolLogic;
  hasRequiredFixRegexpWellKnownSymbolLogic = 1;
  requireEs_regexp_exec();
  var call = requireFunctionCall();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var regexpExec2 = requireRegexpExec();
  var fails2 = requireFails();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var SPECIES = wellKnownSymbol2("species");
  var RegExpPrototype = RegExp.prototype;
  fixRegexpWellKnownSymbolLogic = function(KEY, exec, FORCED, SHAM) {
    var SYMBOL = wellKnownSymbol2(KEY);
    var DELEGATES_TO_SYMBOL = !fails2(function() {
      var O2 = {};
      O2[SYMBOL] = function() {
        return 7;
      };
      return ""[KEY](O2) !== 7;
    });
    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails2(function() {
      var execCalled = false;
      var re2 = /a/;
      if (KEY === "split") {
        re2 = {};
        re2.constructor = {};
        re2.constructor[SPECIES] = function() {
          return re2;
        };
        re2.flags = "";
        re2[SYMBOL] = /./[SYMBOL];
      }
      re2.exec = function() {
        execCalled = true;
        return null;
      };
      re2[SYMBOL]("");
      return !execCalled;
    });
    if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
        var $exec = regexp.exec;
        if ($exec === regexpExec2 || $exec === RegExpPrototype.exec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            return { done: true, value: call(nativeRegExpMethod, regexp, str, arg2) };
          }
          return { done: true, value: call(nativeMethod, str, regexp, arg2) };
        }
        return { done: false };
      });
      defineBuiltIn2(String.prototype, KEY, methods[0]);
      defineBuiltIn2(RegExpPrototype, SYMBOL, methods[1]);
    }
    if (SHAM) createNonEnumerableProperty2(RegExpPrototype[SYMBOL], "sham", true);
  };
  return fixRegexpWellKnownSymbolLogic;
}
var stringMultibyte;
var hasRequiredStringMultibyte;
function requireStringMultibyte() {
  if (hasRequiredStringMultibyte) return stringMultibyte;
  hasRequiredStringMultibyte = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toString3 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var charAt = uncurryThis("".charAt);
  var charCodeAt = uncurryThis("".charCodeAt);
  var stringSlice = uncurryThis("".slice);
  var createMethod = function(CONVERT_TO_STRING) {
    return function($this, pos) {
      var S2 = toString3(requireObjectCoercible2($this));
      var position2 = toIntegerOrInfinity2(pos);
      var size = S2.length;
      var first, second;
      if (position2 < 0 || position2 >= size) return CONVERT_TO_STRING ? "" : void 0;
      first = charCodeAt(S2, position2);
      return first < 55296 || first > 56319 || position2 + 1 === size || (second = charCodeAt(S2, position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S2, position2) : first : CONVERT_TO_STRING ? stringSlice(S2, position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
    };
  };
  stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod(true)
  };
  return stringMultibyte;
}
var advanceStringIndex;
var hasRequiredAdvanceStringIndex;
function requireAdvanceStringIndex() {
  if (hasRequiredAdvanceStringIndex) return advanceStringIndex;
  hasRequiredAdvanceStringIndex = 1;
  var charAt = requireStringMultibyte().charAt;
  advanceStringIndex = function(S2, index2, unicode) {
    return index2 + (unicode ? charAt(S2, index2).length : 1);
  };
  return advanceStringIndex;
}
var regexpFlagsDetection;
var hasRequiredRegexpFlagsDetection;
function requireRegexpFlagsDetection() {
  if (hasRequiredRegexpFlagsDetection) return regexpFlagsDetection;
  hasRequiredRegexpFlagsDetection = 1;
  var globalThis2 = requireGlobalThis();
  var fails2 = requireFails();
  var RegExp2 = globalThis2.RegExp;
  var FLAGS_GETTER_IS_CORRECT = !fails2(function() {
    var INDICES_SUPPORT = true;
    try {
      RegExp2(".", "d");
    } catch (error) {
      INDICES_SUPPORT = false;
    }
    var O2 = {};
    var calls = "";
    var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";
    var addGetter = function(key2, chr) {
      Object.defineProperty(O2, key2, { get: function() {
        calls += chr;
        return true;
      } });
    };
    var pairs = {
      dotAll: "s",
      global: "g",
      ignoreCase: "i",
      multiline: "m",
      sticky: "y"
    };
    if (INDICES_SUPPORT) pairs.hasIndices = "d";
    for (var key in pairs) addGetter(key, pairs[key]);
    var result = Object.getOwnPropertyDescriptor(RegExp2.prototype, "flags").get.call(O2);
    return result !== expected || calls !== expected;
  });
  regexpFlagsDetection = { correct: FLAGS_GETTER_IS_CORRECT };
  return regexpFlagsDetection;
}
var regexpGetFlags;
var hasRequiredRegexpGetFlags;
function requireRegexpGetFlags() {
  if (hasRequiredRegexpGetFlags) return regexpGetFlags;
  hasRequiredRegexpGetFlags = 1;
  var call = requireFunctionCall();
  var hasOwn = requireHasOwnProperty();
  var isPrototypeOf = requireObjectIsPrototypeOf();
  var regExpFlagsDetection = requireRegexpFlagsDetection();
  var regExpFlagsGetterImplementation = requireRegexpFlags();
  var RegExpPrototype = RegExp.prototype;
  regexpGetFlags = regExpFlagsDetection.correct ? function(it2) {
    return it2.flags;
  } : function(it2) {
    return !regExpFlagsDetection.correct && isPrototypeOf(RegExpPrototype, it2) && !hasOwn(it2, "flags") ? call(regExpFlagsGetterImplementation, it2) : it2.flags;
  };
  return regexpGetFlags;
}
var regexpExecAbstract;
var hasRequiredRegexpExecAbstract;
function requireRegexpExecAbstract() {
  if (hasRequiredRegexpExecAbstract) return regexpExecAbstract;
  hasRequiredRegexpExecAbstract = 1;
  var call = requireFunctionCall();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var classof2 = requireClassofRaw();
  var regexpExec2 = requireRegexpExec();
  var $TypeError = TypeError;
  regexpExecAbstract = function(R2, S2) {
    var exec = R2.exec;
    if (isCallable2(exec)) {
      var result = call(exec, R2, S2);
      if (result !== null) anObject2(result);
      return result;
    }
    if (classof2(R2) === "RegExp") return call(regexpExec2, R2, S2);
    throw new $TypeError("RegExp#exec called on incompatible receiver");
  };
  return regexpExecAbstract;
}
var hasRequiredEs_string_match;
function requireEs_string_match() {
  if (hasRequiredEs_string_match) return es_string_match;
  hasRequiredEs_string_match = 1;
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
  var anObject2 = requireAnObject();
  var isObject2 = requireIsObject();
  var toLength2 = requireToLength();
  var toString3 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var getMethod2 = requireGetMethod();
  var advanceStringIndex2 = requireAdvanceStringIndex();
  var getRegExpFlags = requireRegexpGetFlags();
  var regExpExec = requireRegexpExecAbstract();
  var stringIndexOf2 = uncurryThis("".indexOf);
  fixRegExpWellKnownSymbolLogic("match", function(MATCH2, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O2 = requireObjectCoercible2(this);
        var matcher = isObject2(regexp) ? getMethod2(regexp, MATCH2) : void 0;
        return matcher ? call(matcher, regexp, O2) : new RegExp(regexp)[MATCH2](toString3(O2));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function(string) {
        var rx = anObject2(this);
        var S2 = toString3(string);
        var res = maybeCallNative(nativeMatch, rx, S2);
        if (res.done) return res.value;
        var flags = toString3(getRegExpFlags(rx));
        if (stringIndexOf2(flags, "g") === -1) return regExpExec(rx, S2);
        var fullUnicode = stringIndexOf2(flags, "u") !== -1;
        rx.lastIndex = 0;
        var A2 = [];
        var n2 = 0;
        var result;
        while ((result = regExpExec(rx, S2)) !== null) {
          var matchStr = toString3(result[0]);
          A2[n2] = matchStr;
          if (matchStr === "") rx.lastIndex = advanceStringIndex2(S2, toLength2(rx.lastIndex), fullUnicode);
          n2++;
        }
        return n2 === 0 ? null : A2;
      }
    ];
  });
  return es_string_match;
}
requireEs_string_match();
var es_string_replace = {};
var getSubstitution;
var hasRequiredGetSubstitution;
function requireGetSubstitution() {
  if (hasRequiredGetSubstitution) return getSubstitution;
  hasRequiredGetSubstitution = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var toObject2 = requireToObject();
  var floor = Math.floor;
  var charAt = uncurryThis("".charAt);
  var replace = uncurryThis("".replace);
  var stringSlice = uncurryThis("".slice);
  var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
  getSubstitution = function(matched, str, position2, captures, namedCaptures, replacement) {
    var tailPos = position2 + matched.length;
    var m2 = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== void 0) {
      namedCaptures = toObject2(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace(replacement, symbols, function(match, ch) {
      var capture;
      switch (charAt(ch, 0)) {
        case "$":
          return "$";
        case "&":
          return matched;
        case "`":
          return stringSlice(str, 0, position2);
        case "'":
          return stringSlice(str, tailPos);
        case "<":
          capture = namedCaptures[stringSlice(ch, 1, -1)];
          break;
        default:
          var n2 = +ch;
          if (n2 === 0) return match;
          if (n2 > m2) {
            var f2 = floor(n2 / 10);
            if (f2 === 0) return match;
            if (f2 <= m2) return captures[f2 - 1] === void 0 ? charAt(ch, 1) : captures[f2 - 1] + charAt(ch, 1);
            return match;
          }
          capture = captures[n2 - 1];
      }
      return capture === void 0 ? "" : capture;
    });
  };
  return getSubstitution;
}
var hasRequiredEs_string_replace;
function requireEs_string_replace() {
  if (hasRequiredEs_string_replace) return es_string_replace;
  hasRequiredEs_string_replace = 1;
  var apply2 = requireFunctionApply();
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
  var fails2 = requireFails();
  var anObject2 = requireAnObject();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var toIntegerOrInfinity2 = requireToIntegerOrInfinity();
  var toLength2 = requireToLength();
  var toString3 = requireToString();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var advanceStringIndex2 = requireAdvanceStringIndex();
  var getMethod2 = requireGetMethod();
  var getSubstitution2 = requireGetSubstitution();
  var getRegExpFlags = requireRegexpGetFlags();
  var regExpExec = requireRegexpExecAbstract();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var REPLACE = wellKnownSymbol2("replace");
  var max = Math.max;
  var min = Math.min;
  var concat = uncurryThis([].concat);
  var push = uncurryThis([].push);
  var stringIndexOf2 = uncurryThis("".indexOf);
  var stringSlice = uncurryThis("".slice);
  var maybeToString = function(it2) {
    return it2 === void 0 ? it2 : String(it2);
  };
  var REPLACE_KEEPS_$0 = (function() {
    return "a".replace(/./, "$0") === "$0";
  })();
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function() {
    if (/./[REPLACE]) {
      return /./[REPLACE]("a", "$0") === "";
    }
    return false;
  })();
  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails2(function() {
    var re2 = /./;
    re2.exec = function() {
      var result = [];
      result.groups = { a: "7" };
      return result;
    };
    return "".replace(re2, "$<a>") !== "7";
  });
  fixRegExpWellKnownSymbolLogic("replace", function(_2, nativeReplace, maybeCallNative) {
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O2 = requireObjectCoercible2(this);
        var replacer = isObject2(searchValue) ? getMethod2(searchValue, REPLACE) : void 0;
        return replacer ? call(replacer, searchValue, O2, replaceValue) : call(nativeReplace, toString3(O2), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function(string, replaceValue) {
        var rx = anObject2(this);
        var S2 = toString3(string);
        if (typeof replaceValue == "string" && stringIndexOf2(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf2(replaceValue, "$<") === -1) {
          var res = maybeCallNative(nativeReplace, rx, S2, replaceValue);
          if (res.done) return res.value;
        }
        var functionalReplace = isCallable2(replaceValue);
        if (!functionalReplace) replaceValue = toString3(replaceValue);
        var flags = toString3(getRegExpFlags(rx));
        var global2 = stringIndexOf2(flags, "g") !== -1;
        var fullUnicode;
        if (global2) {
          fullUnicode = stringIndexOf2(flags, "u") !== -1;
          rx.lastIndex = 0;
        }
        var results = [];
        var result;
        while (true) {
          result = regExpExec(rx, S2);
          if (result === null) break;
          push(results, result);
          if (!global2) break;
          var matchStr = toString3(result[0]);
          if (matchStr === "") rx.lastIndex = advanceStringIndex2(S2, toLength2(rx.lastIndex), fullUnicode);
        }
        var accumulatedResult = "";
        var nextSourcePosition = 0;
        for (var i2 = 0; i2 < results.length; i2++) {
          result = results[i2];
          var matched = toString3(result[0]);
          var position2 = max(min(toIntegerOrInfinity2(result.index), S2.length), 0);
          var captures = [];
          var replacement;
          for (var j2 = 1; j2 < result.length; j2++) push(captures, maybeToString(result[j2]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = concat([matched], captures, position2, S2);
            if (namedCaptures !== void 0) push(replacerArgs, namedCaptures);
            replacement = toString3(apply2(replaceValue, void 0, replacerArgs));
          } else {
            replacement = getSubstitution2(matched, S2, position2, captures, namedCaptures, replaceValue);
          }
          if (position2 >= nextSourcePosition) {
            accumulatedResult += stringSlice(S2, nextSourcePosition, position2) + replacement;
            nextSourcePosition = position2 + matched.length;
          }
        }
        return accumulatedResult + stringSlice(S2, nextSourcePosition);
      }
    ];
  }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  return es_string_replace;
}
requireEs_string_replace();
var es_string_startsWith = {};
var isRegexp;
var hasRequiredIsRegexp;
function requireIsRegexp() {
  if (hasRequiredIsRegexp) return isRegexp;
  hasRequiredIsRegexp = 1;
  var isObject2 = requireIsObject();
  var classof2 = requireClassofRaw();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH2 = wellKnownSymbol2("match");
  isRegexp = function(it2) {
    var isRegExp2;
    return isObject2(it2) && ((isRegExp2 = it2[MATCH2]) !== void 0 ? !!isRegExp2 : classof2(it2) === "RegExp");
  };
  return isRegexp;
}
var notARegexp;
var hasRequiredNotARegexp;
function requireNotARegexp() {
  if (hasRequiredNotARegexp) return notARegexp;
  hasRequiredNotARegexp = 1;
  var isRegExp2 = requireIsRegexp();
  var $TypeError = TypeError;
  notARegexp = function(it2) {
    if (isRegExp2(it2)) {
      throw new $TypeError("The method doesn't accept regular expressions");
    }
    return it2;
  };
  return notARegexp;
}
var correctIsRegexpLogic;
var hasRequiredCorrectIsRegexpLogic;
function requireCorrectIsRegexpLogic() {
  if (hasRequiredCorrectIsRegexpLogic) return correctIsRegexpLogic;
  hasRequiredCorrectIsRegexpLogic = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var MATCH2 = wellKnownSymbol2("match");
  correctIsRegexpLogic = function(METHOD_NAME) {
    var regexp = /./;
    try {
      "/./"[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH2] = false;
        return "/./"[METHOD_NAME](regexp);
      } catch (error2) {
      }
    }
    return false;
  };
  return correctIsRegexpLogic;
}
var hasRequiredEs_string_startsWith;
function requireEs_string_startsWith() {
  if (hasRequiredEs_string_startsWith) return es_string_startsWith;
  hasRequiredEs_string_startsWith = 1;
  var $2 = require_export();
  var uncurryThis = requireFunctionUncurryThisClause();
  var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
  var toLength2 = requireToLength();
  var toString3 = requireToString();
  var notARegExp = requireNotARegexp();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
  var IS_PURE = requireIsPure();
  var stringSlice = uncurryThis("".slice);
  var min = Math.min;
  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
  var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
    var descriptor = getOwnPropertyDescriptor2(String.prototype, "startsWith");
    return descriptor && !descriptor.writable;
  })();
  $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    startsWith: function startsWith(searchString) {
      var that = toString3(requireObjectCoercible2(this));
      notARegExp(searchString);
      var index2 = toLength2(min(arguments.length > 1 ? arguments[1] : void 0, that.length));
      var search = toString3(searchString);
      return stringSlice(that, index2, index2 + search.length) === search;
    }
  });
  return es_string_startsWith;
}
requireEs_string_startsWith();
var addToUnscopables;
var hasRequiredAddToUnscopables;
function requireAddToUnscopables() {
  if (hasRequiredAddToUnscopables) return addToUnscopables;
  hasRequiredAddToUnscopables = 1;
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var create2 = requireObjectCreate();
  var defineProperty = requireObjectDefineProperty().f;
  var UNSCOPABLES = wellKnownSymbol2("unscopables");
  var ArrayPrototype = Array.prototype;
  if (ArrayPrototype[UNSCOPABLES] === void 0) {
    defineProperty(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: create2(null)
    });
  }
  addToUnscopables = function(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };
  return addToUnscopables;
}
var correctPrototypeGetter;
var hasRequiredCorrectPrototypeGetter;
function requireCorrectPrototypeGetter() {
  if (hasRequiredCorrectPrototypeGetter) return correctPrototypeGetter;
  hasRequiredCorrectPrototypeGetter = 1;
  var fails2 = requireFails();
  correctPrototypeGetter = !fails2(function() {
    function F2() {
    }
    F2.prototype.constructor = null;
    return Object.getPrototypeOf(new F2()) !== F2.prototype;
  });
  return correctPrototypeGetter;
}
var objectGetPrototypeOf;
var hasRequiredObjectGetPrototypeOf;
function requireObjectGetPrototypeOf() {
  if (hasRequiredObjectGetPrototypeOf) return objectGetPrototypeOf;
  hasRequiredObjectGetPrototypeOf = 1;
  var hasOwn = requireHasOwnProperty();
  var isCallable2 = requireIsCallable();
  var toObject2 = requireToObject();
  var sharedKey2 = requireSharedKey();
  var CORRECT_PROTOTYPE_GETTER = requireCorrectPrototypeGetter();
  var IE_PROTO = sharedKey2("IE_PROTO");
  var $Object = Object;
  var ObjectPrototype = $Object.prototype;
  objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
    var object = toObject2(O2);
    if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
    var constructor = object.constructor;
    if (isCallable2(constructor) && object instanceof constructor) {
      return constructor.prototype;
    }
    return object instanceof $Object ? ObjectPrototype : null;
  };
  return objectGetPrototypeOf;
}
var iteratorsCore;
var hasRequiredIteratorsCore;
function requireIteratorsCore() {
  if (hasRequiredIteratorsCore) return iteratorsCore;
  hasRequiredIteratorsCore = 1;
  var fails2 = requireFails();
  var isCallable2 = requireIsCallable();
  var isObject2 = requireIsObject();
  var create2 = requireObjectCreate();
  var getPrototypeOf2 = requireObjectGetPrototypeOf();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var IS_PURE = requireIsPure();
  var ITERATOR = wellKnownSymbol2("iterator");
  var BUGGY_SAFARI_ITERATORS = false;
  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
  if ([].keys) {
    arrayIterator = [].keys();
    if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
    else {
      PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }
  var NEW_ITERATOR_PROTOTYPE = !isObject2(IteratorPrototype) || fails2(function() {
    var test2 = {};
    return IteratorPrototype[ITERATOR].call(test2) !== test2;
  });
  if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
  else if (IS_PURE) IteratorPrototype = create2(IteratorPrototype);
  if (!isCallable2(IteratorPrototype[ITERATOR])) {
    defineBuiltIn2(IteratorPrototype, ITERATOR, function() {
      return this;
    });
  }
  iteratorsCore = {
    IteratorPrototype,
    BUGGY_SAFARI_ITERATORS
  };
  return iteratorsCore;
}
var iteratorCreateConstructor;
var hasRequiredIteratorCreateConstructor;
function requireIteratorCreateConstructor() {
  if (hasRequiredIteratorCreateConstructor) return iteratorCreateConstructor;
  hasRequiredIteratorCreateConstructor = 1;
  var IteratorPrototype = requireIteratorsCore().IteratorPrototype;
  var create2 = requireObjectCreate();
  var createPropertyDescriptor2 = requireCreatePropertyDescriptor();
  var setToStringTag2 = requireSetToStringTag();
  var Iterators = requireIterators();
  var returnThis = function() {
    return this;
  };
  iteratorCreateConstructor = function(IteratorConstructor, NAME2, next, ENUMERABLE_NEXT) {
    var TO_STRING_TAG = NAME2 + " Iterator";
    IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor2(+!ENUMERABLE_NEXT, next) });
    setToStringTag2(IteratorConstructor, TO_STRING_TAG, false, true);
    Iterators[TO_STRING_TAG] = returnThis;
    return IteratorConstructor;
  };
  return iteratorCreateConstructor;
}
var iteratorDefine;
var hasRequiredIteratorDefine;
function requireIteratorDefine() {
  if (hasRequiredIteratorDefine) return iteratorDefine;
  hasRequiredIteratorDefine = 1;
  var $2 = require_export();
  var call = requireFunctionCall();
  var IS_PURE = requireIsPure();
  var FunctionName = requireFunctionName();
  var isCallable2 = requireIsCallable();
  var createIteratorConstructor = requireIteratorCreateConstructor();
  var getPrototypeOf2 = requireObjectGetPrototypeOf();
  var setPrototypeOf2 = requireObjectSetPrototypeOf();
  var setToStringTag2 = requireSetToStringTag();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var defineBuiltIn2 = requireDefineBuiltIn();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var Iterators = requireIterators();
  var IteratorsCore = requireIteratorsCore();
  var PROPER_FUNCTION_NAME = FunctionName.PROPER;
  var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
  var IteratorPrototype = IteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR = wellKnownSymbol2("iterator");
  var KEYS = "keys";
  var VALUES = "values";
  var ENTRIES = "entries";
  var returnThis = function() {
    return this;
  };
  iteratorDefine = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME2, next);
    var getIterationMethod = function(KIND) {
      if (KIND === DEFAULT2 && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
      switch (KIND) {
        case KEYS:
          return function keys2() {
            return new IteratorConstructor(this, KIND);
          };
        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };
        case ENTRIES:
          return function entries2() {
            return new IteratorConstructor(this, KIND);
          };
      }
      return function() {
        return new IteratorConstructor(this);
      };
    };
    var TO_STRING_TAG = NAME2 + " Iterator";
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
    var anyNativeIterator = NAME2 === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;
    if (anyNativeIterator) {
      CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
      if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
        if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
          if (setPrototypeOf2) {
            setPrototypeOf2(CurrentIteratorPrototype, IteratorPrototype);
          } else if (!isCallable2(CurrentIteratorPrototype[ITERATOR])) {
            defineBuiltIn2(CurrentIteratorPrototype, ITERATOR, returnThis);
          }
        }
        setToStringTag2(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
        if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
      }
    }
    if (PROPER_FUNCTION_NAME && DEFAULT2 === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
        createNonEnumerableProperty2(IterablePrototype, "name", VALUES);
      } else {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
          return call(nativeIterator, this);
        };
      }
    }
    if (DEFAULT2) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          defineBuiltIn2(IterablePrototype, KEY, methods[KEY]);
        }
      }
      else $2({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
    }
    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
      defineBuiltIn2(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT2 });
    }
    Iterators[NAME2] = defaultIterator;
    return methods;
  };
  return iteratorDefine;
}
var createIterResultObject;
var hasRequiredCreateIterResultObject;
function requireCreateIterResultObject() {
  if (hasRequiredCreateIterResultObject) return createIterResultObject;
  hasRequiredCreateIterResultObject = 1;
  createIterResultObject = function(value, done) {
    return { value, done };
  };
  return createIterResultObject;
}
var es_array_iterator;
var hasRequiredEs_array_iterator;
function requireEs_array_iterator() {
  if (hasRequiredEs_array_iterator) return es_array_iterator;
  hasRequiredEs_array_iterator = 1;
  var toIndexedObject2 = requireToIndexedObject();
  var addToUnscopables2 = requireAddToUnscopables();
  var Iterators = requireIterators();
  var InternalStateModule = requireInternalState();
  var defineProperty = requireObjectDefineProperty().f;
  var defineIterator = requireIteratorDefine();
  var createIterResultObject2 = requireCreateIterResultObject();
  var IS_PURE = requireIsPure();
  var DESCRIPTORS = requireDescriptors();
  var ARRAY_ITERATOR = "Array Iterator";
  var setInternalState = InternalStateModule.set;
  var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
  es_array_iterator = defineIterator(Array, "Array", function(iterated, kind) {
    setInternalState(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject2(iterated),
      // target
      index: 0,
      // next index
      kind
      // kind
    });
  }, function() {
    var state = getInternalState(this);
    var target = state.target;
    var index2 = state.index++;
    if (!target || index2 >= target.length) {
      state.target = null;
      return createIterResultObject2(void 0, true);
    }
    switch (state.kind) {
      case "keys":
        return createIterResultObject2(index2, false);
      case "values":
        return createIterResultObject2(target[index2], false);
    }
    return createIterResultObject2([index2, target[index2]], false);
  }, "values");
  var values = Iterators.Arguments = Iterators.Array;
  addToUnscopables2("keys");
  addToUnscopables2("values");
  addToUnscopables2("entries");
  if (!IS_PURE && DESCRIPTORS && values.name !== "values") try {
    defineProperty(values, "name", { value: "values" });
  } catch (error) {
  }
  return es_array_iterator;
}
requireEs_array_iterator();
var web_domCollections_iterator = {};
var domIterables;
var hasRequiredDomIterables;
function requireDomIterables() {
  if (hasRequiredDomIterables) return domIterables;
  hasRequiredDomIterables = 1;
  domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };
  return domIterables;
}
var domTokenListPrototype;
var hasRequiredDomTokenListPrototype;
function requireDomTokenListPrototype() {
  if (hasRequiredDomTokenListPrototype) return domTokenListPrototype;
  hasRequiredDomTokenListPrototype = 1;
  var documentCreateElement2 = requireDocumentCreateElement();
  var classList = documentCreateElement2("span").classList;
  var DOMTokenListPrototype = classList && classList.constructor && classList.constructor.prototype;
  domTokenListPrototype = DOMTokenListPrototype === Object.prototype ? void 0 : DOMTokenListPrototype;
  return domTokenListPrototype;
}
var hasRequiredWeb_domCollections_iterator;
function requireWeb_domCollections_iterator() {
  if (hasRequiredWeb_domCollections_iterator) return web_domCollections_iterator;
  hasRequiredWeb_domCollections_iterator = 1;
  var globalThis2 = requireGlobalThis();
  var DOMIterables = requireDomIterables();
  var DOMTokenListPrototype = requireDomTokenListPrototype();
  var ArrayIteratorMethods = requireEs_array_iterator();
  var createNonEnumerableProperty2 = requireCreateNonEnumerableProperty();
  var setToStringTag2 = requireSetToStringTag();
  var wellKnownSymbol2 = requireWellKnownSymbol();
  var ITERATOR = wellKnownSymbol2("iterator");
  var ArrayValues = ArrayIteratorMethods.values;
  var handlePrototype = function(CollectionPrototype, COLLECTION_NAME2) {
    if (CollectionPrototype) {
      if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
        createNonEnumerableProperty2(CollectionPrototype, ITERATOR, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR] = ArrayValues;
      }
      setToStringTag2(CollectionPrototype, COLLECTION_NAME2, true);
      if (DOMIterables[COLLECTION_NAME2]) for (var METHOD_NAME in ArrayIteratorMethods) {
        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
          createNonEnumerableProperty2(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
        }
      }
    }
  };
  for (var COLLECTION_NAME in DOMIterables) {
    handlePrototype(globalThis2[COLLECTION_NAME] && globalThis2[COLLECTION_NAME].prototype, COLLECTION_NAME);
  }
  handlePrototype(DOMTokenListPrototype, "DOMTokenList");
  return web_domCollections_iterator;
}
requireWeb_domCollections_iterator();
function toPrimitive(t3, r2) {
  if ("object" != _typeof$1(t3) || !t3) return t3;
  var e2 = t3[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t3, r2);
    if ("object" != _typeof$1(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t3);
}
function toPropertyKey(t3) {
  var i2 = toPrimitive(t3, "string");
  return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
}
function _defineProperty(e2, r2, t3) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t3, e2;
}
var es_array_reduce = {};
var arrayReduce;
var hasRequiredArrayReduce;
function requireArrayReduce() {
  if (hasRequiredArrayReduce) return arrayReduce;
  hasRequiredArrayReduce = 1;
  var aCallable2 = requireACallable();
  var toObject2 = requireToObject();
  var IndexedObject = requireIndexedObject();
  var lengthOfArrayLike2 = requireLengthOfArrayLike();
  var $TypeError = TypeError;
  var REDUCE_EMPTY = "Reduce of empty array with no initial value";
  var createMethod = function(IS_RIGHT) {
    return function(that, callbackfn, argumentsLength, memo) {
      var O2 = toObject2(that);
      var self2 = IndexedObject(O2);
      var length = lengthOfArrayLike2(O2);
      aCallable2(callbackfn);
      if (length === 0 && argumentsLength < 2) throw new $TypeError(REDUCE_EMPTY);
      var index2 = IS_RIGHT ? length - 1 : 0;
      var i2 = IS_RIGHT ? -1 : 1;
      if (argumentsLength < 2) while (true) {
        if (index2 in self2) {
          memo = self2[index2];
          index2 += i2;
          break;
        }
        index2 += i2;
        if (IS_RIGHT ? index2 < 0 : length <= index2) {
          throw new $TypeError(REDUCE_EMPTY);
        }
      }
      for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2) if (index2 in self2) {
        memo = callbackfn(memo, self2[index2], index2, O2);
      }
      return memo;
    };
  };
  arrayReduce = {
    // `Array.prototype.reduce` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduce
    left: createMethod(false),
    // `Array.prototype.reduceRight` method
    // https://tc39.es/ecma262/#sec-array.prototype.reduceright
    right: createMethod(true)
  };
  return arrayReduce;
}
var arrayMethodIsStrict;
var hasRequiredArrayMethodIsStrict;
function requireArrayMethodIsStrict() {
  if (hasRequiredArrayMethodIsStrict) return arrayMethodIsStrict;
  hasRequiredArrayMethodIsStrict = 1;
  var fails2 = requireFails();
  arrayMethodIsStrict = function(METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method && fails2(function() {
      method.call(null, argument || function() {
        return 1;
      }, 1);
    });
  };
  return arrayMethodIsStrict;
}
var hasRequiredEs_array_reduce;
function requireEs_array_reduce() {
  if (hasRequiredEs_array_reduce) return es_array_reduce;
  hasRequiredEs_array_reduce = 1;
  var $2 = require_export();
  var $reduce = requireArrayReduce().left;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var CHROME_VERSION = requireEnvironmentV8Version();
  var IS_NODE = requireEnvironmentIsNode();
  var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;
  var FORCED = CHROME_BUG || !arrayMethodIsStrict2("reduce");
  $2({ target: "Array", proto: true, forced: FORCED }, {
    reduce: function reduce(callbackfn) {
      var length = arguments.length;
      return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : void 0);
    }
  });
  return es_array_reduce;
}
requireEs_array_reduce();
var es_string_endsWith = {};
var hasRequiredEs_string_endsWith;
function requireEs_string_endsWith() {
  if (hasRequiredEs_string_endsWith) return es_string_endsWith;
  hasRequiredEs_string_endsWith = 1;
  var $2 = require_export();
  var uncurryThis = requireFunctionUncurryThisClause();
  var getOwnPropertyDescriptor2 = requireObjectGetOwnPropertyDescriptor().f;
  var toLength2 = requireToLength();
  var toString3 = requireToString();
  var notARegExp = requireNotARegexp();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
  var IS_PURE = requireIsPure();
  var slice = uncurryThis("".slice);
  var min = Math.min;
  var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("endsWith");
  var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!(function() {
    var descriptor = getOwnPropertyDescriptor2(String.prototype, "endsWith");
    return descriptor && !descriptor.writable;
  })();
  $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
    endsWith: function endsWith2(searchString) {
      var that = toString3(requireObjectCoercible2(this));
      notARegExp(searchString);
      var endPosition = arguments.length > 1 ? arguments[1] : void 0;
      var len = that.length;
      var end = endPosition === void 0 ? len : min(toLength2(endPosition), len);
      var search = toString3(searchString);
      return slice(that, end - search.length, end) === search;
    }
  });
  return es_string_endsWith;
}
requireEs_string_endsWith();
var es_string_split = {};
var hasRequiredEs_string_split;
function requireEs_string_split() {
  if (hasRequiredEs_string_split) return es_string_split;
  hasRequiredEs_string_split = 1;
  var call = requireFunctionCall();
  var uncurryThis = requireFunctionUncurryThis();
  var fixRegExpWellKnownSymbolLogic = requireFixRegexpWellKnownSymbolLogic();
  var anObject2 = requireAnObject();
  var isObject2 = requireIsObject();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var speciesConstructor2 = requireSpeciesConstructor();
  var advanceStringIndex2 = requireAdvanceStringIndex();
  var toLength2 = requireToLength();
  var toString3 = requireToString();
  var getMethod2 = requireGetMethod();
  var regExpExec = requireRegexpExecAbstract();
  var stickyHelpers = requireRegexpStickyHelpers();
  var fails2 = requireFails();
  var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
  var MAX_UINT32 = 4294967295;
  var min = Math.min;
  var push = uncurryThis([].push);
  var stringSlice = uncurryThis("".slice);
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails2(function() {
    var re2 = /(?:)/;
    var originalExec = re2.exec;
    re2.exec = function() {
      return originalExec.apply(this, arguments);
    };
    var result = "ab".split(re2);
    return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
  });
  var BUGGY = "abbc".split(/(b)*/)[1] === "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
  "test".split(/(?:)/, -1).length !== 4 || "ab".split(/(?:ab)*/).length !== 2 || ".".split(/(.?)(.?)/).length !== 4 || // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing
  ".".split(/()()/).length > 1 || "".split(/.?/).length;
  fixRegExpWellKnownSymbolLogic("split", function(SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit = "0".split(void 0, 0).length ? function(separator, limit) {
      return separator === void 0 && limit === 0 ? [] : call(nativeSplit, this, separator, limit);
    } : nativeSplit;
    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O2 = requireObjectCoercible2(this);
        var splitter = isObject2(separator) ? getMethod2(separator, SPLIT) : void 0;
        return splitter ? call(splitter, separator, O2, limit) : call(internalSplit, toString3(O2), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function(string, limit) {
        var rx = anObject2(this);
        var S2 = toString3(string);
        if (!BUGGY) {
          var res = maybeCallNative(internalSplit, rx, S2, limit, internalSplit !== nativeSplit);
          if (res.done) return res.value;
        }
        var C2 = speciesConstructor2(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
        var splitter = new C2(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
        var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S2.length === 0) return regExpExec(splitter, S2) === null ? [S2] : [];
        var p2 = 0;
        var q2 = 0;
        var A2 = [];
        while (q2 < S2.length) {
          splitter.lastIndex = UNSUPPORTED_Y ? 0 : q2;
          var z2 = regExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S2, q2) : S2);
          var e2;
          if (z2 === null || (e2 = min(toLength2(splitter.lastIndex + (UNSUPPORTED_Y ? q2 : 0)), S2.length)) === p2) {
            q2 = advanceStringIndex2(S2, q2, unicodeMatching);
          } else {
            push(A2, stringSlice(S2, p2, q2));
            if (A2.length === lim) return A2;
            for (var i2 = 1; i2 <= z2.length - 1; i2++) {
              push(A2, z2[i2]);
              if (A2.length === lim) return A2;
            }
            q2 = p2 = e2;
          }
        }
        push(A2, stringSlice(S2, p2));
        return A2;
      }
    ];
  }, BUGGY || !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);
  return es_string_split;
}
requireEs_string_split();
var raf = { exports: {} };
var performanceNow$1 = { exports: {} };
var performanceNow = performanceNow$1.exports;
var hasRequiredPerformanceNow;
function requirePerformanceNow() {
  if (hasRequiredPerformanceNow) return performanceNow$1.exports;
  hasRequiredPerformanceNow = 1;
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      performanceNow$1.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      performanceNow$1.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow$1.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow$1.exports = function() {
        return (/* @__PURE__ */ new Date()).getTime() - loadTime;
      };
      loadTime = (/* @__PURE__ */ new Date()).getTime();
    }
  }).call(performanceNow);
  return performanceNow$1.exports;
}
var hasRequiredRaf;
function requireRaf() {
  if (hasRequiredRaf) return raf.exports;
  hasRequiredRaf = 1;
  var now = requirePerformanceNow(), root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf$1 = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
  for (var i2 = 0; !raf$1 && i2 < vendors.length; i2++) {
    raf$1 = root[vendors[i2] + "Request" + suffix];
    caf = root[vendors[i2] + "Cancel" + suffix] || root[vendors[i2] + "CancelRequest" + suffix];
  }
  if (!raf$1 || !caf) {
    var last = 0, id = 0, queue2 = [], frameDuration = 1e3 / 60;
    raf$1 = function(callback) {
      if (queue2.length === 0) {
        var _now = now(), next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue2.slice(0);
          queue2.length = 0;
          for (var i3 = 0; i3 < cp.length; i3++) {
            if (!cp[i3].cancelled) {
              try {
                cp[i3].callback(last);
              } catch (e2) {
                setTimeout(function() {
                  throw e2;
                }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue2.push({
        handle: ++id,
        callback,
        cancelled: false
      });
      return id;
    };
    caf = function(handle) {
      for (var i3 = 0; i3 < queue2.length; i3++) {
        if (queue2[i3].handle === handle) {
          queue2[i3].cancelled = true;
        }
      }
    };
  }
  raf.exports = function(fn) {
    return raf$1.call(root, fn);
  };
  raf.exports.cancel = function() {
    caf.apply(root, arguments);
  };
  raf.exports.polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf$1;
    object.cancelAnimationFrame = caf;
  };
  return raf.exports;
}
var rafExports = requireRaf();
const requestAnimationFrame = /* @__PURE__ */ getDefaultExportFromCjs(rafExports);
var es_string_trim = {};
var whitespaces;
var hasRequiredWhitespaces;
function requireWhitespaces() {
  if (hasRequiredWhitespaces) return whitespaces;
  hasRequiredWhitespaces = 1;
  whitespaces = "	\n\v\f\r Â áââââââââââââ¯âã\u2028\u2029\uFEFF";
  return whitespaces;
}
var stringTrim;
var hasRequiredStringTrim;
function requireStringTrim() {
  if (hasRequiredStringTrim) return stringTrim;
  hasRequiredStringTrim = 1;
  var uncurryThis = requireFunctionUncurryThis();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toString3 = requireToString();
  var whitespaces2 = requireWhitespaces();
  var replace = uncurryThis("".replace);
  var ltrim = RegExp("^[" + whitespaces2 + "]+");
  var rtrim = RegExp("(^|[^" + whitespaces2 + "])[" + whitespaces2 + "]+$");
  var createMethod = function(TYPE2) {
    return function($this) {
      var string = toString3(requireObjectCoercible2($this));
      if (TYPE2 & 1) string = replace(string, ltrim, "");
      if (TYPE2 & 2) string = replace(string, rtrim, "$1");
      return string;
    };
  };
  stringTrim = {
    // `String.prototype.{ trimLeft, trimStart }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimstart
    start: createMethod(1),
    // `String.prototype.{ trimRight, trimEnd }` methods
    // https://tc39.es/ecma262/#sec-string.prototype.trimend
    end: createMethod(2),
    // `String.prototype.trim` method
    // https://tc39.es/ecma262/#sec-string.prototype.trim
    trim: createMethod(3)
  };
  return stringTrim;
}
var stringTrimForced;
var hasRequiredStringTrimForced;
function requireStringTrimForced() {
  if (hasRequiredStringTrimForced) return stringTrimForced;
  hasRequiredStringTrimForced = 1;
  var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
  var fails2 = requireFails();
  var whitespaces2 = requireWhitespaces();
  var non = "âÂá ";
  stringTrimForced = function(METHOD_NAME) {
    return fails2(function() {
      return !!whitespaces2[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces2[METHOD_NAME].name !== METHOD_NAME;
    });
  };
  return stringTrimForced;
}
var hasRequiredEs_string_trim;
function requireEs_string_trim() {
  if (hasRequiredEs_string_trim) return es_string_trim;
  hasRequiredEs_string_trim = 1;
  var $2 = require_export();
  var $trim = requireStringTrim().trim;
  var forcedStringTrimMethod = requireStringTrimForced();
  $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
    trim: function trim2() {
      return $trim(this);
    }
  });
  return es_string_trim;
}
requireEs_string_trim();
var rgbcolor;
var hasRequiredRgbcolor;
function requireRgbcolor() {
  if (hasRequiredRgbcolor) return rgbcolor;
  hasRequiredRgbcolor = 1;
  rgbcolor = function(color_string) {
    this.ok = false;
    this.alpha = 1;
    if (color_string.charAt(0) == "#") {
      color_string = color_string.substr(1, 6);
    }
    color_string = color_string.replace(/ /g, "");
    color_string = color_string.toLowerCase();
    var simple_colors = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "00ffff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000000",
      blanchedalmond: "ffebcd",
      blue: "0000ff",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "00ffff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dodgerblue: "1e90ff",
      feldspar: "d19275",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "ff00ff",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgrey: "d3d3d3",
      lightgreen: "90ee90",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslateblue: "8470ff",
      lightslategray: "778899",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "00ff00",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "ff00ff",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370d8",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "d87093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "ff0000",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      violetred: "d02090",
      wheat: "f5deb3",
      white: "ffffff",
      whitesmoke: "f5f5f5",
      yellow: "ffff00",
      yellowgreen: "9acd32"
    };
    color_string = simple_colors[color_string] || color_string;
    var color_defs = [
      {
        re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
        example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
        process: function(bits2) {
          return [
            parseInt(bits2[1]),
            parseInt(bits2[2]),
            parseInt(bits2[3]),
            parseFloat(bits2[4])
          ];
        }
      },
      {
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
        process: function(bits2) {
          return [
            parseInt(bits2[1]),
            parseInt(bits2[2]),
            parseInt(bits2[3])
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        example: ["#00ff00", "336699"],
        process: function(bits2) {
          return [
            parseInt(bits2[1], 16),
            parseInt(bits2[2], 16),
            parseInt(bits2[3], 16)
          ];
        }
      },
      {
        re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        example: ["#fb0", "f0f"],
        process: function(bits2) {
          return [
            parseInt(bits2[1] + bits2[1], 16),
            parseInt(bits2[2] + bits2[2], 16),
            parseInt(bits2[3] + bits2[3], 16)
          ];
        }
      }
    ];
    for (var i2 = 0; i2 < color_defs.length; i2++) {
      var re2 = color_defs[i2].re;
      var processor = color_defs[i2].process;
      var bits = re2.exec(color_string);
      if (bits) {
        var channels = processor(bits);
        this.r = channels[0];
        this.g = channels[1];
        this.b = channels[2];
        if (channels.length > 3) {
          this.alpha = channels[3];
        }
        this.ok = true;
      }
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
    this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
    this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
    this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
    this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    };
    this.toRGBA = function() {
      return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
    };
    this.toHex = function() {
      var r2 = this.r.toString(16);
      var g2 = this.g.toString(16);
      var b2 = this.b.toString(16);
      if (r2.length == 1) r2 = "0" + r2;
      if (g2.length == 1) g2 = "0" + g2;
      if (b2.length == 1) b2 = "0" + b2;
      return "#" + r2 + g2 + b2;
    };
    this.getHelpXML = function() {
      var examples = new Array();
      for (var i3 = 0; i3 < color_defs.length; i3++) {
        var example = color_defs[i3].example;
        for (var j2 = 0; j2 < example.length; j2++) {
          examples[examples.length] = example[j2];
        }
      }
      for (var sc in simple_colors) {
        examples[examples.length] = sc;
      }
      var xml2 = document.createElement("ul");
      xml2.setAttribute("id", "rgbcolor-examples");
      for (var i3 = 0; i3 < examples.length; i3++) {
        try {
          var list_item = document.createElement("li");
          var list_color = new RGBColor(examples[i3]);
          var example_div = document.createElement("div");
          example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
          example_div.appendChild(document.createTextNode("test"));
          var list_item_value = document.createTextNode(
            " " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
          );
          list_item.appendChild(example_div);
          list_item.appendChild(list_item_value);
          xml2.appendChild(list_item);
        } catch (e2) {
        }
      }
      return xml2;
    };
  };
  return rgbcolor;
}
var rgbcolorExports = requireRgbcolor();
const RGBColor$1 = /* @__PURE__ */ getDefaultExportFromCjs(rgbcolorExports);
var es_array_indexOf = {};
var hasRequiredEs_array_indexOf;
function requireEs_array_indexOf() {
  if (hasRequiredEs_array_indexOf) return es_array_indexOf;
  hasRequiredEs_array_indexOf = 1;
  var $2 = require_export();
  var uncurryThis = requireFunctionUncurryThisClause();
  var $indexOf = requireArrayIncludes().indexOf;
  var arrayMethodIsStrict2 = requireArrayMethodIsStrict();
  var nativeIndexOf = uncurryThis([].indexOf);
  var NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;
  var FORCED = NEGATIVE_ZERO || !arrayMethodIsStrict2("indexOf");
  $2({ target: "Array", proto: true, forced: FORCED }, {
    indexOf: function indexOf(searchElement) {
      var fromIndex = arguments.length > 1 ? arguments[1] : void 0;
      return NEGATIVE_ZERO ? nativeIndexOf(this, searchElement, fromIndex) || 0 : $indexOf(this, searchElement, fromIndex);
    }
  });
  return es_array_indexOf;
}
requireEs_array_indexOf();
var es_string_includes = {};
var hasRequiredEs_string_includes;
function requireEs_string_includes() {
  if (hasRequiredEs_string_includes) return es_string_includes;
  hasRequiredEs_string_includes = 1;
  var $2 = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var notARegExp = requireNotARegexp();
  var requireObjectCoercible2 = requireRequireObjectCoercible();
  var toString3 = requireToString();
  var correctIsRegExpLogic = requireCorrectIsRegexpLogic();
  var stringIndexOf2 = uncurryThis("".indexOf);
  $2({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
    includes: function includes(searchString) {
      return !!~stringIndexOf2(
        toString3(requireObjectCoercible2(this)),
        toString3(notARegExp(searchString)),
        arguments.length > 1 ? arguments[1] : void 0
      );
    }
  });
  return es_string_includes;
}
requireEs_string_includes();
var es_array_reverse = {};
var isArray;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray;
  hasRequiredIsArray = 1;
  var classof2 = requireClassofRaw();
  isArray = Array.isArray || function isArray2(argument) {
    return classof2(argument) === "Array";
  };
  return isArray;
}
var hasRequiredEs_array_reverse;
function requireEs_array_reverse() {
  if (hasRequiredEs_array_reverse) return es_array_reverse;
  hasRequiredEs_array_reverse = 1;
  var $2 = require_export();
  var uncurryThis = requireFunctionUncurryThis();
  var isArray2 = requireIsArray();
  var nativeReverse = uncurryThis([].reverse);
  var test2 = [1, 2];
  $2({ target: "Array", proto: true, forced: String(test2) === String(test2.reverse()) }, {
    reverse: function reverse() {
      if (isArray2(this)) this.length = this.length;
      return nativeReverse(this);
    }
  });
  return es_array_reverse;
}
requireEs_array_reverse();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t2 = function(r2, e2) {
  return (t2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t3, r3) {
    t3.__proto__ = r3;
  } || function(t3, r3) {
    for (var e3 in r3) Object.prototype.hasOwnProperty.call(r3, e3) && (t3[e3] = r3[e3]);
  })(r2, e2);
};
function r(r2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
  function i2() {
    this.constructor = r2;
  }
  t2(r2, e2), r2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
}
function e(t3) {
  var r2 = "";
  Array.isArray(t3) || (t3 = [t3]);
  for (var e2 = 0; e2 < t3.length; e2++) {
    var i2 = t3[e2];
    if (i2.type === _.CLOSE_PATH) r2 += "z";
    else if (i2.type === _.HORIZ_LINE_TO) r2 += (i2.relative ? "h" : "H") + i2.x;
    else if (i2.type === _.VERT_LINE_TO) r2 += (i2.relative ? "v" : "V") + i2.y;
    else if (i2.type === _.MOVE_TO) r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
    else if (i2.type === _.LINE_TO) r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
    else if (i2.type === _.CURVE_TO) r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_CURVE_TO) r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.QUAD_TO) r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
    else if (i2.type === _.SMOOTH_QUAD_TO) r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
    else {
      if (i2.type !== _.ARC) throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
      r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
    }
  }
  return r2;
}
function i(t3, r2) {
  var e2 = t3[0], i2 = t3[1];
  return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
}
function a() {
  for (var t3 = [], r2 = 0; r2 < arguments.length; r2++) t3[r2] = arguments[r2];
  for (var e2 = 0; e2 < t3.length; e2++) if ("number" != typeof t3[e2]) throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t3[e2] + " == typeof " + t3[e2]);
  return true;
}
var n = Math.PI;
function o(t3, r2, e2) {
  t3.lArcFlag = 0 === t3.lArcFlag ? 0 : 1, t3.sweepFlag = 0 === t3.sweepFlag ? 0 : 1;
  var a2 = t3.rX, o2 = t3.rY, s2 = t3.x, u2 = t3.y;
  a2 = Math.abs(t3.rX), o2 = Math.abs(t3.rY);
  var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t3.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p2 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);
  1 < p2 && (a2 *= Math.sqrt(p2), o2 *= Math.sqrt(p2)), t3.rX = a2, t3.rY = o2;
  var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t3.lArcFlag !== t3.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t3.xRot / 180 * n);
  t3.cX = v2[0] + (r2 + s2) / 2, t3.cY = v2[1] + (e2 + u2) / 2, t3.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t3.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), 0 === t3.sweepFlag && t3.phi2 > t3.phi1 && (t3.phi2 -= 2 * n), 1 === t3.sweepFlag && t3.phi2 < t3.phi1 && (t3.phi2 += 2 * n), t3.phi1 *= 180 / n, t3.phi2 *= 180 / n;
}
function s(t3, r2, e2) {
  a(t3, r2, e2);
  var i2 = t3 * t3 + r2 * r2 - e2 * e2;
  if (0 > i2) return [];
  if (0 === i2) return [[t3 * e2 / (t3 * t3 + r2 * r2), r2 * e2 / (t3 * t3 + r2 * r2)]];
  var n2 = Math.sqrt(i2);
  return [[(t3 * e2 + r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 - t3 * n2) / (t3 * t3 + r2 * r2)], [(t3 * e2 - r2 * n2) / (t3 * t3 + r2 * r2), (r2 * e2 + t3 * n2) / (t3 * t3 + r2 * r2)]];
}
var u, h = Math.PI / 180;
function c$1(t3, r2, e2) {
  return (1 - e2) * t3 + e2 * r2;
}
function y(t3, r2, e2, i2) {
  return t3 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
}
function p(t3, r2, e2, i2) {
  var a2 = 1e-6, n2 = r2 - t3, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
  return Math.abs(s2) < a2 ? [-h2 / u2] : (function(t4, r3, e3) {
    var i3 = t4 * t4 / 4 - r3;
    if (i3 < -e3) return [];
    if (i3 <= e3) return [-t4 / 2];
    var a3 = Math.sqrt(i3);
    return [-t4 / 2 - a3, -t4 / 2 + a3];
  })(u2 / s2, h2 / s2, a2);
}
function m$1(t3, r2, e2, i2, a2) {
  var n2 = 1 - a2;
  return t3 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
}
!(function(t3) {
  function r2() {
    return u2((function(t4, r3, e3) {
      return t4.relative && (void 0 !== t4.x1 && (t4.x1 += r3), void 0 !== t4.y1 && (t4.y1 += e3), void 0 !== t4.x2 && (t4.x2 += r3), void 0 !== t4.y2 && (t4.y2 += e3), void 0 !== t4.x && (t4.x += r3), void 0 !== t4.y && (t4.y += e3), t4.relative = false), t4;
    }));
  }
  function e2() {
    var t4 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
    return u2((function(a2, n3, o2) {
      return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t4 = isNaN(t4) ? n3 : t4, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t4 : 2 * n3 - t4, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t4 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t4 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
    }));
  }
  function n2() {
    var t4 = NaN, r3 = NaN;
    return u2((function(e3, i2, a2) {
      if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t4 = isNaN(t4) ? i2 : t4, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t4 : 2 * i2 - t4, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
        t4 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
        var n3 = e3.x1, o2 = e3.y1;
        e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
      } else t4 = NaN, r3 = NaN;
      return e3;
    }));
  }
  function u2(t4) {
    var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
    return function(n3) {
      if (isNaN(i2) && !(n3.type & _.MOVE_TO)) throw new Error("path must start with moveto");
      var o2 = t4(n3, r3, e3, i2, a2);
      return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), void 0 !== n3.x && (r3 = n3.relative ? r3 + n3.x : n3.x), void 0 !== n3.y && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
    };
  }
  function O2(t4, r3, e3, i2, n3, o2) {
    return a(t4, r3, e3, i2, n3, o2), u2((function(a2, s2, u3, h2) {
      var c2 = a2.x1, y2 = a2.x2, p2 = a2.relative && !isNaN(h2), m2 = void 0 !== a2.x ? a2.x : p2 ? 0 : s2, O3 = void 0 !== a2.y ? a2.y : p2 ? 0 : u3;
      function l3(t5) {
        return t5 * t5;
      }
      a2.type & _.HORIZ_LINE_TO && 0 !== r3 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && 0 !== e3 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), void 0 !== a2.x && (a2.x = a2.x * t4 + O3 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y && (a2.y = m2 * r3 + a2.y * i2 + (p2 ? 0 : o2)), void 0 !== a2.x1 && (a2.x1 = a2.x1 * t4 + a2.y1 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y1 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p2 ? 0 : o2)), void 0 !== a2.x2 && (a2.x2 = a2.x2 * t4 + a2.y2 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y2 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p2 ? 0 : o2));
      var T2 = t4 * i2 - r3 * e3;
      if (void 0 !== a2.xRot && (1 !== t4 || 0 !== r3 || 0 !== e3 || 1 !== i2)) if (0 === T2) delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
      else {
        var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t4 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t4 * r3), g2 = E2 * e3 * e3 - A2 * t4 * e3 + C2 * t4 * t4, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
        a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;
      }
      return void 0 !== a2.sweepFlag && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;
    }));
  }
  function l2() {
    return function(t4) {
      var r3 = {};
      for (var e3 in t4) r3[e3] = t4[e3];
      return r3;
    };
  }
  t3.ROUND = function(t4) {
    function r3(r4) {
      return Math.round(r4 * t4) / t4;
    }
    return void 0 === t4 && (t4 = 1e13), a(t4), function(t5) {
      return void 0 !== t5.x1 && (t5.x1 = r3(t5.x1)), void 0 !== t5.y1 && (t5.y1 = r3(t5.y1)), void 0 !== t5.x2 && (t5.x2 = r3(t5.x2)), void 0 !== t5.y2 && (t5.y2 = r3(t5.y2)), void 0 !== t5.x && (t5.x = r3(t5.x)), void 0 !== t5.y && (t5.y = r3(t5.y)), void 0 !== t5.rX && (t5.rX = r3(t5.rX)), void 0 !== t5.rY && (t5.rY = r3(t5.rY)), t5;
    };
  }, t3.TO_ABS = r2, t3.TO_REL = function() {
    return u2((function(t4, r3, e3) {
      return t4.relative || (void 0 !== t4.x1 && (t4.x1 -= r3), void 0 !== t4.y1 && (t4.y1 -= e3), void 0 !== t4.x2 && (t4.x2 -= r3), void 0 !== t4.y2 && (t4.y2 -= e3), void 0 !== t4.x && (t4.x -= r3), void 0 !== t4.y && (t4.y -= e3), t4.relative = true), t4;
    }));
  }, t3.NORMALIZE_HVZ = function(t4, r3, e3) {
    return void 0 === t4 && (t4 = true), void 0 === r3 && (r3 = true), void 0 === e3 && (e3 = true), u2((function(i2, a2, n3, o2, s2) {
      if (isNaN(o2) && !(i2.type & _.MOVE_TO)) throw new Error("path must start with moveto");
      return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t4 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (0 === i2.rX || 0 === i2.rY) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
    }));
  }, t3.NORMALIZE_ST = e2, t3.QT_TO_C = n2, t3.INFO = u2, t3.SANITIZE = function(t4) {
    void 0 === t4 && (t4 = 0), a(t4);
    var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
    return u2((function(a2, o2, s2, u3, h2) {
      var c2 = Math.abs, y2 = false, p2 = 0, m2 = 0;
      if (a2.type & _.SMOOTH_CURVE_TO && (p2 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (0 === a2.rX || 0 === a2.rY || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
        var O3 = void 0 === a2.x ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = void 0 === a2.y ? 0 : a2.relative ? a2.y : a2.y - s2;
        p2 = isNaN(i2) ? void 0 === a2.x1 ? p2 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? void 0 === a2.y1 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
        var T2 = void 0 === a2.x2 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = void 0 === a2.y2 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
        c2(O3) <= t4 && c2(l3) <= t4 && c2(p2) <= t4 && c2(m2) <= t4 && c2(T2) <= t4 && c2(v2) <= t4 && (y2 = true);
      }
      return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t4 && c2(s2 - h2) <= t4 && (y2 = true), y2 ? [] : a2;
    }));
  }, t3.MATRIX = O2, t3.ROTATE = function(t4, r3, e3) {
    void 0 === r3 && (r3 = 0), void 0 === e3 && (e3 = 0), a(t4, r3, e3);
    var i2 = Math.sin(t4), n3 = Math.cos(t4);
    return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
  }, t3.TRANSLATE = function(t4, r3) {
    return void 0 === r3 && (r3 = 0), a(t4, r3), O2(1, 0, 0, 1, t4, r3);
  }, t3.SCALE = function(t4, r3) {
    return void 0 === r3 && (r3 = t4), a(t4, r3), O2(t4, 0, 0, r3, 0, 0);
  }, t3.SKEW_X = function(t4) {
    return a(t4), O2(1, 0, Math.atan(t4), 1, 0, 0);
  }, t3.SKEW_Y = function(t4) {
    return a(t4), O2(1, Math.atan(t4), 0, 1, 0, 0);
  }, t3.X_AXIS_SYMMETRY = function(t4) {
    return void 0 === t4 && (t4 = 0), a(t4), O2(-1, 0, 0, 1, t4, 0);
  }, t3.Y_AXIS_SYMMETRY = function(t4) {
    return void 0 === t4 && (t4 = 0), a(t4), O2(1, 0, 0, -1, 0, t4);
  }, t3.A_TO_C = function() {
    return u2((function(t4, r3, e3) {
      return _.ARC === t4.type ? (function(t5, r4, e4) {
        var a2, n3, s2, u3;
        t5.cX || o(t5, r4, e4);
        for (var y2 = Math.min(t5.phi1, t5.phi2), p2 = Math.max(t5.phi1, t5.phi2) - y2, m2 = Math.ceil(p2 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {
          var f2 = c$1(t5.phi1, t5.phi2, v2 / m2), N2 = c$1(t5.phi1, t5.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];
          O3[v2] = { relative: t5.relative, type: _.CURVE_TO };
          var H4 = function(r5, e5) {
            var a3 = i([r5 * t5.rX, e5 * t5.rY], t5.xRot), n4 = a3[0], o2 = a3[1];
            return [t5.cX + n4, t5.cY + o2];
          };
          a2 = H4(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H4(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H4(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t5.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];
        }
        return O3;
      })(t4, t4.relative ? 0 : r3, t4.relative ? 0 : e3) : t4;
    }));
  }, t3.ANNOTATE_ARCS = function() {
    return u2((function(t4, r3, e3) {
      return t4.relative && (r3 = 0, e3 = 0), _.ARC === t4.type && o(t4, r3, e3), t4;
    }));
  }, t3.CLONE = l2, t3.CALCULATE_BOUNDS = function() {
    var t4 = function(t5) {
      var r3 = {};
      for (var e3 in t5) r3[e3] = t5[e3];
      return r3;
    }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2((function(r3, e3, n3) {
      var u3 = h2(a2(i2(t4(r3))));
      function O3(t5) {
        t5 > c2.maxX && (c2.maxX = t5), t5 < c2.minX && (c2.minX = t5);
      }
      function l3(t5) {
        t5 > c2.maxY && (c2.maxY = t5), t5 < c2.minY && (c2.minY = t5);
      }
      if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
        O3(u3.x), l3(u3.y);
        for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {
          0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));
        }
        for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {
          0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));
        }
      }
      if (u3.type & _.ARC) {
        O3(u3.x), l3(u3.y), o(u3, e3, n3);
        for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t5) {
          var r4 = t5[0], e4 = t5[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
          return i3 < R2 ? i3 + 360 : i3;
        }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
          (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));
        }
        for (var H4 = 0, U2 = s(C2, -E2, 0).map(I2); H4 < U2.length; H4++) {
          var w2;
          (w2 = U2[H4]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));
        }
      }
      return r3;
    }));
    return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
  };
})(u || (u = {}));
var O, l = (function() {
  function t3() {
  }
  return t3.prototype.round = function(t4) {
    return this.transform(u.ROUND(t4));
  }, t3.prototype.toAbs = function() {
    return this.transform(u.TO_ABS());
  }, t3.prototype.toRel = function() {
    return this.transform(u.TO_REL());
  }, t3.prototype.normalizeHVZ = function(t4, r2, e2) {
    return this.transform(u.NORMALIZE_HVZ(t4, r2, e2));
  }, t3.prototype.normalizeST = function() {
    return this.transform(u.NORMALIZE_ST());
  }, t3.prototype.qtToC = function() {
    return this.transform(u.QT_TO_C());
  }, t3.prototype.aToC = function() {
    return this.transform(u.A_TO_C());
  }, t3.prototype.sanitize = function(t4) {
    return this.transform(u.SANITIZE(t4));
  }, t3.prototype.translate = function(t4, r2) {
    return this.transform(u.TRANSLATE(t4, r2));
  }, t3.prototype.scale = function(t4, r2) {
    return this.transform(u.SCALE(t4, r2));
  }, t3.prototype.rotate = function(t4, r2, e2) {
    return this.transform(u.ROTATE(t4, r2, e2));
  }, t3.prototype.matrix = function(t4, r2, e2, i2, a2, n2) {
    return this.transform(u.MATRIX(t4, r2, e2, i2, a2, n2));
  }, t3.prototype.skewX = function(t4) {
    return this.transform(u.SKEW_X(t4));
  }, t3.prototype.skewY = function(t4) {
    return this.transform(u.SKEW_Y(t4));
  }, t3.prototype.xSymmetry = function(t4) {
    return this.transform(u.X_AXIS_SYMMETRY(t4));
  }, t3.prototype.ySymmetry = function(t4) {
    return this.transform(u.Y_AXIS_SYMMETRY(t4));
  }, t3.prototype.annotateArcs = function() {
    return this.transform(u.ANNOTATE_ARCS());
  }, t3;
})(), T = function(t3) {
  return " " === t3 || "	" === t3 || "\r" === t3 || "\n" === t3;
}, v = function(t3) {
  return "0".charCodeAt(0) <= t3.charCodeAt(0) && t3.charCodeAt(0) <= "9".charCodeAt(0);
}, f = (function(t3) {
  function e2() {
    var r2 = t3.call(this) || this;
    return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
  }
  return r(e2, t3), e2.prototype.finish = function(t4) {
    if (void 0 === t4 && (t4 = []), this.parse(" ", t4), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
    return t4;
  }, e2.prototype.parse = function(t4, r2) {
    var e3 = this;
    void 0 === r2 && (r2 = []);
    for (var i2 = function(t5) {
      r2.push(t5), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
    }, a2 = 0; a2 < t4.length; a2++) {
      var n2 = t4[a2], o2 = !(this.curCommandType !== _.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s2 = v(n2) && ("0" === this.curNumber && "0" === n2 || o2);
      if (!v(n2) || s2) if ("e" !== n2 && "E" !== n2) if ("-" !== n2 && "+" !== n2 || !this.curNumberHasExp || this.curNumberHasExpDigits) if ("." !== n2 || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
        if (this.curNumber && -1 !== this.curCommandType) {
          var u2 = Number(this.curNumber);
          if (isNaN(u2)) throw new SyntaxError("Invalid number ending at " + a2);
          if (this.curCommandType === _.ARC) {
            if (0 === this.curArgs.length || 1 === this.curArgs.length) {
              if (0 > u2) throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
            } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
          }
          this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
        }
        if (!T(n2)) if ("," === n2 && this.canParseCommandOrComma) this.canParseCommandOrComma = false;
        else if ("+" !== n2 && "-" !== n2 && "." !== n2) if (s2) this.curNumber = n2, this.curNumberHasDecimal = false;
        else {
          if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + a2 + ".");
          if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
          if (this.canParseCommandOrComma = false, "z" !== n2 && "Z" !== n2) if ("h" === n2 || "H" === n2) this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = "h" === n2;
          else if ("v" === n2 || "V" === n2) this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = "v" === n2;
          else if ("m" === n2 || "M" === n2) this.curCommandType = _.MOVE_TO, this.curCommandRelative = "m" === n2;
          else if ("l" === n2 || "L" === n2) this.curCommandType = _.LINE_TO, this.curCommandRelative = "l" === n2;
          else if ("c" === n2 || "C" === n2) this.curCommandType = _.CURVE_TO, this.curCommandRelative = "c" === n2;
          else if ("s" === n2 || "S" === n2) this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n2;
          else if ("q" === n2 || "Q" === n2) this.curCommandType = _.QUAD_TO, this.curCommandRelative = "q" === n2;
          else if ("t" === n2 || "T" === n2) this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n2;
          else {
            if ("a" !== n2 && "A" !== n2) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
            this.curCommandType = _.ARC, this.curCommandRelative = "a" === n2;
          }
          else r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
        }
        else this.curNumber = n2, this.curNumberHasDecimal = "." === n2;
      } else this.curNumber += n2, this.curNumberHasDecimal = true;
      else this.curNumber += n2;
      else this.curNumber += n2, this.curNumberHasExp = true;
      else this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return r2;
  }, e2.prototype.transform = function(t4) {
    return Object.create(this, { parse: { value: function(r2, e3) {
      void 0 === e3 && (e3 = []);
      for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
        var n2 = a2[i2], o2 = t4(n2);
        Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
      }
      return e3;
    } } });
  }, e2;
})(l), _ = (function(t3) {
  function i2(r2) {
    var e2 = t3.call(this) || this;
    return e2.commands = "string" == typeof r2 ? i2.parse(r2) : r2, e2;
  }
  return r(i2, t3), i2.prototype.encode = function() {
    return i2.encode(this.commands);
  }, i2.prototype.getBounds = function() {
    var t4 = u.CALCULATE_BOUNDS();
    return this.transform(t4), t4;
  }, i2.prototype.transform = function(t4) {
    for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
      var a2 = t4(i3[e2]);
      Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
    }
    return this.commands = r2, this;
  }, i2.encode = function(t4) {
    return e(t4);
  }, i2.parse = function(t4) {
    var r2 = new f(), e2 = [];
    return r2.parse(t4, e2), r2.finish(e2), e2;
  }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
})(l), N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
var es_regexp_toString = {};
var hasRequiredEs_regexp_toString;
function requireEs_regexp_toString() {
  if (hasRequiredEs_regexp_toString) return es_regexp_toString;
  hasRequiredEs_regexp_toString = 1;
  var PROPER_FUNCTION_NAME = requireFunctionName().PROPER;
  var defineBuiltIn2 = requireDefineBuiltIn();
  var anObject2 = requireAnObject();
  var $toString = requireToString();
  var fails2 = requireFails();
  var getRegExpFlags = requireRegexpGetFlags();
  var TO_STRING = "toString";
  var RegExpPrototype = RegExp.prototype;
  var nativeToString = RegExpPrototype[TO_STRING];
  var NOT_GENERIC = fails2(function() {
    return nativeToString.call({ source: "a", flags: "b" }) !== "/a/b";
  });
  var INCORRECT_NAME = PROPER_FUNCTION_NAME && nativeToString.name !== TO_STRING;
  if (NOT_GENERIC || INCORRECT_NAME) {
    defineBuiltIn2(RegExpPrototype, TO_STRING, function toString3() {
      var R2 = anObject2(this);
      var pattern = $toString(R2.source);
      var flags = $toString(getRegExpFlags(R2));
      return "/" + pattern + "/" + flags;
    }, { unsafe: true });
  }
  return es_regexp_toString;
}
requireEs_regexp_toString();
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function getImageDataFromCanvas(canvas, topX, topY, width, height) {
  if (typeof canvas === "string") {
    canvas = document.getElementById(canvas);
  }
  if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  }
  var context = canvas.getContext("2d");
  try {
    return context.getImageData(topX, topY, width, height);
  } catch (e2) {
    throw new Error("unable to access image data: " + e2);
  }
}
function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
  if (isNaN(radius) || radius < 1) {
    return;
  }
  radius |= 0;
  var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
  imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
  canvas.getContext("2d").putImageData(imageData, topX, topY);
}
function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
  var pixels = imageData.data;
  var div = 2 * radius + 1;
  var widthMinus1 = width - 1;
  var heightMinus1 = height - 1;
  var radiusPlus1 = radius + 1;
  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
  var stackStart = new BlurStack();
  var stack = stackStart;
  var stackEnd;
  for (var i2 = 1; i2 < div; i2++) {
    stack = stack.next = new BlurStack();
    if (i2 === radiusPlus1) {
      stackEnd = stack;
    }
  }
  stack.next = stackStart;
  var stackIn = null, stackOut = null, yw = 0, yi = 0;
  var mulSum = mulTable[radius];
  var shgSum = shgTable[radius];
  for (var y2 = 0; y2 < height; y2++) {
    stack = stackStart;
    var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
    for (var _i = 0; _i < radiusPlus1; _i++) {
      stack.r = pr;
      stack.g = pg;
      stack.b = pb;
      stack.a = pa;
      stack = stack.next;
    }
    var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
    for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
      var p2 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
      var r2 = pixels[p2], g2 = pixels[p2 + 1], b2 = pixels[p2 + 2], a2 = pixels[p2 + 3];
      var rbs = radiusPlus1 - _i2;
      rSum += (stack.r = r2) * rbs;
      gSum += (stack.g = g2) * rbs;
      bSum += (stack.b = b2) * rbs;
      aSum += (stack.a = a2) * rbs;
      rInSum += r2;
      gInSum += g2;
      bInSum += b2;
      aInSum += a2;
      stack = stack.next;
    }
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var x2 = 0; x2 < width; x2++) {
      var paInitial = aSum * mulSum >>> shgSum;
      pixels[yi + 3] = paInitial;
      if (paInitial !== 0) {
        var _a2 = 255 / paInitial;
        pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
        pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
      } else {
        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
      }
      rSum -= rOutSum;
      gSum -= gOutSum;
      bSum -= bOutSum;
      aSum -= aOutSum;
      rOutSum -= stackIn.r;
      gOutSum -= stackIn.g;
      bOutSum -= stackIn.b;
      aOutSum -= stackIn.a;
      var _p = x2 + radius + 1;
      _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
      rInSum += stackIn.r = pixels[_p];
      gInSum += stackIn.g = pixels[_p + 1];
      bInSum += stackIn.b = pixels[_p + 2];
      aInSum += stackIn.a = pixels[_p + 3];
      rSum += rInSum;
      gSum += gInSum;
      bSum += bInSum;
      aSum += aInSum;
      stackIn = stackIn.next;
      var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
      rOutSum += _r;
      gOutSum += _g;
      bOutSum += _b2;
      aOutSum += _a3;
      rInSum -= _r;
      gInSum -= _g;
      bInSum -= _b2;
      aInSum -= _a3;
      stackOut = stackOut.next;
      yi += 4;
    }
    yw += width;
  }
  for (var _x = 0; _x < width; _x++) {
    yi = _x << 2;
    var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
    stack = stackStart;
    for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
      stack.r = _pr;
      stack.g = _pg;
      stack.b = _pb;
      stack.a = _pa;
      stack = stack.next;
    }
    var yp = width;
    var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
    for (var _i4 = 1; _i4 <= radius; _i4++) {
      yi = yp + _x << 2;
      var _rbs = radiusPlus1 - _i4;
      _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
      _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
      _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
      _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
      _rInSum += _pr;
      _gInSum += _pg;
      _bInSum += _pb;
      _aInSum += _pa;
      stack = stack.next;
      if (_i4 < heightMinus1) {
        yp += width;
      }
    }
    yi = _x;
    stackIn = stackStart;
    stackOut = stackEnd;
    for (var _y = 0; _y < height; _y++) {
      var _p2 = yi << 2;
      pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
      if (_pa > 0) {
        _pa = 255 / _pa;
        pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
        pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
      } else {
        pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
      }
      _rSum -= _rOutSum;
      _gSum -= _gOutSum;
      _bSum -= _bOutSum;
      _aSum -= _aOutSum;
      _rOutSum -= stackIn.r;
      _gOutSum -= stackIn.g;
      _bOutSum -= stackIn.b;
      _aOutSum -= stackIn.a;
      _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
      _rSum += _rInSum += stackIn.r = pixels[_p2];
      _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
      _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
      _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
      stackIn = stackIn.next;
      _rOutSum += _pr = stackOut.r;
      _gOutSum += _pg = stackOut.g;
      _bOutSum += _pb = stackOut.b;
      _aOutSum += _pa = stackOut.a;
      _rInSum -= _pr;
      _gInSum -= _pg;
      _bInSum -= _pb;
      _aInSum -= _pa;
      stackOut = stackOut.next;
      yi += width;
    }
  }
  return imageData;
}
var BlurStack = (
  /**
   * Set properties.
   */
  function BlurStack2() {
    _classCallCheck(this, BlurStack2);
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  }
);
function offscreen() {
  var {
    DOMParser: DOMParserFallback
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var preset = {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParserFallback,
    createCanvas(width, height) {
      return new OffscreenCanvas(width, height);
    },
    createImage(url) {
      return _asyncToGenerator(function* () {
        var response = yield fetch(url);
        var blob = yield response.blob();
        var img = yield createImageBitmap(blob);
        return img;
      })();
    }
  };
  if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
    Reflect.deleteProperty(preset, "DOMParser");
  }
  return preset;
}
function node(_ref) {
  var {
    DOMParser: DOMParser2,
    canvas,
    fetch: fetch2
  } = _ref;
  return {
    window: null,
    ignoreAnimation: true,
    ignoreMouse: true,
    DOMParser: DOMParser2,
    fetch: fetch2,
    createCanvas: canvas.createCanvas,
    createImage: canvas.loadImage
  };
}
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  offscreen,
  node
});
function compressSpaces(str) {
  return str.replace(/(?!\u3000)\s+/gm, " ");
}
function trimLeft(str) {
  return str.replace(/^[\n \t]+/, "");
}
function trimRight(str) {
  return str.replace(/[\n \t]+$/, "");
}
function toNumbers(str) {
  var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
  return matches.map(parseFloat);
}
var allUppercase = /^[A-Z-]+$/;
function normalizeAttributeName(name) {
  if (allUppercase.test(name)) {
    return name.toLowerCase();
  }
  return name;
}
function parseExternalUrl(url) {
  var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
  return urlMatch[2] || urlMatch[3] || urlMatch[4];
}
function normalizeColor(color2) {
  if (!color2.startsWith("rgb")) {
    return color2;
  }
  var rgbParts = 3;
  var normalizedColor = color2.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
  return normalizedColor;
}
var attributeRegex = /(\[[^\]]+\])/g;
var idRegex = /(#[^\s+>~.[:]+)/g;
var classRegex = /(\.[^\s+>~.[:]+)/g;
var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
var elementRegex = /([^\s+>~.[:]+)/g;
function findSelectorMatch(selector, regex) {
  var matches = regex.exec(selector);
  if (!matches) {
    return [selector, 0];
  }
  return [selector.replace(regex, " "), matches.length];
}
function getSelectorSpecificity(selector) {
  var specificity = [0, 0, 0];
  var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
  var delta = 0;
  [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
  specificity[0] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
  specificity[2] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
  specificity[1] += delta;
  [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
  specificity[1] += delta;
  currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
  [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
  specificity[2] += delta;
  return specificity.join("");
}
var PSEUDO_ZERO = 1e-8;
function vectorMagnitude(v2) {
  return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
}
function vectorsRatio(u2, v2) {
  return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
}
function vectorsAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
}
function CB1(t3) {
  return t3 * t3 * t3;
}
function CB2(t3) {
  return 3 * t3 * t3 * (1 - t3);
}
function CB3(t3) {
  return 3 * t3 * (1 - t3) * (1 - t3);
}
function CB4(t3) {
  return (1 - t3) * (1 - t3) * (1 - t3);
}
function QB1(t3) {
  return t3 * t3;
}
function QB2(t3) {
  return 2 * t3 * (1 - t3);
}
function QB3(t3) {
  return (1 - t3) * (1 - t3);
}
class Property {
  constructor(document2, name, value) {
    this.document = document2;
    this.name = name;
    this.value = value;
    this.isNormalizedColor = false;
  }
  static empty(document2) {
    return new Property(document2, "EMPTY", "");
  }
  split() {
    var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    var {
      document: document2,
      name
    } = this;
    return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
  }
  hasValue(zeroIsValue) {
    var {
      value
    } = this;
    return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
  }
  isString(regexp) {
    var {
      value
    } = this;
    var result = typeof value === "string";
    if (!result || !regexp) {
      return result;
    }
    return regexp.test(value);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue()) {
      return false;
    }
    var asString2 = this.getString();
    switch (true) {
      case asString2.endsWith("px"):
      case /^[0-9]+$/.test(asString2):
        return true;
      default:
        return false;
    }
  }
  setValue(value) {
    this.value = value;
    return this;
  }
  getValue(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return this.value;
    }
    return def;
  }
  getNumber(def) {
    if (!this.hasValue()) {
      if (typeof def === "undefined") {
        return 0;
      }
      return parseFloat(def);
    }
    var {
      value
    } = this;
    var n2 = parseFloat(value);
    if (this.isString(/%$/)) {
      n2 /= 100;
    }
    return n2;
  }
  getString(def) {
    if (typeof def === "undefined" || this.hasValue()) {
      return typeof this.value === "undefined" ? "" : String(this.value);
    }
    return String(def);
  }
  getColor(def) {
    var color2 = this.getString(def);
    if (this.isNormalizedColor) {
      return color2;
    }
    this.isNormalizedColor = true;
    color2 = normalizeColor(color2);
    this.value = color2;
    return color2;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(axisOrIsFontSize) {
    var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!this.hasValue()) {
      return 0;
    }
    var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
    var {
      viewPort
    } = this.document.screen;
    switch (true) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * viewPort.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * viewPort.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && isFontSize):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * viewPort.computeSize(axis);
      default: {
        var n2 = this.getNumber();
        if (processPercent && n2 < 1) {
          return n2 * viewPort.computeSize(axis);
        }
        return n2;
      }
    }
  }
  getMilliseconds() {
    if (!this.hasValue()) {
      return 0;
    }
    if (this.isString(/ms$/)) {
      return this.getNumber();
    }
    return this.getNumber() * 1e3;
  }
  getRadians() {
    if (!this.hasValue()) {
      return 0;
    }
    switch (true) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    var asString2 = this.getString();
    var name = /#([^)'"]+)/.exec(asString2);
    if (name) {
      name = name[1];
    }
    if (!name) {
      name = asString2;
    }
    return this.document.definitions[name];
  }
  getFillStyleDefinition(element, opacity2) {
    var def = this.getDefinition();
    if (!def) {
      return null;
    }
    if (typeof def.createGradient === "function") {
      return def.createGradient(this.document.ctx, element, opacity2);
    }
    if (typeof def.createPattern === "function") {
      if (def.getHrefAttribute().hasValue()) {
        var patternTransform = def.getAttribute("patternTransform");
        def = def.getHrefAttribute().getDefinition();
        if (patternTransform.hasValue()) {
          def.getAttribute("patternTransform", true).setValue(patternTransform.value);
        }
      }
      return def.createPattern(this.document.ctx, element, opacity2);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue()) {
      return null;
    }
    return Property.textBaselineMapping[this.getString()];
  }
  addOpacity(opacity2) {
    var value = this.getColor();
    var len = value.length;
    var commas = 0;
    for (var i2 = 0; i2 < len; i2++) {
      if (value[i2] === ",") {
        commas++;
      }
      if (commas === 3) {
        break;
      }
    }
    if (opacity2.hasValue() && this.isString() && commas !== 3) {
      var color2 = new RGBColor$1(value);
      if (color2.ok) {
        color2.alpha = opacity2.getNumber();
        value = color2.toRGBA();
      }
    }
    return new Property(this.document, this.name, value);
  }
}
Property.textBaselineMapping = {
  "baseline": "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  "middle": "middle",
  "central": "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  "ideographic": "ideographic",
  "alphabetic": "alphabetic",
  "hanging": "hanging",
  "mathematical": "alphabetic"
};
class ViewPort {
  constructor() {
    this.viewPorts = [];
  }
  clear() {
    this.viewPorts = [];
  }
  setCurrent(width, height) {
    this.viewPorts.push({
      width,
      height
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getCurrent() {
    var {
      viewPorts
    } = this;
    return viewPorts[viewPorts.length - 1];
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(d2) {
    if (typeof d2 === "number") {
      return d2;
    }
    if (d2 === "x") {
      return this.width;
    }
    if (d2 === "y") {
      return this.height;
    }
    return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
}
class Point {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
  static parse(point) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
    return new Point(x2, y2);
  }
  static parseScale(scale) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var [x2 = defaultValue, y2 = x2] = toNumbers(scale);
    return new Point(x2, y2);
  }
  static parsePath(path2) {
    var points = toNumbers(path2);
    var len = points.length;
    var pathPoints = [];
    for (var i2 = 0; i2 < len; i2 += 2) {
      pathPoints.push(new Point(points[i2], points[i2 + 1]));
    }
    return pathPoints;
  }
  angleTo(point) {
    return Math.atan2(point.y - this.y, point.x - this.x);
  }
  applyTransform(transform2) {
    var {
      x: x2,
      y: y2
    } = this;
    var xp = x2 * transform2[0] + y2 * transform2[2] + transform2[4];
    var yp = x2 * transform2[1] + y2 * transform2[3] + transform2[5];
    this.x = xp;
    this.y = yp;
  }
}
class Mouse {
  constructor(screen) {
    this.screen = screen;
    this.working = false;
    this.events = [];
    this.eventElements = [];
    this.onClick = this.onClick.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
  }
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working) {
      return;
    }
    var {
      screen,
      onClick,
      onMouseMove
    } = this;
    var canvas = screen.ctx.canvas;
    canvas.onclick = onClick;
    canvas.onmousemove = onMouseMove;
    this.working = true;
  }
  stop() {
    if (!this.working) {
      return;
    }
    var canvas = this.screen.ctx.canvas;
    this.working = false;
    canvas.onclick = null;
    canvas.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working) {
      return;
    }
    var {
      screen: document2,
      events,
      eventElements
    } = this;
    var {
      style
    } = document2.ctx.canvas;
    if (style) {
      style.cursor = "";
    }
    events.forEach((_ref, i2) => {
      var {
        run
      } = _ref;
      var element = eventElements[i2];
      while (element) {
        run(element);
        element = element.parent;
      }
    });
    this.events = [];
    this.eventElements = [];
  }
  checkPath(element, ctx) {
    if (!this.working || !ctx) {
      return;
    }
    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref2, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref2;
      if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  checkBoundingBox(element, boundingBox) {
    if (!this.working || !boundingBox) {
      return;
    }
    var {
      events,
      eventElements
    } = this;
    events.forEach((_ref3, i2) => {
      var {
        x: x2,
        y: y2
      } = _ref3;
      if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {
        eventElements[i2] = element;
      }
    });
  }
  mapXY(x2, y2) {
    var {
      window: window2,
      ctx
    } = this.screen;
    var point = new Point(x2, y2);
    var element = ctx.canvas;
    while (element) {
      point.x -= element.offsetLeft;
      point.y -= element.offsetTop;
      element = element.offsetParent;
    }
    if (window2.scrollX) {
      point.x += window2.scrollX;
    }
    if (window2.scrollY) {
      point.y += window2.scrollY;
    }
    return point;
  }
  onClick(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onclick",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onClick) {
          eventTarget.onClick();
        }
      }
    });
  }
  onMouseMove(event) {
    var {
      x: x2,
      y: y2
    } = this.mapXY(event.clientX, event.clientY);
    this.events.push({
      type: "onmousemove",
      x: x2,
      y: y2,
      run(eventTarget) {
        if (eventTarget.onMouseMove) {
          eventTarget.onMouseMove();
        }
      }
    });
  }
}
var defaultWindow = typeof window !== "undefined" ? window : null;
var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
class Screen {
  constructor(ctx) {
    var {
      fetch: fetch2 = defaultFetch$1,
      window: window2 = defaultWindow
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.ctx = ctx;
    this.FRAMERATE = 30;
    this.MAX_VIRTUAL_PIXELS = 3e4;
    this.CLIENT_WIDTH = 800;
    this.CLIENT_HEIGHT = 600;
    this.viewPort = new ViewPort();
    this.mouse = new Mouse(this);
    this.animations = [];
    this.waits = [];
    this.frameDuration = 0;
    this.isReadyLock = false;
    this.isFirstRender = true;
    this.intervalId = null;
    this.window = window2;
    this.fetch = fetch2;
  }
  wait(checker) {
    this.waits.push(checker);
  }
  ready() {
    if (!this.readyPromise) {
      return Promise.resolve();
    }
    return this.readyPromise;
  }
  isReady() {
    if (this.isReadyLock) {
      return true;
    }
    var isReadyLock = this.waits.every((_2) => _2());
    if (isReadyLock) {
      this.waits = [];
      if (this.resolveReady) {
        this.resolveReady();
      }
    }
    this.isReadyLock = isReadyLock;
    return isReadyLock;
  }
  setDefaults(ctx) {
    ctx.strokeStyle = "rgba(0,0,0,0)";
    ctx.lineCap = "butt";
    ctx.lineJoin = "miter";
    ctx.miterLimit = 4;
  }
  setViewBox(_ref) {
    var {
      document: document2,
      ctx,
      aspectRatio,
      width,
      desiredWidth,
      height,
      desiredHeight,
      minX = 0,
      minY = 0,
      refX,
      refY,
      clip = false,
      clipX = 0,
      clipY = 0
    } = _ref;
    var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
    var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
    var align = aspectRatioAlign || "xMidYMid";
    var meetOrSlice = aspectRatioMeetOrSlice || "meet";
    var scaleX = width / desiredWidth;
    var scaleY = height / desiredHeight;
    var scaleMin = Math.min(scaleX, scaleY);
    var scaleMax = Math.max(scaleX, scaleY);
    var finalDesiredWidth = desiredWidth;
    var finalDesiredHeight = desiredHeight;
    if (meetOrSlice === "meet") {
      finalDesiredWidth *= scaleMin;
      finalDesiredHeight *= scaleMin;
    }
    if (meetOrSlice === "slice") {
      finalDesiredWidth *= scaleMax;
      finalDesiredHeight *= scaleMax;
    }
    var refXProp = new Property(document2, "refX", refX);
    var refYProp = new Property(document2, "refY", refY);
    var hasRefs = refXProp.hasValue() && refYProp.hasValue();
    if (hasRefs) {
      ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
    }
    if (clip) {
      var scaledClipX = scaleMin * clipX;
      var scaledClipY = scaleMin * clipY;
      ctx.beginPath();
      ctx.moveTo(scaledClipX, scaledClipY);
      ctx.lineTo(width, scaledClipY);
      ctx.lineTo(width, height);
      ctx.lineTo(scaledClipX, height);
      ctx.closePath();
      ctx.clip();
    }
    if (!hasRefs) {
      var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
      var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
      var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
      var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
      if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
      }
      if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height / 2 - finalDesiredHeight / 2);
      }
      if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
        ctx.translate(width - finalDesiredWidth, 0);
      }
      if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
        ctx.translate(0, height - finalDesiredHeight);
      }
    }
    switch (true) {
      case align === "none":
        ctx.scale(scaleX, scaleY);
        break;
      case meetOrSlice === "meet":
        ctx.scale(scaleMin, scaleMin);
        break;
      case meetOrSlice === "slice":
        ctx.scale(scaleMax, scaleMax);
        break;
    }
    ctx.translate(-minX, -minY);
  }
  start(element) {
    var {
      enableRedraw = false,
      ignoreMouse = false,
      ignoreAnimation = false,
      ignoreDimensions = false,
      ignoreClear = false,
      forceRedraw,
      scaleWidth,
      scaleHeight,
      offsetX,
      offsetY
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      FRAMERATE,
      mouse
    } = this;
    var frameDuration = 1e3 / FRAMERATE;
    this.frameDuration = frameDuration;
    this.readyPromise = new Promise((resolve) => {
      this.resolveReady = resolve;
    });
    if (this.isReady()) {
      this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
    }
    if (!enableRedraw) {
      return;
    }
    var now = Date.now();
    var then = now;
    var delta = 0;
    var tick = () => {
      now = Date.now();
      delta = now - then;
      if (delta >= frameDuration) {
        then = now - delta % frameDuration;
        if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
          this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
          mouse.runEvents();
        }
      }
      this.intervalId = requestAnimationFrame(tick);
    };
    if (!ignoreMouse) {
      mouse.start();
    }
    this.intervalId = requestAnimationFrame(tick);
  }
  stop() {
    if (this.intervalId) {
      requestAnimationFrame.cancel(this.intervalId);
      this.intervalId = null;
    }
    this.mouse.stop();
  }
  shouldUpdate(ignoreAnimation, forceRedraw) {
    if (!ignoreAnimation) {
      var {
        frameDuration
      } = this;
      var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
      if (shouldUpdate) {
        return true;
      }
    }
    if (typeof forceRedraw === "function" && forceRedraw()) {
      return true;
    }
    if (!this.isReadyLock && this.isReady()) {
      return true;
    }
    if (this.mouse.hasEvents()) {
      return true;
    }
    return false;
  }
  render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
    var {
      CLIENT_WIDTH,
      CLIENT_HEIGHT,
      viewPort,
      ctx,
      isFirstRender
    } = this;
    var canvas = ctx.canvas;
    viewPort.clear();
    if (canvas.width && canvas.height) {
      viewPort.setCurrent(canvas.width, canvas.height);
    } else {
      viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
    }
    var widthStyle = element.getStyle("width");
    var heightStyle = element.getStyle("height");
    if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
      if (widthStyle.hasValue()) {
        canvas.width = widthStyle.getPixels("x");
        if (canvas.style) {
          canvas.style.width = "".concat(canvas.width, "px");
        }
      }
      if (heightStyle.hasValue()) {
        canvas.height = heightStyle.getPixels("y");
        if (canvas.style) {
          canvas.style.height = "".concat(canvas.height, "px");
        }
      }
    }
    var cWidth = canvas.clientWidth || canvas.width;
    var cHeight = canvas.clientHeight || canvas.height;
    if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
      cWidth = widthStyle.getPixels("x");
      cHeight = heightStyle.getPixels("y");
    }
    viewPort.setCurrent(cWidth, cHeight);
    if (typeof offsetX === "number") {
      element.getAttribute("x", true).setValue(offsetX);
    }
    if (typeof offsetY === "number") {
      element.getAttribute("y", true).setValue(offsetY);
    }
    if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
      var viewBox = toNumbers(element.getAttribute("viewBox").getString());
      var xRatio = 0;
      var yRatio = 0;
      if (typeof scaleWidth === "number") {
        var _widthStyle = element.getStyle("width");
        if (_widthStyle.hasValue()) {
          xRatio = _widthStyle.getPixels("x") / scaleWidth;
        } else if (!isNaN(viewBox[2])) {
          xRatio = viewBox[2] / scaleWidth;
        }
      }
      if (typeof scaleHeight === "number") {
        var _heightStyle = element.getStyle("height");
        if (_heightStyle.hasValue()) {
          yRatio = _heightStyle.getPixels("y") / scaleHeight;
        } else if (!isNaN(viewBox[3])) {
          yRatio = viewBox[3] / scaleHeight;
        }
      }
      if (!xRatio) {
        xRatio = yRatio;
      }
      if (!yRatio) {
        yRatio = xRatio;
      }
      element.getAttribute("width", true).setValue(scaleWidth);
      element.getAttribute("height", true).setValue(scaleHeight);
      var transformStyle = element.getStyle("transform", true, true);
      transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
    }
    if (!ignoreClear) {
      ctx.clearRect(0, 0, cWidth, cHeight);
    }
    element.render(ctx);
    if (isFirstRender) {
      this.isFirstRender = false;
    }
  }
}
Screen.defaultWindow = defaultWindow;
Screen.defaultFetch = defaultFetch$1;
var {
  defaultFetch
} = Screen;
var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
class Parser {
  constructor() {
    var {
      fetch: fetch2 = defaultFetch,
      DOMParser: DOMParser2 = DefaultDOMParser
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fetch = fetch2;
    this.DOMParser = DOMParser2;
  }
  parse(resource) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (resource.startsWith("<")) {
        return _this.parseFromString(resource);
      }
      return _this.load(resource);
    })();
  }
  parseFromString(xml2) {
    var parser = new this.DOMParser();
    try {
      return this.checkDocument(parser.parseFromString(xml2, "image/svg+xml"));
    } catch (err) {
      return this.checkDocument(parser.parseFromString(xml2, "text/xml"));
    }
  }
  checkDocument(document2) {
    var parserError = document2.getElementsByTagName("parsererror")[0];
    if (parserError) {
      throw new Error(parserError.textContent);
    }
    return document2;
  }
  load(url) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var response = yield _this2.fetch(url);
      var xml2 = yield response.text();
      return _this2.parseFromString(xml2);
    })();
  }
}
class Translate {
  constructor(_2, point) {
    this.type = "translate";
    this.point = null;
    this.point = Point.parse(point);
  }
  apply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(x2 || 0, y2 || 0);
  }
  unapply(ctx) {
    var {
      x: x2,
      y: y2
    } = this.point;
    ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.point;
    point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
  }
}
class Rotate {
  constructor(document2, rotate, transformOrigin2) {
    this.type = "rotate";
    this.angle = null;
    this.originX = null;
    this.originY = null;
    this.cx = 0;
    this.cy = 0;
    var numbers = toNumbers(rotate);
    this.angle = new Property(document2, "angle", numbers[0]);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
    this.cx = numbers[1] || 0;
    this.cy = numbers[2] || 0;
  }
  apply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      cx,
      cy,
      originX,
      originY,
      angle: angle2
    } = this;
    var tx = cx + originX.getPixels("x");
    var ty = cy + originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.rotate(-1 * angle2.getRadians());
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      cx,
      cy,
      angle: angle2
    } = this;
    var rad = angle2.getRadians();
    point.applyTransform([
      1,
      0,
      0,
      1,
      cx || 0,
      cy || 0
      // this.p.y
    ]);
    point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
    point.applyTransform([
      1,
      0,
      0,
      1,
      -cx || 0,
      -cy || 0
      // -this.p.y
    ]);
  }
}
class Scale {
  constructor(_2, scale, transformOrigin2) {
    this.type = "scale";
    this.scale = null;
    this.originX = null;
    this.originY = null;
    var scaleSize = Point.parseScale(scale);
    if (scaleSize.x === 0 || scaleSize.y === 0) {
      scaleSize.x = PSEUDO_ZERO;
      scaleSize.y = PSEUDO_ZERO;
    }
    this.scale = scaleSize;
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(x2, y2 || x2);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      scale: {
        x: x2,
        y: y2
      },
      originX,
      originY
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.scale(1 / x2, 1 / y2 || x2);
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    var {
      x: x2,
      y: y2
    } = this.scale;
    point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
  }
}
class Matrix {
  constructor(_2, matrix2, transformOrigin2) {
    this.type = "matrix";
    this.matrix = [];
    this.originX = null;
    this.originY = null;
    this.matrix = toNumbers(matrix2);
    this.originX = transformOrigin2[0];
    this.originY = transformOrigin2[1];
  }
  apply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
    ctx.translate(-tx, -ty);
  }
  unapply(ctx) {
    var {
      originX,
      originY,
      matrix: matrix2
    } = this;
    var a2 = matrix2[0];
    var b2 = matrix2[2];
    var c2 = matrix2[4];
    var d2 = matrix2[1];
    var e2 = matrix2[3];
    var f2 = matrix2[5];
    var g2 = 0;
    var h2 = 0;
    var i2 = 1;
    var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));
    var tx = originX.getPixels("x");
    var ty = originY.getPixels("y");
    ctx.translate(tx, ty);
    ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));
    ctx.translate(-tx, -ty);
  }
  applyToPoint(point) {
    point.applyTransform(this.matrix);
  }
}
class Skew extends Matrix {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skew";
    this.angle = null;
    this.angle = new Property(document2, "angle", skew);
  }
}
class SkewX extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewX";
    this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
  }
}
class SkewY extends Skew {
  constructor(document2, skew, transformOrigin2) {
    super(document2, skew, transformOrigin2);
    this.type = "skewY";
    this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
  }
}
function parseTransforms(transform2) {
  return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function parseTransform(transform2) {
  var [type, value] = transform2.split("(");
  return [type.trim(), value.trim().replace(")", "")];
}
class Transform {
  constructor(document2, transform2, transformOrigin2) {
    this.document = document2;
    this.transforms = [];
    var data = parseTransforms(transform2);
    data.forEach((transform3) => {
      if (transform3 === "none") {
        return;
      }
      var [type, value] = parseTransform(transform3);
      var TransformType = Transform.transformTypes[type];
      if (typeof TransformType !== "undefined") {
        this.transforms.push(new TransformType(this.document, value, transformOrigin2));
      }
    });
  }
  static fromElement(document2, element) {
    var transformStyle = element.getStyle("transform", false, true);
    var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
    var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];
    if (transformStyle.hasValue()) {
      return new Transform(document2, transformStyle.getString(), transformOrigin2);
    }
    return null;
  }
  apply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms[i2].apply(ctx);
    }
  }
  unapply(ctx) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i2 = len - 1; i2 >= 0; i2--) {
      transforms[i2].unapply(ctx);
    }
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(point) {
    var {
      transforms
    } = this;
    var len = transforms.length;
    for (var i2 = 0; i2 < len; i2++) {
      transforms[i2].applyToPoint(point);
    }
  }
}
Transform.transformTypes = {
  translate: Translate,
  rotate: Rotate,
  scale: Scale,
  matrix: Matrix,
  skewX: SkewX,
  skewY: SkewY
};
let Element$1 = class Element2 {
  constructor(document2, node2) {
    var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.document = document2;
    this.node = node2;
    this.captureTextNodes = captureTextNodes;
    this.attributes = /* @__PURE__ */ Object.create(null);
    this.styles = /* @__PURE__ */ Object.create(null);
    this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
    this.animationFrozen = false;
    this.animationFrozenValue = "";
    this.parent = null;
    this.children = [];
    if (!node2 || node2.nodeType !== 1) {
      return;
    }
    Array.from(node2.attributes).forEach((attribute) => {
      var nodeName = normalizeAttributeName(attribute.nodeName);
      this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
    });
    this.addStylesFromStyleDefinition();
    if (this.getAttribute("style").hasValue()) {
      var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
      styles.forEach((style) => {
        if (!style) {
          return;
        }
        var [name, value] = style.split(":").map((_2) => _2.trim());
        this.styles[name] = new Property(document2, name, value);
      });
    }
    var {
      definitions
    } = document2;
    var id = this.getAttribute("id");
    if (id.hasValue()) {
      if (!definitions[id.getString()]) {
        definitions[id.getString()] = this;
      }
    }
    Array.from(node2.childNodes).forEach((childNode) => {
      if (childNode.nodeType === 1) {
        this.addChild(childNode);
      } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
        var textNode = document2.createTextNode(childNode);
        if (textNode.getText().length > 0) {
          this.addChild(textNode);
        }
      }
    });
  }
  getAttribute(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var attr = this.attributes[name];
    if (!attr && createIfNotExists) {
      var _attr = new Property(this.document, name, "");
      this.attributes[name] = _attr;
      return _attr;
    }
    return attr || Property.empty(this.document);
  }
  getHrefAttribute() {
    for (var key in this.attributes) {
      if (key === "href" || key.endsWith(":href")) {
        return this.attributes[key];
      }
    }
    return Property.empty(this.document);
  }
  getStyle(name) {
    var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var style = this.styles[name];
    if (style) {
      return style;
    }
    var attr = this.getAttribute(name);
    if (attr !== null && attr !== void 0 && attr.hasValue()) {
      this.styles[name] = attr;
      return attr;
    }
    if (!skipAncestors) {
      var {
        parent
      } = this;
      if (parent) {
        var parentStyle = parent.getStyle(name);
        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
          return parentStyle;
        }
      }
    }
    if (createIfNotExists) {
      var _style = new Property(this.document, name, "");
      this.styles[name] = _style;
      return _style;
    }
    return style || Property.empty(this.document);
  }
  render(ctx) {
    if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
      return;
    }
    ctx.save();
    if (this.getStyle("mask").hasValue()) {
      var mask = this.getStyle("mask").getDefinition();
      if (mask) {
        this.applyEffects(ctx);
        mask.apply(ctx, this);
      }
    } else if (this.getStyle("filter").getValue("none") !== "none") {
      var filter2 = this.getStyle("filter").getDefinition();
      if (filter2) {
        this.applyEffects(ctx);
        filter2.apply(ctx, this);
      }
    } else {
      this.setContext(ctx);
      this.renderChildren(ctx);
      this.clearContext(ctx);
    }
    ctx.restore();
  }
  setContext(_2) {
  }
  applyEffects(ctx) {
    var transform2 = Transform.fromElement(this.document, this);
    if (transform2) {
      transform2.apply(ctx);
    }
    var clipPathStyleProp = this.getStyle("clip-path", false, true);
    if (clipPathStyleProp.hasValue()) {
      var clip = clipPathStyleProp.getDefinition();
      if (clip) {
        clip.apply(ctx);
      }
    }
  }
  clearContext(_2) {
  }
  renderChildren(ctx) {
    this.children.forEach((child) => {
      child.render(ctx);
    });
  }
  addChild(childNode) {
    var child = childNode instanceof Element2 ? childNode : this.document.createElement(childNode);
    child.parent = this;
    if (!Element2.ignoreChildTypes.includes(child.type)) {
      this.children.push(child);
    }
  }
  matchesSelector(selector) {
    var _node$getAttribute;
    var {
      node: node2
    } = this;
    if (typeof node2.matches === "function") {
      return node2.matches(selector);
    }
    var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
    if (!styleClasses || styleClasses === "") {
      return false;
    }
    return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
  }
  addStylesFromStyleDefinition() {
    var {
      styles,
      stylesSpecificity
    } = this.document;
    for (var selector in styles) {
      if (!selector.startsWith("@") && this.matchesSelector(selector)) {
        var style = styles[selector];
        var specificity = stylesSpecificity[selector];
        if (style) {
          for (var name in style) {
            var existingSpecificity = this.stylesSpecificity[name];
            if (typeof existingSpecificity === "undefined") {
              existingSpecificity = "000";
            }
            if (specificity >= existingSpecificity) {
              this.styles[name] = style[name];
              this.stylesSpecificity[name] = specificity;
            }
          }
        }
      }
    }
  }
  removeStyles(element, ignoreStyles) {
    var toRestore = ignoreStyles.reduce((toRestore2, name) => {
      var styleProp = element.getStyle(name);
      if (!styleProp.hasValue()) {
        return toRestore2;
      }
      var value = styleProp.getString();
      styleProp.setValue("");
      return [...toRestore2, [name, value]];
    }, []);
    return toRestore;
  }
  restoreStyles(element, styles) {
    styles.forEach((_ref) => {
      var [name, value] = _ref;
      element.getStyle(name, true).setValue(value);
    });
  }
  isFirstChild() {
    var _this$parent;
    return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
  }
};
Element$1.ignoreChildTypes = ["title"];
class UnknownElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
  }
}
function wrapFontFamily(fontFamily2) {
  var trimmed = fontFamily2.trim();
  return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
}
function prepareFontFamily(fontFamily2) {
  return typeof process === "undefined" ? fontFamily2 : fontFamily2.trim().split(",").map(wrapFontFamily).join(",");
}
function prepareFontStyle(fontStyle2) {
  if (!fontStyle2) {
    return "";
  }
  var targetFontStyle = fontStyle2.trim().toLowerCase();
  switch (targetFontStyle) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontStyle;
    default:
      if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
        return targetFontStyle;
      }
      return "";
  }
}
function prepareFontWeight(fontWeight2) {
  if (!fontWeight2) {
    return "";
  }
  var targetFontWeight = fontWeight2.trim().toLowerCase();
  switch (targetFontWeight) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return targetFontWeight;
    default:
      if (/^[\d.]+$/.test(targetFontWeight)) {
        return targetFontWeight;
      }
      return "";
  }
}
class Font {
  constructor(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {
    var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
    this.fontFamily = fontFamily2 || inheritFont.fontFamily;
    this.fontSize = fontSize2 || inheritFont.fontSize;
    this.fontStyle = fontStyle2 || inheritFont.fontStyle;
    this.fontWeight = fontWeight2 || inheritFont.fontWeight;
    this.fontVariant = fontVariant2 || inheritFont.fontVariant;
  }
  static parse() {
    var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    var inherit = arguments.length > 1 ? arguments[1] : void 0;
    var fontStyle2 = "";
    var fontVariant2 = "";
    var fontWeight2 = "";
    var fontSize2 = "";
    var fontFamily2 = "";
    var parts = compressSpaces(font).trim().split(" ");
    var set = {
      fontSize: false,
      fontStyle: false,
      fontWeight: false,
      fontVariant: false
    };
    parts.forEach((part) => {
      switch (true) {
        case (!set.fontStyle && Font.styles.includes(part)):
          if (part !== "inherit") {
            fontStyle2 = part;
          }
          set.fontStyle = true;
          break;
        case (!set.fontVariant && Font.variants.includes(part)):
          if (part !== "inherit") {
            fontVariant2 = part;
          }
          set.fontStyle = true;
          set.fontVariant = true;
          break;
        case (!set.fontWeight && Font.weights.includes(part)):
          if (part !== "inherit") {
            fontWeight2 = part;
          }
          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          break;
        case !set.fontSize:
          if (part !== "inherit") {
            [fontSize2] = part.split("/");
          }
          set.fontStyle = true;
          set.fontVariant = true;
          set.fontWeight = true;
          set.fontSize = true;
          break;
        default:
          if (part !== "inherit") {
            fontFamily2 += part;
          }
      }
    });
    return new Font(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);
  }
  toString() {
    return [
      prepareFontStyle(this.fontStyle),
      this.fontVariant,
      prepareFontWeight(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      prepareFontFamily(this.fontFamily)
    ].join(" ").trim();
  }
}
Font.styles = "normal|italic|oblique|inherit";
Font.variants = "normal|small-caps|inherit";
Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class BoundingBox {
  constructor() {
    var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
    var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
    var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
    var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(x2, y2) {
    if (typeof x2 !== "undefined") {
      if (isNaN(this.x1) || isNaN(this.x2)) {
        this.x1 = x2;
        this.x2 = x2;
      }
      if (x2 < this.x1) {
        this.x1 = x2;
      }
      if (x2 > this.x2) {
        this.x2 = x2;
      }
    }
    if (typeof y2 !== "undefined") {
      if (isNaN(this.y1) || isNaN(this.y2)) {
        this.y1 = y2;
        this.y2 = y2;
      }
      if (y2 < this.y1) {
        this.y1 = y2;
      }
      if (y2 > this.y2) {
        this.y2 = y2;
      }
    }
  }
  addX(x2) {
    this.addPoint(x2, null);
  }
  addY(y2) {
    this.addPoint(null, y2);
  }
  addBoundingBox(boundingBox) {
    if (!boundingBox) {
      return;
    }
    var {
      x1,
      y1,
      x2,
      y2
    } = boundingBox;
    this.addPoint(x1, y1);
    this.addPoint(x2, y2);
  }
  sumCubic(t3, p0, p1, p2, p3) {
    return Math.pow(1 - t3, 3) * p0 + 3 * Math.pow(1 - t3, 2) * t3 * p1 + 3 * (1 - t3) * Math.pow(t3, 2) * p2 + Math.pow(t3, 3) * p3;
  }
  bezierCurveAdd(forX, p0, p1, p2, p3) {
    var b2 = 6 * p0 - 12 * p1 + 6 * p2;
    var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var c2 = 3 * p1 - 3 * p0;
    if (a2 === 0) {
      if (b2 === 0) {
        return;
      }
      var t3 = -c2 / b2;
      if (0 < t3 && t3 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t3, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t3, p0, p1, p2, p3));
        }
      }
      return;
    }
    var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
    if (b2ac < 0) {
      return;
    }
    var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t1, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t1, p0, p1, p2, p3));
      }
    }
    var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      if (forX) {
        this.addX(this.sumCubic(t22, p0, p1, p2, p3));
      } else {
        this.addY(this.sumCubic(t22, p0, p1, p2, p3));
      }
    }
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
    this.addPoint(p0x, p0y);
    this.addPoint(p3x, p3y);
    this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
    this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
  }
  addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
    var cp1x = p0x + 2 / 3 * (p1x - p0x);
    var cp1y = p0y + 2 / 3 * (p1y - p0y);
    var cp2x = cp1x + 1 / 3 * (p2x - p0x);
    var cp2y = cp1y + 1 / 3 * (p2y - p0y);
    this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
  }
  isPointInBox(x2, y2) {
    var {
      x1,
      y1,
      x2: x22,
      y2: y22
    } = this;
    return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
  }
}
class PathParser extends _ {
  constructor(path2) {
    super(path2.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
    this.control = null;
    this.start = null;
    this.current = null;
    this.command = null;
    this.commands = this.commands;
    this.i = -1;
    this.previousCommand = null;
    this.points = [];
    this.angles = [];
  }
  reset() {
    this.i = -1;
    this.command = null;
    this.previousCommand = null;
    this.start = new Point(0, 0);
    this.control = new Point(0, 0);
    this.current = new Point(0, 0);
    this.points = [];
    this.angles = [];
  }
  isEnd() {
    var {
      i: i2,
      commands
    } = this;
    return i2 >= commands.length - 1;
  }
  next() {
    var command = this.commands[++this.i];
    this.previousCommand = this.command;
    this.command = command;
    return command;
  }
  getPoint() {
    var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
    var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    var point = new Point(this.command[xProp], this.command[yProp]);
    return this.makeAbsolute(point);
  }
  getAsControlPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.control = point;
    return point;
  }
  getAsCurrentPoint(xProp, yProp) {
    var point = this.getPoint(xProp, yProp);
    this.current = point;
    return point;
  }
  getReflectedControlPoint() {
    var previousCommand = this.previousCommand.type;
    if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
      return this.current;
    }
    var {
      current: {
        x: cx,
        y: cy
      },
      control: {
        x: ox,
        y: oy
      }
    } = this;
    var point = new Point(2 * cx - ox, 2 * cy - oy);
    return point;
  }
  makeAbsolute(point) {
    if (this.command.relative) {
      var {
        x: x2,
        y: y2
      } = this.current;
      point.x += x2;
      point.y += y2;
    }
    return point;
  }
  addMarker(point, from, priorTo) {
    var {
      points,
      angles
    } = this;
    if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
      angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
    }
    this.addMarkerAngle(point, from ? from.angleTo(point) : null);
  }
  addMarkerAngle(point, angle2) {
    this.points.push(point);
    this.angles.push(angle2);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    var {
      angles
    } = this;
    var len = angles.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!angles[i2]) {
        for (var j2 = i2 + 1; j2 < len; j2++) {
          if (angles[j2]) {
            angles[i2] = angles[j2];
            break;
          }
        }
      }
    }
    return angles;
  }
}
class RenderedElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.modifiedEmSizeStack = false;
  }
  calculateOpacity() {
    var opacity2 = 1;
    var element = this;
    while (element) {
      var opacityStyle = element.getStyle("opacity", false, true);
      if (opacityStyle.hasValue(true)) {
        opacity2 *= opacityStyle.getNumber();
      }
      element = element.parent;
    }
    return opacity2;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!fromMeasure) {
      var fillStyleProp = this.getStyle("fill");
      var fillOpacityStyleProp = this.getStyle("fill-opacity");
      var strokeStyleProp = this.getStyle("stroke");
      var strokeOpacityProp = this.getStyle("stroke-opacity");
      if (fillStyleProp.isUrlDefinition()) {
        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
        if (fillStyle) {
          ctx.fillStyle = fillStyle;
        }
      } else if (fillStyleProp.hasValue()) {
        if (fillStyleProp.getString() === "currentColor") {
          fillStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _fillStyle = fillStyleProp.getColor();
        if (_fillStyle !== "inherit") {
          ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
        }
      }
      if (fillOpacityStyleProp.hasValue()) {
        var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
        ctx.fillStyle = _fillStyle2;
      }
      if (strokeStyleProp.isUrlDefinition()) {
        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
        if (strokeStyle) {
          ctx.strokeStyle = strokeStyle;
        }
      } else if (strokeStyleProp.hasValue()) {
        if (strokeStyleProp.getString() === "currentColor") {
          strokeStyleProp.setValue(this.getStyle("color").getColor());
        }
        var _strokeStyle = strokeStyleProp.getString();
        if (_strokeStyle !== "inherit") {
          ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
        }
      }
      if (strokeOpacityProp.hasValue()) {
        var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
        ctx.strokeStyle = _strokeStyle2;
      }
      var strokeWidthStyleProp = this.getStyle("stroke-width");
      if (strokeWidthStyleProp.hasValue()) {
        var newLineWidth = strokeWidthStyleProp.getPixels();
        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
      }
      var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
      var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
      var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
      var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
      var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
      if (strokeLinecapStyleProp.hasValue()) {
        ctx.lineCap = strokeLinecapStyleProp.getString();
      }
      if (strokeLinejoinStyleProp.hasValue()) {
        ctx.lineJoin = strokeLinejoinStyleProp.getString();
      }
      if (strokeMiterlimitProp.hasValue()) {
        ctx.miterLimit = strokeMiterlimitProp.getNumber();
      }
      if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
        var gaps = toNumbers(strokeDasharrayStyleProp.getString());
        if (typeof ctx.setLineDash !== "undefined") {
          ctx.setLineDash(gaps);
        } else if (typeof ctx.webkitLineDash !== "undefined") {
          ctx.webkitLineDash = gaps;
        } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
          ctx.mozDash = gaps;
        }
        var offset = strokeDashoffsetProp.getPixels();
        if (typeof ctx.lineDashOffset !== "undefined") {
          ctx.lineDashOffset = offset;
        } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
          ctx.webkitLineDashOffset = offset;
        } else if (typeof ctx.mozDashOffset !== "undefined") {
          ctx.mozDashOffset = offset;
        }
      }
    }
    this.modifiedEmSizeStack = false;
    if (typeof ctx.font !== "undefined") {
      var fontStyleProp = this.getStyle("font");
      var fontStyleStyleProp = this.getStyle("font-style");
      var fontVariantStyleProp = this.getStyle("font-variant");
      var fontWeightStyleProp = this.getStyle("font-weight");
      var fontSizeStyleProp = this.getStyle("font-size");
      var fontFamilyStyleProp = this.getStyle("font-family");
      var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
      fontStyleStyleProp.setValue(font.fontStyle);
      fontVariantStyleProp.setValue(font.fontVariant);
      fontWeightStyleProp.setValue(font.fontWeight);
      fontSizeStyleProp.setValue(font.fontSize);
      fontFamilyStyleProp.setValue(font.fontFamily);
      ctx.font = font.toString();
      if (fontSizeStyleProp.isPixels()) {
        this.document.emSize = fontSizeStyleProp.getPixels();
        this.modifiedEmSizeStack = true;
      }
    }
    if (!fromMeasure) {
      this.applyEffects(ctx);
      ctx.globalAlpha = this.calculateOpacity();
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    if (this.modifiedEmSizeStack) {
      this.document.popEmSize();
    }
  }
}
class PathElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "path";
    this.pathParser = null;
    this.pathParser = new PathParser(this.getAttribute("d").getString());
  }
  path(ctx) {
    var {
      pathParser
    } = this;
    var boundingBox = new BoundingBox();
    pathParser.reset();
    if (ctx) {
      ctx.beginPath();
    }
    while (!pathParser.isEnd()) {
      switch (pathParser.next().type) {
        case PathParser.MOVE_TO:
          this.pathM(ctx, boundingBox);
          break;
        case PathParser.LINE_TO:
          this.pathL(ctx, boundingBox);
          break;
        case PathParser.HORIZ_LINE_TO:
          this.pathH(ctx, boundingBox);
          break;
        case PathParser.VERT_LINE_TO:
          this.pathV(ctx, boundingBox);
          break;
        case PathParser.CURVE_TO:
          this.pathC(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          this.pathS(ctx, boundingBox);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(ctx, boundingBox);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          this.pathT(ctx, boundingBox);
          break;
        case PathParser.ARC:
          this.pathA(ctx, boundingBox);
          break;
        case PathParser.CLOSE_PATH:
          this.pathZ(ctx, boundingBox);
          break;
      }
    }
    return boundingBox;
  }
  getBoundingBox(_2) {
    return this.path();
  }
  getMarkers() {
    var {
      pathParser
    } = this;
    var points = pathParser.getMarkerPoints();
    var angles = pathParser.getMarkerAngles();
    var markers = points.map((point, i2) => [point, angles[i2]]);
    return markers;
  }
  renderChildren(ctx) {
    this.path(ctx);
    this.document.screen.mouse.checkPath(this, ctx);
    var fillRuleStyleProp = this.getStyle("fill-rule");
    if (ctx.fillStyle !== "") {
      if (fillRuleStyleProp.getString("inherit") !== "inherit") {
        ctx.fill(fillRuleStyleProp.getString());
      } else {
        ctx.fill();
      }
    }
    if (ctx.strokeStyle !== "") {
      if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.stroke();
      }
    }
    var markers = this.getMarkers();
    if (markers) {
      var markersLastIndex = markers.length - 1;
      var markerStartStyleProp = this.getStyle("marker-start");
      var markerMidStyleProp = this.getStyle("marker-mid");
      var markerEndStyleProp = this.getStyle("marker-end");
      if (markerStartStyleProp.isUrlDefinition()) {
        var marker = markerStartStyleProp.getDefinition();
        var [point, angle2] = markers[0];
        marker.render(ctx, point, angle2);
      }
      if (markerMidStyleProp.isUrlDefinition()) {
        var _marker = markerMidStyleProp.getDefinition();
        for (var i2 = 1; i2 < markersLastIndex; i2++) {
          var [_point, _angle] = markers[i2];
          _marker.render(ctx, _point, _angle);
        }
      }
      if (markerEndStyleProp.isUrlDefinition()) {
        var _marker2 = markerEndStyleProp.getDefinition();
        var [_point2, _angle2] = markers[markersLastIndex];
        _marker2.render(ctx, _point2, _angle2);
      }
    }
  }
  static pathM(pathParser) {
    var point = pathParser.getAsCurrentPoint();
    pathParser.start = pathParser.current;
    return {
      point
    };
  }
  pathM(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      point
    } = PathElement.pathM(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.moveTo(x2, y2);
    }
  }
  static pathL(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getAsCurrentPoint();
    return {
      current,
      point
    };
  }
  pathL(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathL(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathH(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathH(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathH(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathV(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
    pathParser.current = point;
    return {
      current,
      point
    };
  }
  pathV(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point
    } = PathElement.pathV(pathParser);
    var {
      x: x2,
      y: y2
    } = point;
    pathParser.addMarker(point, current);
    boundingBox.addPoint(x2, y2);
    if (ctx) {
      ctx.lineTo(x2, y2);
    }
  }
  static pathC(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getPoint("x1", "y1");
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathC(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathS(pathParser) {
    var {
      current
    } = pathParser;
    var point = pathParser.getReflectedControlPoint();
    var controlPoint = pathParser.getAsControlPoint("x2", "y2");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      point,
      controlPoint,
      currentPoint
    };
  }
  pathS(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, point);
    boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathQ(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getAsControlPoint("x1", "y1");
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathQ(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathT(pathParser) {
    var {
      current
    } = pathParser;
    var controlPoint = pathParser.getReflectedControlPoint();
    pathParser.control = controlPoint;
    var currentPoint = pathParser.getAsCurrentPoint();
    return {
      current,
      controlPoint,
      currentPoint
    };
  }
  pathT(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      current,
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    pathParser.addMarker(currentPoint, controlPoint, controlPoint);
    boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    if (ctx) {
      ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
  }
  static pathA(pathParser) {
    var {
      current,
      command
    } = pathParser;
    var {
      rX,
      rY,
      xRot,
      lArcFlag,
      sweepFlag
    } = command;
    var xAxisRotation = xRot * (Math.PI / 180);
    var currentPoint = pathParser.getAsCurrentPoint();
    var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
    var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
    if (l2 > 1) {
      rX *= Math.sqrt(l2);
      rY *= Math.sqrt(l2);
    }
    var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
    if (isNaN(s2)) {
      s2 = 0;
    }
    var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
    var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
    var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
    var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
    var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
    var ad = vectorsAngle(u2, v2);
    if (vectorsRatio(u2, v2) <= -1) {
      ad = Math.PI;
    }
    if (vectorsRatio(u2, v2) >= 1) {
      ad = 0;
    }
    return {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    };
  }
  pathA(ctx, boundingBox) {
    var {
      pathParser
    } = this;
    var {
      currentPoint,
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    var dir = 1 - sweepFlag ? 1 : -1;
    var ah = a1 + dir * (ad / 2);
    var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
    pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
    pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
    boundingBox.addPoint(currentPoint.x, currentPoint.y);
    if (ctx && !isNaN(a1) && !isNaN(ad)) {
      var r2 = rX > rY ? rX : rY;
      var sx = rX > rY ? 1 : rX / rY;
      var sy = rX > rY ? rY / rX : 1;
      ctx.translate(centp.x, centp.y);
      ctx.rotate(xAxisRotation);
      ctx.scale(sx, sy);
      ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
      ctx.scale(1 / sx, 1 / sy);
      ctx.rotate(-xAxisRotation);
      ctx.translate(-centp.x, -centp.y);
    }
  }
  static pathZ(pathParser) {
    pathParser.current = pathParser.start;
  }
  pathZ(ctx, boundingBox) {
    PathElement.pathZ(this.pathParser);
    if (ctx) {
      if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
        ctx.closePath();
      }
    }
  }
}
class GlyphElement extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "glyph";
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    this.unicode = this.getAttribute("unicode").getString();
    this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class TextElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TextElement ? true : captureTextNodes);
    this.type = "text";
    this.x = 0;
    this.y = 0;
    this.measureCache = -1;
  }
  setContext(ctx) {
    var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    super.setContext(ctx, fromMeasure);
    var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    if (textBaseline) {
      ctx.textBaseline = textBaseline;
    }
  }
  initializeCoordinates() {
    this.x = 0;
    this.y = 0;
    this.leafTexts = [];
    this.textChunkStart = 0;
    this.minX = Number.POSITIVE_INFINITY;
    this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(ctx) {
    if (this.type !== "text") {
      return this.getTElementBoundingBox(ctx);
    }
    this.initializeCoordinates();
    this.adjustChildCoordinatesRecursive(ctx);
    var boundingBox = null;
    this.children.forEach((_2, i2) => {
      var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
      if (!boundingBox) {
        boundingBox = childBoundingBox;
      } else {
        boundingBox.addBoundingBox(childBoundingBox);
      }
    });
    return boundingBox;
  }
  getFontSize() {
    var {
      document: document2,
      parent
    } = this;
    var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
    var fontSize2 = parent.getStyle("font-size").getNumber(inheritFontSize);
    return fontSize2;
  }
  getTElementBoundingBox(ctx) {
    var fontSize2 = this.getFontSize();
    return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);
  }
  getGlyph(font, text2, i2) {
    var char = text2[i2];
    var glyph = null;
    if (font.isArabic) {
      var len = text2.length;
      var prevChar = text2[i2 - 1];
      var nextChar = text2[i2 + 1];
      var arabicForm = "isolated";
      if ((i2 === 0 || prevChar === " ") && i2 < len - 1 && nextChar !== " ") {
        arabicForm = "terminal";
      }
      if (i2 > 0 && prevChar !== " " && i2 < len - 1 && nextChar !== " ") {
        arabicForm = "medial";
      }
      if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
        arabicForm = "initial";
      }
      if (typeof font.glyphs[char] !== "undefined") {
        var maybeGlyph = font.glyphs[char];
        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
      }
    } else {
      glyph = font.glyphs[char];
    }
    if (!glyph) {
      glyph = font.missingGlyph;
    }
    return glyph;
  }
  getText() {
    return "";
  }
  getTextFromNode(node2) {
    var textNode = node2 || this.node;
    var childNodes = Array.from(textNode.parentNode.childNodes);
    var index2 = childNodes.indexOf(textNode);
    var lastIndex = childNodes.length - 1;
    var text2 = compressSpaces(
      // textNode.value
      // || textNode.text
      textNode.textContent || ""
    );
    if (index2 === 0) {
      text2 = trimLeft(text2);
    }
    if (index2 === lastIndex) {
      text2 = trimRight(text2);
    }
    return text2;
  }
  renderChildren(ctx) {
    if (this.type !== "text") {
      this.renderTElementChildren(ctx);
      return;
    }
    this.initializeCoordinates();
    this.adjustChildCoordinatesRecursive(ctx);
    this.children.forEach((_2, i2) => {
      this.renderChild(ctx, this, this, i2);
    });
    var {
      mouse
    } = this.document.screen;
    if (mouse.isWorking()) {
      mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
    }
  }
  renderTElementChildren(ctx) {
    var {
      document: document2,
      parent
    } = this;
    var renderText = this.getText();
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var {
        unitsPerEm
      } = customFont.fontFace;
      var ctxFont = Font.parse(document2.ctx.font);
      var fontSize2 = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
      var fontStyle2 = parent.getStyle("font-style").getString(ctxFont.fontStyle);
      var scale = fontSize2 / unitsPerEm;
      var text2 = customFont.isRTL ? renderText.split("").reverse().join("") : renderText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        ctx.translate(this.x, this.y);
        ctx.scale(scale, -scale);
        var lw = ctx.lineWidth;
        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, 0.4, 1, 0, 0);
        }
        glyph.render(ctx);
        if (fontStyle2 === "italic") {
          ctx.transform(1, 0, -0.4, 1, 0, 0);
        }
        ctx.lineWidth = lw;
        ctx.scale(1 / scale, -1 / scale);
        ctx.translate(-this.x, -this.y);
        this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          this.x += dx[i2];
        }
      }
      return;
    }
    var {
      x: x2,
      y: y2
    } = this;
    if (ctx.fillStyle) {
      ctx.fillText(renderText, x2, y2);
    }
    if (ctx.strokeStyle) {
      ctx.strokeText(renderText, x2, y2);
    }
  }
  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length) {
      return;
    }
    var firstElement = this.leafTexts[this.textChunkStart];
    var textAnchor = firstElement.getStyle("text-anchor").getString("start");
    var isRTL = false;
    var shift = 0;
    if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
      shift = firstElement.x - this.minX;
    } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
      shift = firstElement.x - this.maxX;
    } else {
      shift = firstElement.x - (this.minX + this.maxX) / 2;
    }
    for (var i2 = this.textChunkStart; i2 < this.leafTexts.length; i2++) {
      this.leafTexts[i2].x += shift;
    }
    this.minX = Number.POSITIVE_INFINITY;
    this.maxX = Number.NEGATIVE_INFINITY;
    this.textChunkStart = this.leafTexts.length;
  }
  adjustChildCoordinatesRecursive(ctx) {
    this.children.forEach((_2, i2) => {
      this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i2);
    });
    this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    if (child.children.length > 0) {
      child.children.forEach((_2, i3) => {
        textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i3);
      });
    } else {
      this.adjustChildCoordinates(ctx, textParent, parent, i2);
    }
  }
  adjustChildCoordinates(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    if (typeof child.measureText !== "function") {
      return child;
    }
    ctx.save();
    child.setContext(ctx, true);
    var xAttr = child.getAttribute("x");
    var yAttr = child.getAttribute("y");
    var dxAttr = child.getAttribute("dx");
    var dyAttr = child.getAttribute("dy");
    var customFont = child.getStyle("font-family").getDefinition();
    var isRTL = Boolean(customFont) && customFont.isRTL;
    if (i2 === 0) {
      if (!xAttr.hasValue()) {
        xAttr.setValue(child.getInheritedAttribute("x"));
      }
      if (!yAttr.hasValue()) {
        yAttr.setValue(child.getInheritedAttribute("y"));
      }
      if (!dxAttr.hasValue()) {
        dxAttr.setValue(child.getInheritedAttribute("dx"));
      }
      if (!dyAttr.hasValue()) {
        dyAttr.setValue(child.getInheritedAttribute("dy"));
      }
    }
    var width = child.measureText(ctx);
    if (isRTL) {
      textParent.x -= width;
    }
    if (xAttr.hasValue()) {
      textParent.applyAnchoring();
      child.x = xAttr.getPixels("x");
      if (dxAttr.hasValue()) {
        child.x += dxAttr.getPixels("x");
      }
    } else {
      if (dxAttr.hasValue()) {
        textParent.x += dxAttr.getPixels("x");
      }
      child.x = textParent.x;
    }
    textParent.x = child.x;
    if (!isRTL) {
      textParent.x += width;
    }
    if (yAttr.hasValue()) {
      child.y = yAttr.getPixels("y");
      if (dyAttr.hasValue()) {
        child.y += dyAttr.getPixels("y");
      }
    } else {
      if (dyAttr.hasValue()) {
        textParent.y += dyAttr.getPixels("y");
      }
      child.y = textParent.y;
    }
    textParent.y = child.y;
    textParent.leafTexts.push(child);
    textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
    textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
    child.clearContext(ctx);
    ctx.restore();
    return child;
  }
  getChildBoundingBox(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    if (typeof child.getBoundingBox !== "function") {
      return null;
    }
    var boundingBox = child.getBoundingBox(ctx);
    if (!boundingBox) {
      return null;
    }
    child.children.forEach((_2, i3) => {
      var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
      boundingBox.addBoundingBox(childBoundingBox);
    });
    return boundingBox;
  }
  renderChild(ctx, textParent, parent, i2) {
    var child = parent.children[i2];
    child.render(ctx);
    child.children.forEach((_2, i3) => {
      textParent.renderChild(ctx, textParent, child, i3);
    });
  }
  measureText(ctx) {
    var {
      measureCache
    } = this;
    if (~measureCache) {
      return measureCache;
    }
    var renderText = this.getText();
    var measure = this.measureTargetText(ctx, renderText);
    this.measureCache = measure;
    return measure;
  }
  measureTargetText(ctx, targetText) {
    if (!targetText.length) {
      return 0;
    }
    var {
      parent
    } = this;
    var customFont = parent.getStyle("font-family").getDefinition();
    if (customFont) {
      var fontSize2 = this.getFontSize();
      var text2 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
      var dx = toNumbers(parent.getAttribute("dx").getString());
      var len = text2.length;
      var _measure = 0;
      for (var i2 = 0; i2 < len; i2++) {
        var glyph = this.getGlyph(customFont, text2, i2);
        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;
        if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
          _measure += dx[i2];
        }
      }
      return _measure;
    }
    if (!ctx.measureText) {
      return targetText.length * 10;
    }
    ctx.save();
    this.setContext(ctx, true);
    var {
      width: measure
    } = ctx.measureText(targetText);
    this.clearContext(ctx);
    ctx.restore();
    return measure;
  }
  /**
   * Inherits positional attributes from {@link TextElement} parent(s). Attributes
   * are only inherited from a parent to its first child.
   * @param name - The attribute name.
   * @returns The attribute value or null.
   */
  getInheritedAttribute(name) {
    var current = this;
    while (current instanceof TextElement && current.isFirstChild()) {
      var parentAttr = current.parent.getAttribute(name);
      if (parentAttr.hasValue(true)) {
        return parentAttr.getValue("0");
      }
      current = current.parent;
    }
    return null;
  }
}
class TSpanElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
    this.type = "tspan";
    this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
  getText() {
    return this.text;
  }
}
class TextNode extends TSpanElement {
  constructor() {
    super(...arguments);
    this.type = "textNode";
  }
}
class SVGElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.root = false;
  }
  setContext(ctx) {
    var _this$node$parentNode;
    var {
      document: document2
    } = this;
    var {
      screen,
      window: window2
    } = document2;
    var canvas = ctx.canvas;
    screen.setDefaults(ctx);
    if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
      ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
      var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
      if (fontSizeProp.hasValue()) {
        document2.rootEmSize = fontSizeProp.getPixels("y");
        document2.emSize = document2.rootEmSize;
      }
    }
    if (!this.getAttribute("x").hasValue()) {
      this.getAttribute("x", true).setValue(0);
    }
    if (!this.getAttribute("y").hasValue()) {
      this.getAttribute("y", true).setValue(0);
    }
    var {
      width,
      height
    } = screen.viewPort;
    if (!this.getStyle("width").hasValue()) {
      this.getStyle("width", true).setValue("100%");
    }
    if (!this.getStyle("height").hasValue()) {
      this.getStyle("height", true).setValue("100%");
    }
    if (!this.getStyle("color").hasValue()) {
      this.getStyle("color", true).setValue("black");
    }
    var refXAttr = this.getAttribute("refX");
    var refYAttr = this.getAttribute("refY");
    var viewBoxAttr = this.getAttribute("viewBox");
    var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
    var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    var minX = 0;
    var minY = 0;
    var clipX = 0;
    var clipY = 0;
    if (viewBox) {
      minX = viewBox[0];
      minY = viewBox[1];
    }
    if (!this.root) {
      width = this.getStyle("width").getPixels("x");
      height = this.getStyle("height").getPixels("y");
      if (this.type === "marker") {
        clipX = minX;
        clipY = minY;
        minX = 0;
        minY = 0;
      }
    }
    screen.viewPort.setCurrent(width, height);
    if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
      this.getStyle("transform-origin", true, true).setValue("50% 50%");
    }
    super.setContext(ctx);
    ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
    if (viewBox) {
      width = viewBox[2];
      height = viewBox[3];
    }
    document2.setViewBox({
      ctx,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: screen.viewPort.width,
      desiredWidth: width,
      height: screen.viewPort.height,
      desiredHeight: height,
      minX,
      minY,
      refX: refXAttr.getValue(),
      refY: refYAttr.getValue(),
      clip,
      clipX,
      clipY
    });
    if (viewBox) {
      screen.viewPort.removeCurrent();
      screen.viewPort.setCurrent(width, height);
    }
  }
  clearContext(ctx) {
    super.clearContext(ctx);
    this.document.screen.viewPort.removeCurrent();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var widthAttr = this.getAttribute("width", true);
    var heightAttr = this.getAttribute("height", true);
    var viewBoxAttr = this.getAttribute("viewBox");
    var styleAttr = this.getAttribute("style");
    var originWidth = widthAttr.getNumber(0);
    var originHeight = heightAttr.getNumber(0);
    if (preserveAspectRatio) {
      if (typeof preserveAspectRatio === "string") {
        this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
      } else {
        var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
        if (preserveAspectRatioAttr.hasValue()) {
          preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
        }
      }
    }
    widthAttr.setValue(width);
    heightAttr.setValue(height);
    if (!viewBoxAttr.hasValue()) {
      viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
    }
    if (styleAttr.hasValue()) {
      var widthStyle = this.getStyle("width");
      var heightStyle = this.getStyle("height");
      if (widthStyle.hasValue()) {
        widthStyle.setValue("".concat(width, "px"));
      }
      if (heightStyle.hasValue()) {
        heightStyle.setValue("".concat(height, "px"));
      }
    }
  }
}
class RectElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "rect";
  }
  path(ctx) {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width", false, true).getPixels("x");
    var height = this.getStyle("height", false, true).getPixels("y");
    var rxAttr = this.getAttribute("rx");
    var ryAttr = this.getAttribute("ry");
    var rx = rxAttr.getPixels("x");
    var ry = ryAttr.getPixels("y");
    if (rxAttr.hasValue() && !ryAttr.hasValue()) {
      ry = rx;
    }
    if (ryAttr.hasValue() && !rxAttr.hasValue()) {
      rx = ry;
    }
    rx = Math.min(rx, width / 2);
    ry = Math.min(ry, height / 2);
    if (ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      ctx.beginPath();
      if (height > 0 && width > 0) {
        ctx.moveTo(x2 + rx, y2);
        ctx.lineTo(x2 + width - rx, y2);
        ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
        ctx.lineTo(x2 + width, y2 + height - ry);
        ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
        ctx.lineTo(x2 + rx, y2 + height);
        ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
        ctx.lineTo(x2, y2 + ry);
        ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
        ctx.closePath();
      }
    }
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
  getMarkers() {
    return null;
  }
}
class CircleElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "circle";
  }
  path(ctx) {
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    var r2 = this.getAttribute("r").getPixels();
    if (ctx && r2 > 0) {
      ctx.beginPath();
      ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
      ctx.closePath();
    }
    return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
  }
  getMarkers() {
    return null;
  }
}
class EllipseElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "ellipse";
  }
  path(ctx) {
    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
    var rx = this.getAttribute("rx").getPixels("x");
    var ry = this.getAttribute("ry").getPixels("y");
    var cx = this.getAttribute("cx").getPixels("x");
    var cy = this.getAttribute("cy").getPixels("y");
    if (ctx && rx > 0 && ry > 0) {
      ctx.beginPath();
      ctx.moveTo(cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
      ctx.closePath();
    }
    return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
  }
  getMarkers() {
    return null;
  }
}
class LineElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "line";
  }
  getPoints() {
    return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
  }
  path(ctx) {
    var [{
      x: x0,
      y: y0
    }, {
      x: x1,
      y: y1
    }] = this.getPoints();
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(x1, y1);
    }
    return new BoundingBox(x0, y0, x1, y1);
  }
  getMarkers() {
    var [p0, p1] = this.getPoints();
    var a2 = p0.angleTo(p1);
    return [[p0, a2], [p1, a2]];
  }
}
class PolylineElement extends PathElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "polyline";
    this.points = [];
    this.points = Point.parsePath(this.getAttribute("points").getString());
  }
  path(ctx) {
    var {
      points
    } = this;
    var [{
      x: x0,
      y: y0
    }] = points;
    var boundingBox = new BoundingBox(x0, y0);
    if (ctx) {
      ctx.beginPath();
      ctx.moveTo(x0, y0);
    }
    points.forEach((_ref) => {
      var {
        x: x2,
        y: y2
      } = _ref;
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    });
    return boundingBox;
  }
  getMarkers() {
    var {
      points
    } = this;
    var lastIndex = points.length - 1;
    var markers = [];
    points.forEach((point, i2) => {
      if (i2 === lastIndex) {
        return;
      }
      markers.push([point, point.angleTo(points[i2 + 1])]);
    });
    if (markers.length > 0) {
      markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
    }
    return markers;
  }
}
class PolygonElement extends PolylineElement {
  constructor() {
    super(...arguments);
    this.type = "polygon";
  }
  path(ctx) {
    var boundingBox = super.path(ctx);
    var [{
      x: x2,
      y: y2
    }] = this.points;
    if (ctx) {
      ctx.lineTo(x2, y2);
      ctx.closePath();
    }
    return boundingBox;
  }
}
class PatternElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "pattern";
  }
  createPattern(ctx, _2, parentOpacityProp) {
    var width = this.getStyle("width").getPixels("x", true);
    var height = this.getStyle("height").getPixels("y", true);
    var patternSvg = new SVGElement(this.document, null);
    patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
    patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
    patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
    patternSvg.children = this.children;
    var patternCanvas = this.document.createCanvas(width, height);
    var patternCtx = patternCanvas.getContext("2d");
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue() && yAttr.hasValue()) {
      patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
    }
    if (parentOpacityProp.hasValue()) {
      this.styles["fill-opacity"] = parentOpacityProp;
    } else {
      Reflect.deleteProperty(this.styles, "fill-opacity");
    }
    for (var x2 = -1; x2 <= 1; x2++) {
      for (var y2 = -1; y2 <= 1; y2++) {
        patternCtx.save();
        patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
        patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
        patternSvg.render(patternCtx);
        patternCtx.restore();
      }
    }
    var pattern = ctx.createPattern(patternCanvas, "repeat");
    return pattern;
  }
}
class MarkerElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "marker";
  }
  render(ctx, point, angle2) {
    if (!point) {
      return;
    }
    var {
      x: x2,
      y: y2
    } = point;
    var orient = this.getAttribute("orient").getString("auto");
    var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
    ctx.translate(x2, y2);
    if (orient === "auto") {
      ctx.rotate(angle2);
    }
    if (markerUnits === "strokeWidth") {
      ctx.scale(ctx.lineWidth, ctx.lineWidth);
    }
    ctx.save();
    var markerSvg = new SVGElement(this.document, null);
    markerSvg.type = this.type;
    markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
    markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
    markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
    markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
    markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
    markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
    markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
    markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
    markerSvg.children = this.children;
    markerSvg.render(ctx);
    ctx.restore();
    if (markerUnits === "strokeWidth") {
      ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
    }
    if (orient === "auto") {
      ctx.rotate(-angle2);
    }
    ctx.translate(-x2, -y2);
  }
}
class DefsElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "defs";
  }
  render() {
  }
}
class GElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "g";
  }
  getBoundingBox(ctx) {
    var boundingBox = new BoundingBox();
    this.children.forEach((child) => {
      boundingBox.addBoundingBox(child.getBoundingBox(ctx));
    });
    return boundingBox;
  }
}
class GradientElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.attributesToInherit = ["gradientUnits"];
    this.stops = [];
    var {
      stops,
      children
    } = this;
    children.forEach((child) => {
      if (child.type === "stop") {
        stops.push(child);
      }
    });
  }
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(ctx, element, parentOpacityProp) {
    var stopsContainer = this;
    if (this.getHrefAttribute().hasValue()) {
      stopsContainer = this.getHrefAttribute().getDefinition();
      this.inheritStopContainer(stopsContainer);
    }
    var {
      stops
    } = stopsContainer;
    var gradient = this.getGradient(ctx, element);
    if (!gradient) {
      return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
    }
    stops.forEach((stop) => {
      gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
    });
    if (this.getAttribute("gradientTransform").hasValue()) {
      var {
        document: document2
      } = this;
      var {
        MAX_VIRTUAL_PIXELS,
        viewPort
      } = document2.screen;
      var [rootView] = viewPort.viewPorts;
      var rect = new RectElement(document2, null);
      rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
      rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
      rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
      var group = new GElement(document2, null);
      group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
      group.children = [rect];
      var patternSvg = new SVGElement(document2, null);
      patternSvg.attributes.x = new Property(document2, "x", 0);
      patternSvg.attributes.y = new Property(document2, "y", 0);
      patternSvg.attributes.width = new Property(document2, "width", rootView.width);
      patternSvg.attributes.height = new Property(document2, "height", rootView.height);
      patternSvg.children = [group];
      var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
      var patternCtx = patternCanvas.getContext("2d");
      patternCtx.fillStyle = gradient;
      patternSvg.render(patternCtx);
      return patternCtx.createPattern(patternCanvas, "no-repeat");
    }
    return gradient;
  }
  inheritStopContainer(stopsContainer) {
    this.attributesToInherit.forEach((attributeToInherit) => {
      if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
        this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
      }
    });
  }
  addParentOpacity(parentOpacityProp, color2) {
    if (parentOpacityProp.hasValue()) {
      var colorProp = new Property(this.document, "color", color2);
      return colorProp.addOpacity(parentOpacityProp).getColor();
    }
    return color2;
  }
}
class LinearGradientElement extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "linearGradient";
    this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
      this.getAttribute("x1", true).setValue(0);
      this.getAttribute("y1", true).setValue(0);
      this.getAttribute("x2", true).setValue(1);
      this.getAttribute("y2", true).setValue(0);
    }
    var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
    var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
    var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
    var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    if (x1 === x2 && y1 === y2) {
      return null;
    }
    return ctx.createLinearGradient(x1, y1, x2, y2);
  }
}
class RadialGradientElement extends GradientElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "radialGradient";
    this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
  getGradient(ctx, element) {
    var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
    var boundingBox = element.getBoundingBox(ctx);
    if (isBoundingBoxUnits && !boundingBox) {
      return null;
    }
    if (!this.getAttribute("cx").hasValue()) {
      this.getAttribute("cx", true).setValue("50%");
    }
    if (!this.getAttribute("cy").hasValue()) {
      this.getAttribute("cy", true).setValue("50%");
    }
    if (!this.getAttribute("r").hasValue()) {
      this.getAttribute("r", true).setValue("50%");
    }
    var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
    var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    var fx = cx;
    var fy = cy;
    if (this.getAttribute("fx").hasValue()) {
      fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
    }
    if (this.getAttribute("fy").hasValue()) {
      fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
    }
    var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
    var fr = this.getAttribute("fr").getPixels();
    return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
  }
}
class StopElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "stop";
    var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
    var stopOpacity = this.getStyle("stop-opacity");
    var stopColor = this.getStyle("stop-color", true);
    if (stopColor.getString() === "") {
      stopColor.setValue("#000");
    }
    if (stopOpacity.hasValue()) {
      stopColor = stopColor.addOpacity(stopOpacity);
    }
    this.offset = offset;
    this.color = stopColor.getColor();
  }
}
class AnimateElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "animate";
    this.duration = 0;
    this.initialValue = null;
    this.initialUnits = "";
    this.removed = false;
    this.frozen = false;
    document2.screen.animations.push(this);
    this.begin = this.getAttribute("begin").getMilliseconds();
    this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
    this.from = this.getAttribute("from");
    this.to = this.getAttribute("to");
    this.values = new Property(document2, "values", null);
    var valuesAttr = this.getAttribute("values");
    if (valuesAttr.hasValue()) {
      this.values.setValue(valuesAttr.getString().split(";"));
    }
  }
  getProperty() {
    var attributeType = this.getAttribute("attributeType").getString();
    var attributeName = this.getAttribute("attributeName").getString();
    if (attributeType === "CSS") {
      return this.parent.getStyle(attributeName, true);
    }
    return this.parent.getAttribute(attributeName, true);
  }
  calcValue() {
    var {
      initialUnits
    } = this;
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
    if (initialUnits === "%") {
      newValue *= 100;
    }
    return "".concat(newValue).concat(initialUnits);
  }
  update(delta) {
    var {
      parent
    } = this;
    var prop = this.getProperty();
    if (!this.initialValue) {
      this.initialValue = prop.getString();
      this.initialUnits = prop.getUnits();
    }
    if (this.duration > this.maxDuration) {
      var fill2 = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
        this.duration = 0;
      } else if (fill2 === "freeze" && !this.frozen) {
        this.frozen = true;
        parent.animationFrozen = true;
        parent.animationFrozenValue = prop.getString();
      } else if (fill2 === "remove" && !this.removed) {
        this.removed = true;
        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
        return true;
      }
      return false;
    }
    this.duration += delta;
    var updated = false;
    if (this.begin < this.duration) {
      var newValue = this.calcValue();
      var typeAttr = this.getAttribute("type");
      if (typeAttr.hasValue()) {
        var type = typeAttr.getString();
        newValue = "".concat(type, "(").concat(newValue, ")");
      }
      prop.setValue(newValue);
      updated = true;
    }
    return updated;
  }
  getProgress() {
    var {
      document: document2,
      values
    } = this;
    var result = {
      progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
    };
    if (values.hasValue()) {
      var p2 = result.progress * (values.getValue().length - 1);
      var lb = Math.floor(p2);
      var ub = Math.ceil(p2);
      result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
      result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
      result.progress = (p2 - lb) / (ub - lb);
    } else {
      result.from = this.from;
      result.to = this.to;
    }
    return result;
  }
}
class AnimateColorElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateColor";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var colorFrom = new RGBColor$1(from.getColor());
    var colorTo = new RGBColor$1(to.getColor());
    if (colorFrom.ok && colorTo.ok) {
      var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
      var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
      var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
      return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
    }
    return this.getAttribute("from").getColor();
  }
}
class AnimateTransformElement extends AnimateElement {
  constructor() {
    super(...arguments);
    this.type = "animateTransform";
  }
  calcValue() {
    var {
      progress,
      from,
      to
    } = this.getProgress();
    var transformFrom = toNumbers(from.getString());
    var transformTo = toNumbers(to.getString());
    var newValue = transformFrom.map((from2, i2) => {
      var to2 = transformTo[i2];
      return from2 + (to2 - from2) * progress;
    }).join(" ");
    return newValue;
  }
}
class FontElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font";
    this.glyphs = /* @__PURE__ */ Object.create(null);
    this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    var {
      definitions
    } = document2;
    var {
      children
    } = this;
    for (var child of children) {
      switch (child.type) {
        case "font-face": {
          this.fontFace = child;
          var fontFamilyStyle = child.getStyle("font-family");
          if (fontFamilyStyle.hasValue()) {
            definitions[fontFamilyStyle.getString()] = this;
          }
          break;
        }
        case "missing-glyph":
          this.missingGlyph = child;
          break;
        case "glyph": {
          var glyph = child;
          if (glyph.arabicForm) {
            this.isRTL = true;
            this.isArabic = true;
            if (typeof this.glyphs[glyph.unicode] === "undefined") {
              this.glyphs[glyph.unicode] = /* @__PURE__ */ Object.create(null);
            }
            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
          } else {
            this.glyphs[glyph.unicode] = glyph;
          }
          break;
        }
      }
    }
  }
  render() {
  }
}
class FontFaceElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "font-face";
    this.ascent = this.getAttribute("ascent").getNumber();
    this.descent = this.getAttribute("descent").getNumber();
    this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class MissingGlyphElement extends PathElement {
  constructor() {
    super(...arguments);
    this.type = "missing-glyph";
    this.horizAdvX = 0;
  }
}
class TRefElement extends TextElement {
  constructor() {
    super(...arguments);
    this.type = "tref";
  }
  getText() {
    var element = this.getHrefAttribute().getDefinition();
    if (element) {
      var firstChild = element.children[0];
      if (firstChild) {
        return firstChild.getText();
      }
    }
    return "";
  }
}
class AElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "a";
    var {
      childNodes
    } = node2;
    var firstChild = childNodes[0];
    var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
    this.hasText = hasText;
    this.text = hasText ? this.getTextFromNode(firstChild) : "";
  }
  getText() {
    return this.text;
  }
  renderChildren(ctx) {
    if (this.hasText) {
      super.renderChildren(ctx);
      var {
        document: document2,
        x: x2,
        y: y2
      } = this;
      var {
        mouse
      } = document2.screen;
      var fontSize2 = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize2.getPixels("y"), x2 + this.measureText(ctx), y2));
      }
    } else if (this.children.length > 0) {
      var g2 = new GElement(this.document, null);
      g2.children = this.children;
      g2.parent = this;
      g2.render(ctx);
    }
  }
  onClick() {
    var {
      window: window2
    } = this.document;
    if (window2) {
      window2.open(this.getHrefAttribute().getString());
    }
  }
  onMouseMove() {
    var ctx = this.document.ctx;
    ctx.canvas.style.cursor = "pointer";
  }
}
function ownKeys$2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
class TextPathElement extends TextElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "textPath";
    this.textWidth = 0;
    this.textHeight = 0;
    this.pathLength = -1;
    this.glyphInfo = null;
    this.letterSpacingCache = [];
    this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
    var pathElement = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode();
    this.dataArray = this.parsePathData(pathElement);
  }
  getText() {
    return this.text;
  }
  path(ctx) {
    var {
      dataArray
    } = this;
    if (ctx) {
      ctx.beginPath();
    }
    dataArray.forEach((_ref) => {
      var {
        type,
        points
      } = _ref;
      switch (type) {
        case PathParser.LINE_TO:
          if (ctx) {
            ctx.lineTo(points[0], points[1]);
          }
          break;
        case PathParser.MOVE_TO:
          if (ctx) {
            ctx.moveTo(points[0], points[1]);
          }
          break;
        case PathParser.CURVE_TO:
          if (ctx) {
            ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
          }
          break;
        case PathParser.QUAD_TO:
          if (ctx) {
            ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
          }
          break;
        case PathParser.ARC: {
          var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          if (ctx) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          }
          break;
        }
        case PathParser.CLOSE_PATH:
          if (ctx) {
            ctx.closePath();
          }
          break;
      }
    });
  }
  renderChildren(ctx) {
    this.setTextData(ctx);
    ctx.save();
    var textDecoration = this.parent.getStyle("text-decoration").getString();
    var fontSize2 = this.getFontSize();
    var {
      glyphInfo
    } = this;
    var fill2 = ctx.fillStyle;
    if (textDecoration === "underline") {
      ctx.beginPath();
    }
    glyphInfo.forEach((glyph, i2) => {
      var {
        p0,
        p1,
        rotation,
        text: partialText
      } = glyph;
      ctx.save();
      ctx.translate(p0.x, p0.y);
      ctx.rotate(rotation);
      if (ctx.fillStyle) {
        ctx.fillText(partialText, 0, 0);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(partialText, 0, 0);
      }
      ctx.restore();
      if (textDecoration === "underline") {
        if (i2 === 0) {
          ctx.moveTo(p0.x, p0.y + fontSize2 / 8);
        }
        ctx.lineTo(p1.x, p1.y + fontSize2 / 5);
      }
    });
    if (textDecoration === "underline") {
      ctx.lineWidth = fontSize2 / 20;
      ctx.strokeStyle = fill2;
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  }
  getLetterSpacingAt() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[idx] || 0;
  }
  findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
    var offset = inputOffset;
    var glyphWidth = this.measureText(ctx, c2);
    if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
      glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
    }
    if (charI > -1) {
      offset += this.getLetterSpacingAt(charI);
    }
    var splineStep = this.textHeight / 20;
    var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
    var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
    var segment = {
      p0,
      p1
    };
    var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
    if (dy) {
      var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
      var dyY = Math.cos(-rotation) * dy;
      segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
        x: p0.x + dyX,
        y: p0.y + dyY
      });
      segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
        x: p1.x + dyX,
        y: p1.y + dyY
      });
    }
    offset += glyphWidth;
    return {
      offset,
      segment,
      rotation
    };
  }
  measureText(ctx, text2) {
    var {
      measuresCache
    } = this;
    var targetText = text2 || this.getText();
    if (measuresCache.has(targetText)) {
      return measuresCache.get(targetText);
    }
    var measure = this.measureTargetText(ctx, targetText);
    measuresCache.set(targetText, measure);
    return measure;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(ctx) {
    if (this.glyphInfo) {
      return;
    }
    var renderText = this.getText();
    var chars2 = renderText.split("");
    var spacesNumber = renderText.split(" ").length - 1;
    var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
    var dy = this.parent.getAttribute("dy").getPixels("y");
    var anchor = this.parent.getStyle("text-anchor").getString("start");
    var thisSpacing = this.getStyle("letter-spacing");
    var parentSpacing = this.parent.getStyle("letter-spacing");
    var letterSpacing2 = 0;
    if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
      letterSpacing2 = parentSpacing.getPixels();
    } else if (thisSpacing.hasValue()) {
      if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
        letterSpacing2 = thisSpacing.getPixels();
      }
    }
    var letterSpacingCache = [];
    var textLen = renderText.length;
    this.letterSpacingCache = letterSpacingCache;
    for (var i2 = 0; i2 < textLen; i2++) {
      letterSpacingCache.push(typeof dx[i2] !== "undefined" ? dx[i2] : letterSpacing2);
    }
    var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
    var textWidth = this.measureText(ctx);
    var textFullWidth = Math.max(textWidth + dxSum, 0);
    this.textWidth = textWidth;
    this.textHeight = this.getFontSize();
    this.glyphInfo = [];
    var fullPathWidth = this.getPathLength();
    var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
    var offset = 0;
    if (anchor === "middle" || anchor === "center") {
      offset = -textFullWidth / 2;
    }
    if (anchor === "end" || anchor === "right") {
      offset = -textFullWidth;
    }
    offset += startOffset;
    chars2.forEach((char, i3) => {
      var {
        offset: nextOffset,
        segment,
        rotation
      } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i3);
      offset = nextOffset;
      if (!segment.p0 || !segment.p1) {
        return;
      }
      this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: chars2[i3],
        p0: segment.p0,
        p1: segment.p1,
        rotation
      });
    });
  }
  parsePathData(path2) {
    this.pathLength = -1;
    if (!path2) {
      return [];
    }
    var pathCommands = [];
    var {
      pathParser
    } = path2;
    pathParser.reset();
    while (!pathParser.isEnd()) {
      var {
        current
      } = pathParser;
      var startX = current ? current.x : 0;
      var startY = current ? current.y : 0;
      var command = pathParser.next();
      var nextCommandType = command.type;
      var points = [];
      switch (command.type) {
        case PathParser.MOVE_TO:
          this.pathM(pathParser, points);
          break;
        case PathParser.LINE_TO:
          nextCommandType = this.pathL(pathParser, points);
          break;
        case PathParser.HORIZ_LINE_TO:
          nextCommandType = this.pathH(pathParser, points);
          break;
        case PathParser.VERT_LINE_TO:
          nextCommandType = this.pathV(pathParser, points);
          break;
        case PathParser.CURVE_TO:
          this.pathC(pathParser, points);
          break;
        case PathParser.SMOOTH_CURVE_TO:
          nextCommandType = this.pathS(pathParser, points);
          break;
        case PathParser.QUAD_TO:
          this.pathQ(pathParser, points);
          break;
        case PathParser.SMOOTH_QUAD_TO:
          nextCommandType = this.pathT(pathParser, points);
          break;
        case PathParser.ARC:
          points = this.pathA(pathParser);
          break;
        case PathParser.CLOSE_PATH:
          PathElement.pathZ(pathParser);
          break;
      }
      if (command.type !== PathParser.CLOSE_PATH) {
        pathCommands.push({
          type: nextCommandType,
          points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, nextCommandType, points)
        });
      } else {
        pathCommands.push({
          type: PathParser.CLOSE_PATH,
          points: [],
          pathLength: 0
        });
      }
    }
    return pathCommands;
  }
  pathM(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathM(pathParser).point;
    points.push(x2, y2);
  }
  pathL(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathL(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathH(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathH(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathV(pathParser, points) {
    var {
      x: x2,
      y: y2
    } = PathElement.pathV(pathParser).point;
    points.push(x2, y2);
    return PathParser.LINE_TO;
  }
  pathC(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathC(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathS(pathParser, points) {
    var {
      point,
      controlPoint,
      currentPoint
    } = PathElement.pathS(pathParser);
    points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.CURVE_TO;
  }
  pathQ(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathQ(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
  }
  pathT(pathParser, points) {
    var {
      controlPoint,
      currentPoint
    } = PathElement.pathT(pathParser);
    points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    return PathParser.QUAD_TO;
  }
  pathA(pathParser) {
    var {
      rX,
      rY,
      sweepFlag,
      xAxisRotation,
      centp,
      a1,
      ad
    } = PathElement.pathA(pathParser);
    if (sweepFlag === 0 && ad > 0) {
      ad -= 2 * Math.PI;
    }
    if (sweepFlag === 1 && ad < 0) {
      ad += 2 * Math.PI;
    }
    return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
  }
  calcLength(x2, y2, commandType, points) {
    var len = 0;
    var p1 = null;
    var p2 = null;
    var t3 = 0;
    switch (commandType) {
      case PathParser.LINE_TO:
        return this.getLineLength(x2, y2, points[0], points[1]);
      case PathParser.CURVE_TO:
        len = 0;
        p1 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p2 = this.getPointOnCubicBezier(t3, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case PathParser.QUAD_TO:
        len = 0;
        p1 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
        for (t3 = 0.01; t3 <= 1; t3 += 0.01) {
          p2 = this.getPointOnQuadraticBezier(t3, x2, y2, points[0], points[1], points[2], points[3]);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case PathParser.ARC: {
        len = 0;
        var start = points[4];
        var dTheta = points[5];
        var end = points[4] + dTheta;
        var inc = Math.PI / 180;
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
        if (dTheta < 0) {
          for (t3 = start - inc; t3 > end; t3 -= inc) {
            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          for (t3 = start + inc; t3 < end; t3 += inc) {
            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t3, 0);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
        len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
        return len;
      }
    }
    return 0;
  }
  getPointOnLine(dist, p1x, p1y, p2x, p2y) {
    var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
    var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
    var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
    var run = Math.sqrt(dist * dist / (1 + m2 * m2));
    if (p2x < p1x) {
      run *= -1;
    }
    var rise = m2 * run;
    var pt2 = null;
    if (p2x === p1x) {
      pt2 = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
      pt2 = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      var ix = 0;
      var iy = 0;
      var len = this.getLineLength(p1x, p1y, p2x, p2y);
      if (len < PSEUDO_ZERO) {
        return null;
      }
      var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
      u2 /= len * len;
      ix = p1x + u2 * (p2x - p1x);
      iy = p1y + u2 * (p2y - p1y);
      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m2 * m2));
      if (p2x < p1x) {
        run *= -1;
      }
      rise = m2 * run;
      pt2 = {
        x: ix + run,
        y: iy + rise
      };
    }
    return pt2;
  }
  getPointOnPath(distance2) {
    var fullLen = this.getPathLength();
    var cumulativePathLength = 0;
    var p2 = null;
    if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {
      return null;
    }
    var {
      dataArray
    } = this;
    for (var command of dataArray) {
      if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {
        cumulativePathLength += command.pathLength;
        continue;
      }
      var delta = distance2 - cumulativePathLength;
      var currentT = 0;
      switch (command.type) {
        case PathParser.LINE_TO:
          p2 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
          break;
        case PathParser.ARC: {
          var start = command.points[4];
          var dTheta = command.points[5];
          var end = command.points[4] + dTheta;
          currentT = start + delta / command.pathLength * dTheta;
          if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
            break;
          }
          p2 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
          break;
        }
        case PathParser.CURVE_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p2 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
          break;
        case PathParser.QUAD_TO:
          currentT = delta / command.pathLength;
          if (currentT > 1) {
            currentT = 1;
          }
          p2 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
          break;
      }
      if (p2) {
        return p2;
      }
      break;
    }
    return null;
  }
  getLineLength(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  getPathLength() {
    if (this.pathLength === -1) {
      this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
    }
    return this.pathLength;
  }
  getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
    var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
    var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
    var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
    var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
    return {
      x: x2,
      y: y2
    };
  }
  getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi);
    var sinPsi = Math.sin(psi);
    var pt2 = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
      y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(inputStep, inputPrecision) {
    var fullLen = this.getPathLength();
    var precision = inputPrecision || 0.25;
    var step = inputStep || fullLen / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
      this.equidistantCache = {
        step,
        precision,
        points: []
      };
      var s2 = 0;
      for (var l2 = 0; l2 <= fullLen; l2 += precision) {
        var p0 = this.getPointOnPath(l2);
        var p1 = this.getPointOnPath(l2 + precision);
        if (!p0 || !p1) {
          continue;
        }
        s2 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
        if (s2 >= step) {
          this.equidistantCache.points.push({
            x: p0.x,
            y: p0.y,
            distance: l2
          });
          s2 -= step;
        }
      }
    }
  }
  getEquidistantPointOnPath(targetDistance, step, precision) {
    this.buildEquidistantCache(step, precision);
    if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
      return null;
    }
    var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[idx] || null;
  }
}
var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class ImageElement extends RenderedElement {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "image";
    this.loaded = false;
    var href = this.getHrefAttribute().getString();
    if (!href) {
      return;
    }
    var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
    document2.images.push(this);
    if (!isSvg) {
      void this.loadImage(href);
    } else {
      void this.loadSvg(href);
    }
    this.isSvg = isSvg;
  }
  loadImage(href) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var image2 = yield _this.document.createImage(href);
        _this.image = image2;
      } catch (err) {
        console.error('Error while loading image "'.concat(href, '":'), err);
      }
      _this.loaded = true;
    })();
  }
  loadSvg(href) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var match = dataUriRegex.exec(href);
      if (match) {
        var data = match[5];
        if (match[4] === "base64") {
          _this2.image = atob(data);
        } else {
          _this2.image = decodeURIComponent(data);
        }
      } else {
        try {
          var response = yield _this2.document.fetch(href);
          var svg2 = yield response.text();
          _this2.image = svg2;
        } catch (err) {
          console.error('Error while loading image "'.concat(href, '":'), err);
        }
      }
      _this2.loaded = true;
    })();
  }
  renderChildren(ctx) {
    var {
      document: document2,
      image: image2,
      loaded
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!loaded || !image2 || !width || !height) {
      return;
    }
    ctx.save();
    ctx.translate(x2, y2);
    if (this.isSvg) {
      var subDocument = document2.canvg.forkString(ctx, this.image, {
        ignoreMouse: true,
        ignoreAnimation: true,
        ignoreDimensions: true,
        ignoreClear: true,
        offsetX: 0,
        offsetY: 0,
        scaleWidth: width,
        scaleHeight: height
      });
      subDocument.document.documentElement.parent = this;
      void subDocument.render();
    } else {
      var _image = this.image;
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width,
        desiredWidth: _image.width,
        height,
        desiredHeight: _image.height
      });
      if (this.loaded) {
        if (typeof _image.complete === "undefined" || _image.complete) {
          ctx.drawImage(_image, 0, 0);
        }
      }
    }
    ctx.restore();
  }
  getBoundingBox() {
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    return new BoundingBox(x2, y2, x2 + width, y2 + height);
  }
}
class SymbolElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "symbol";
  }
  render(_2) {
  }
}
class SVGFontLoader {
  constructor(document2) {
    this.document = document2;
    this.loaded = false;
    document2.fonts.push(this);
  }
  load(fontFamily2, url) {
    var _this = this;
    return _asyncToGenerator(function* () {
      try {
        var {
          document: document2
        } = _this;
        var svgDocument = yield document2.canvg.parser.load(url);
        var fonts = svgDocument.getElementsByTagName("font");
        Array.from(fonts).forEach((fontNode) => {
          var font = document2.createElement(fontNode);
          document2.definitions[fontFamily2] = font;
        });
      } catch (err) {
        console.error('Error while loading font "'.concat(url, '":'), err);
      }
      _this.loaded = true;
    })();
  }
}
class StyleElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "style";
    var css = compressSpaces(
      Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    );
    var cssDefs = css.split("}");
    cssDefs.forEach((_2) => {
      var def = _2.trim();
      if (!def) {
        return;
      }
      var cssParts = def.split("{");
      var cssClasses = cssParts[0].split(",");
      var cssProps = cssParts[1].split(";");
      cssClasses.forEach((_3) => {
        var cssClass = _3.trim();
        if (!cssClass) {
          return;
        }
        var props = document2.styles[cssClass] || {};
        cssProps.forEach((cssProp) => {
          var prop = cssProp.indexOf(":");
          var name = cssProp.substr(0, prop).trim();
          var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
          if (name && value) {
            props[name] = new Property(document2, name, value);
          }
        });
        document2.styles[cssClass] = props;
        document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
        if (cssClass === "@font-face") {
          var fontFamily2 = props["font-family"].getString().replace(/"|'/g, "");
          var srcs = props.src.getString().split(",");
          srcs.forEach((src) => {
            if (src.indexOf('format("svg")') > 0) {
              var url = parseExternalUrl(src);
              if (url) {
                void new SVGFontLoader(document2).load(fontFamily2, url);
              }
            }
          });
        }
      });
    });
  }
}
StyleElement.parseExternalUrl = parseExternalUrl;
class UseElement extends RenderedElement {
  constructor() {
    super(...arguments);
    this.type = "use";
  }
  setContext(ctx) {
    super.setContext(ctx);
    var xAttr = this.getAttribute("x");
    var yAttr = this.getAttribute("y");
    if (xAttr.hasValue()) {
      ctx.translate(xAttr.getPixels("x"), 0);
    }
    if (yAttr.hasValue()) {
      ctx.translate(0, yAttr.getPixels("y"));
    }
  }
  path(ctx) {
    var {
      element
    } = this;
    if (element) {
      element.path(ctx);
    }
  }
  renderChildren(ctx) {
    var {
      document: document2,
      element
    } = this;
    if (element) {
      var tempSvg = element;
      if (element.type === "symbol") {
        tempSvg = new SVGElement(document2, null);
        tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
        tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
        tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
        tempSvg.children = element.children;
        element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
      }
      if (tempSvg.type === "svg") {
        var widthStyle = this.getStyle("width", false, true);
        var heightStyle = this.getStyle("height", false, true);
        if (widthStyle.hasValue()) {
          tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
        }
        if (heightStyle.hasValue()) {
          tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
        }
      }
      var oldParent = tempSvg.parent;
      tempSvg.parent = this;
      tempSvg.render(ctx);
      tempSvg.parent = oldParent;
    }
  }
  getBoundingBox(ctx) {
    var {
      element
    } = this;
    if (element) {
      return element.getBoundingBox(ctx);
    }
    return null;
  }
  elementTransform() {
    var {
      document: document2,
      element
    } = this;
    return Transform.fromElement(document2, element);
  }
  get element() {
    if (!this.cachedElement) {
      this.cachedElement = this.getHrefAttribute().getDefinition();
    }
    return this.cachedElement;
  }
}
function imGet(img, x2, y2, width, _height, rgba) {
  return img[y2 * width * 4 + x2 * 4 + rgba];
}
function imSet(img, x2, y2, width, _height, rgba, val) {
  img[y2 * width * 4 + x2 * 4 + rgba] = val;
}
function m(matrix2, i2, v2) {
  var mi = matrix2[i2];
  return mi * v2;
}
function c(a2, m1, m2, m3) {
  return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
}
class FeColorMatrixElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feColorMatrix";
    var matrix2 = toNumbers(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
      case "saturate": {
        var s2 = matrix2[0];
        matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "hueRotate": {
        var a2 = matrix2[0] * Math.PI / 180;
        matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
        break;
      }
      case "luminanceToAlpha":
        matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
        break;
    }
    this.matrix = matrix2;
    this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
  apply(ctx, _x, _y, width, height) {
    var {
      includeOpacity,
      matrix: matrix2
    } = this;
    var srcData = ctx.getImageData(0, 0, width, height);
    for (var y2 = 0; y2 < height; y2++) {
      for (var x2 = 0; x2 < width; x2++) {
        var r2 = imGet(srcData.data, x2, y2, width, height, 0);
        var g2 = imGet(srcData.data, x2, y2, width, height, 1);
        var b2 = imGet(srcData.data, x2, y2, width, height, 2);
        var a2 = imGet(srcData.data, x2, y2, width, height, 3);
        var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
        var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
        var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
        var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
        if (includeOpacity) {
          nr = 0;
          ng = 0;
          nb = 0;
          na *= a2 / 255;
        }
        imSet(srcData.data, x2, y2, width, height, 0, nr);
        imSet(srcData.data, x2, y2, width, height, 1, ng);
        imSet(srcData.data, x2, y2, width, height, 2, nb);
        imSet(srcData.data, x2, y2, width, height, 3, na);
      }
    }
    ctx.clearRect(0, 0, width, height);
    ctx.putImageData(srcData, 0, 0);
  }
}
class MaskElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "mask";
  }
  apply(ctx, element) {
    var {
      document: document2
    } = this;
    var x2 = this.getAttribute("x").getPixels("x");
    var y2 = this.getAttribute("y").getPixels("y");
    var width = this.getStyle("width").getPixels("x");
    var height = this.getStyle("height").getPixels("y");
    if (!width && !height) {
      var boundingBox = new BoundingBox();
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      x2 = Math.floor(boundingBox.x1);
      y2 = Math.floor(boundingBox.y1);
      width = Math.floor(boundingBox.width);
      height = Math.floor(boundingBox.height);
    }
    var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
    var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
    var maskCtx = maskCanvas.getContext("2d");
    document2.screen.setDefaults(maskCtx);
    this.renderChildren(maskCtx);
    new FeColorMatrixElement(document2, {
      nodeType: 1,
      childNodes: [],
      attributes: [{
        nodeName: "type",
        value: "luminanceToAlpha"
      }, {
        nodeName: "includeOpacity",
        value: "true"
      }]
    }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
    var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    element.render(tmpCtx);
    tmpCtx.globalCompositeOperation = "destination-in";
    tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
    tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
    ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
    ctx.fillRect(0, 0, x2 + width, y2 + height);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
}
MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
var noop = () => {
};
class ClipPathElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "clipPath";
  }
  apply(ctx) {
    var {
      document: document2
    } = this;
    var contextProto = Reflect.getPrototypeOf(ctx);
    var {
      beginPath,
      closePath
    } = ctx;
    if (contextProto) {
      contextProto.beginPath = noop;
      contextProto.closePath = noop;
    }
    Reflect.apply(beginPath, ctx, []);
    this.children.forEach((child) => {
      if (typeof child.path === "undefined") {
        return;
      }
      var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
      if (!transform2) {
        transform2 = Transform.fromElement(document2, child);
      }
      if (transform2) {
        transform2.apply(ctx);
      }
      child.path(ctx);
      if (contextProto) {
        contextProto.closePath = closePath;
      }
      if (transform2) {
        transform2.unapply(ctx);
      }
    });
    Reflect.apply(closePath, ctx, []);
    ctx.clip();
    if (contextProto) {
      contextProto.beginPath = beginPath;
      contextProto.closePath = closePath;
    }
  }
  render(_2) {
  }
}
class FilterElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "filter";
  }
  apply(ctx, element) {
    var {
      document: document2,
      children
    } = this;
    var boundingBox = element.getBoundingBox(ctx);
    if (!boundingBox) {
      return;
    }
    var px = 0;
    var py = 0;
    children.forEach((child) => {
      var efd = child.extraFilterDistance || 0;
      px = Math.max(px, efd);
      py = Math.max(py, efd);
    });
    var width = Math.floor(boundingBox.width);
    var height = Math.floor(boundingBox.height);
    var tmpCanvasWidth = width + 2 * px;
    var tmpCanvasHeight = height + 2 * py;
    if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
      return;
    }
    var x2 = Math.floor(boundingBox.x);
    var y2 = Math.floor(boundingBox.y);
    var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
    var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
    var tmpCtx = tmpCanvas.getContext("2d");
    document2.screen.setDefaults(tmpCtx);
    tmpCtx.translate(-x2 + px, -y2 + py);
    element.render(tmpCtx);
    children.forEach((child) => {
      if (typeof child.apply === "function") {
        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
      }
    });
    ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
    this.restoreStyles(element, ignoredStyles);
  }
  render(_2) {
  }
}
FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
class FeDropShadowElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feDropShadow";
    this.addStylesFromStyleDefinition();
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeMorphologyElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feMorphology";
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeCompositeElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "feComposite";
  }
  apply(_2, _x, _y, _width, _height) {
  }
}
class FeGaussianBlurElement extends Element$1 {
  constructor(document2, node2, captureTextNodes) {
    super(document2, node2, captureTextNodes);
    this.type = "feGaussianBlur";
    this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
    this.extraFilterDistance = this.blurRadius;
  }
  apply(ctx, x2, y2, width, height) {
    var {
      document: document2,
      blurRadius
    } = this;
    var body = document2.window ? document2.window.document.body : null;
    var canvas = ctx.canvas;
    canvas.id = document2.getUniqueId();
    if (body) {
      canvas.style.display = "none";
      body.appendChild(canvas);
    }
    processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
    if (body) {
      body.removeChild(canvas);
    }
  }
}
class TitleElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "title";
  }
}
class DescElement extends Element$1 {
  constructor() {
    super(...arguments);
    this.type = "desc";
  }
}
var elements = {
  "svg": SVGElement,
  "rect": RectElement,
  "circle": CircleElement,
  "ellipse": EllipseElement,
  "line": LineElement,
  "polyline": PolylineElement,
  "polygon": PolygonElement,
  "path": PathElement,
  "pattern": PatternElement,
  "marker": MarkerElement,
  "defs": DefsElement,
  "linearGradient": LinearGradientElement,
  "radialGradient": RadialGradientElement,
  "stop": StopElement,
  "animate": AnimateElement,
  "animateColor": AnimateColorElement,
  "animateTransform": AnimateTransformElement,
  "font": FontElement,
  "font-face": FontFaceElement,
  "missing-glyph": MissingGlyphElement,
  "glyph": GlyphElement,
  "text": TextElement,
  "tspan": TSpanElement,
  "tref": TRefElement,
  "a": AElement,
  "textPath": TextPathElement,
  "image": ImageElement,
  "g": GElement,
  "symbol": SymbolElement,
  "style": StyleElement,
  "use": UseElement,
  "mask": MaskElement,
  "clipPath": ClipPathElement,
  "filter": FilterElement,
  "feDropShadow": FeDropShadowElement,
  "feMorphology": FeMorphologyElement,
  "feComposite": FeCompositeElement,
  "feColorMatrix": FeColorMatrixElement,
  "feGaussianBlur": FeGaussianBlurElement,
  "title": TitleElement,
  "desc": DescElement
};
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function createCanvas(width, height) {
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  return canvas;
}
function createImage(_x) {
  return _createImage.apply(this, arguments);
}
function _createImage() {
  _createImage = _asyncToGenerator(function* (src) {
    var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var image2 = document.createElement("img");
    if (anonymousCrossOrigin) {
      image2.crossOrigin = "Anonymous";
    }
    return new Promise((resolve, reject) => {
      image2.onload = () => {
        resolve(image2);
      };
      image2.onerror = (_event, _source, _lineno, _colno, error) => {
        reject(error);
      };
      image2.src = src;
    });
  });
  return _createImage.apply(this, arguments);
}
let Document$1 = class Document2 {
  constructor(canvg) {
    var {
      rootEmSize = 12,
      emSize = 12,
      createCanvas: createCanvas2 = Document2.createCanvas,
      createImage: createImage2 = Document2.createImage,
      anonymousCrossOrigin
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.canvg = canvg;
    this.definitions = /* @__PURE__ */ Object.create(null);
    this.styles = /* @__PURE__ */ Object.create(null);
    this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
    this.images = [];
    this.fonts = [];
    this.emSizeStack = [];
    this.uniqueId = 0;
    this.screen = canvg.screen;
    this.rootEmSize = rootEmSize;
    this.emSize = emSize;
    this.createCanvas = createCanvas2;
    this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
    this.screen.wait(this.isImagesLoaded.bind(this));
    this.screen.wait(this.isFontsLoaded.bind(this));
  }
  bindCreateImage(createImage2, anonymousCrossOrigin) {
    if (typeof anonymousCrossOrigin === "boolean") {
      return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
    }
    return createImage2;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    var {
      emSizeStack
    } = this;
    return emSizeStack[emSizeStack.length - 1];
  }
  set emSize(value) {
    var {
      emSizeStack
    } = this;
    emSizeStack.push(value);
  }
  popEmSize() {
    var {
      emSizeStack
    } = this;
    emSizeStack.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every((_2) => _2.loaded);
  }
  isFontsLoaded() {
    return this.fonts.every((_2) => _2.loaded);
  }
  createDocumentElement(document2) {
    var documentElement = this.createElement(document2.documentElement);
    documentElement.root = true;
    documentElement.addStylesFromStyleDefinition();
    this.documentElement = documentElement;
    return documentElement;
  }
  createElement(node2) {
    var elementType = node2.nodeName.replace(/^[^:]+:/, "");
    var ElementType = Document2.elementTypes[elementType];
    if (typeof ElementType !== "undefined") {
      return new ElementType(this, node2);
    }
    return new UnknownElement(this, node2);
  }
  createTextNode(node2) {
    return new TextNode(this, node2);
  }
  setViewBox(config) {
    this.screen.setViewBox(_objectSpread$1({
      document: this
    }, config));
  }
};
Document$1.createCanvas = createCanvas;
Document$1.createImage = createImage;
Document$1.elementTypes = elements;
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
class Canvg {
  /**
   * Main constructor.
   * @param ctx - Rendering context.
   * @param svg - SVG Document.
   * @param options - Rendering options.
   */
  constructor(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.parser = new Parser(options);
    this.screen = new Screen(ctx, options);
    this.options = options;
    var document2 = new Document$1(this, options);
    var documentElement = document2.createDocumentElement(svg2);
    this.document = document2;
    this.documentElement = documentElement;
  }
  /**
   * Create Canvg instance from SVG source string or URL.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static from(ctx, svg2) {
    var _arguments = arguments;
    return _asyncToGenerator(function* () {
      var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = yield parser.parse(svg2);
      return new Canvg(ctx, svgDocument, options);
    })();
  }
  /**
   * Create Canvg instance from SVG source string.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  static fromString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var parser = new Parser(options);
    var svgDocument = parser.parseFromString(svg2);
    return new Canvg(ctx, svgDocument, options);
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string or URL.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  fork(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  /**
   * Create new Canvg instance with inherited options.
   * @param ctx - Rendering context.
   * @param svg - SVG source string.
   * @param options - Rendering options.
   * @returns Canvg instance.
   */
  forkString(ctx, svg2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
  }
  /**
   * Document is ready promise.
   * @returns Ready promise.
   */
  ready() {
    return this.screen.ready();
  }
  /**
   * Document is ready value.
   * @returns Is ready or not.
   */
  isReady() {
    return this.screen.isReady();
  }
  /**
   * Render only first frame, ignoring animations and mouse.
   * @param options - Rendering options.
   */
  render() {
    var _arguments2 = arguments, _this = this;
    return _asyncToGenerator(function* () {
      var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
      _this.start(_objectSpread({
        enableRedraw: true,
        ignoreAnimation: true,
        ignoreMouse: true
      }, options));
      yield _this.ready();
      _this.stop();
    })();
  }
  /**
   * Start rendering.
   * @param options - Render options.
   */
  start() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var {
      documentElement,
      screen,
      options: baseOptions
    } = this;
    screen.start(documentElement, _objectSpread(_objectSpread({
      enableRedraw: true
    }, baseOptions), options));
  }
  /**
   * Stop rendering.
   */
  stop() {
    this.screen.stop();
  }
  /**
   * Resize SVG to fit in given size.
   * @param width
   * @param height
   * @param preserveAspectRatio
   */
  resize(width) {
    var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
    var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    this.documentElement.resize(width, height, preserveAspectRatio);
  }
}
const index_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AElement,
  AnimateColorElement,
  AnimateElement,
  AnimateTransformElement,
  BoundingBox,
  CB1,
  CB2,
  CB3,
  CB4,
  Canvg,
  CircleElement,
  ClipPathElement,
  DefsElement,
  DescElement,
  Document: Document$1,
  Element: Element$1,
  EllipseElement,
  FeColorMatrixElement,
  FeCompositeElement,
  FeDropShadowElement,
  FeGaussianBlurElement,
  FeMorphologyElement,
  FilterElement,
  Font,
  FontElement,
  FontFaceElement,
  GElement,
  GlyphElement,
  GradientElement,
  ImageElement,
  LineElement,
  LinearGradientElement,
  MarkerElement,
  MaskElement,
  Matrix,
  MissingGlyphElement,
  Mouse,
  PSEUDO_ZERO,
  Parser,
  PathElement,
  PathParser,
  PatternElement,
  Point,
  PolygonElement,
  PolylineElement,
  Property,
  QB1,
  QB2,
  QB3,
  RadialGradientElement,
  RectElement,
  RenderedElement,
  Rotate,
  SVGElement,
  SVGFontLoader,
  Scale,
  Screen,
  Skew,
  SkewX,
  SkewY,
  StopElement,
  StyleElement,
  SymbolElement,
  TRefElement,
  TSpanElement,
  TextElement,
  TextPathElement,
  TitleElement,
  Transform,
  Translate,
  UnknownElement,
  UseElement,
  ViewPort,
  compressSpaces,
  default: Canvg,
  getSelectorSpecificity,
  normalizeAttributeName,
  normalizeColor,
  parseExternalUrl,
  presets: index,
  toNumbers,
  trimLeft,
  trimRight,
  vectorMagnitude,
  vectorsAngle,
  vectorsRatio
}, Symbol.toStringTag, { value: "Module" }));
